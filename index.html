<!DOCTYPE html>
<html lang="nl">
<head>
	<meta charset="utf-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
	<meta title="LOCUS Digitaal">
	<script>
		/*
			EN:
			- WHY: Apply the saved theme class as early as possible to avoid a flash of the wrong theme.
			- STATE: Reads `localStorage.theme` (and legacy `localStorage.darkMode`). Writes `dark-mode` on <html>.
			- OVERRIDE: The later DOMContentLoaded theme handler (applyTheme) is still the source of truth.
		*/
		(function preloadThemeClass() {
			try {
				var storedTheme = localStorage.getItem('theme');
				if (!storedTheme) {
					var legacy = localStorage.getItem('darkMode');
					if (legacy === 'true') storedTheme = 'dark';
					else if (legacy === 'false') storedTheme = 'light';
				}
				// Default: dark mode on (unless user explicitly chose light before).
				if (!storedTheme) storedTheme = 'dark';
				if (storedTheme === 'dark') {
					document.documentElement.classList.add('dark-mode');
				}
			} catch (e) {
				// Ignore storage errors (private mode / blocked storage).
			}
		})();
	</script>
		<style>
			/*
				EN: Comment tags used throughout this file:
				- WHY: reason the code exists / design intent
				- STATE: what global state / DOM state is read or written
				- OVERRIDE: this block can be overwritten later (order-dependent)
				- DUPLICATE: a similar rule/handler exists elsewhere (risk of divergence)
				- LEGACY: kept for backwards compatibility / older UI paths
				
				Note: This is a single-file app with large CSS + JS blocks; ordering matters.
			*/

			/* === Shared defaults (desktop look from 22-10 + mobile HUD from 23-10-3) === */
			html {
				min-height: 100%;
				background: #f6f8fb;
				overflow-y: hidden;
				overflow-x: hidden;
				overscroll-behavior: contain;
				/* Prevent browser back-navigation on horizontal swipe (iOS Safari, Chrome) */
				overscroll-behavior-x: none;
			}

			body {
				margin: 0;
				position: relative;
				padding: 10px;
				min-height: 100%;
				width: 100%;
				background: #f6f8fb;
				/*
					IMPORTANT (mobile/iOS): never put emoji fonts before system UI fonts.
					Otherwise digits can render in Apple Color Emoji, which looks "weird".
					Keep emoji fonts at the end so emoji still work when needed.
				*/
				font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", "Helvetica Neue", Arial, sans-serif, "Segoe UI Emoji", "Apple Color Emoji", "Noto Color Emoji";
				font-size: 16px;
				/*
					EN:
					- STATE: sets the page base typography + background.
					- LEGACY/BUG-PRONE: `gap`, `grid-template-columns`, `justify-content`, `align-items`
					  have no effect unless `display: grid` or `display: flex` is set on body.
					  If layout is controlled elsewhere (e.g. a `.layout` wrapper), these may be leftovers.
				*/
					gap: 10px;
				grid-template-columns: auto;
				justify-content: center;
				align-items: start;
				color: #222;
				transition: background-color 0.3s, color 0.3s;
			}

		:root {
			/* Base measurements */
			/* Fixed across all grids; the board itself is scaled to fit the screen. */
			--cell-size: 26px;
			--board-grid-gap: 2px;
			--preview-gap: 2px;
			--gap: 10px;
			--radius: 10px;
			--bottom-height: 70px;
			--side-panel-width: 120px;
			--card-size: 150px;

			/* Bottom bar sizing */
			--bottom-bar-gap: 0px;
			--bottom-bar-bottom-offset: 0px;
			--card-hand-lift: 12px;

			/* Z-index scale */
			--z-bottom: 450;      /* bottom bar */
			--z-controls: 1000;   /* controls panel */
			--z-menu: 1100;       /* menu / hamburger (must stay above other UI) */
			--z-ui: 250;          /* generic UI buttons */
			--z-blur: 400;        /* blur backdrop */
			--z-zoom: 500;        /* focused/zoomed zone */
			--z-drag: 600;        /* drag overlay (highest for dragged items) */
			--z-score: 700;       /* transient score / sparkle popups */
			--z-draggable: 600;   /* draggable block default */

			/* Colors - Light mode */
			--main-bg-light: #f6f8fb;
			--panel-bg-light: #ffffff;
			--score-bg-light: rgba(255,255,255,0.9);
			--card-bg-light: #ffffff;
			--coin-color: #ffd700;
			--coin-border: #b8860b;

			/* Colors - Dark mode */
			--main-bg-dark: #1a1a1a;
			--panel-bg-dark: #2d2d2d;
			--score-bg-dark: rgba(45,45,45,0.9);
			--card-bg-dark: #2d2d2d;
		}

		* {
			box-sizing: border-box;
		}

		#drag-overlay {
			position: fixed;
			top: 0;
			left: 0;
			width: 100vw;
			height: 100vh;
			pointer-events: none;
			cursor: none;
			z-index: var(--z-drag);
		}

	/* Floating preview voor touch-vriendelijke kaart plaatsing */
	#floating-preview {
		position: fixed;
		/* Positie wordt dynamisch ingesteld via JS */
		width: 138px;
		min-height: 180px;
		padding: 16px;
		display: none;
		flex-direction: column;
		align-items: center;
		justify-content: center;
		gap: 12px;
		border-radius: 16px;
		background: linear-gradient(165deg, #ffffff 0%, #eef2ff 45%, #dfe4ff 100%);
		border: 2px solid #4a90e2;
		box-shadow: 0 18px 26px rgba(10,12,20,0.3);
		z-index: calc(var(--z-zoom) + 50);
		touch-action: none;
		cursor: grab;
		transition: transform 0.2s ease, box-shadow 0.2s ease, opacity 0.2s ease;
		transform: scale(0.8);
		opacity: 0;
		overflow: visible;
	}		#floating-preview.dragging {
			cursor: grabbing;
			transform: scale(1.1);
			box-shadow: 0 12px 32px rgba(0,0,0,0.4);
		}

	body.dark-mode #floating-preview {
		background: linear-gradient(165deg, #2d2d2d 0%, #1f2233 45%, #1a1d2e 100%);
		border-color: #5a9fd4;
	}	#floating-preview-pattern {
		width: 100%;
		flex: 1;
		display: flex;
		align-items: center;
		justify-content: center;
		pointer-events: none;
		position: relative;
		z-index: 1;
	}		#floating-preview-rotate {
			position: absolute;
			top: 6px;
			right: 6px;
			width: 36px;
			height: 36px;
			background: #4a90e2;
			border: 2px solid white;
			border-radius: 50%;
			display: flex;
			align-items: center;
			justify-content: center;
			font-size: 18px;
			color: white;
			cursor: pointer;
			touch-action: none;
			box-shadow: 0 4px 12px rgba(0,0,0,0.3);
			z-index: 1;
			user-select: none;
		}

		#floating-preview-rotate:active {
			transform: scale(0.95);
		}

		body.dark-mode #floating-preview-rotate {
			background: #5a9fd4;
			border-color: #1e2128;
		}

		#floating-preview-mirror {
			position: absolute;
			bottom: 6px;
			right: 6px;
			width: 36px;
			height: 36px;
			background: #9b59b6;
			border: 2px solid white;
			border-radius: 50%;
			display: flex;
			align-items: center;
			justify-content: center;
			font-size: 18px;
			color: white;
			cursor: pointer;
			touch-action: none;
			box-shadow: 0 4px 12px rgba(0,0,0,0.3);
			z-index: 1;
			user-select: none;
		}

		#floating-preview-mirror:active {
			transform: scale(0.95);
		}

		body.dark-mode #floating-preview-mirror {
			background: #8e44ad;
			border-color: #1e2128;
		}

		#floating-preview-cancel {
			position: absolute;
			top: 6px;
			left: 6px;
			width: 36px;
			height: 36px;
			background: #e74c3c;
			border: 2px solid white;
			border-radius: 50%;
			display: flex;
			align-items: center;
			justify-content: center;
			font-size: 20px;
			color: white;
			cursor: pointer;
			touch-action: none;
			box-shadow: 0 4px 12px rgba(0,0,0,0.3);
			z-index: calc(var(--z-zoom) + 51);
			user-select: none;
		}

		#floating-preview-cancel:active {
			transform: scale(0.95);
		}

		body.dark-mode #floating-preview-cancel {
			background: #c0392b;
			border-color: #1e2128;
		}

		/* Zoom-lens voor plaatsing preview */
		#placement-zoom-lens {
			position: fixed;
			width: 160px;
			height: 160px;
			background: rgba(255, 255, 255, 0.98);
			border: 3px solid #4a90e2;
			border-radius: 16px;
			box-shadow: 0 12px 32px rgba(0,0,0,0.5), 0 0 0 2px rgba(74, 144, 226, 0.3);
			z-index: calc(var(--z-zoom) + 1);
			pointer-events: none;
			transition: opacity 0.15s ease;
		}

		body.dark-mode #placement-zoom-lens {
			background: rgba(30, 33, 40, 0.98);
			border-color: #5a9fd4;
			box-shadow: 0 12px 32px rgba(0,0,0,0.7), 0 0 0 2px rgba(90, 159, 212, 0.3);
		}

		#zoom-lens-content {
			width: 100%;
			height: 100%;
			display: flex;
			align-items: center;
			justify-content: center;
			padding: 8px;
			overflow: hidden;
		}

		#zoom-lens-content .zoom-grid {
			display: grid;
			gap: var(--board-grid-gap, 2px);
			transform: scale(1.5);
			transform-origin: center;
		}

		#zoom-lens-content .zoom-cell {
			border-radius: 2px;
			border: 1px solid rgba(0,0,0,0.15);
		}

		body.dark-mode #zoom-lens-content .zoom-cell {
			border-color: rgba(255,255,255,0.2);
		}

		#zoom-lens-content .zoom-cell.filled {
			box-shadow: 0 2px 4px rgba(0,0,0,0.2);
		}

		#zoom-lens-content .zoom-cell.preview {
			opacity: 0.7;
			border: 2px solid rgba(74, 144, 226, 0.8);
		}

		#zoom-lens-content .zoom-cell.preview.valid {
			border-color: rgba(76, 175, 80, 0.9);
			box-shadow: 0 0 8px rgba(76, 175, 80, 0.4);
		}

		#zoom-lens-content .zoom-cell.preview.invalid {
			border-color: rgba(244, 67, 54, 0.9);
			box-shadow: 0 0 8px rgba(244, 67, 54, 0.4);
		}


		body .blur-overlay {
			pointer-events: none;
		}

		/* ============================================
		   DARK MODE - BASIS STYLING
		   ============================================
		*/
		body.dark-mode {
			background: #1b1d22;
			color: #e5e5e5;
		}

		.board {
			display: flex;
			gap: 12px; /* ruimte tussen kolommen */
			margin: 0 auto;
			touch-action: manipulation;
			position: relative;
			z-index: 1;
			transition: transform 0.25s ease;
		}

		body.board-scaled {
			overflow-y: auto;
		}

		body.board-scaled .board {
			transform-origin: top center;
		}

	.column {
		display: flex;
		flex-direction: column;
		gap: 12px; /* ruimte tussen vakken in dezelfde kolom */
		flex: 1; /* kolommen gelijk breed op mobiel */
	}

	// Reposition and clear touch control styling after pointer/touch release
	(function(){
		function repositionCardControlsSoon(){
			try {
				setTimeout(function(){
					if (typeof addCardControlButtons === 'function') {
						try { addCardControlButtons(); } catch (e) {}
					}
					// Clear any lingering transforms that some browsers keep after drag
					document.querySelectorAll('.card-control-btn').forEach(btn => {
						btn.style.transform = '';
					});
				}, 60);
			} catch (e) {}
		}
		['touchend','pointerup','mouseup','touchcancel'].forEach(ev => {
			document.addEventListener(ev, repositionCardControlsSoon, { passive: true });
		});
	})();
	.zone {
		/* Geen background hier - wordt per zone ingesteld */
		position: relative;
		border-radius: 10px;
		border: 1px solid #e3e6ea;
		box-shadow: 0 2px 6px rgba(0,0,0,0.12);
		box-sizing: border-box;
		padding: 10px;
		margin: 10px;
		touch-action: manipulation;
		transition: transform 0.3s ease;
		z-index: 1;
	}

	body.debug-mode .zone .cell:not(.void-cell) {
		cursor: pointer;
	}

	.red-group {
		display: flex;
		flex-wrap: wrap;
		gap: 8px;
		justify-content: center;
	}

	.red-group.zoom-focus {
		width: auto;
		min-height: 400px; /* Minimum height, niet fixed */
		height: auto; /* Laat content de height bepalen */
	}


	body.dark-mode .zone {
		border: 1px solid #2d2f36;
		box-shadow: 0 4px 10px rgba(0,0,0,0.5);
	}		.zone-placeholder {
			pointer-events: none;
			position: relative;
		}

		.blur-overlay {
			display: none;
			position: fixed;
			inset: 0;
			background: rgba(0, 0, 0, 0.4);
			backdrop-filter: blur(4px);
			-webkit-backdrop-filter: blur(4px);
			z-index: var(--z-blur);
		}

		body.zoomed-in .blur-overlay {
			display: block;
		}

		.zone.zoom-focus {
			position: fixed;
			top: 22%;
			left: 50%;
			transform: translate(-50%, -50%) scale(1.25);
			z-index: var(--z-zoom);
			box-shadow: 0 0 30px rgba(0, 0, 0, 0.5);
			margin: 2px;
			padding: 3px;
			border-radius: 6px;
		}

		/* Mobile (incl. larger phones): use the same zoom sizing as the compact (<550px) layout. */
		@media (max-width: 900px) {
			.zone.zoom-focus {
				position: fixed;
				top: 25%;
				left: 50%;
				transform: translate(-50%, -50%) scale(0.95);
				z-index: var(--z-zoom);
				box-shadow: 0 0 30px rgba(0, 0, 0, 0.5);
				margin: 2px;
				padding: 3px;
				border-radius: 6px;
			}

			/* Red zone: keep proportions in zoom, like compact mobile. */
			#red-zone.zoom-focus {
				flex-wrap: wrap !important;
				flex-direction: row !important;
				width: auto !important;
				min-width: 380px !important;
				height: auto !important;
				max-width: 90vw;
			}
		}

		@media (max-width: 650px) {
			body.zoomed-in #yellow-zone.zoom-focus,
			body.zoomed-in #blue-zone.zoom-focus {
				top: calc(22% + 50px);
			}
		}

		/* Phone landscape (short height): scale board down so everything fits.
		   Keep this limited to coarse pointers to avoid shrinking desktop windows. */
		@media (max-height: 600px) and (orientation: landscape) and (pointer: coarse) {
			:root {
				--cell-size: 26px;
			}
		}

		/* ===== MOBILE SIDEBAR LAYOUT =====
		   Used for both mobile landscape AND mobile portrait on phones.
		   Board center, options in slim sidebars. */
		body.mobile-sidebar-layout {
			overflow: hidden !important;
			max-height: 100vh;
			max-height: 100svh;
		}

		body.mobile-sidebar-layout,
		body.mobile-sidebar-layout html {
			overflow: hidden !important;
		}

		/* Hamburger menu in mobile sidebar layout */
		body.mobile-sidebar-layout #menu-toggle {
			position: fixed !important;
			top: 4px;
			left: 4px;
			z-index: 1100;
			width: 36px;
			height: 36px;
			display: flex !important;
		}

		body.mobile-sidebar-layout #controls {
			position: fixed;
			top: 44px;
			left: 4px;
			z-index: 1099;
			max-height: calc(100vh - 50px);
			max-height: calc(100svh - 50px);
			overflow-y: auto;
		}

		body.mobile-sidebar-layout #bottom-bar {
			display: none !important;
		}

		body.mobile-sidebar-layout #mobile-objective-banner {
			display: none !important;
		}

		/* Safety net: if the sidebar class ever lingers, never apply it in portrait. */
		@media (max-width: 650px) and (orientation: portrait) {
			body.mobile-sidebar-layout {
				overflow: auto !important;
				max-height: none;
			}
			body.mobile-sidebar-layout html {
				overflow: auto !important;
			}
			body.mobile-sidebar-layout #mobile-landscape-wrapper {
				display: none !important;
			}
			body.mobile-sidebar-layout #bottom-bar {
				display: flex !important;
			}
			body.mobile-sidebar-layout #mobile-objective-banner {
				display: flex !important;
			}
		}

		/* Mobile landscape sidebar zoom mode */
		body.mobile-sidebar-layout.zoomed-in .zone.zoom-focus {
			position: fixed;
			top: 50%;
			left: 50%;
			transform: translate(-50%, -50%) scale(0.85);
			z-index: var(--z-zoom);
			box-shadow: 0 0 30px rgba(0, 0, 0, 0.5);
			margin: 0;
			padding: 6px;
			border-radius: 8px;
			max-width: 90vw;
			max-height: 85vh;
			max-height: 85svh;
			overflow: auto;
		}

		body.mobile-sidebar-layout.zoomed-in #red-zone.zoom-focus {
			display: grid !important;
			grid-template-columns: repeat(2, max-content) !important;
			width: auto;
			max-width: 95vw;
		}

		body.mobile-sidebar-layout.zoomed-in .zone-nav-arrow {
			display: flex;
		}

		body.mobile-sidebar-layout #mobile-landscape-wrapper {
			display: flex !important;
			flex-direction: row;
			align-items: stretch;
			justify-content: center;
			width: 100vw;
			height: 100vh;
			height: 100svh;
			gap: 2px;
			padding: 2px;
			padding-left: 44px; /* Room for hamburger */
			box-sizing: border-box;
			overflow: hidden;
		}

		body.mobile-sidebar-layout #ml-sidebar-left,
		body.mobile-sidebar-layout #ml-sidebar-right {
			display: flex !important;
			flex-direction: column;
			gap: 2px;
			flex: 0 0 auto;
			width: 58px;
			min-width: 50px;
			max-width: 70px;
			overflow-y: auto;
			overflow-x: hidden;
			scrollbar-width: none;
		}

		/* Landscape: slightly wider sidebars */
		@media (orientation: landscape) {
			body.mobile-sidebar-layout #ml-sidebar-left,
			body.mobile-sidebar-layout #ml-sidebar-right {
				width: 72px;
				min-width: 65px;
				max-width: 90px;
				gap: 3px;
			}
			
			body.mobile-sidebar-layout #mobile-landscape-wrapper {
				gap: 4px;
				padding: 4px;
			}
		}

		body.mobile-sidebar-layout #ml-sidebar-left::-webkit-scrollbar,
		body.mobile-sidebar-layout #ml-sidebar-right::-webkit-scrollbar {
			display: none;
		}

		body.mobile-sidebar-layout #ml-board-center {
			/* Don't expand to fill all remaining width: keep sidebars close to the board
			   (fixes "options too far to the sides" on phone landscape). */
			flex: 0 1 auto;
			display: flex;
			flex-direction: column;
			justify-content: flex-start;
			align-items: center;
			min-width: 0;
			overflow: hidden;
			gap: 2px;
		}

		/* Small-ish desktop landscape: slightly smaller cells so zones fit cleanly. */
		@media (min-width: 651px) and (orientation: landscape) and (max-height: 760px) {
			body.desktop-landscape {
				--cell-size: 26px;
			}
		}

		/* Mid-size desktop landscape (e.g. ~950px wide / ~925px tall):
		   reduce cell size so symbols don't look oversized and the board fits better. */
		@media (min-width: 801px) and (max-width: 1100px) and (orientation: landscape) and (max-height: 980px) {
			body.desktop-landscape {
				--cell-size: 26px;
			}
		}

		/* Compact objective banner in sidebar layout */
		body.mobile-sidebar-layout #ml-objective-top {
			display: flex !important;
			width: 100%;
			padding: 2px 6px;
			background: rgba(255, 251, 234, 0.95);
			border-radius: 6px;
			font-size: 0.65rem;
			text-align: center;
			justify-content: center;
			align-items: center;
			flex-shrink: 0;
		}

		body.dark-mode.mobile-sidebar-layout #ml-objective-top {
			background: rgba(34, 37, 43, 0.95);
			color: #e5e5e5;
		}

		body.mobile-sidebar-layout #ml-objective-top #objective-zone {
			min-height: auto;
			padding: 2px 8px;
			font-size: 0.6rem;
		}

		body.mobile-sidebar-layout #ml-objective-top #objective-zone h2 {
			display: none;
		}

		body.mobile-sidebar-layout #ml-board-center #board {
			transform-origin: top center;
		}

		/* Mobile sidebar styling */
		body.mobile-sidebar-layout #ml-sidebar-left #scoreboard,
		body.mobile-sidebar-layout #ml-sidebar-left #gold-zone,
		body.mobile-sidebar-layout #ml-sidebar-right #bonus-zone {
			padding: 3px 4px;
			font-size: 0.6rem;
		}

		body.mobile-sidebar-layout #ml-sidebar-left #scoreboard h2,
		body.mobile-sidebar-layout #ml-sidebar-left #gold-zone h2,
		body.mobile-sidebar-layout #ml-sidebar-right #bonus-zone h2 {
			display: none;
		}

		/* Gold zone in left sidebar */
		body.mobile-sidebar-layout #ml-sidebar-left #gold-zone {
			display: flex !important;
			flex-direction: column;
			align-items: center;
			gap: 2px;
			padding: 4px;
			background: rgba(255, 215, 0, 0.15);
			border-radius: 6px;
		}

		body.mobile-sidebar-layout #ml-sidebar-left #gold-zone::after {
			content: attr(data-coin-text);
			display: block;
			font-size: 0.6rem;
			font-weight: 700;
			padding-left: 20px; /* ruimte voor het CSS-coin icoon */
			position: relative;
		}

		/* CSS-drawn coin voor compatibele weergave (fallback voor Emoji/Edge) */
		body.mobile-sidebar-layout #ml-sidebar-left #gold-zone::before {
			content: '';
			position: absolute;
			left: 0;
			top: 50%;
			transform: translateY(-50%);
			width: 14px;
			height: 14px;
			border-radius: 50%;
			background: radial-gradient(circle at 30% 30%, #fff6b5, #f7bb36 60%, #d49f20);
			box-shadow: inset 0 -1px 2px rgba(0,0,0,0.2);
			border: 1px solid #c9960a;
		}

		body.mobile-sidebar-layout #ml-sidebar-left #gold-zone .buy-placement-btn {
			padding: 3px 5px;
			font-size: 0.45rem;
			display: block !important;
		}

		body.mobile-sidebar-layout #ml-sidebar-left #gold-zone #collected-coins {
			display: none !important;
		}

		@media (orientation: landscape) {
			body.mobile-sidebar-layout #ml-sidebar-left #gold-zone::after {
				font-size: 0.6rem;
			}

			body.mobile-sidebar-layout #ml-sidebar-left #gold-zone .buy-placement-btn {
				padding: 3px 5px;
				font-size: 0.45rem;
			}
		}

		body.mobile-sidebar-layout #ml-sidebar-left #scoreboard .score-row {
			padding: 1px 2px;
			font-size: 0.55rem;
		}

		body.mobile-sidebar-layout #ml-sidebar-left #scoreboard .score-row .label {
			display: none;
		}

		body.mobile-sidebar-layout #ml-sidebar-left #scoreboard .score-row .color-box {
			width: 8px;
			height: 8px;
		}

		body.mobile-sidebar-layout #ml-sidebar-left #scoreboard .score-total {
			font-size: 0.7rem;
			padding: 2px;
		}

		body.mobile-sidebar-layout #ml-sidebar-left #scoreboard .score-total .label {
			display: none;
		}

		body.mobile-sidebar-layout .bonus-inventory {
			flex-direction: column;
			gap: 1px;
		}

		body.mobile-sidebar-layout .bonus-badge {
			padding: 2px 4px;
			font-size: 0.5rem;
		}

		body.mobile-sidebar-layout .bonus-count {
			font-size: 0.45rem;
			padding: 1px 3px;
		}

		body.mobile-sidebar-layout #ml-sidebar-right #card-choice-zone {
			padding: 3px;
			display: flex;
			flex-direction: column;
			gap: 4px;
		}

		body.mobile-sidebar-layout #ml-sidebar-right #card-choice-zone h2,
		body.mobile-sidebar-layout #ml-sidebar-right #kiesKaartTitel,
		body.mobile-sidebar-layout #ml-sidebar-right #card-choice-zone br {
			display: none !important;
		}

		body.mobile-sidebar-layout #ml-sidebar-right #card-options {
			flex-direction: column;
			gap: 3px;
			order: 1;
		}

		/* Action buttons below cards */
		body.mobile-sidebar-layout #ml-sidebar-right #card-action-buttons {
			order: 2;
			flex-direction: row;
			flex-wrap: wrap;
			justify-content: center;
			gap: 3px;
			margin-top: 4px;
			padding-top: 4px;
			border-top: 1px solid rgba(0,0,0,0.1);
		}

		/* Portrait: smaller cards */
		body.mobile-sidebar-layout #ml-sidebar-right .card-option {
			width: 44px;
			min-height: 50px;
			padding: 2px;
			--preview-cell: 6px;
		}

		body.mobile-sidebar-layout #ml-sidebar-right .card-option .card-cell {
			width: 6px;
			height: 6px;
		}

		body.mobile-sidebar-layout #ml-sidebar-right .card-label {
			font-size: 0.4rem;
			padding: 1px 2px;
		}

		/* Landscape: allow slightly larger cards */
		@media (orientation: landscape) {
			body.mobile-sidebar-layout #ml-sidebar-right .card-option {
				width: 58px;
				min-height: 70px;
				padding: 4px;
				--preview-cell: 10px;
			}

			body.mobile-sidebar-layout #ml-sidebar-right .card-option .card-cell {
				width: 9px;
				height: 9px;
			}

			body.mobile-sidebar-layout #ml-sidebar-right .card-label {
				font-size: 0.5rem;
				padding: 2px 4px;
			}
		}

		body.mobile-sidebar-layout #ml-sidebar-right .card-action-btn {
			width: 22px;
			height: 22px;
			min-width: 22px;
			padding: 2px;
		}

		body.mobile-sidebar-layout #ml-sidebar-right .card-action-btn::before {
			font-size: 0.65rem;
		}

		/* Landscape: larger action buttons */
		@media (orientation: landscape) {
			body.mobile-sidebar-layout #ml-sidebar-right .card-action-btn {
				width: 24px;
				height: 24px;
				min-width: 24px;
				padding: 3px;
			}

			body.mobile-sidebar-layout #ml-sidebar-right .card-action-btn::before {
				font-size: 0.7rem;
			}
		}
		
		.zone.portal-active {
			box-shadow: 0 0 12px 4px rgba(100, 200, 255, 0.6);
			animation: portalPulse 2s ease-in-out infinite;
		}
		
		@keyframes portalPulse {
			0%, 100% { box-shadow: 0 0 12px 4px rgba(100, 200, 255, 0.6); }
			50% { box-shadow: 0 0 20px 6px rgba(150, 220, 255, 0.8); }
		}

		/* Blue zone scroll - lang uitgezoomd, kort ingezoomd */


		#blue-zone.zoom-focus {
			/* Keep the zoomed blue zone ~2/3 of the viewport height. */
			max-height: 66vh;
			overflow-y: auto;
			overflow-x: hidden;
			/* Keep blue scrollable but hide the scrollbar visuals (no "scroll wheel"). */
			scrollbar-width: none; /* Firefox */
			-ms-overflow-style: none; /* IE/Edge legacy */
		}
		#blue-zone.zoom-focus::-webkit-scrollbar {
			width: 0;
			height: 0;
			display: none;
		}

		/*
		#red-zone {
			width: 430px;
		}
			*/

		#original-card-zone {
			width: 430px;
		}

		/* Zone navigation arrows */
		.zone-nav-arrow {
			position: fixed;
			top: 50%;
			transform: translateY(-50%);
			z-index: calc(var(--z-zoom) + 1);
			background: rgba(255, 255, 255, 0.9);
			border: 2px solid rgba(40, 55, 120, 0.3);
			border-radius: 50%;
			width: 48px;
			height: 48px;
			display: flex;
			align-items: center;
			justify-content: center;
			font-size: 24px;
			cursor: pointer;
			transition: all 0.2s ease;
			box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
			user-select: none;
		}

		.zone-nav-arrow:hover {
			background: rgba(255, 255, 255, 1);
			transform: translateY(-50%) scale(1.1);
			box-shadow: 0 6px 16px rgba(0, 0, 0, 0.3);
		}

		.zone-nav-arrow:active {
			transform: translateY(-50%) scale(0.95);
		}

		.zone-nav-arrow-left {
			left: 20px;
		}

		.zone-nav-arrow-right {
			right: 20px;
		}

		body.dark-mode .zone-nav-arrow {
			background: rgba(30, 35, 50, 0.9);
			border-color: rgba(140, 150, 200, 0.4);
			color: rgba(240, 242, 255, 0.9);
		}

		body.dark-mode .zone-nav-arrow:hover {
			background: rgba(40, 45, 60, 1);
		}

		/* === Mobile scaling tweaks (<=650px) === */

	/* ============================================
	   CARD CHOICE ZONE - ADDITIONAL FEATURES
	   ============================================
	   Golden cards and selection disabled states
	*/
	.card-option.card-golden {
		position: relative;
		overflow: hidden;
		background: linear-gradient(135deg, #fff9e6 0%, #ffe082 30%, #f6c84a 60%, #c78c1f 100%);
		border: 1px solid rgba(220,180,60,0.9);
		box-shadow: 0 28px 56px rgba(184,120,18,0.45), inset 0 1px 0 rgba(255,255,255,0.6);
	}

	@keyframes goldenCardShine {
		0% { transform: translateX(-70%) rotate(20deg); }
		100% { transform: translateX(70%) rotate(20deg); }
	}

	/* Subtle shine over the golden frame (does not affect the block colors). */
	.card-option.card-golden::before {
		content: '';
		position: absolute;
		top: -40%;
		left: -40%;
		width: 180%;
		height: 180%;
		background: linear-gradient(90deg, rgba(255,255,255,0) 0%, rgba(255,255,255,0.55) 45%, rgba(255,255,255,0) 70%);
		opacity: 0.22;
		pointer-events: none;
		transform: translateX(-70%) rotate(20deg);
		animation: goldenCardShine 3.2s linear infinite;
		z-index: 1;
	}

	.card-option.card-golden .card-pattern,
	.card-option.card-golden .card-label,
	.card-option.card-golden .card-meta {
		position: relative;
		z-index: 2;
	}

	.card-option.card-golden::after {
		background: linear-gradient(120deg, rgba(255,255,255,0.95), rgba(255,255,255,0) 60%);
		opacity: 0.72;
		mix-blend-mode: overlay;
	}

	.card-option.card-golden .card-label {
		background: rgba(120,80,0,0.1);
		color: #7c4d00;
	}

	#card-choice-zone .card-option.selection-disabled {
		opacity: 0.45;
		pointer-events: none;
		filter: grayscale(0.25);
	}

	body.dark-mode .card-option.card-golden {
		background: linear-gradient(135deg, #5b4a14 0%, #8a6a1c 35%, #bf952a 70%, #e3c45e 100%);
		border: 1px solid rgba(200,160,30,0.8);
		box-shadow: 0 28px 52px rgba(0,0,0,0.6), inset 0 1px 0 rgba(255,255,255,0.08);
	}

	body.dark-mode .card-option.card-golden::before {
		opacity: 0.18;
	}

	body.dark-mode .card-option.card-golden .card-label {
		background: rgba(255,220,120,0.12);
		color: #ffe79a;
	}

	/*
		#card-choice-zone defines its own (more specific) `.card-option` background later.
		These overrides ensure golden styling remains visible inside the card-choice UI.
	*/
	#card-choice-zone .card-option.card-golden {
		background: linear-gradient(135deg, #fff9e6 0%, #ffe082 30%, #f6c84a 60%, #c78c1f 100%);
		border: 1px solid rgba(220,180,60,0.9);
		box-shadow: 0 28px 56px rgba(184,120,18,0.45), inset 0 1px 0 rgba(255,255,255,0.6);
	}

	body.dark-mode #card-choice-zone .card-option.card-golden {
		background: linear-gradient(135deg, #5b4a14 0%, #8a6a1c 35%, #bf952a 70%, #e3c45e 100%);
		border: 1px solid rgba(200,160,30,0.8);
		box-shadow: 0 28px 52px rgba(0,0,0,0.6), inset 0 1px 0 rgba(255,255,255,0.08);
	}

	body.dark-mode #card-choice-zone .card-option.selection-disabled {
		opacity: 0.32;
		filter: grayscale(0.4);
	}

	/* Deck kopie kaart (extraHandSize upgrade) */
	#card-choice-zone .card-option.card-deck-copy {
		position: relative;
		border: 2px dashed rgba(100, 140, 255, 0.6);
	}
	#card-choice-zone .card-option.card-deck-copy::before {
		content: 'ðŸ“‹';
		position: absolute;
		top: -8px;
		right: -8px;
		font-size: 16px;
		background: #fff;
		border-radius: 50%;
		padding: 2px;
		box-shadow: 0 2px 6px rgba(0,0,0,0.2);
		z-index: 10;
	}
	body.dark-mode #card-choice-zone .card-option.card-deck-copy {
		border-color: rgba(140, 180, 255, 0.5);
	}
	body.dark-mode #card-choice-zone .card-option.card-deck-copy::before {
		background: #2a2a3a;
	}

	/* Lucky draw kopie kaart */
	#card-choice-zone .card-option.card-lucky-copy {
		position: relative;
		border: 2px dashed rgba(80, 200, 80, 0.6);
	}
	#card-choice-zone .card-option.card-lucky-copy::before {
		content: 'ðŸ€';
		position: absolute;
		top: -8px;
		right: -8px;
		font-size: 16px;
		background: #fff;
		border-radius: 50%;
		padding: 2px;
		box-shadow: 0 2px 6px rgba(0,0,0,0.2);
		z-index: 10;
	}
	body.dark-mode #card-choice-zone .card-option.card-lucky-copy {
		border-color: rgba(120, 220, 120, 0.5);
	}
	body.dark-mode #card-choice-zone .card-option.card-lucky-copy::before {
		background: #2a2a3a;
	}

	/*
		EN:
		- DUPLICATE/OVERRIDE: There are many `@media (max-width: 650px)` blocks in this file.
		  They stack and later rules win, so the *order* in this CSS file is part of the behavior.
		- TIP: If something "randomly" changes on mobile, search for the same selector in later @media blocks.
	*/
	@media (max-width: 650px) {


	#bottom-bar {
		padding-left: 5px;
		padding-right: 5px;
	}

	  #bottom-bar-score,
	  #bottom-bar-coins {
		flex: 0 0 50%;
		min-width: 0;
	  }

	  #bottom-bar #scoreboard,
	  #bottom-bar #gold-zone {
		width: 100%;
		padding: 6px 10px;
		box-sizing: border-box;
	  }

	  #bottom-bar #gold-zone {
		min-width: 0;
	  }

	  #bottom-bar #new-cards-btn {
		height: 48px;
		padding: 8px 12px;
		font-size: 0.76rem;
	  }

	  #bottom-bar #rotate-card-btn {
		height: 44px;
		padding: 7px 12px;
		font-size: 0.7rem;
		margin-top: 8px;
		width: 104px;
	  }

	  #bottom-bar #card-options .card-option {
		max-width: 110px;
	  }
	}

	@media (max-width: 650px) {
	  .bottom-bar-footer {
		display: flex;
		flex-direction: column;
		align-items: stretch;
		gap: 2px;
		justify-content: flex-start;
		margin-top: 10px;
	  }

	  #bottom-bar-left {
		display: flex;
		flex-direction: column;
		flex-wrap: nowrap;
		gap: 4px;
		flex: 1 1 auto;
		min-width: 0;
		align-items: stretch;
	  }

	  #bottom-bar-bonus {
		order: 2;
		flex: 0 0 auto;
		display: flex;
		flex-direction: column;
		align-items: stretch;
		justify-content: flex-start;
		gap: 8px;
	  }

	  #bottom-bar-score-coins {
		display: flex;
		flex-direction: row;
		gap: 4px;
		align-items: center;
		order: 3;
		flex: 1 1 auto;
		min-width: 0;
	  }

	  #bottom-bar-score {
		flex: 1 1 auto;
		min-width: 0;
	  }

	  #bottom-bar-coins {
		display: none !important;
	  }

	  #bottom-bar #scoreboard,
	  #bottom-bar #gold-zone {
		width: 100%;
		box-sizing: border-box;
		height: auto;
	  }

	  #bottom-bar #bonus-zone {
		width: auto;
		flex: 1 1 auto;
		min-width: 0;
		padding: 6px 8px;
	  }

	  /* Place the coin panel next to the bonus inventory. */
	  #bottom-bar-bonus #gold-zone {
		width: 100% !important;
		flex: 0 0 auto;
		padding: 3px 6px;
		margin: 0;
		display: flex;
		flex-direction: column;
		align-items: stretch;
		justify-content: flex-start;
		gap: 4px;
	  }
	  #bottom-bar-bonus #gold-zone .buy-placement-btn {
		margin-left: 0;
	  }
	  

	#bottom-bar #collected-coins {
		grid-template-rows: repeat(3, 12px);
		grid-auto-columns: 12px;
		column-gap: 4px;
		row-gap: 4px;
	}
	}


	@media (max-width: 650px) {
		:root {
			--bottom-bar-height: 140px;
			--bottom-bar-gap: 4px;
			--bottom-bar-bottom-offset: -16px;
			--card-hand-lift: 0px;
			--hand-card-width: 52px;
			--hand-card-gap: 4px;
			--hand-card-height: 78px;
		}

		#bottom-bar {
			padding-left: 5px;
			padding-right: 5px;
			margin-bottom: 5px;
		}

		#bottom-bar #scoreboard,
		#bottom-bar #gold-zone {
			padding: 6px 8px;
		}

		#bottom-bar #gold-zone {
			min-width: 0;
			gap: 9px;
		}

		#bottom-bar #card-options {
			padding-left: 0;
			padding-right: 0;
			touch-action: none;
			overflow-y: hidden;
		}

	  #bonus-zone .bonus-hint {
		display: none;
	  }

	  #bottom-bar #scoreboard {
		--score-chip-gap: 3px;
	  }
	  
	  /* Hide desktop bonus-zone on mobile (it's in bottom-bar) */
	  #original-bonus-zone {
		display: none;
	  }

	  #bottom-bar #scoreboard .score-row {
		font-size: 0.62rem;
		padding: 2px 4px;
	  }

	  #bottom-bar #scoreboard .score-row .color-box {
		width: 8px;
		height: 8px;
	  }

	  #bottom-bar #scoreboard .score-row .score {
		font-size: 0.66rem;
	  }

	  #bottom-bar #scoreboard .score-total {
		font-size: 0.68rem;
	  }

	  #bottom-bar #scoreboard .score-total .total-score {
		font-size: 0.78rem;
	  }

	  #bottom-bar #scoreboard .score-total .label {
		font-size: 0.64rem;
	  }

	#bottom-bar #card-choice-zone .card-option {
		width: 98px;
		min-height: 18px;
		gap: 9px;
	}

	  #bottom-bar #new-cards-btn {
		height: 36px;
		padding: 6px 11px;
		font-size: 0.66rem;
	  }

	  #bottom-bar #rotate-card-btn {
		height: 34px;
		padding: 6px 10px;
		font-size: 0.62rem;
		width: 102px;
		margin-top: 6px;
	  }

	#bottom-bar #collected-coins {
		grid-template-rows: repeat(3, 12px);
		grid-auto-columns: 12px;
		column-gap: 4px;
		row-gap: 4px;
	}

	#bottom-bar .coin {
		width: 12px;
		height: 12px;
	}
	}

	@media (max-width: 520px) {
	  :root {
		--bottom-bar-height: 120px;
		--bottom-bar-gap: 4px;
		--card-hand-lift: 0px;
		--hand-card-width: 56px;
		--hand-card-gap: 4px;
		--hand-card-height: 70px;
	  }

	  #bottom-bar {
		padding-left: 4px;
		padding-right: 4px;
		padding-bottom: 4px;
	  }

	  #bottom-bar-cards {
		margin-top: 0;
		height: 80px;
	  }

	  #bottom-bar #card-options {
		display: flex;
		gap: 4px;
		align-items: stretch;
		justify-content: flex-start;
		flex-wrap: nowrap;
		scroll-snap-type: x proximity;
		flex: 1 1 auto;
		min-width: 0;
		width: auto;
		max-width: 100%;
		transform: translateY(0px);
		padding: 0 0 8px 0;
		touch-action: pan-x;
		overflow-x: auto;
		overflow-y: hidden;
		scrollbar-width: thin;
		scrollbar-color: rgba(255,255,255,0.3) transparent;
	  }
	  
	  #bottom-bar #card-options::-webkit-scrollbar {
		height: 4px;
	  }
	  #bottom-bar #card-options::-webkit-scrollbar-track {
		background: transparent;
		border-radius: 2px;
	  }
	  #bottom-bar #card-options::-webkit-scrollbar-thumb {
		background: linear-gradient(90deg, rgba(255,255,255,0.25), rgba(200,210,255,0.35));
		border-radius: 2px;
	  }
	  #bottom-bar #card-options::-webkit-scrollbar-thumb:hover {
		background: linear-gradient(90deg, rgba(255,255,255,0.4), rgba(200,210,255,0.5));
	  }

	  #bottom-bar #card-choice-zone .card-option {
		width: var(--hand-card-width);
		min-height: 80px;
		padding: 3px 4px 5px;
		gap: 2px;
	  }

	  #bottom-bar #card-choice-zone .card-option .card-cell {
		width: 8px;
		height: 8px;
	  }

	  #bottom-bar #card-choice-zone .card-option .card-pattern {
		gap: var(--preview-gap);
	  }

	  #bottom-bar #card-choice-zone .card-option .card-label {
		font-size: 0.52rem;
		padding: 1px 4px;
		gap: 1px;
	  }

	  #bottom-bar #card-choice-zone .card-option .card-label .label-dot {
		width: 5px;
		height: 5px;
	  }

	  #bottom-bar #new-cards-btn,
	  #bottom-bar #rotate-card-btn {
		width: 40px;
		height: 40px;
	  }

	  #bottom-bar #new-cards-btn::before {
		font-size: 1.6rem;
	  }

	  #bottom-bar #rotate-card-btn::before {
		font-size: 1.4rem;
	  }

	  .deck-count {
		padding: 5px 10px;
		font-size: 0.9rem;
		min-width: 45px;
		gap: 5px;
		border-radius: 9px;
	  }

	  .deck-count::before {
		font-size: 1rem;
	  }


	  #bottom-bar-left {
		gap: 3px;
	  }

	  .bottom-bar-footer {
		padding: 2px 3px 0;
	  }
	}


	@media (max-width: 650px) {
		:root {
			/* Use 0.5 for pixel-perfect scaling: 2px gaps become clean 1px after scaling */
			--board-scale: 0.5;
		}

		/* Classic mode (mobile): show ONLY the board + hamburger menu. */
		body.classic-mode #bottom-bar,
		body.classic-mode #card-choice-zone,
		body.classic-mode #bonus-zone,
		body.classic-mode #scoreboard,
		body.classic-mode #objective-zone,
		body.classic-mode #mobile-objective-banner,
		body.classic-mode #buy-placement-container,
		body.classic-mode #original-coins-zone,
		body.classic-mode #gold-zone,
		body.classic-mode #dark-mode-toggle,
		body.classic-mode .zone-info-btn,
		body.classic-mode .zone-info-popover {
			display: none !important;
		}

		/* Classic mode: don't scale down; board should fill the screen. */
		body.classic-mode {
			--board-scale: 1;
		}

		/* Hide the legacy UI column so the board uses the full width. */
		body.classic-mode #board > .column:last-child {
			display: none !important;
		}

		#original-card-zone {
			width: auto;
			max-width: 100%;
		}

		.board {
			gap: 2px;
			margin: 0;
			padding: 2px;
			transform-origin: top left;
			transition: transform 0.4s ease;	
			left: 50%;
			transform: translateX(-50%) scale(var(--board-scale, 0.5));
			max-height: none;
		}

		/* Bottom bar: make the 3 hand cards visibly smaller (â‰ˆ25%), while keeping cell-size identical to the board. */
		#bottom-bar #card-choice-zone .card-option {
			width: var(--hand-card-width);
			min-height: var(--hand-card-height);
			padding: 3px 4px;
			gap: 2px;
			justify-content: flex-start;
		}
		#bottom-bar #card-choice-zone .card-pattern {
			gap: var(--preview-gap);
		}
		#bottom-bar #card-choice-zone .card-label {
			font-size: 0.52rem;
			padding: 1px 4px;
			gap: 3px;
		}
		#bottom-bar #card-choice-zone .card-meta {
			font-size: 0.6rem;
		}

		/* Red zone sub-grids: center the grid inside each quadrant (also when NOT zoomed). */
		#red-zone.red-group > .zone {
			display: flex;
			align-items: center;
			justify-content: center;
		}
		#red-zone.red-group .grid {
			margin: 0;
		}

		/* Zones compacter maken voor betere fit */
		/* Green grid (lichtgroene binnenste area) beperken (niet tijdens zoom) */
		body:not(.zoomed-in) #green-grid {
			min-width: calc(15 * var(--cell-size)) !important;
			max-width: calc(15 * var(--cell-size) + 20px) !important;
		}
		/* Zoomed-in: groen mag breder (2Ã—) zodat niets afkapt */
		body.zoomed-in #green-grid {
			min-width: calc(30 * var(--cell-size)) !important;
			max-width: calc(30 * var(--cell-size) + 20px) !important;
		}

		/* Mobile: blue is vertically long by design; keep it scrollable but not a giant strip. */
		body:not(.zoomed-in) #blue-zone,
		#blue-zone--placeholder {
			overflow: auto;
		}

		/* World 2: verberg de (witte) scrollbar in de blauwe zone (blijft wel scrollbaar) */
		#blue-zone {
			scrollbar-width: none;
			-ms-overflow-style: none;
		}
		#blue-zone::-webkit-scrollbar {
			width: 0;
			height: 0;
			display: none;
		}

		/* Blue zone met scroll in zoom voor kaarten zichtbaarheid */
		#blue-zone.zoom-focus {
			max-height: 66vh;
			overflow-y: auto;
			scrollbar-width: none;
			-ms-overflow-style: none;
		}
		#blue-zone.zoom-focus::-webkit-scrollbar {
			width: 0;
			height: 0;
			display: none;
		}
		
	}

	@media (max-width: 600px) {
			:root { --bottom-bar-height: 211px; }
		.board {
			gap: 3px;
			transform-origin: top left;
			transition: transform 0.4s ease;	
			left: 50%;
			transform: translateX(-50%) scale(var(--board-scale, 0.5));
			max-height: none;
		}

		/* Green grid (lichtgroene binnenste area) beperken (niet tijdens zoom) */
		body:not(.zoomed-in) #green-grid {
			min-width: calc(15 * var(--cell-size)) !important;
			max-width: calc(15 * var(--cell-size) + 20px) !important;
		}
		/* Zoomed-in: groen mag breder (2Ã—) zodat niets afkapt */
		body.zoomed-in #green-grid {
			min-width: calc(30 * var(--cell-size)) !important;
			max-width: calc(30 * var(--cell-size) + 20px) !important;
		}

		#blue-zone.zoom-focus {
			max-height: 66vh;
		}

		/* Actieve zone komt BOVEN de blur - behoud aspect ratio */
		.zone.zoom-focus {
		  position: fixed;
		  top: 32%;
		  left: 50%;
		  transform: translate(-50%, -50%) scale(0.95);
		  z-index: var(--z-zoom);
		  box-shadow: 0 0 30px rgba(0, 0, 0, 0.5);
		  margin: 2px;
		  padding: 3px;
		  border-radius: 6px;
		}

		/* Green zone zoom-focus specifiek */
		#green-zone.zoom-focus {
		  margin: 2px;
		  padding: 3px;
		  border-radius: 6px;
		}

		/* Red zone: behoud originele verhoudingen bij zoom */
		#red-zone.zoom-focus {
		  flex-wrap: wrap !important;
		  flex-direction: row !important;
		  width: auto !important;
		  min-width: 380px !important;
		  height: auto !important;
		  max-width: 90vw;
		}
		
	}
	
	@media (max-width: 550px) {
			:root { --bottom-bar-height: 196px; }
		.board {
			gap: 3px;
			transform-origin: top left;
			transition: transform 0.4s ease;	
			left: 50%;
			transform: translateX(-50%) scale(var(--board-scale, 0.5));
			max-height: none;
		}

		#blue-zone.zoom-focus {
			max-height: 66vh;
		}

		/* Actieve zone komt BOVEN de blur */
		.zone.zoom-focus {
		  position: fixed;
		  top: 35%;
		  left: 50%;
		  transform: translate(-50%, -50%) scale(0.95);
		  z-index: var(--z-zoom);
		  box-shadow: 0 0 30px rgba(0, 0, 0, 0.5);
		}

		/* Red zone: behoud originele verhoudingen bij zoom */
		#red-zone.zoom-focus {
		  flex-wrap: wrap !important;
		  flex-direction: row !important;
		  width: auto !important;
		  min-width: 380px !important;
		  height: auto !important;
		  max-width: 90vw;
		}
	
	}
	  
	@media (max-width: 510px) {
	
		.board {
			gap: 3px;
			transform-origin: top left;
			transition: transform 0.4s ease;	
			left: 50%;
			transform: translateX(-50%) scale(var(--board-scale, 0.5));
			max-height: none;
			padding: 0;
		}

		#blue-zone.zoom-focus {
			max-height: 66vh;
		}
	
	}

	@media (max-width: 490px) {
	
		:root {
			--bottom-bar-height: 175px;
		}
	
		.board {
			gap: 2px;
			transform-origin: top left;
			transition: transform 0.4s ease;	
			left: 50%;
			transform: translateX(-50%) scale(var(--board-scale, 0.5));
			max-height: none;
			padding: 0;
		}


		#blue-zone.zoom-focus {
			max-height: 66vh;
		}
		
		.zone.zoom-focus {
			transform: translate(-50%, -50%) scale(0.95);
			max-height: 80vh;
			overflow: hidden;
		}
		#blue-zone.zoom-focus {
			overflow-y: auto;
		}



		.bottom-bar-footer {
			margin-top: 0px;
			padding-top: 0px;
		}
	
	}

	@media (max-width: 450px) {
	
		:root {
			--bottom-bar-height: 175px;
		}
	
		.board {
			gap: 2px;
			transform-origin: top left;
			transition: transform 0.4s ease;	
			left: 50%;
			transform: translateX(-50%) scale(var(--board-scale, 0.5));
			max-height: none;
			padding: 0;
		}

		#blue-zone.zoom-focus {
			max-height: 66vh;
		}
		
		.zone.zoom-focus {
			transform: translate(-50%, -50%) scale(0.95);
			max-height: 80vh;
			overflow: hidden;
		}
		#blue-zone.zoom-focus {
			overflow-y: auto;
		}



		.bottom-bar-footer {
			margin-top: 0px;
			padding-top: 0px;
		}
	
	}

	@media (max-width: 430px) {
	
		:root {
			--bottom-bar-height: 175px;
		}
	
		.board {
			gap: 2px;
			transform-origin: top left;
			transition: transform 0.4s ease;	
			left: 50%;
			transform: translateX(-50%) scale(var(--board-scale, 0.5));
			max-height: none;
			padding: 0;
		}

		#blue-zone.zoom-focus {
			max-height: 66vh;
		}
		
		.zone.zoom-focus {
			transform: translate(-50%, -50%) scale(0.95);
			max-height: 80vh;
			overflow: hidden;
		}
		#blue-zone.zoom-focus {
			overflow-y: auto;
		}


		.bottom-bar-footer {
			margin-top: 0px;
			padding-top: 0px;
		}
	
	}

	@media (max-width: 410px) {
	
		:root {
			--bottom-bar-height: 175px;
		}
	
		.board {
			gap: 2px;
			transform-origin: top left;
			transition: transform 0.4s ease;	
			left: 50%;
			transform: translateX(-50%) scale(var(--board-scale, 0.5));
			max-height: none;
		}

		.zone.zoom-focus {
			transform: translate(-50%, -50%) scale(0.93);
		}


	}
	
	@media (max-width: 390px) {
	
		:root {
			--bottom-bar-height: 175px;
		}
	
		.board {
			gap: 2px;
			transform-origin: top left;
			transition: transform 0.4s ease;	
			left: 50%;
			transform: translateX(-50%) scale(var(--board-scale, 0.5));
			max-height: none;
		}

		.zone.zoom-focus {
			transform: translate(-50%, -50%) scale(0.60);
		}

	
	}

	/* ============================================
	   ZONE HEADERS
	   ============================================
	   H2 titels die bovenaan elke zone verschijnen (bijv. "Geel vak", "Blauw vak")
	   Dark mode krijgt lichtere grijstint voor betere leesbaarheid
	*/
	h2 { color: #555; margin:0 0 8px; font-size:1rem; text-align:center }
	body.dark-mode h2 { color: #b0b0b0; }

	/* ============================================
	   ZONE KLEUREN & AFMETINGEN
	   ============================================
	   Elk speelvak (zone) krijgt zijn eigen kleur, breedte en hoogte
	   Placeholder varianten zijn voor drag-and-drop preview
	   Dark mode krijgt donkere gradient overlays (zie verderop)
	*/
	#yellow-zone,
	#yellow-zone--placeholder { background:#f0dc7d; height: 450px; min-width: 300px; padding: 14px; }
	/* Yellow (World 2): keep the generated grid visually centered (equal top/bottom spacing). */
	#yellow-zone,
	#yellow-zone--placeholder {
		display: flex;
		flex-direction: column;
		align-items: center;
		justify-content: center;
	}
	#green-zone,
	#green-zone--placeholder { background:#a8d5a2; }
	/* World 2: keep green zone square (same width, more height). */
	body.world-2:not(.zoomed-in) #green-zone,
	body.world-2:not(.zoomed-in) #green-zone--placeholder {
		/* Width is set below; match height to that width. */
		height: calc(13 * var(--cell-size) + 80px);
		max-height: calc(13 * var(--cell-size) + 80px);
		overflow: auto;
	}
	/* Green (World 2 request): hide scrollbar visuals while keeping scroll. */
	#green-zone {
		scrollbar-width: none; /* Firefox */
		-ms-overflow-style: none; /* IE/Edge legacy */
	}
	#green-zone::-webkit-scrollbar {
		width: 0;
		height: 0;
		display: none;
	}
	#green-zone {
		cursor: grab;
	}
	#green-zone.drag-scroll-active {
		cursor: grabbing;
	}
	/* World 1: disable scrolling in green zone */
	#green-zone.no-scroll {
		overflow: hidden !important;
		cursor: default !important;
	}
	#green-zone.no-scroll.drag-scroll-active {
		cursor: default !important;
	}

	/* Desktop: beperk groene en rode zone breedte */
	@media (min-width: 651px) {
		#green-zone,
		#green-zone--placeholder {
			width: calc(13 * var(--cell-size) + 80px);
			max-width: calc(13 * var(--cell-size) + 80px);
		}
		#green-grid {
			max-width: calc(13 * var(--cell-size) + 40px);
		}
		/* Red zone should match the green zone width (user request). */
		#red-zone,
		#red-zone--placeholder {
			width: calc(13 * var(--cell-size) + 80px);
			max-width: calc(13 * var(--cell-size) + 80px);
			margin: 0;
		}
	}

	#yellow-zone,
	#yellow-zone--placeholder,
	#purple-zone,
	#purple-zone--placeholder {
		overflow: hidden;
	}
	#purple-zone,
	#purple-zone--placeholder { background:#a48dcc; height: 310px;  }
	#blue-zone,
	#blue-zone--placeholder { background:#6ba8d8; width: 180px; height: 791px; }

	/* Blue (World 2): keep scroll but hide the (white) scrollbar visuals on desktop too. */
	#blue-zone {
		overflow-y: auto;
		overflow-x: auto;
		scrollbar-width: none; /* Firefox */
		-ms-overflow-style: none; /* IE/Edge legacy */
	}
	#blue-zone::-webkit-scrollbar {
		width: 0;
		height: 0;
		display: none;
	}
	#blue-zone #blue-grid {
		scrollbar-width: none;
		-ms-overflow-style: none;
	}
	#blue-zone #blue-grid::-webkit-scrollbar {
		width: 0;
		height: 0;
		display: none;
	}
	#gold-zone,
	#gold-zone--placeholder { background:#fffbea; height: 100px; width: 280px; box-shadow: 0 0 8px rgba(0,0,0,0.4); }
	#red-zone,
	#red-zone--placeholder { background:#de838c; height: auto; min-height: 323px;  margin: 15px; border-radius: 10px; box-shadow: 0 2px 6px rgba(0,0,0,0.12);
	  box-sizing: border-box; padding: 10px; touch-action: manipulation; overflow: visible; }
	#red-zone.red-group {
		display: grid;
		grid-template-columns: repeat(2, max-content);
		justify-content: center;
		gap: 18px;
	}
	#red-zone.red-group > .zone {
		margin: 0 !important;
	}
	  
	#red-grid1,
	#red-grid1--placeholder { background:#de838c; margin: 15px; border-radius: 0; border:0; box-shadow: none !important; }
	#red-grid2,
	#red-grid2--placeholder { background:#de838c; margin: 15px; border-radius: 0; border:0; box-shadow: none; }
	#red-grid3,
	#red-grid3--placeholder { background:#de838c; margin: 15px; border-radius: 0; border:0; box-shadow: none; }
	#red-grid4,
	#red-grid4--placeholder { background:#de838c; margin: 15px; border-radius: 0; border:0; box-shadow: none; }
	@media (min-width: 651px) {
		#red-zone.red-group #red-grid1,
		#red-zone.red-group #red-grid2,
		#red-zone.red-group #red-grid3,
		#red-zone.red-group #red-grid4 {
			margin: 0 !important;
		}
	}

	/* DARK MODE: Override zone kleuren met donkere gradient */

	body.dark-mode #gold-zone--placeholder { 
		background: linear-gradient(145deg, #2d2920, #232119);
		border: 1px solid #3d3930;
	}
	

	/* ============================================
	   CEL KLEUREN PER ZONE
	   ============================================
	   Elke zone heeft cellen met hun eigen kleur schema
	   .cell = standaard (niet ingevuld)
	   .cell.active = ingevuld/actief (donkerder kleur)
	   .end-cell = speciale eindcel in groen vak
	*/
	#yellow-zone .cell,
	#yellow-zone--placeholder .cell { background: #fff3b0; color: #3e2f00; border-color: #fffba8; }
	#red-zone .cell,
	#red-zone--placeholder .cell { background: #ffd6d1; color: #4b0000; border-color: #ff7b73; }
	#purple-zone .cell,
	#purple-zone--placeholder .cell { background: #f3e8fa; border-color: #e6a8ff; }
	#green-zone .cell,
	#green-zone--placeholder .cell { background: #d6f5d6; color: #003300; border-color: #c1ffa8; } 
	#green-zone .cell.end-cell,
	#green-zone--placeholder .cell.end-cell {background-color: #7bba7b !important; border-color: #7bb57f; } 
	#blue-zone .cell,
	#blue-zone--placeholder .cell { background: #d6eaff; color: #001f3f; border-color: #a8d8ff; }
	#yellow-zone .cell.active,
	#yellow-zone--placeholder .cell.active { background: #cfba51; border-color: #f7dc54; } 
	#red-zone .cell.active,
	#red-zone--placeholder .cell.active { background: #b56069; border-color: #ff7b73; }
	#purple-zone .cell.active,
	#purple-zone--placeholder .cell.active { background: #8f76b8; color: #33004b; border-color: #e6a8ff; }
	#green-zone .cell.active,
	#green-zone--placeholder .cell.active { background: #92c28c; border-color: #c1ffa8; }
	#green-zone .cell.end-cell.active,
	#green-zone--placeholder .cell.end-cell.active {background-color: #5da35d !important; border-color: #518755; } 
#yellow-zone .cell.end-cell.active,
#yellow-zone--placeholder .cell.end-cell.active { background-color: #cfae4a !important; border-color: #b8963c !important; }
#purple-zone .cell.end-cell.active,
#purple-zone--placeholder .cell.end-cell.active { background-color: #7a5aa8 !important; border-color: #62478a !important; }
#blue-zone .cell.end-cell.active,
#blue-zone--placeholder .cell.end-cell.active { background-color: #3b7aa4 !important; border-color: #2f6386 !important; }

	/* Bold start cells should keep the normal active background but have a thicker/darker border */
	#green-zone .cell.bold-cell.active,
	#green-zone--placeholder .cell.bold-cell.active {
		background-color: #92c28c !important; /* match normal green active */
		border-color: #2b572b !important;
	}

	/* Start cell in green should not use the dark end-cell active color */
	#green-zone .cell.start-cell.active,
	#green-zone--placeholder .cell.start-cell.active { background-color: #92c28c !important; border-color: #c1ffa8 !important; }
	#blue-zone .cell.active,
	#blue-zone--placeholder .cell.active { background: #5689b0; border-color: #a8d8ff; }

	/* ============================================
	   COIN SYMBOL STYLING
	   ============================================
	   Gebruik Segoe UI Symbol / Apple Color Emoji voor coin emoji
	   zodat het correct wordt weergegeven in alle browsers
	*/
	.coin-symbol {
		font-family: "Segoe UI Symbol", "Segoe UI Emoji", "Apple Color Emoji", "Noto Color Emoji", Arial, sans-serif;
	}
	
	/* Algemene emoji ondersteuning voor toast berichten, feedback, etc. */
	.toast-message,
	.blackhole-feedback,
	.blackhole-subtext,
	.objective-toast,
	.modal-score-summary,
	.round-summary-icon,
	.card-label,
	[class*="feedback"],
	[class*="toast"] {
		font-family: "Segoe UI", -apple-system, BlinkMacSystemFont, sans-serif, "Segoe UI Symbol", "Segoe UI Emoji", "Apple Color Emoji", "Noto Color Emoji";
	}
	
	/* ============================================
	   GRID LAYOUT BASIS
	   ============================================
	   Basisstijl voor alle grid containers binnen zones
	   Gebruikt CSS Grid voor automatische cel positionering
	*/
	.grid { display: grid; gap: var(--board-grid-gap, 2px); justify-content: center; margin: 20px; }
	/* Yellow (World 2): remove inner grid margin so spacing stays even and not clipped. */
	#yellow-zone #yellow-grid.grid,
	#yellow-zone--placeholder #yellow-grid.grid {
		margin: 0;
	}
	/* Purple: match Yellow centering (no inner grid margin). */
	#purple-zone #purple-grid.grid,
	#purple-zone--placeholder #purple-grid.grid {
		margin: 0;
	}
	/* Green: remove inner margin so the darker outer rim disappears. */
	#green-zone #green-grid {
		margin: 0;
		background: transparent;
	}
	
	/* ============================================
	   CEL STIJLEN - BASIS
	   ============================================
	   De individuele cellen in elk speelvak
	   .edge-cell = rode gloed voor rand-cellen (in rood vak)
	   .bold-cell = dikke zwarte rand
	   .end-cell = groene eindcel
	   .active = ingevuld met animatie
	   .gold-cell = heeft gouden muntje symbool
	*/
	.cell.edge-cell {
	  border: 2px solid rgba(255,80,80,0.95);
	  box-shadow: 0 0 10px 3px rgba(255,80,80,0.45);
	  z-index: 6; /* op de root-cellen liggen */
	  transition: box-shadow 0.18s ease, border 0.18s ease;
	}
	.cell{
	  width: var(--cell-size);
	  height: var(--cell-size);
	  background: #f9fafc;      
	  color: #222;
	  border: 1px solid #d8dee9;
	  box-shadow: 0 1px 2px rgba(0,0,0,0.05);
	  border-radius: calc(var(--cell-size) / 4);
	  position:relative;
	  user-select:none;
	  display: flex;
	  align-items: center;
	  justify-content: center;
	  transition: background 0.25s, transform 0.15s;
	  animation: growRoot 0.3s forwards;
	}

	/* Green root cells are absolutely positioned; shrink + center them to create visible spacing. */
	#green-grid .root-cell:not(.void-cell) {
		width: calc(var(--cell-size) - 2px);
		height: calc(var(--cell-size) - 2px);
		transform: translate(1px, 1px);
	}



	/* WORLD 2 (Yellow): Alternate diagonal shading so players see the diagonal-row rule.
	   Keep it subtle and do NOT affect active/void cells. */
	#yellow-grid .cell.diag-shade-odd:not(.void-cell):not(.active) {
	  filter: brightness(0.985);
	}
	body.dark-mode #yellow-grid .cell.diag-shade-odd:not(.void-cell):not(.active) {
	  filter: brightness(1.06);
	}

	/* WORLD 2 (Purple): Buitenste 2 ringen met subtiel andere achtergrondkleur */
	#purple-grid .cell.outer-ring-0:not(.void-cell):not(.active) {
	  /* Buitenste ring: iets lichter (subtiel) */
	  background: #efe8f7;
	  filter: brightness(1.00);
	}
	#purple-grid .cell.outer-ring-1:not(.void-cell):not(.active) {
	  /* Tweede ring: nog iets lichter */
	  background: #f3eefb;
	  filter: brightness(1.00);
	}
	body.dark-mode #purple-grid .cell.outer-ring-0:not(.void-cell):not(.active) {
	  background: #d3c3ea;
	  filter: brightness(0.97);
	}
	body.dark-mode #purple-grid .cell.outer-ring-1:not(.void-cell):not(.active) {
	  background: #d9ccec;
	  filter: brightness(0.97);
	}

	/* Ensure golden card frame shows in the bottom-bar hand (more specific than the hand card background rules). */
	#bottom-bar #card-choice-zone .card-option.card-golden {
		background: linear-gradient(135deg, #fff9e6 0%, #ffe082 30%, #f6c84a 60%, #c78c1f 100%);
		border: 1px solid rgba(220,180,60,0.9);
		box-shadow: 0 28px 56px rgba(184,120,18,0.45), inset 0 1px 0 rgba(255,255,255,0.6);
	}
	body.dark-mode #bottom-bar #card-choice-zone .card-option.card-golden {
		background: linear-gradient(135deg, #5b4a14 0%, #8a6a1c 35%, #bf952a 70%, #e3c45e 100%);
		border: 1px solid rgba(200,160,30,0.8);
		box-shadow: 0 28px 52px rgba(0,0,0,0.6), inset 0 1px 0 rgba(255,255,255,0.08);
	}
	.cell.void-cell {
	  visibility: hidden;
	  pointer-events: none;
	  border: none;
	  background: transparent;
	  box-shadow: none;
	  animation: none;
	}
	.cell:hover { background: #eef3ff; }
	.cell.active { background: #cde3ff; border-color: #a8c9ff; color: #000; transform: scale(1.1); box-shadow: 0 0 8px rgba(58,111,247,0.25); }
	.cell.bold-cell{ border:2px solid #2c3333 !important }
	.cell.end-cell{ background:#a7d6aa; border-color:#a7d6aa }
	.cell.end-cell.active{ background:#81b884 }
	.cell.trap-cell { position: relative; }
	.cell.trap-triggered {
	  box-shadow: 0 0 12px rgba(196,56,56,0.55), inset 0 0 10px rgba(196,56,56,0.45);
	  animation: trapPulse 0.5s ease;
	}

	@keyframes trapPulse {
	  0% { transform: scale(1); }
	  50% { transform: scale(1.05); }
	  100% { transform: scale(1); }
	}
	
	/* ============================================
	   SYMBOLEN IN CELLEN
	   ============================================
	   Gekleurde vierkantjes die in cellen kunnen verschijnen
	   Tonen welke kleur/zone de cel vertegenwoordigt
	*/
	.symbol { display: inline-block; width: 14px; height: 14px; border-radius: 4px; margin: auto; border:2px solid #444; background-color: #999; }
	.symbol.yellow { background-color: #fff48f; }
	.symbol.green  { background-color: #69cf57; }
	.symbol.purple { background-color: #ae7eed; }
	.symbol.blue   { background-color: #76a0e3; }
	.symbol.red    { background-color: #ed7e89; }
	.symbol.trap-symbol {
	  width: 18px;
	  height: 18px;
	  border-radius: 2px;
	  background: #656565;
	  border: none;
	  transform: rotate(45deg) scale(0.75);
	  pointer-events: none;
	  position: relative;
	  overflow: hidden;
	}

	.symbol.trap-symbol::after {
	  content: "";
	  position: absolute;
	  inset: 4px;
	  border-radius: 1px;
	  background: linear-gradient(135deg, rgba(255,255,255,0.2) 0%, rgba(255,255,255,0) 50%);
	  opacity: 0.8;
	}

	.symbol.trap-symbol.trap-symbol--pit::after {
	  opacity: 0.6;
	}

	.symbol.trap-symbol.trap-symbol--black-hole {
	  background: radial-gradient(circle, #1a1a2e 0%, #0a0a15 60%, #000000 100%);
	  border-radius: 50%;
	  box-shadow: 
		0 0 15px rgba(138, 43, 226, 0.6),
		0 0 25px rgba(75, 0, 130, 0.4),
		inset 0 0 20px rgba(138, 43, 226, 0.3);
	  border: 2px solid rgba(138, 43, 226, 0.4);
	}

	.symbol.trap-symbol.trap-symbol--black-hole::after {
	  background: radial-gradient(circle, rgba(138, 43, 226, 0.2) 0%, transparent 70%);
	  opacity: 1;
	  border-radius: 50%;
	  animation: black-hole-pulse 2s ease-in-out infinite;
	}

	/* Mega Bonus Symbol - grotere bonus met shimmer effect */
	.symbol.mega-bonus-symbol {
	  width: 120%;
	  height: 120%;
	  border-radius: 8px;
	  cursor: pointer;
	  display: flex;
	  align-items: center;
	  justify-content: center;
	  font-size: 24px;
	  font-weight: bold;
	  position: absolute;
	  top: 50%;
	  left: 50%;
	  transform: translate(-50%, -50%);
	  transition: transform 0.2s ease;
	  z-index: 15;
	  /* Gradient glim effect over bonus color */
	  background: linear-gradient(135deg, 
		rgba(255, 255, 255, 0.4) 0%, 
		transparent 40%, 
		transparent 60%, 
		rgba(255, 255, 255, 0.4) 100%);
	  background-size: 200% 200%;
	  animation: mega-bonus-glim 2.5s ease-in-out infinite;
	  box-shadow: 0 0 15px rgba(255, 255, 255, 0.5), 
				  inset 0 0 20px rgba(255, 255, 255, 0.3);
	}

	.symbol.mega-bonus-symbol:hover {
	  transform: translate(-50%, -50%) scale(1.15);
	}

	/* Upgrade Shop Symbol - shop icoon met gouden gloed */
	.symbol.upgrade-shop-symbol {
	  width: 100%;
	  height: 100%;
	  border-radius: 8px;
	  cursor: pointer;
	  display: flex;
	  align-items: center;
	  justify-content: center;
	  font-size: 24px;
	  font-weight: bold;
	  position: absolute;
	  top: 50%;
	  left: 50%;
	  transform: translate(-50%, -50%);
	  transition: transform 0.2s ease;
	  z-index: 15;
		/* Diamond-like cool gradient to distinguish from traps */
		background: linear-gradient(135deg, #e6fbff 0%, #bfefff 40%, #9ad8ff 100%);
		color: #0b3b4a;
		box-shadow: 0 0 8px rgba(60,160,200,0.25), inset 0 0 6px rgba(255,255,255,0.6);
	}

/* Diamond glyph styling for inline text (toasts, titles) */
.diamond-glyph { color: #0b3b4a; font-weight: 700; text-shadow: 0 1px 0 rgba(255,255,255,0.25); }
body.dark-mode .diamond-glyph { color: #bfefff; }

	.symbol.upgrade-shop-symbol:hover {
	  transform: translate(-50%, -50%) scale(1.15);
	}

	@keyframes upgrade-shop-glim {
	  0%, 100% { 
		background-position: 0% 50%;
	  }
	  50% { 
		background-position: 100% 50%;
	  }
	}

	@keyframes mega-bonus-glim {
	  0%, 100% { 
		background-position: 0% 50%;
	  }
	  50% { 
		background-position: 100% 50%;
	  }
	}

	@keyframes black-hole-pulse {
		0%, 100% {
			transform: scale(1);
			opacity: 0.8;
		}
		50% {
			transform: scale(1.1);
			opacity: 1;
		}
	}
	
	/* Portal cel styling */
	.portal-cell {
		animation: portal-pulse 2s ease-in-out infinite;
		z-index: 10 !important;
	}

	.portal-symbol {
		position: absolute;
		top: 50%;
		left: 50%;
		transform: translate(-50%, -50%);
		font-size: 24px;
		z-index: 100;
		pointer-events: none;
		filter: drop-shadow(0 0 10px rgba(100, 150, 255, 1));
		animation: portal-rotate 3s linear infinite;
		text-shadow: 0 0 15px rgba(100, 150, 255, 0.8);
	}

	@keyframes portal-pulse {
		0%, 100% {
			box-shadow: 0 0 15px rgba(100, 150, 255, 0.8), inset 0 0 15px rgba(100, 150, 255, 0.5);
		}
		50% {
			box-shadow: 0 0 30px rgba(100, 150, 255, 1), inset 0 0 20px rgba(100, 150, 255, 0.7);
		}
	}

	@keyframes portal-rotate {
		0% { transform: translate(-50%, -50%) rotate(0deg); }
		100% { transform: translate(-50%, -50%) rotate(360deg); }
	}
	
	/* Gouden muntje binnen een cel (gebruikt ::after pseudo-element) */
	.gold-cell::after { content: ""; position: absolute; top: 4px; left: 4px; width: 12px; height: 12px; border-radius: 50%; background: #ffea63; border: 2px solid #171615; z-index: 1; }
	.cell.active.gold-cell::after{ background:#edcd21 }
	
	/* ============================================
	   MUNTEN VERZAMELING (GOUDEN VAK)
	   ============================================
	   Container voor de 20 muntjes in het gouden vak
	   Toont hoeveel munten je hebt verzameld/gebruikt
	*/
	#collected-coins{ display:flex; gap:6px; flex-wrap:wrap; justify-content:center; margin-top:5px;  }
	
	/* ============================================
	   INDIVIDUELE MUNTEN
	   ============================================
	   Elk muntje heeft 3 states:
	   - standaard (grijs, niet verzameld)
	   - .active (goudkleurig, verzameld maar niet gebruikt)
	   - .used (donkergrijs, al uitgegeven in shop)
	*/
	.coin {
		width: 18px;
		height: 18px;
		border-radius: 50%;
		background: rgba(255,255,255,0.18);
		border: 1px solid rgba(255,255,255,0.28);
		box-shadow: inset 0 0 0 1px rgba(0,0,0,0.25), 0 0 6px rgba(0,0,0,0.25);
		transition: transform 0.2s ease, background 0.2s ease, border-color 0.2s ease, box-shadow 0.2s ease;
	}

	.coin.active {
		background: radial-gradient(circle at 30% 30%, #fff6b5, #f7bb36 70%);
		border-color: #f3b12b;
		box-shadow: 0 0 8px rgba(255,209,90,0.78), inset 0 0 2px rgba(255,255,255,0.85);
		transform: scale(1.05);
	}

	.coin.used {
		background: rgba(80,82,95,0.65);
		border-color: rgba(120,124,140,0.6);
		box-shadow: inset 0 0 0 1px rgba(0,0,0,0.4);
		transform: scale(1);
	}

	body.dark-mode .coin {
		background: rgba(255,255,255,0.14);
		border-color: rgba(255,255,255,0.24);
	}

	body.dark-mode .coin.active {
		background: radial-gradient(circle at 30% 30%, #ffe58c, #f5b72f 70%);
	}

	body.dark-mode .coin.used {
		background: rgba(60,60,72,0.7);
		border-color: rgba(110,110,130,0.55);
		box-shadow: inset 0 0 0 1px rgba(0,0,0,0.55);
	}

	/* ============================================
	   +1 BLOKPLAATSING KNOP
	   ============================================ */
	.buy-placement-btn {
		display: flex;
		align-items: center;
		justify-content: center;
		gap: 6px;
		margin-top: 10px;
		padding: 8px 14px;
		border: 1px solid rgba(26,32,48,0.16);
		border-radius: 8px;
		background: linear-gradient(155deg, #eff3ff 0%, #dbe2f6 100%);
		color: #2b3148;
		font-weight: 600;
		font-size: 0.9rem;
		cursor: pointer;
		transition: transform 0.15s ease, box-shadow 0.15s ease, background 0.15s ease;
		box-shadow: 0 12px 20px rgba(10,12,20,0.22);
	}
	.buy-placement-btn:hover:not(:disabled) {
		transform: translateY(-2px);
		box-shadow: 0 18px 28px rgba(10,12,20,0.28);
		background: linear-gradient(155deg, #f4f7ff 0%, #e2e8fb 100%);
	}
	.buy-placement-btn:active:not(:disabled) {
		transform: translateY(0);
		box-shadow: 0 10px 18px rgba(10,12,20,0.22);
	}
	.buy-placement-btn:disabled {
		opacity: 0.5;
		cursor: not-allowed;
		background: linear-gradient(135deg, #e0e0e0, #bdbdbd);
		border-color: rgba(26,32,48,0.16);
		color: #757575;
	}
	.buy-placement-arrow {
		font-size: 1.05rem;
		line-height: 1;
		opacity: 0.9;
		transform: translateY(-0.5px);
	}
	/* Hide the arrow on touch devices */
	@media (pointer: coarse) {
		.buy-placement-arrow {
			display: none;
		}
	}
	.buy-placement-rainbow-cell {
		width: 18px;
		height: 18px;
		/* Border-radius: max 5px, minder rond */
		border-radius: min(5px, calc(18px / 5));
		display: inline-block;
		box-shadow: inset 0 0 0 1px rgba(0,0,0,0.22), 0 2px 6px rgba(0,0,0,0.22);
		background: linear-gradient(
			135deg,
			#ff5757 0%,
			#ffbf3a 22%,
			#8cff6a 45%,
			#47b1ff 70%,
			#b16cff 100%
		);
	}
	.buy-placement-cost {
		display: flex;
		gap: 3px;
		background: rgba(0,0,0,0.1);
		padding: 2px 6px;
		border-radius: 4px;
		font-size: 0.8rem;
	}
	.buy-placement-cost .coin-icon {
		display: inline-block;
		width: 0.9em;
		height: 0.9em;
		border-radius: 50%;
		background: radial-gradient(circle at 30% 30%, #fff6b5, #f7bb36 60%, #d49f20);
		box-shadow: inset 0 -1px 2px rgba(0,0,0,0.2);
		border: 1px solid #c9960a;
	}
	body.dark-mode .buy-placement-btn {
		background: linear-gradient(160deg, #2c3144 0%, #222635 100%);
		border-color: rgba(140,150,200,0.3);
		color: rgba(235,238,255,0.88);
		box-shadow: 0 16px 30px rgba(0,0,0,0.42);
	}
	body.dark-mode .buy-placement-btn:hover:not(:disabled) {
		background: linear-gradient(160deg, #333a52 0%, #252a3b 100%);
		box-shadow: 0 20px 34px rgba(0,0,0,0.5);
	}
	body.dark-mode .buy-placement-btn:disabled {
		background: linear-gradient(135deg, #3a3a3a, #2a2a2a);
		border-color: rgba(140,150,200,0.2);
		color: #888;
		transform: scale(1);
	}
	body.dark-mode .buy-placement-rainbow-cell {
		box-shadow: inset 0 0 0 1px rgba(255,255,255,0.12), 0 2px 8px rgba(0,0,0,0.55);
	}

	/* Gekocht blok preview in gold zone */
	#buy-placement-container {
		display: flex;
		justify-content: center;
		margin-top: 10px;
	}
	.purchased-block-preview {
		display: flex;
		flex-direction: column;
		align-items: center;
		gap: 6px;
		padding: 10px 16px;
		background: linear-gradient(135deg, rgba(240,98,114,0.15), rgba(255,245,90,0.15), rgba(78,211,70,0.15), rgba(93,144,240,0.15));
		border: 2px dashed rgba(150,100,200,0.5);
		border-radius: 10px;
		cursor: grab;
		transition: transform 0.15s ease, box-shadow 0.15s ease;
		animation: pulse-glow 1.5s ease-in-out infinite;
	}
	.purchased-block-preview:hover {
		transform: scale(1.05);
		box-shadow: 0 4px 16px rgba(150,100,200,0.3);
	}
	.purchased-block-preview:active {
		cursor: grabbing;
	}
	.purchased-block-cell {
		width: 28px;
		height: 28px;
		border-radius: 4px;
		background: linear-gradient(45deg, #f06272, #fff25a, #4ed346, #5d90f0, #a35eff);
		border: 2px solid rgba(255,255,255,0.5);
		box-shadow: 0 2px 8px rgba(0,0,0,0.2);
	}
	.purchased-block-label {
		font-size: 0.75rem;
		font-weight: 600;
		color: #6b4d8a;
	}
	@media (max-width: 650px) {
		.purchased-block-label {
			display: none;
		}
		.purchased-block-preview {
			gap: 4px;
			padding: 8px 12px;
		}
	}
	body.dark-mode .purchased-block-preview {
		background: linear-gradient(135deg, rgba(240,98,114,0.1), rgba(255,245,90,0.1), rgba(78,211,70,0.1), rgba(93,144,240,0.1));
		border-color: rgba(180,140,220,0.4);
	}
	body.dark-mode .purchased-block-label {
		color: #c9b0e8;
	}
	/* Keep the purchased preview visible everywhere; it's the drag handle to place the bought block. */
	@keyframes pulse-glow {
		0%, 100% { box-shadow: 0 0 8px rgba(150,100,200,0.2); }
		50% { box-shadow: 0 0 16px rgba(150,100,200,0.4); }
	}
	
	/* ============================================
	   SCOREBORD
	   ============================================
	   Toont score per kleur + totaal
	   Gepositioneerd in kolom 4 op desktop, in bottom-bar op mobiel
	   Score-rows gebruiken kleur-dots voor compactheid
	*/
	#scoreboard {
	  background: #fffbea;
	  border-radius: 12px;
	  padding: 16px 20px;
	  color: #333;
	  font-family: "Segoe UI", sans-serif;
	  width: 280px;
	  position: relative;
	  z-index: 1;
	  box-shadow: 0 0 8px rgba(0,0,0,0.4);
	  display: flex;
	  flex-direction: column;
	  align-items: stretch;
	  gap: 12px;
	}

	#scoreboard h2 {
	  margin: 0;
	}

	body.dark-mode #scoreboard {
	  background: linear-gradient(145deg, #2d2920, #232119);
	  border: 1px solid #3d3930;
	  color: #e0e0e0;
	}

	.score-row { 
	  display: flex; 
	  align-items: center; 
	  justify-content: space-between; 
	  background: #eee; 
	  padding: 6px 10px; 
	  border-radius: 8px; 
	  margin: 0;
	  position: relative;
	  transition: transform 0.1s ease, background 0.3s, box-shadow 0.3s; 
	}

	/* Zone-info knopjes (links boven in elke zone) */
	.zone-info-btn {
		position: absolute;
		left: 8px;
		top: 8px;
		z-index: 20;
		width: 20px;
		height: 20px;
		border-radius: 999px;
		border: 1px solid rgba(0,0,0,0.18);
		background: rgba(255,255,255,0.7);
		color: rgba(0,0,0,0.75);
		font-weight: 800;
		font-size: 12px;
		line-height: 1;
		display: inline-flex;
		align-items: center;
		justify-content: center;
		cursor: pointer;
		padding: 0;
		-webkit-user-select: none;
		user-select: none;
	}

	/* When a zone is scrollable, pin the info UI to the zone viewport. */
	#blue-zone .zone-info-btn,
	#green-zone .zone-info-btn {
		position: sticky;
		top: 8px;
		left: 8px;
		margin: 0 0 -20px 0;
	}
	#blue-zone .zone-info-popover,
	#green-zone .zone-info-popover {
		position: sticky;
		top: 34px;
		left: 8px;
		margin: 0 0 -140px 0;
	}

	body.dark-mode .zone-info-btn {
		border-color: rgba(255,255,255,0.18);
		background: rgba(0,0,0,0.2);
		color: rgba(255,255,255,0.82);
	}

	.zone-info-btn:focus {
		outline: 2px solid rgba(0,0,0,0.25);
		outline-offset: 2px;
	}

	body.dark-mode .zone-info-btn:focus {
		outline-color: rgba(255,255,255,0.22);
	}

	.zone-info-popover {
		position: absolute;
		left: 8px;
		right: 8px;
		top: 34px;
		z-index: 30;
		display: none;
		padding: 10px 12px;
		border-radius: 10px;
		background: rgba(255,255,255,0.95);
		border: 1px solid rgba(0,0,0,0.14);
		box-shadow: 0 8px 20px rgba(0,0,0,0.18);
		font-size: 0.82rem;
		line-height: 1.25;
		color: rgba(0,0,0,0.78);
		-webkit-backdrop-filter: blur(6px);
		backdrop-filter: blur(6px);
	}

	body.dark-mode .zone-info-popover {
		background: rgba(35, 33, 25, 0.96);
		border-color: rgba(255,255,255,0.12);
		box-shadow: 0 10px 22px rgba(0,0,0,0.55);
		color: rgba(255,255,255,0.85);
	}

	.zone[data-info-open="true"] .zone-info-popover {
		display: block;
	}
	
	body.dark-mode .score-row {
	  background: #383838;
	  color: #e0e0e0;
	}

	.score-row:hover { transform: scale(1.03); background: #383838; }
	
	/* Score highlighting voor behaalde doelstellingen */
	.score-row.objective-achieved {
	  box-shadow: 0 0 10px 2px rgba(255, 215, 0, 0.6);
	  animation: objective-pulse 2s ease-in-out infinite;
	}
	
	body.dark-mode .score-row.objective-achieved {
	  box-shadow: 0 0 12px 2px rgba(255, 215, 0, 0.7);
	  animation: objective-pulse-dark 2s ease-in-out infinite;
	}
	
	@keyframes objective-pulse {
	  0%, 100% { box-shadow: 0 0 10px 2px rgba(255, 215, 0, 0.6); }
	  50% { box-shadow: 0 0 15px 3px rgba(255, 215, 0, 0.8); }
	}
	
	@keyframes objective-pulse-dark {
	  0%, 100% { box-shadow: 0 0 12px 2px rgba(255, 215, 0, 0.7); }
	  50% { box-shadow: 0 0 18px 4px rgba(255, 215, 0, 0.9); }
	}

	body.dark-mode .score-row:hover {
	  background: #484848;
	}

	.color-box { width: 14px; height: 14px; border-radius: 3px; margin-right: 8px; }
	.label { flex: 1; font-size: 0.9em; }
	.score { font-weight: bold; font-size: 1em; }
	.score-row.yellow .color-box { background-color: #f7e757; }
	.score-row.red .color-box { background-color: #ed7e89; }
	.score-row.green .color-box { background-color: #69cf57; }
	.score-row.purple .color-box { background-color: #ae7eed; }
	.score-row.blue .color-box { background-color: #76a0e3; }
	.score-row.bonus .color-box { background-color: #C0C0C0; }
	#scoreboard hr {
	  width: 100%;
	  border: none;
	  border-top: 1px solid rgba(0,0,0,0.08);
	  margin: 0;
	}

	body.dark-mode #scoreboard hr {
	  border-top-color: rgba(255,255,255,0.12);
	}

	#scoreboard .score-total {
	  display: flex;
	  align-items: center;
	  justify-content: space-between;
	  gap: 6px;
	  padding: 4px 8px;
	  background: #f0ead8;
	  border-radius: 6px;
	  border: 1px solid #d9d0bd;
	  font-weight: 600;
	  color: #333;
	  margin-top: 3px;
	  font-size: 0.9rem;
	  transition: box-shadow 0.3s;
	}
	
	/* Total score highlighting voor behaalde doelstellingen */
	#scoreboard .score-total.objective-achieved {
	  box-shadow: 0 0 10px 2px rgba(255, 215, 0, 0.6);
	  animation: objective-pulse 2s ease-in-out infinite;
	}
	
	body.dark-mode #scoreboard .score-total.objective-achieved {
	  box-shadow: 0 0 12px 2px rgba(255, 215, 0, 0.7);
	  animation: objective-pulse-dark 2s ease-in-out infinite;
	}

	body.dark-mode #scoreboard .score-total {
	  background: #2f3239;
	  border-color: #3d4048;
	  color: #e5e5e5;
	}

	#scoreboard .trap-summary {
	  display: flex;
	  flex-direction: column;
	  gap: 6px;
	  padding: 10px 12px;
	  border-radius: 12px;
	  background: rgba(0,0,0,0.035);
	  border: 1px solid rgba(0,0,0,0.06);
	}

	#scoreboard .trap-summary-header {
	  display: flex;
	  justify-content: space-between;
	  align-items: center;
	  font-size: 0.78rem;
	  letter-spacing: 0.05em;
	  text-transform: uppercase;
	  color: rgba(0,0,0,0.55);
	}

	#scoreboard .trap-summary-header .trap-label {
	  font-weight: 600;
	}

	#scoreboard .trap-count {
	  font-weight: 600;
	  font-size: 0.85rem;
	  color: #c43838;
	}

	#scoreboard .trap-preview {
	  display: flex;
	  flex-wrap: wrap;
	  gap: 8px;
	  align-items: center;
	  overflow: hidden;
	  padding-bottom: 0;
	  scrollbar-width: none;
	}

	#scoreboard .trap-preview.trap-preview--compact {
	  gap: 6px;
	  row-gap: 4px;
	}

	#scoreboard .trap-preview:empty::after {
	  content: 'Geen valkuilen geactiveerd';
	  font-size: 0.85rem;
	  color: rgba(0,0,0,0.45);
	  font-style: italic;
	}

	.trap-preview::-webkit-scrollbar {
	  display: none;
	}

	.trap-preview::-webkit-scrollbar-track {
	  background: rgba(0,0,0,0.05);
	  border-radius: 6px;
	}

	.trap-preview::-webkit-scrollbar-thumb {
	  background: rgba(196,56,56,0.4);
	  border-radius: 6px;
	}

	.trap-preview--compact .trap-icon {
	  display: none;
	}

	.trap-compact-chip {
	  display: inline-flex;
	  align-items: center;
	  gap: 4px;
	  padding: 2px 9px;
	  border-radius: 999px;
	  font-weight: 600;
	  font-size: 0.8rem;
	  background: rgba(196,56,56,0.12);
	  color: #a51111;
	  border: 1px solid rgba(196,56,56,0.28);
	}

	.trap-compact-chip::before {
	  content: attr(data-symbol);
	  font-size: 1rem;
	  line-height: 1;
	}

	.trap-compact-chip span {
	  pointer-events: none;
	}

	.trap-compact-chip--black-hole {
	  background: rgba(62, 44, 143, 0.12);
	  color: #3e2c8f;
	  border-color: rgba(62, 44, 143, 0.26);
	}

	.trap-icon {
	  position: relative;
	  width: 40px;
	  height: 40px;
	  flex: 0 0 auto;
	  display: flex;
	  align-items: center;
	  justify-content: center;
	  border-radius: 10px;
	  background: radial-gradient(circle at 30% 30%, #ffeaea, #f6d3d3);
	  border: 1px solid rgba(196,56,56,0.35);
	  box-shadow: 0 4px 10px rgba(196,56,56,0.18);
	  font-size: 1.4rem;
	  color: #a51111;
	  transition: transform 0.2s ease, box-shadow 0.2s ease;
	}

	.trap-icon .penalty-chip {
	  position: absolute;
	  right: -4px;
	  bottom: -6px;
	  background: #2a0b0b;
	  color: #ffb3b3;
	  font-size: 0.7rem;
	  font-weight: 600;
	  padding: 1px 5px;
	  border-radius: 10px;
	  border: 1px solid rgba(255,255,255,0.25);
	  box-shadow: 0 4px 8px rgba(0,0,0,0.2);
	}

	.trap-icon.trap-icon--black-hole {
	  background: radial-gradient(circle at 35% 28%, #f1ecff 0%, #d7d1fb 60%, #bfb6ef 100%);
	  border-color: rgba(110, 80, 210, 0.35);
	  color: #3e2c8f;
	  box-shadow: 0 6px 14px rgba(80, 60, 160, 0.28);
	}

	.trap-icon.trap-icon--black-hole .penalty-chip {
	  background: rgba(40, 28, 100, 0.9);
	  color: #efe8ff;
	  border-color: rgba(255,255,255,0.38);
	}

	.trap-icon span {
	  pointer-events: none;
	}

	.trap-icon span:first-child {
	  font-size: 1.05rem;
	}

	.trap-icon.highlight {
	  transform: translateY(-3px) scale(1.05);
	  box-shadow: 0 8px 16px rgba(196,56,56,0.36);
	}

	#scoreboard .score-total .label {
	  font-size: 0.85rem;
	  letter-spacing: 0.08em;
	  text-transform: uppercase;
	  opacity: 0.8;
	}

	#scoreboard .score-total .total-score {
	  font-size: 2.2rem;
	  line-height: 1;
	  font-weight: 700;
	  color: #2b1a00;
	}

	#bonus-score[data-blackhole-extra]:not([data-blackhole-extra="0"])::after {
	  content: ' +' attr(data-blackhole-extra);
	  font-size: 0.7em;
	  margin-left: 6px;
	  color: #6b63c9;
	}

	body.dark-mode #scoreboard .score-total {
	  background: linear-gradient(140deg, #3a331f, #2b2619);
	  border-color: rgba(255, 199, 63, 0.25);
	  color: #f6f1dd;
	  box-shadow: 0 16px 30px rgba(0,0,0,0.35);
	}

	body.dark-mode #scoreboard .trap-summary {
	  background: rgba(255,255,255,0.03);
	  border-color: rgba(255,255,255,0.07);
	}
	body.dark-mode #bonus-score[data-blackhole-extra]:not([data-blackhole-extra="0"])::after {
	  color: #d5d0ff;
	}

	body.dark-mode .trap-icon {
	  background: radial-gradient(circle at 30% 30%, #3c1e1e, #281111);
	  border-color: rgba(196,56,56,0.45);
	  color: #f3bbbb;
	  box-shadow: 0 4px 12px rgba(0,0,0,0.45);
	}

	body.dark-mode .trap-icon.trap-icon--black-hole {
	  background: radial-gradient(circle at 38% 32%, #403472 0%, #291f55 58%, #110b30 100%);
	  border-color: rgba(150,120,240,0.55);
	  color: #d9d5ff;
	  box-shadow: 0 6px 16px rgba(50,30,120,0.45);
	}

	body.dark-mode .trap-icon .penalty-chip {
	  background: rgba(70,20,20,0.85);
	  color: #ffc9c9;
	}

	body.dark-mode .trap-icon.trap-icon--black-hole .penalty-chip {
	  background: rgba(24,18,70,0.9);
	  color: #f0ecff;
	}

	body.dark-mode #scoreboard .trap-summary-header {
	  color: rgba(255,240,210,0.6);
	}

	body.dark-mode #scoreboard .trap-summary-header .trap-label {
	  color: rgba(255,240,210,0.9);
	}

	body.dark-mode #scoreboard .trap-count {
	  color: #ff8585;
	}

	body.dark-mode #scoreboard .trap-preview:empty::after {
	  color: rgba(255,255,255,0.35);
	}

	body.dark-mode .trap-preview::-webkit-scrollbar-track {
	  background: rgba(255,255,255,0.05);
	}

	body.dark-mode .trap-preview::-webkit-scrollbar-thumb {
	  background: rgba(255,120,120,0.45);
	}

	body.dark-mode .trap-compact-chip {
	  background: rgba(196,56,56,0.18);
	  color: #ffb3b3;
	  border-color: rgba(196,56,56,0.32);
	}

	body.dark-mode .trap-compact-chip--black-hole {
	  background: rgba(79, 64, 150, 0.22);
	  color: #d6d1ff;
	  border-color: rgba(131, 117, 210, 0.35);
	}

	body.dark-mode .trap-icon {
	  background: radial-gradient(circle at 30% 30%, #4b1c1c, #2a1212);
	  border-color: rgba(255,120,120,0.45);
	  color: #ffb3b3;
	  box-shadow: 0 4px 10px rgba(0,0,0,0.4);
	}

	body.dark-mode .trap-icon .penalty-chip {
	  background: #901717;
	  color: #ffe0e0;
	  border-color: rgba(0,0,0,0.45);
	}

	body.dark-mode #scoreboard .score-total .label {
	  color: rgba(255, 243, 205, 0.8);
	}

	body.dark-mode #scoreboard .score-total .total-score {
	  color: #ffe6a3;
	}

	/* ============================================
	   HIGH SCORE POPUP & MODAL
	   ============================================
	*/
	.highscore-toast {
		position: fixed;
		top: 80px;
		left: 50%;
		transform: translate(-50%, 0) scale(0.96);
		background: linear-gradient(120deg, #fff7d1, #ffe089);
		color: #2a1b00;
		padding: 14px 20px;
		border-radius: 16px;
		display: flex !important;
		align-items: center;
		gap: 12px;
		box-shadow: 0 18px 40px rgba(0,0,0,0.32);
		font-weight: 600;
		z-index: 2147483647 !important;
		opacity: 0;
		animation: highscoreToastEnter 0.35s ease forwards;
		pointer-events: none;
	}

	.highscore-toast__icon {
		font-size: 1.5rem;
	}

	.highscore-toast__score {
		font-size: 1.25rem;
		font-weight: 800;
	}

	body.dark-mode .highscore-toast {
		background: linear-gradient(120deg, #2f2a1f, #4d3f1d);
		color: #fff6cc;
		box-shadow: 0 20px 46px rgba(0,0,0,0.6);
	}

	@keyframes highscoreToastEnter {
		0% { opacity: 0; transform: translate(-50%, -30px) scale(0.8); }
		70% { opacity: 1; transform: translate(-50%, 6px) scale(1.03); }
		100% { opacity: 1; transform: translate(-50%, 0) scale(1); }
	}

	/* High Score Modal */
	.highscore-modal-overlay {
		position: fixed;
		inset: 0;
		background: rgba(0,0,0,0.5);
		backdrop-filter: blur(4px);
		display: none;
		align-items: center;
		justify-content: center;
		z-index: 10000;
	}
	.highscore-modal-overlay.show { display: flex; }
	.highscore-modal {
		background: white;
		padding: 30px;
		border-radius: 12px;
		text-align: center;
		box-shadow: 0 10px 30px rgba(0,0,0,0.3);
		max-width: 90%;
		width: 300px;
	}
	body.dark-mode .highscore-modal {
		background: #2d2d2d;
		color: #eee;
	}
	.highscore-value {
		font-size: 3rem;
		font-weight: bold;
		color: #d4af37;
		margin: 20px 0;
	}
	.highscore-close-btn {
		background: #eee;
		border: none;
		padding: 10px 20px;
		border-radius: 6px;
		cursor: pointer;
		font-weight: bold;
	}
	.highscore-close-btn:hover { background: #ddd; }
	body.dark-mode .highscore-close-btn {
		background: #444;
		color: #eee;
	}
	body.dark-mode .highscore-close-btn:hover {
		background: #555;
	}

/* Saved-levels modal tweaks */
#saved-levels-modal .highscore-modal { width: 420px; max-width: 95%; text-align: left; }
#saved-levels-modal .highscore-modal h2 { margin: 0 0 12px 0; }
#saved-levels-modal #saved-levels-list { padding: 6px 4px; gap: 8px; }
#saved-levels-modal #saved-levels-list > div { display:flex; align-items:center; gap:8px; padding:8px; border-radius:6px; }
#saved-levels-modal #saved-levels-list > div:hover { background: rgba(0,0,0,0.03); }
#saved-levels-modal .highscore-modal button { padding:6px 10px; border-radius:6px; border:1px solid rgba(0,0,0,0.08); background:transparent; cursor:pointer; }
#saved-levels-modal .highscore-modal button:hover { background: rgba(0,0,0,0.04); }
#saved-levels-modal .trash-btn { color: #666; }
#saved-levels-modal .trash-btn:hover { color: #c0392b; }

/* Buttons: default + primary (blue) */
#saved-levels-modal .modal-btn { background: #f6f6f6; color: #222; border: 1px solid rgba(0,0,0,0.06); }
#saved-levels-modal .modal-btn.primary { background: linear-gradient(135deg,#4a90e2,#6fb1ff); color: #fff; border: none; }
#saved-levels-modal .modal-btn.primary:hover { filter: brightness(0.95); }

/* Dark mode overrides for better contrast */
body.dark-mode #saved-levels-modal .modal-btn { background: #3a3a3a; color: #eee; border: 1px solid rgba(255,255,255,0.04); }
body.dark-mode #saved-levels-modal .modal-btn.primary { background: linear-gradient(135deg,#2b6fb8,#4a90e2); color: #fff; }
body.dark-mode #saved-levels-modal .modal-btn.primary:hover { filter: brightness(1.05); }
body.dark-mode #saved-levels-modal .trash-btn { color: #ccc; }

/* Saved item title and label colors */
#saved-levels-modal .saved-title { font-size: 14px; color: rgba(0,0,0,0.9); }
body.dark-mode #saved-levels-modal .saved-title { color: #fff; }

/* Custom scrollbar for saved-levels list */
#saved-levels-modal #saved-levels-list::-webkit-scrollbar { width:10px; }
#saved-levels-modal #saved-levels-list::-webkit-scrollbar-track { background: transparent; }
#saved-levels-modal #saved-levels-list::-webkit-scrollbar-thumb { background: rgba(0,0,0,0.12); border-radius: 6px; }
#saved-levels-modal #saved-levels-list::-webkit-scrollbar-thumb:hover { background: rgba(0,0,0,0.18); }

/* Saved level item text */
#saved-levels-modal .saved-obj-text { font-size: 13px; color: rgba(0,0,0,0.85); opacity: 1; }
body.dark-mode #saved-levels-modal .saved-obj-text { color: #ddd; opacity: 0.95; }

	/* ============================================
	   ANIMATIES
	   ============================================
	*/
	@keyframes popIn {
	  to { transform: translate(-50%, -50%) scale(1); }
	}

	#card-choice-zone {
	  background: #fffbea;
	  border-radius: 12px;
	  color: #333;
	  font-family: "Segoe UI", sans-serif;
	  width: min(402px, 100%);
	  box-shadow: 0 0 8px rgba(0,0,0,0.4);
	  overflow: hidden;
	}

	body.dark-mode #card-choice-zone {
	  background: linear-gradient(145deg, #22252b, #1a1c21);
	  border: 1px solid #2d2f36;
	  box-shadow: 0 0 12px rgba(0,0,0,0.6);
	  color: #e5e5e5;
	}

	#card-controls {
		display: flex;
		flex-direction: row;
		align-items: flex-start;
		justify-content: center;
		gap: 16px;
		width: 100%;
		box-sizing: border-box;
	}

	#card-options {
		flex: 1 1 auto;
		min-width: 0;
		display: flex;
		flex-wrap: wrap;
		gap: 14px;
		justify-content: center;
		align-items: flex-start;
		margin: 0;
		padding: 0;
	}

	#card-action-buttons {
		display: flex;
		flex-direction: column;
		align-items: stretch;
		gap: 14px;
		max-width: 190px;
		width: 100%;
		flex: 0 0 auto;
	}

	.card-action-btn {
		position: relative;
		display: inline-flex;
		align-items: center;
		justify-content: flex-start;
		gap: 10px;
		width: 100%;
		min-width: 0;
		margin: 0;
		padding: 12px 16px;
		border-radius: 14px;
		border: 1px solid rgba(26,32,48,0.16);
		background: linear-gradient(155deg, #eff3ff 0%, #dbe2f6 100%);
		color: #2b3148;
		font-weight: 600;
		font-size: 0.88rem;
		letter-spacing: 0.04em;
		text-transform: none;
		box-shadow: 0 12px 20px rgba(10,12,20,0.22);
		cursor: pointer;
		transition: transform 0.18s ease, box-shadow 0.18s ease, border-color 0.25s ease, background 0.25s ease;
		min-height: 52px;
	}

	.card-action-btn::before {
		content: attr(data-icon);
		font-size: 1.4rem;
		line-height: 1;
	}

	.card-action-btn::after {
		content: attr(data-label);
		line-height: 1.1;
		white-space: nowrap;
	}

	/* Desktop: buttons zijn 52x52px iconen zonder tekst */
	@media (min-width: 651px) {
		/* Desktop must not show the mobile hand-scroll arrows. */
		.hand-scroll-btn,
		#card-controls.hand-scroll-enabled .hand-scroll-btn {
			display: none !important;
		}

		.card-action-btn {
			justify-content: center;
			padding: 12px;
			min-width: 52px;
			width: 52px;
			max-width: 52px;
			min-height: 52px;
			height: 52px;
		}

		.card-action-btn::after {
			display: none;
		}

		/* Ensure the â€œnext turnâ€ button matches the deck button and sits next to it. */
		#card-action-buttons .card-action-btn {
			width: 52px;
			max-width: 52px;
			min-width: 52px;
			justify-content: center;
		}
		#card-action-buttons .card-action-btn::after {
			display: none;
		}
		#card-action-buttons #new-cards-btn { order: 0; }
		#card-action-buttons #deck-preview { order: 1; }
		
		/* Deck preview: vierkant en zelfde kleur als andere buttons */
		.deck-preview {
			min-width: 52px;
			width: 52px;
			max-width: 52px;
			min-height: 52px;
			height: 52px;
			padding: 0;
			background: linear-gradient(155deg, #eff3ff 0%, #dbe2f6 100%);
			border: 1px solid rgba(26,32,48,0.16);
			border-radius: 14px;
			display: flex;
			flex-direction: column;
			align-items: center;
			justify-content: center;
			gap: 2px;
			box-shadow: 0 12px 20px rgba(10,12,20,0.2);
		}
		
		.deck-preview::before {
			content: 'ðŸ“š';
			font-size: 1.2rem;
			display: block;
			line-height: 1;
		}

		.deck-preview::after {
			display: none;
		}
		
		/* Deck preview: zorg dat icoon ook in portrait mode zichtbaar is */
		body.desktop-portrait .deck-preview::before {
			content: 'ðŸ“š';
			display: block;
		}

		.deck-count {
			position: static;
			min-width: auto;
			padding: 0;
			background: none;
			border: none;
			box-shadow: none;
			font-size: 0.75rem;
			font-weight: 700;
			color: #2b3148;
			line-height: 1;
		}

		.deck-count::before {
			display: none;
		}

		body.dark-mode .deck-preview {
			background: linear-gradient(160deg, #2c3144 0%, #222635 100%);
			border-color: rgba(140,150,200,0.3);
		}

		body.dark-mode .deck-count {
			color: rgba(235,238,255,0.88);
		}
	}

	.card-action-btn:hover:not(:disabled),
	.card-action-btn:focus-visible {
		transform: translateY(-2px);
		box-shadow: 0 18px 28px rgba(10,12,20,0.28);
	}

	.card-action-btn:focus-visible {
		outline: 3px solid rgba(86,122,255,0.55);
		outline-offset: 3px;
	}

	.card-action-btn:disabled {
		opacity: 0.55;
		cursor: not-allowed;
		transform: none;
		box-shadow: none;
	}

	body.dark-mode .card-action-btn {
		background: linear-gradient(160deg, #2c3144 0%, #222635 100%);
		border-color: rgba(140,150,200,0.3);
		color: rgba(235,238,255,0.88);
		box-shadow: 0 16px 30px rgba(0,0,0,0.42);
	}

	body.dark-mode .card-action-btn:hover:not(:disabled),
	body.dark-mode .card-action-btn:focus-visible {
		box-shadow: 0 20px 34px rgba(0,0,0,0.5);
	}

	/* Dark mode deck preview matching card buttons */
	body.dark-mode #card-action-buttons .deck-preview {
		background: linear-gradient(160deg, #2c3144 0%, #222635 100%);
		border-color: rgba(140,150,200,0.3);
	}

	body.dark-mode #card-action-buttons .deck-count {
		color: rgba(235,238,255,0.88);
	}

	.deck-preview {
		position: relative;
		display: inline-flex;
		align-items: center;
		justify-content: space-between;
		gap: 10px;
		padding: 12px 16px;
		border-radius: 14px;
		border: 1px solid rgba(26,32,48,0.16);
		background: linear-gradient(160deg, #ffffff 0%, #edf1ff 100%);
		box-shadow: 0 12px 20px rgba(10,12,20,0.2);
		color: #2b3148;
		cursor: pointer;
		transition: transform 0.18s ease, box-shadow 0.18s ease, border-color 0.25s ease, background 0.25s ease;
		min-height: 52px;
		flex: 0 0 auto;
	}

	.deck-preview::after {
		display: none;
	}

	.deck-preview:hover,
	.deck-preview:focus-visible {
		transform: translateY(-2px);
		box-shadow: 0 18px 28px rgba(10,12,20,0.28);
	}

	.deck-preview:focus-visible {
		outline: 3px solid rgba(86,122,255,0.55);
		outline-offset: 3px;
	}
	
	/* Verwijder outline in desktop modes */
	@media (min-width: 651px) {
		.deck-preview:focus-visible {
			outline: none;
		}
	}

	.deck-count {
		display: inline-flex;
		align-items: center;
		justify-content: center;
		gap: 4px;
		min-width: 54px;
		padding: 6px 10px;
		border-radius: 10px;
		background: rgba(255,255,255,0.9);
		border: 1px solid rgba(26,32,48,0.16);
		box-shadow: inset 0 -1px 0 rgba(255,255,255,0.75), 0 6px 12px rgba(10,12,20,0.18);
		font-size: 1.05rem;
		font-weight: 700;
		color: #2b3148;
		font-variant-numeric: tabular-nums;
	}

	/* Desktop: deck count centered zonder icon */
	@media (min-width: 651px) {
		.deck-count {
			position: absolute;
			top: 50%;
			left: 50%;
			transform: translate(-50%, -50%);
			min-width: auto;
			padding: 0;
			background: none;
			border: none;
			box-shadow: none;
		}

		.deck-count::before {
			display: none;
		}
	}

	.deck-count::before {
		content: '\1F4DA';
		font-size: 1.1rem;
	}

	body.dark-mode .deck-preview {
		background: linear-gradient(160deg, #2c3144 0%, #1f2333 100%);
		border-color: rgba(140,150,200,0.28);
		color: rgba(235,238,255,0.9);
		box-shadow: 0 18px 30px rgba(0,0,0,0.4);
	}

	body.dark-mode .deck-preview::after {
		color: rgba(235,238,255,0.75);
	}

	body.dark-mode .deck-preview:focus-visible {
		outline-color: rgba(120,160,255,0.7);
	}

	body.dark-mode .deck-count {
		background: rgba(18,22,36,0.92);
		border-color: rgba(120,140,220,0.38);
		color: rgba(235,238,255,0.88);
		box-shadow: inset 0 -1px 0 rgba(255,255,255,0.08), 0 6px 12px rgba(0,0,0,0.42);
	}

	#turn-counter-inline {
		display: none;
	}

	body.dark-mode #turn-counter-inline {
		background: linear-gradient(145deg, #22252b, #1a1c21);
		border: 1px solid #2d2f36;
		box-shadow: 0 6px 14px rgba(0,0,0,0.45);
		color: #e5e5e5;
	}

	.card-option {
		flex: 0 0 auto;
		width: 138px;
		min-height: 180px;
		padding: 0;
		display: flex;
		flex-direction: column;
		--preview-cell: 20px;
		align-items: center;
		justify-content: center;
		gap: 12px;
		border-radius: 16px;
		background: linear-gradient(165deg, #ffffff 0%, #eef2ff 45%, #dfe4ff 100%);
		border: 1px solid rgba(40,55,120,0.18);
		box-shadow: 0 18px 26px rgba(10,12,20,0.2);
		position: relative;
		overflow: visible;
		transition: transform 0.2s ease, box-shadow 0.2s ease, border-color 0.2s ease;
	}

	/* Desktop landscape request: cards a bit shorter (â‰ˆ10px). */
	body.desktop-landscape #card-choice-zone .card-option {
		min-height: 170px;
	}

	/* Desktop request: make cards ~20px smaller overall. */
	body.desktop-landscape .card-option {
		width: 118px;
	}

	.card-option::after {
		content: "";
		position: absolute;
		inset: 0;
		border-radius: inherit;
		background: linear-gradient(120deg, rgba(255,255,255,0.65), rgba(255,255,255,0) 58%);
		opacity: 0.45;
		pointer-events: none;
	}

	.card-option > * {
		position: relative;
		z-index: 1;
	}

	.card-option:hover {
		transform: translateY(-6px);
		box-shadow: 0 30px 48px rgba(20,30,60,0.32);
	}

	.card-option.selected {
		border-color: rgba(82,118,255,0.6);
		box-shadow: 0 32px 52px rgba(70,90,180,0.45);
	}

	/* Card control buttons voor mobiel en touch devices - fixed positie onderaan */
	.card-control-btn {
		position: fixed;
		/* Position bottom center for touch devices */
		bottom: calc(var(--bottom-bar-height) + 10px);
		width: 44px;
		height: 44px;
		border: 2px solid white;
		border-radius: 50%;
		display: none;
		align-items: center;
		justify-content: center;
		font-size: 20px;
		color: white;
		cursor: pointer;
		box-shadow: 0 4px 12px rgba(0,0,0,0.3);
		z-index: calc(var(--z-controls) + 10);
		user-select: none;
		transition: transform 0.15s ease, opacity 0.15s ease;
		pointer-events: auto;
		touch-action: manipulation;
	}

	.card-control-btn:hover {
		transform: scale(1.1);
	}

	.card-control-btn:active {
		transform: scale(0.95);
	}

	/* Toon buttons wanneer er een selectie is */
	.card-control-btn.visible {
		display: flex;
	}

	/* When JS positions the buttons near the dragged block, override the
	   fixed layout offsets (e.g. mobile-sidebar translateY + right:15px). */
	.card-control-btn.dynamic-pos {
		right: auto !important;
		margin-left: 0 !important;
		transform: none !important;
	}

	.card-control-rotate {
		left: 50%;
		margin-left: 75px;
		background: #4a90e2;
	}

	.card-control-mirror {
		left: 50%;
		margin-left: 25px;
		background: #9b59b6;
	}

	.card-control-cancel {
		left: 50%;
		margin-left: -25px;
		background: #e74c3c;
	}

	/* Touch portrait mode: buttons blijven onderaan gecentreerd */
	body.touch-portrait .card-control-btn {
		bottom: calc(var(--bottom-bar-height) + 10px);
		top: auto;
		right: auto;
	}
	
	/* Mobile sidebar landscape: buttons aan de rechterkant */
	body.mobile-sidebar-layout .card-control-btn {
		bottom: auto;
		top: 50%;
		left: auto;
		right: 15px;
		margin-left: 0;
	}
	body.mobile-sidebar-layout .card-control-rotate {
		transform: translateY(-85px);
	}
	body.mobile-sidebar-layout .card-control-mirror {
		transform: translateY(-30px);
	}
	body.mobile-sidebar-layout .card-control-cancel {
		transform: translateY(25px);
	}

	.card-control-btn:hover {
		transform: scale(1.1);
	}
	
	.card-control-btn:active {
		transform: scale(0.95);
	}

	body.dark-mode .card-control-rotate {
		background: #5a9fd4;
		border-color: #1e2128;
	}

	body.dark-mode .card-control-mirror {
		background: #8e44ad;
		border-color: #1e2128;
	}

	body.dark-mode .card-control-cancel {
		background: #c0392b;
		border-color: #1e2128;
	}

	.card-pattern {
		display: inline-grid;
		gap: var(--preview-gap, 2px);
		align-items: center;
		justify-items: center;
		justify-content: center;
		align-content: center;
	}

	.card-option .card-cell {
		width: var(--card-cell-size, 22px);
		height: var(--card-cell-size, 22px);
		/* Border-radius: max 5px, minder rond voor kleine cells */
		border-radius: min(5px, calc(var(--card-cell-size, 22px) / 5));
		border: 1px solid rgba(12,16,30,0.12);
		box-shadow: inset 0 0 4px rgba(0,0,0,0.18);
		background: rgba(255,255,255,0.95);
	}

	.card-label {
		display: inline-flex;
		align-items: center;
		gap: 6px;
		padding: 5px 10px;
		border-radius: 999px;
		background: rgba(20,24,36,0.06);
		font-size: 0.72rem;
		font-weight: 600;
		letter-spacing: 0.065em;
		text-transform: uppercase;
		color: rgba(20,24,36,0.62);
	}

	.card-label-dot {
		width: 9px;
		height: 9px;
		border-radius: 50%;
		box-shadow: 0 0 5px rgba(0,0,0,0.26);
	}

	.card-meta {
		font-size: 0.72rem;
		letter-spacing: 0.05em;
		color: rgba(20,24,36,0.55);
	}

	body.dark-mode .card-option {
		background: linear-gradient(160deg, #2d3142 0%, #232635 45%, #1b1e2c 100%);
		border-color: rgba(120,140,220,0.2);
		box-shadow: 0 26px 44px rgba(0,0,0,0.5);
	}

	body.dark-mode .card-option::after {
		opacity: 0.25;
	}

	body.dark-mode .card-option .card-cell {
		border-color: rgba(255,255,255,0.08);
		box-shadow: inset 0 0 6px rgba(0,0,0,0.35);
		background: rgba(18,22,32,0.6);
	}

	body.dark-mode .card-label {
		background: rgba(255,255,255,0.08);
		color: rgba(255,255,255,0.82);
	}

	body.dark-mode .card-label-dot {
		box-shadow: 0 0 6px rgba(0,0,0,0.45);
	}

	body.dark-mode .card-meta {
		color: rgba(255,255,255,0.65);
	}

	#card-options {
	  display: flex;
	  flex-wrap: wrap;
	  gap: 12px;
	  justify-content: center;
	  margin-top: 12px;
	}

	@keyframes coinPop {
	  0% { transform: translate(-50%, -50%) scale(0); opacity: 0.2; }
	  70% { transform: translate(-50%, -50%) scale(1.3); opacity: 1; }
	  100% { transform: translate(-50%, -50%) scale(1); }
	}


	@keyframes growRoot {
	  from { opacity: 0; transform: scale(0.5); }
	  to { opacity: 1; transform: scale(1); }
	}

	.modal-overlay {
		position: fixed;
		inset: 0;
		padding: 18px;
		display: none;
		align-items: flex-start;
		justify-content: center;
		background: rgba(10, 12, 20, 0.6);
		backdrop-filter: blur(6px);
		-webkit-backdrop-filter: blur(6px);
		z-index: 1200;
		overflow-y: auto;
	}

	.modal-overlay.show {
		display: flex;
	}

	.game-modal {
		background: #fffbea;
		border-radius: 16px;
		padding: 24px;
		width: min(420px, 100%);
		box-shadow: 0 26px 48px rgba(10, 12, 20, 0.34);
		border: 1px solid rgba(20, 24, 36, 0.18);
		color: #191d2a;
		position: relative;
	}

	body.dark-mode .game-modal {
		background: rgba(12, 14, 20, 0.95);
		border-color: rgba(255, 255, 255, 0.14);
		color: #f5f6ff;
		box-shadow: 0 30px 52px rgba(0, 0, 0, 0.55);
	}

	.game-modal h2 {
		margin-top: 0;
		margin-bottom: 8px;
		font-size: 1.35rem;
	}

	.game-modal p {
		margin: 8px 0;
		line-height: 1.5;
	}

	.modal-subtext {
		margin: 4px 0 0;
		font-size: 0.85rem;
		color: rgba(27, 33, 48, 0.7);
	}

	body.dark-mode .modal-subtext {
		color: rgba(245, 246, 255, 0.7);
	}

	.modal-actions {
		display: flex;
		flex-wrap: wrap;
		gap: 12px;
		justify-content: flex-end;
		margin-top: 20px;
	}

	.modal-actions button {
		background: linear-gradient(145deg, #ffd560, #ffb23c);
		border: 1px solid rgba(20, 24, 36, 0.14);
		border-radius: 10px;
		padding: 10px 18px;
		font-weight: 600;
		cursor: pointer;
		transition: transform 0.2s ease, box-shadow 0.2s ease;
		color: #1f2433;
	}

	.modal-actions button:hover:not(:disabled) {
		transform: translateY(-2px);
		box-shadow: 0 14px 28px rgba(10, 12, 20, 0.28);
	}

	.modal-actions button:disabled {
		opacity: 0.6;
		cursor: not-allowed;
		box-shadow: none;
	}

	body.dark-mode .modal-actions button {
		background: linear-gradient(145deg, #2f3546, #1c2233);
		border-color: rgba(255, 255, 255, 0.12);
		color: #f5f6ff;
	}

	.modal-score-summary {
		margin-top: 14px;
		display: flex;
		flex-direction: column;
		gap: 16px;
	}

	.round-summary-cards {
		display: flex;
		flex-wrap: wrap;
		gap: 12px;
		justify-content: center;
	}

	.round-summary-card {
		flex: 1 1 160px;
		min-width: 150px;
		padding: 14px 16px;
		border-radius: 16px;
		text-align: center;
		background: linear-gradient(145deg, rgba(255, 242, 196, 0.85), rgba(255, 214, 125, 0.9));
		border: 1px solid rgba(20, 24, 36, 0.08);
		box-shadow: 0 16px 24px rgba(31, 36, 51, 0.12);
	}

	.round-summary-card--coins {
		background: linear-gradient(145deg, rgba(255, 240, 200, 0.9), rgba(255, 199, 142, 0.95));
	}

	/* Unlock Modal Styles */
	.unlock-modal {
		max-width: 500px;
		text-align: center;
	}

	/* Modal button (Doorgaan knop) */
	.modal-button {
		background: linear-gradient(145deg, #667eea, #764ba2);
		border: 1px solid rgba(102, 126, 234, 0.3);
		border-radius: 10px;
		padding: 12px 28px;
		font-weight: 600;
		font-size: 1rem;
		cursor: pointer;
		transition: transform 0.2s ease, box-shadow 0.2s ease, background 0.2s ease;
		color: #fff;
		box-shadow: 0 8px 20px rgba(102, 126, 234, 0.3);
		margin-top: 10px;
	}

	.modal-button:hover {
		transform: translateY(-2px);
		box-shadow: 0 12px 28px rgba(102, 126, 234, 0.45);
		background: linear-gradient(145deg, #7a8ff0, #8a5cb8);
	}

	body.dark-mode .modal-button {
		background: linear-gradient(145deg, #4a5fb8, #5a3d8a);
		border-color: rgba(139, 159, 245, 0.4);
		box-shadow: 0 8px 20px rgba(74, 95, 184, 0.4);
	}

	body.dark-mode .modal-button:hover {
		background: linear-gradient(145deg, #5a6fc8, #6a4d9a);
		box-shadow: 0 12px 28px rgba(74, 95, 184, 0.55);
	}

	.unlock-modal-content {
		display: flex;
		flex-direction: column;
		align-items: center;
		gap: 20px;
	}

	.unlock-icon {
		font-size: 64px;
		animation: unlock-bounce 0.6s ease-out;
	}

	@keyframes unlock-bounce {
		0% { transform: scale(0) rotate(-180deg); opacity: 0; }
		50% { transform: scale(1.2) rotate(10deg); }
		100% { transform: scale(1) rotate(0deg); opacity: 1; }
	}

	.unlock-title {
		font-size: 1.8rem;
		margin: 0;
		background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
		-webkit-background-clip: text;
		-webkit-text-fill-color: transparent;
		background-clip: text;
	}

	body.dark-mode .unlock-title {
		background: linear-gradient(135deg, #8b9ff5 0%, #a77bc9 100%);
		-webkit-background-clip: text;
		-webkit-text-fill-color: transparent;
		background-clip: text;
	}

	.unlock-items-container {
		width: 100%;
		display: flex;
		flex-direction: column;
		gap: 16px;
	}

	.unlock-item {
		background: linear-gradient(145deg, rgba(102, 126, 234, 0.1), rgba(118, 75, 162, 0.1));
		border: 2px solid rgba(102, 126, 234, 0.3);
		border-radius: 12px;
		padding: 16px;
		display: flex;
		align-items: center;
		gap: 16px;
		animation: unlock-slide-in 0.4s ease-out backwards;
	}

	body.dark-mode .unlock-item {
		background: linear-gradient(145deg, rgba(102, 126, 234, 0.15), rgba(118, 75, 162, 0.15));
		border-color: rgba(139, 159, 245, 0.4);
	}

	.unlock-item:nth-child(2) { animation-delay: 0.1s; }
	.unlock-item:nth-child(3) { animation-delay: 0.2s; }
	.unlock-item:nth-child(4) { animation-delay: 0.3s; }

	@keyframes unlock-slide-in {
		from { 
			opacity: 0; 
			transform: translateX(-30px);
		}
		to {
			opacity: 1;
			transform: translateX(0);
		}
	}

	.unlock-item-icon {
		font-size: 32px;
		flex-shrink: 0;
	}

	.unlock-item-content {
		flex: 1;
		text-align: left;
	}

	.unlock-item-name {
		font-weight: bold;
		font-size: 1.1rem;
		margin-bottom: 4px;
		color: #667eea;
	}

	body.dark-mode .unlock-item-name {
		color: #8b9ff5;
	}

	.unlock-item-description {
		font-size: 0.9rem;
		opacity: 0.8;
		margin: 0;
	}

	.unlock-item--feature {
		border-color: rgba(102, 126, 234, 0.5);
		background: linear-gradient(145deg, rgba(102, 126, 234, 0.2), rgba(118, 75, 162, 0.2));
	}

	body.dark-mode .unlock-item--feature {
		border-color: rgba(139, 159, 245, 0.6);
		background: linear-gradient(145deg, rgba(102, 126, 234, 0.25), rgba(118, 75, 162, 0.25));
	}

	.unlock-item--feature .unlock-item-name {
		color: #8b6dff;
	}

	body.dark-mode .unlock-item--feature .unlock-item-name {
		color: #a899ff;
	}

	.unlock-item--challenge {
		border-color: rgba(255, 99, 71, 0.4);
		background: linear-gradient(145deg, rgba(255, 99, 71, 0.1), rgba(255, 140, 0, 0.1));
	}

	body.dark-mode .unlock-item--challenge {
		border-color: rgba(255, 140, 0, 0.5);
		background: linear-gradient(145deg, rgba(255, 99, 71, 0.15), rgba(255, 140, 0, 0.15));
	}

	.unlock-item--challenge .unlock-item-name {
		color: #ff6347;
	}

	body.dark-mode .unlock-item--challenge .unlock-item-name {
		color: #ff8c69;
	}

	body.dark-mode .round-summary-card {
		background: linear-gradient(145deg, rgba(46, 54, 78, 0.9), rgba(32, 39, 58, 0.95));
		border-color: rgba(255, 255, 255, 0.08);
		box-shadow: 0 18px 28px rgba(5, 8, 16, 0.6);
	}

	body.dark-mode .round-summary-card--coins {
		background: linear-gradient(145deg, rgba(66, 52, 22, 0.82), rgba(97, 76, 36, 0.92));
	}

	.round-summary-icon {
		display: block;
		font-size: 1.35rem;
		margin-bottom: 6px;
	}

	.round-summary-label {
		display: block;
		font-size: 0.75rem;
		letter-spacing: 0.18em;
		text-transform: uppercase;
		color: rgba(31, 36, 51, 0.7);
		margin-bottom: 4px;
	}

	body.dark-mode .round-summary-label {
		color: rgba(245, 246, 255, 0.6);
	}

	.round-summary-value {
		display: block;
		font-size: 2.1rem;
		font-weight: 700;
		color: #1f2433;
	}

	body.dark-mode .round-summary-value {
		color: #f5f6ff;
	}

	.round-summary-bonus {
		display: inline-flex;
		align-items: center;
		justify-content: center;
		margin-top: 8px;
		padding: 4px 10px;
		border-radius: 999px;
		font-size: 0.78rem;
		font-weight: 600;
		background: rgba(31, 36, 51, 0.08);
		color: #1f2433;
	}

	body.dark-mode .round-summary-bonus {
		background: rgba(245, 246, 255, 0.15);
		color: #f5f6ff;
	}

	.round-summary-bonus--muted {
		opacity: 0.6;
	}

	.modal-summary-line {
		display: flex;
		justify-content: space-between;
		align-items: center;
		gap: 12px;
		padding: 6px 0;
		font-size: 0.95rem;
		line-height: 1.5;
		border-bottom: 1px solid rgba(20, 24, 36, 0.1);
	}

	.modal-summary-line:last-child {
		border-bottom: none;
	}

	body.dark-mode .modal-summary-line {
		border-color: rgba(255, 255, 255, 0.12);
	}

	#deck-modal {
		width: min(90vw, 780px);
		max-height: 80vh;
	}

	.deck-modal-grid {
		display: grid;
		grid-template-columns: repeat(auto-fit, minmax(110px, 1fr));
		gap: 12px;
		margin-top: 14px;
		max-height: 56vh;
		overflow-y: auto;
		padding: 0 6px;
	}

	.deck-modal-grid::-webkit-scrollbar {
		width: 6px;
	}

	.deck-modal-grid::-webkit-scrollbar-thumb {
		background: rgba(80, 90, 110, 0.35);
		border-radius: 6px;
	}

	.deck-modal-grid .card-option {
		transform: none !important;
		width: 100%;
		max-width: 120px;
		min-height: 132px;
		margin: 0 auto;
		padding: 8px;
		gap: 8px;
		justify-content: flex-start;
	}

	/* The deck overview modal is a read-only preview: clicking should NOT select cards there. */
	#deck-modal-content.deck-modal-grid .card-option {
		pointer-events: none;
		cursor: default;
	}

	/* The golden unlock modal MUST be clickable (pick 1 of 3). */
	#golden-unlock-content.deck-modal-grid .card-option {
		pointer-events: auto;
		cursor: pointer;
	}

	.deck-modal-grid .card-pattern {
		gap: 3px;
	}

	/* Deck overview: smaller preview cells than the selectable hand cards. */
	.deck-modal-grid .card-option {
		--preview-cell: 14px;
	}

	.deck-modal-grid .deck-modal-card.deck-modal-card--depleted {
		opacity: 0.35;
		filter: saturate(35%);
	}

	/* Inactive blueprint badge: small exclamation in the corner. Exclude
	   multikleur cards (they are special and should not show this). */
	.deck-modal-grid .deck-modal-card.deck-modal-card--inactive {
		position: relative;
		opacity: 0.5;
		filter: grayscale(40%);
	}
	.deck-modal-grid .deck-modal-card.deck-modal-card--inactive::after {
		content: '!';
		position: absolute;
		top: 6px;
		right: 6px;
		background: #ffcc00;
		color: #3b2b00;
		font-weight: 700;
		font-size: 11px;
		line-height: 14px;
		width: 18px;
		height: 18px;
		border-radius: 10px;
		display: inline-flex;
		align-items: center;
		justify-content: center;
		box-shadow: 0 2px 4px rgba(0,0,0,0.25);
	}

	/* Explicit badge element styling (fallback for older browsers / layout) */
	.deck-modal-inactive-badge {
		position: absolute;
		top: 6px;
		right: 6px;
		width: 20px;
		height: 20px;
		border-radius: 10px;
		background: #ffcc00;
		color: #3b2b00;
		display: inline-flex;
		align-items: center;
		justify-content: center;
		font-weight: 700;
		font-size: 12px;
		box-shadow: 0 2px 4px rgba(0,0,0,0.25);
		pointer-events: none;
	}
	/* Hide badge for multikleur (rainbow) cards which already have their own corner mark */
	.deck-modal-grid .deck-modal-card[data-card-label*="MULTIKLEUR"].deck-modal-card--inactive::after,
	.deck-modal-grid .deck-modal-card[data-card-label*="RAINBOW"].deck-modal-card--inactive::after {
		display: none;
	}

	.deck-modal-grid .deck-modal-card.deck-modal-card--in-hand {
		opacity: 0.55;
	}

	.deck-modal-grid .card-option:hover,
	.deck-modal-grid .card-option:focus {
		transform: none;
		box-shadow: 0 18px 26px rgba(10,12,20,0.2);
	}

	body.dark-mode .deck-modal-grid .card-option:hover,
	body.dark-mode .deck-modal-grid .card-option:focus {
		box-shadow: 0 26px 44px rgba(0,0,0,0.5);
	}

	.deck-modal-grid .card-option .card-label,
	.deck-modal-grid .card-option .card-meta {
		justify-content: center;
	}

	.deck-modal-empty {
		margin: 18px 0 6px;
		text-align: center;
		color: rgba(0, 0, 0, 0.6);
	}

	.blackhole-modal {
	  width: min(92vw, 760px);
	  max-height: 82vh;
	}

	.blackhole-card-grid {
	  margin-top: 16px;
	}

	.blackhole-card-grid .blackhole-card {
	  pointer-events: auto;
	  cursor: pointer;
	  transition: transform 0.18s ease, box-shadow 0.18s ease, border-color 0.18s ease;
	}

	.blackhole-card-grid .blackhole-card:hover {
	  transform: translateY(-4px);
	  box-shadow: 0 22px 36px rgba(40, 32, 88, 0.25);
	}

	.blackhole-card-grid .blackhole-card.selected {
	  border-color: rgba(120, 100, 220, 0.58);
	  box-shadow: 0 26px 44px rgba(70, 60, 160, 0.35);
	}

	.blackhole-stats {
	  display: flex;
	  flex-wrap: wrap;
	  justify-content: space-between;
	  gap: 12px;
	  font-size: 0.95rem;
	  color: rgba(20,24,36,0.82);
	}

	.blackhole-stats strong {
	  font-weight: 700;
	  color: #3a3570;
	}

	.blackhole-feedback {
	  min-height: 18px;
	  font-size: 0.9rem;
	  color: rgba(40,40,60,0.8);
	  margin-top: 6px;
	  transition: opacity 0.2s ease;
	  opacity: 0;
	}

	.blackhole-feedback.show {
	  opacity: 1;
	}

	.blackhole-feedback[data-tone="warn"] {
	  color: #c43838;
	}

	.blackhole-actions {
	  display: flex;
	  justify-content: flex-end;
	  gap: 10px;
	}

	.blackhole-actions button {
	  min-width: 140px;
	}

	body.dark-mode .deck-modal-grid::-webkit-scrollbar-thumb {
		background: rgba(160, 170, 210, 0.25);
	}

	body.dark-mode .deck-modal-empty {
		color: rgba(255, 255, 255, 0.65);
	}
	body.dark-mode .deck-modal-grid .card-option {
	  background: linear-gradient(160deg, #2d3142 0%, #232635 45%, #1b1e2c 100%);
	  border: 1px solid rgba(120,140,220,0.2);
	  box-shadow: 0 18px 32px rgba(0,0,0,0.45);
	}

	body.dark-mode .deck-modal-grid .card-option.card-golden {
	  background: linear-gradient(135deg, #5b4a14 0%, #8a6a1c 35%, #bf952a 70%, #e3c45e 100%);
	  border: 1px solid rgba(200,160,30,0.8);
	  box-shadow: 0 22px 40px rgba(0,0,0,0.58), inset 0 1px 0 rgba(255,255,255,0.08);
	}

	body.dark-mode .deck-modal-grid .card-option::after {
	  background: linear-gradient(120deg, rgba(255,255,255,0.18), rgba(255,255,255,0));
	  opacity: 0.35;
	}

	body.dark-mode .deck-modal-grid .card-option.card-golden::after {
	  opacity: 0.28;
	}
	body.dark-mode .blackhole-stats {
	  color: rgba(220, 224, 248, 0.82);
	}

	body.dark-mode .blackhole-stats strong {
	  color: #d4cffd;
	}

	body.dark-mode .blackhole-feedback {
	  color: rgba(210, 210, 248, 0.75);
	}

	body.dark-mode .blackhole-feedback[data-tone="warn"] {
	  color: #ff9a9a;
	}

	/* Rules Modal Styling */
	#rules-modal {
		max-height: 80vh;
		overflow-y: auto;
	}

	.rules-section {
		margin-bottom: 20px;
	}

	.rules-section:last-child {
		margin-bottom: 0;
	}

	.rules-section h3 {
		margin: 0 0 10px 0;
		font-size: 1.1rem;
		font-weight: 700;
		color: rgba(20,24,36,0.9);
	}

	.rules-section ul {
		margin: 8px 0;
		padding-left: 24px;
	}

	.rules-section li {
		margin-bottom: 6px;
		line-height: 1.5;
	}

	.rules-section p {
		margin: 8px 0;
		line-height: 1.6;
	}

	.rules-section strong {
		color: rgba(20,24,36,0.95);
		font-weight: 600;
	}

	body.dark-mode .rules-section h3 {
		color: rgba(255, 255, 255, 0.95);
	}

	body.dark-mode .rules-section strong {
		color: rgba(255, 255, 255, 0.9);
	}

	/* ============================================
	   DECK MODAL & SHOP - MOBILE
	   ============================================ */
	@media (max-width: 650px) {
		#deck-modal {
			width: min(96vw, 560px);
			max-height: 74vh;
			padding: 12px;
		}

		#deck-modal h2 {
			font-size: 0.98rem;
			margin-bottom: 4px;
		}

		#deck-modal .modal-subtext {
			font-size: 0.78rem;
		}

		.deck-modal-grid {
			grid-template-columns: repeat(auto-fit, minmax(64px, 1fr));
			gap: 12px;
			padding: 0 2px;
			max-height: 54vh;
		}

		.deck-modal-grid .card-option {
			max-width: 82px;
			min-height: 112px;
			padding: 4px !important;
			overflow: hidden;
		}

		.deck-modal-grid .card-pattern {
			gap: 2px;
		}

		.deck-modal-grid .card-option {
			--preview-cell: 9px;
		}

		.deck-modal-grid .card-option .card-label {
			font-size: 0.52rem;
			padding: 2px 6px;
			gap: 4px;
			letter-spacing: 0.05em;
			text-transform: none;
			white-space: nowrap;
			max-width: 100%;
			overflow: hidden;
			text-overflow: ellipsis;
		}

		.deck-modal-grid .card-option .card-label-dot {
			width: 6px;
			height: 6px;
		}

		.deck-modal-grid .card-option .card-meta {
			font-size: 0.52rem;
			letter-spacing: 0.03em;
			white-space: nowrap;
			max-width: 100%;
			overflow: hidden;
			text-overflow: ellipsis;
		}
	}

	@media (max-width: 450px) {
		/* Deck Modal - kleinere kaarten met betere spacing */
		#deck-modal {
			width: min(94vw, 420px);
			max-height: 75vh;
			padding: 10px;
		}

		.deck-modal-grid {
			grid-template-columns: repeat(auto-fit, minmax(58px, 1fr));
			gap: 10px;
			max-height: 54vh;
		}

		.deck-modal-grid .card-option {
			min-height: 72px;
			max-width: 72px;
			padding: 4px !important;
			transform: none !important;
			overflow: hidden;
		}

		.deck-modal-grid .card-pattern {
			gap: var(--preview-gap);
		}

		.deck-modal-grid .card-option {
			--preview-cell: 8px;
		}

		.deck-modal-grid .card-option .card-label {
			font-size: 0.5rem;
			padding: 2px 6px;
			gap: 4px;
			letter-spacing: 0.03em;
			text-transform: none;
			white-space: nowrap;
			max-width: 100%;
			overflow: hidden;
			text-overflow: ellipsis;
		}

		.deck-modal-grid .card-option .card-meta {
			font-size: 0.5rem;
			letter-spacing: 0.02em;
			white-space: nowrap;
			max-width: 100%;
			overflow: hidden;
			text-overflow: ellipsis;
		}

		/* Shop Modal - compactere layout */
		#shop-modal {
			width: min(96vw, 420px) !important;
			max-height: 72vh;
			padding: 12px 14px;
			gap: 8px;
		}

		#shop-modal h2 {
			font-size: 0.88rem;
		}

		/* Verberg uitleg tekst */
		#shop-modal-message {
			display: none !important;
		}

		/* Verberg shop-card-header */
		.shop-card-header {
			display: none !important;
		}

		/* Shop cards - kleiner schalen */
		.shop-card {
			transform: scale(0.85);
			transform-origin: center;
			padding: 8px !important;
			gap: 6px !important;
		}

		.shop-card-list {
			grid-template-columns: repeat(2, 1fr) !important;
			gap: 16px;
		}

		.shop-card-preview {
			max-width: 100%;
		}

		.shop-card-preview .card-option {
			width: 100%;
			min-height: 120px;
		}

		/* Shop lower grid - force side by side with flexbox */
		.shop-lower-grid {
			display: flex !important;
			flex-direction: row !important;
			gap: 10px !important;
			width: 100% !important;
		}

		.shop-upgrades-section,
		.shop-bonus-section {
			flex: 1 1 0 !important;
			min-width: 0 !important;
			width: auto !important;
			max-width: none !important;
			padding: 12px !important;
			flex-direction: column !important;
			align-items: stretch !important;
			justify-content: flex-start !important;
			border-radius: 12px !important;
		}

		.shop-section-title {
			font-size: 0.72rem !important;
			margin-bottom: 10px !important;
		}

		.shop-section-title::before {
			font-size: 0.85rem !important;
		}

		.shop-upgrade-container {
			display: grid !important;
			grid-template-columns: repeat(2, minmax(0, 1fr)) !important;
			gap: 10px !important;
			width: 100% !important;
		}

		/* Bonus container ook single column */
		.shop-bonus-container {
			display: flex !important;
			flex-direction: column !important;
			gap: 10px !important;
			width: 100% !important;
		}

		/* Bonus cards compacter - verticale layout */
		.shop-bonus-card {
			flex-direction: column !important;
			align-items: flex-start !important;
			gap: 8px !important;
			padding: 10px 12px !important;
		}

		.shop-bonus-info {
			width: 100%;
			gap: 8px !important;
			font-size: 0.75rem !important;
		}

		.shop-bonus-swatch {
			width: 16px !important;
			height: 16px !important;
		}

		.shop-bonus-actions {
			width: 100%;
		}

		.shop-bonus-actions button {
			width: 100%;
			padding: 8px 12px !important;
			font-size: 0.75rem !important;
		}

		.shop-upgrade-card {
			padding: 12px !important;
			gap: 8px !important;
		}

		.shop-upgrade-card::before {
			height: 2px !important;
		}

		.shop-upgrade-header {
			font-size: 0.8rem !important;
		}

		.upgrade-icon {
			width: 28px !important;
			height: 28px !important;
			font-size: 1rem !important;
			border-radius: 8px !important;
		}

		.shop-upgrade-desc {
			font-size: 0.7rem !important;
			line-height: 1.35 !important;
		}

		.shop-upgrade-actions button {
			padding: 8px 14px !important;
			font-size: 0.75rem !important;
			border-radius: 8px !important;
		}

		.shop-empty-state {
			padding: 14px !important;
			font-size: 0.72rem !important;
		}
	}

	/* ============================================
	   SHOP MODAL - BASIS (DESKTOP)
	   ============================================
	   Pop-up winkel waar je met munten extra kaarten en upgrades kunt kopen
	   2-kolommen layout: kaarten links, upgrades rechts
	*/
	#shop-modal {
		display: flex;
		flex-direction: column;
		gap: 18px;
		padding: 24px;
		background: linear-gradient(160deg, rgba(255,255,255,0.98), rgba(232,238,252,0.92));
		border: 1px solid rgba(60,70,140,0.12);
		box-shadow: 0 32px 54px rgba(12,18,38,0.25);
		border-radius: 20px;
		max-width: 920px;
		width: min(92vw, 920px);
		margin: auto;
		max-height: calc(100vh - 36px);
		overflow-y: auto;
		overscroll-behavior: contain;
		-webkit-overflow-scrolling: touch;
		contain: layout paint;
		scrollbar-width: thin;
		scrollbar-color: rgba(100, 120, 180, 0.5) transparent;
	}

	/* Shop overlay: avoid nested scrolling (keeps scrolling smooth inside the modal). */
	#shop-modal-layer {
		overflow: hidden;
		overscroll-behavior: contain;
	}
	
	#shop-modal::-webkit-scrollbar {
		width: 8px;
	}
	#shop-modal::-webkit-scrollbar-track {
		background: transparent;
		border-radius: 4px;
	}
	#shop-modal::-webkit-scrollbar-thumb {
		background: linear-gradient(180deg, rgba(100, 120, 180, 0.6), rgba(80, 100, 160, 0.4));
		border-radius: 4px;
		border: 1px solid rgba(255,255,255,0.2);
	}
	#shop-modal::-webkit-scrollbar-thumb:hover {
		background: linear-gradient(180deg, rgba(120, 140, 200, 0.8), rgba(100, 120, 180, 0.6));
	}

	body.dark-mode #shop-modal {
		background: linear-gradient(160deg, rgba(28,30,44,0.96), rgba(20,22,35,0.96));
		border-color: rgba(140,150,220,0.22);
		box-shadow: 0 34px 60px rgba(0,0,0,0.55);
		scrollbar-color: rgba(140, 160, 220, 0.4) transparent;
	}
	body.dark-mode #shop-modal::-webkit-scrollbar-thumb {
		background: linear-gradient(180deg, rgba(100, 120, 180, 0.5), rgba(80, 100, 160, 0.3));
		border-color: rgba(255,255,255,0.1);
	}
	body.dark-mode #shop-modal::-webkit-scrollbar-thumb:hover {
		background: linear-gradient(180deg, rgba(120, 140, 200, 0.6), rgba(100, 120, 180, 0.5));
	}
	body.dark-mode .shop-coin-display {
		background: linear-gradient(145deg, rgba(42,44,62,0.92), rgba(32,34,52,0.9));
		border-color: rgba(160, 178, 255, 0.24);
		box-shadow: inset 0 0 0 1px rgba(255,255,255,0.08), 0 18px 34px rgba(0,0,0,0.5);
	}
	body.dark-mode .shop-coin-label {
		color: rgba(214, 220, 255, 0.72);
	}
	body.dark-mode .shop-coin-balance {
		color: #f6f7ff;
	}
	body.dark-mode .shop-coin-display.is-empty {
		background: linear-gradient(145deg, rgba(110, 32, 32, 0.4), rgba(140, 28, 28, 0.35));
		border-color: rgba(255, 120, 120, 0.35);
	}
	body.dark-mode .shop-coin-display.is-empty .shop-coin-label {
		color: rgba(255, 196, 196, 0.78);
	}
	body.dark-mode .shop-coin-display.is-empty .shop-coin-balance {
		color: rgba(255, 220, 220, 0.9);
	}

	.shop-modal-header {
		display: flex;
		flex-wrap: wrap;
		justify-content: space-between;
		align-items: center;
		gap: 16px;
	}

	.shop-coin-display {
		display: inline-flex;
		align-items: center;
		gap: 10px;
		padding: 6px 14px;
		border-radius: 999px;
		background: linear-gradient(145deg, rgba(255,255,255,0.96), rgba(236,246,255,0.92));
		border: 1px solid rgba(120,140,200,0.25);
		box-shadow: inset 0 0 0 1px rgba(255,255,255,0.25), 0 16px 28px rgba(14,22,48,0.16);
	}

	.shop-coin-label {
		font-size: 0.78rem;
		font-weight: 600;
		letter-spacing: 0.05em;
		text-transform: uppercase;
		color: rgba(24,32,60,0.68);
	}

	.shop-coin-balance {
		position: relative;
		font-weight: 700;
		font-size: 1.05rem;
		color: #1c253c;
		padding-left: 1.4em;
		min-width: 2.4em;
		text-align: right;
	}

	.shop-coin-balance::before {
		content: "";
		position: absolute;
		left: 0;
		top: 50%;
		transform: translateY(-50%);
		width: 1em;
		height: 1em;
		border-radius: 50%;
		background: radial-gradient(circle at 30% 30%, #fff6b5, #f7bb36 60%, #d49f20);
		box-shadow: inset 0 -2px 4px rgba(0,0,0,0.2), 0 1px 2px rgba(0,0,0,0.15);
		border: 1px solid #c9960a;
	}

	.shop-coin-display.is-empty {
		background: linear-gradient(145deg, rgba(245, 80, 80, 0.1), rgba(255, 140, 140, 0.12));
		border-color: rgba(220, 90, 90, 0.24);
	}

	.shop-coin-display.is-empty .shop-coin-label {
		color: rgba(160, 48, 48, 0.8);
	}

	.shop-coin-display.is-empty .shop-coin-balance {
		color: rgba(164, 52, 52, 0.9);
	}

	/* 2-kolommen grid voor shop inhoud */
	.shop-content-grid {
		display: flex;
		flex-direction: column;
		gap: 24px;
		margin-top: 12px;
		align-items: stretch;
	}
	
	.shop-lower-grid {
		display: grid;
		grid-template-columns: minmax(0, 1fr) minmax(0, 1fr);
		gap: 24px 28px;
		align-items: start;
	}

	/* Modal close button styling */
	.modal-close-btn {
		position: absolute;
		top: 16px;
		right: 16px;
		width: 32px;
		height: 32px;
		border: none;
		background: rgba(0,0,0,0.08);
		border-radius: 50%;
		font-size: 24px;
		line-height: 1;
		color: #666;
		cursor: pointer;
		transition: all 0.2s ease;
		display: flex;
		align-items: center;
		justify-content: center;
		padding: 0;
		z-index: 10;
	}

	.modal-close-btn:hover {
		background: rgba(0,0,0,0.12);
		color: #333;
		transform: scale(1.1);
	}

	body.dark-mode .modal-close-btn {
		background: rgba(255,255,255,0.1);
		color: #ccc;
	}

	body.dark-mode .modal-close-btn:hover {
		background: rgba(255,255,255,0.15);
		color: #fff;
	}

	/* Elke sectie (kaarten of upgrades) */
	.shop-section {
		display: flex;
		flex-direction: column;
		gap: 16px;
	}

	.shop-upgrades-section,
	.shop-bonus-section,
	.shop-freeplace-section {
		display: flex;
		flex-direction: column;
		align-items: stretch;
		gap: 14px;
		padding: 20px;
		border-radius: 16px;
		background: linear-gradient(160deg, rgba(248,250,255,0.95), rgba(240,244,255,0.9));
		border: 1px solid rgba(40,55,120,0.12);
		box-shadow: 0 8px 24px rgba(12,18,38,0.08);
		position: relative;
	}

	.shop-upgrades-section::before,
	.shop-bonus-section::before,
	.shop-freeplace-section::before {
		content: '';
		position: absolute;
		top: 0;
		left: 20px;
		right: 20px;
		height: 1px;
		background: linear-gradient(90deg, transparent, rgba(40,55,120,0.15), transparent);
	}

	body.dark-mode .shop-upgrades-section,
	body.dark-mode .shop-bonus-section,
	body.dark-mode .shop-freeplace-section {
		background: linear-gradient(160deg, rgba(36,40,60,0.95), rgba(24,28,44,0.95));
		border-color: rgba(150,170,240,0.2);
		box-shadow: 0 12px 32px rgba(0,0,0,0.4);
	}

	body.dark-mode .shop-upgrades-section::before,
	body.dark-mode .shop-bonus-section::before,
	body.dark-mode .shop-freeplace-section::before {
		background: linear-gradient(90deg, transparent, rgba(150,170,240,0.2), transparent);
	}

	.shop-section-title {
		margin: 0 0 4px 0;
		font-size: 0.85rem;
		font-weight: 700;
		letter-spacing: 0.08em;
		text-transform: uppercase;
		color: rgba(20,24,46,0.6);
		display: flex;
		align-items: center;
		gap: 8px;
	}

	.shop-section-title::before {
		content: 'âš™ï¸';
		font-size: 1rem;
	}

	.shop-bonus-section .shop-section-title::before {
		content: 'ðŸŽ';
	}

	body.dark-mode .shop-section-title {
		color: rgba(240,242,255,0.6);
	}

	.shop-upgrade-container {
		margin-top: 0;
		padding: 0;
		border-radius: 0;
		background: transparent;
		border: none;
		box-shadow: none;
		display: grid;
		grid-template-columns: repeat(2, 1fr);
		gap: 12px;
	}

	.shop-empty-state {
		margin: 0;
		padding: 20px;
		font-size: 0.85rem;
		font-weight: 500;
		color: rgba(24,32,52,0.55);
		text-align: center;
		background: rgba(0,0,0,0.03);
		border-radius: 12px;
		border: 1px dashed rgba(40,55,120,0.15);
	}

	body.dark-mode .shop-empty-state {
		color: rgba(235,238,255,0.5);
		background: rgba(255,255,255,0.03);
		border-color: rgba(150,170,240,0.15);
	}

	/* Kaarten sectie (links) met rechter border */
	.shop-cards-section {
		border-right: 1px solid rgba(40,55,120,0.12);
		padding-right: 20px;
	}

	@media (max-width: 720px) {
		.shop-cards-section {
			border-right: none;
			padding-right: 0;
			border-bottom: 1px solid rgba(40,55,120,0.12);
			padding-bottom: 18px;
		}
		.shop-upgrades-section,
		.shop-bonus-section {
			padding: 16px;
		}
		body.dark-mode .shop-cards-section {
			border-bottom-color: rgba(140,150,200,0.22);
		}
		.shop-card-list {
			grid-template-columns: 1fr;
		}
		.shop-card-price {
			align-self: flex-start;
		}
		.shop-card-actions {
			margin-top: 0;
		}
	}

	/* Grid van kaarten in de shop */
	.shop-card-list {
		display: grid;
		grid-template-columns: repeat(auto-fill, minmax(260px, 1fr));
		gap: 24px;
		align-items: stretch;
	}

	#shop-card-options {
		flex: 1 1 auto;
	}

	#shop-upgrade-container {
		flex: 0 0 auto;
	}

	body.dark-mode .shop-section-title {
		color: rgba(240,242,255,0.85);
	}

	body.dark-mode .shop-cards-section {
		border-right-color: rgba(140,150,200,0.25);
	}

	.shop-section--empty {
		opacity: 0.75;
	}

	.shop-empty-state {
		margin: 0;
		font-size: 0.84rem;
		font-weight: 600;
		color: rgba(24,32,52,0.68);
	}

	body.dark-mode .shop-empty-state {
		color: rgba(235,238,255,0.64);
	}

	/* Individuele shop kaart met prijs en koop knop */
	.shop-card {
		border: 2px solid rgba(40, 55, 120, 0.15);
		border-radius: 20px;
		padding: 20px;
		background: linear-gradient(155deg, rgba(255,255,255,0.98), rgba(248,252,255,0.95));
		display: flex;
		flex-direction: column;
		gap: 16px;
		box-shadow: 0 4px 16px rgba(12,18,38,0.08), 0 12px 40px rgba(12,18,38,0.12);
		transition: transform 0.2s ease, box-shadow 0.2s ease;
		position: relative;
		overflow: hidden;
	}
	
	.shop-card::before {
		content: '';
		position: absolute;
		top: 0;
		left: 0;
		right: 0;
		height: 4px;
		background: linear-gradient(90deg, #ffb347, #ffda76, #ffc65d);
		opacity: 0;
		transition: opacity 0.2s ease;
	}
	
	.shop-card:hover {
		transform: translateY(-4px);
		box-shadow: 0 8px 24px rgba(12,18,38,0.12), 0 16px 48px rgba(12,18,38,0.16);
	}
	
	.shop-card:hover::before {
		opacity: 1;
	}
	
	.shop-card-random {
		border-color: rgba(255, 215, 0, 0.4);
		background: linear-gradient(155deg, rgba(255,252,245,0.98), rgba(255,248,235,0.95));
	}
	
	.shop-card-random::before {
		background: linear-gradient(90deg, #ffd700, #ffed4e, #ffd700);
	}

	body.dark-mode .shop-card {
		background: linear-gradient(155deg, rgba(38,42,58,0.95), rgba(28,32,48,0.95));
		border-color: rgba(160, 170, 240, 0.22);
		box-shadow: 0 4px 16px rgba(0,0,0,0.25), 0 12px 40px rgba(0,0,0,0.35);
	}
	
	body.dark-mode .shop-card:hover {
		box-shadow: 0 8px 24px rgba(0,0,0,0.35), 0 16px 48px rgba(0,0,0,0.45);
	}
	
	body.dark-mode .shop-card-random {
		border-color: rgba(255, 215, 0, 0.3);
		background: linear-gradient(155deg, rgba(48,44,32,0.95), rgba(38,36,28,0.95));
	}

	.shop-card-header {
		display: flex;
		align-items: center;
		justify-content: space-between;
		gap: 12px;
		font-weight: 700;
		font-size: 1.05rem;
	}
	
	/* Verberg lege header voor random kaarten */
	.shop-card-random .shop-card-header:empty {
		display: none;
	}
	
	.shop-card-header span:first-child {
		flex: 1;
		color: #1a2644;
	}
	
	body.dark-mode .shop-card-header span:first-child {
		color: #e8ebff;
	}
	
	.card-meta {
		font-size: 0.75rem;
		font-weight: 700;
		padding: 4px 10px;
		border-radius: 12px;
		background: rgba(100, 120, 200, 0.12);
		color: #3d4e7a;
		letter-spacing: 0.05em;
		text-transform: uppercase;
	}
	
	body.dark-mode .card-meta {
		background: rgba(120, 140, 220, 0.18);
		color: #a8b8ff;
	}

	.shop-card-price {
		font-size: 1rem;
		font-weight: 700;
		color: #e67e22;
		letter-spacing: 0.02em;
		padding: 6px 14px;
		background: rgba(230, 126, 34, 0.08);
		border-radius: 12px;
		display: inline-block;
	}

	body.dark-mode .shop-card-price {
		color: #ffb84d;
		background: rgba(255, 184, 77, 0.12);
	}

	.shop-card-preview {
		display: flex;
		justify-content: center;
		align-items: center;
		padding: 20px;
		border-radius: 16px;
		background: linear-gradient(145deg, rgba(235,242,255,0.6), rgba(245,248,255,0.8));
		border: 1px solid rgba(100, 120, 200, 0.08);
		min-height: 160px;
	}

	body.dark-mode .shop-card-preview {
		background: linear-gradient(145deg, rgba(20,24,36,0.4), rgba(28,32,44,0.6));
		border-color: rgba(120, 140, 220, 0.12);
	}

	.shop-card-actions {
		display: flex;
		justify-content: stretch;
		align-items: center;
		margin-top: 4px;
	}

	.shop-card-actions button {
		flex: 1;
		background: linear-gradient(145deg, #ffb347, #ff9f33);
		border: 2px solid rgba(230, 126, 34, 0.3);
		border-radius: 14px;
		padding: 12px 24px;
		font-weight: 700;
		font-size: 0.95rem;
		letter-spacing: 0.04em;
		cursor: pointer;
		transition: all 0.2s ease;
		box-shadow: 0 4px 12px rgba(255, 140, 50, 0.25);
		color: #fff;
		text-shadow: 0 1px 2px rgba(0,0,0,0.2);
	}

	.shop-card-actions button:hover:not(:disabled) {
		transform: translateY(-2px);
		box-shadow: 0 6px 20px rgba(255, 140, 50, 0.35);
		background: linear-gradient(145deg, #ffc55a, #ffb347);
	}
	
	.shop-card-actions button:active:not(:disabled) {
		transform: translateY(0);
	}

	.shop-card-actions button:disabled {
		cursor: not-allowed;
		opacity: 0.5;
		box-shadow: none;
		background: linear-gradient(145deg, #aaa, #999);
		border-color: rgba(100, 100, 100, 0.3);
	}

	.shop-upgrade-container {
		margin-top: 0;
		padding: 0;
		border-radius: 0;
		background: transparent;
		border: none;
		box-shadow: none;
		display: grid;
		grid-template-columns: repeat(2, minmax(0, 1fr));
		gap: 12px;
		width: 100%;
	}

	.shop-upgrade-card {
		min-width: 0;
	}

	/* Mystery Card Styles */
	.mystery-card-container {
		width: 100%;
		height: 200px;
		perspective: 1000px;
		position: relative;
	}

	.mystery-card-inner {
		width: 100%;
		height: 100%;
		transition: transform 0.8s;
		transform-style: preserve-3d;
		position: relative;
	}

	.mystery-card-inner.flipped {
		transform: rotateY(180deg);
	}

	.mystery-card-front,
	.mystery-card-back {
		position: absolute;
		width: 100%;
		height: 100%;
		backface-visibility: hidden;
		display: flex;
		align-items: center;
		justify-content: center;
		border-radius: 12px;
	}

	.mystery-card-front {
		background: linear-gradient(145deg, #4a4a4a, #2a2a2a);
		border: 2px solid rgba(255, 215, 0, 0.5);
		box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
	}

	.mystery-card-front .question-mark {
		font-size: 96px;
		font-weight: bold;
		color: #ffd700;
		text-shadow: 0 0 20px rgba(255, 215, 0, 0.6);
		animation: pulse 2s ease-in-out infinite;
	}

	@keyframes pulse {
		0%, 100% {
			opacity: 1;
			transform: scale(1);
		}
		50% {
			opacity: 0.7;
			transform: scale(1.1);
		}
	}

	.mystery-card-back {
		transform: rotateY(180deg);
		background: white;
		padding: 15px;
	}

	body.dark-mode .mystery-card-back {
		background: rgba(28,32,44,0.95);
	}

	.shop-upgrade-container h3 {
		margin: 0;
		font-size: 0.92rem;
	}

	.shop-upgrade-container p {
		margin: 0;
		font-size: 0.78rem;
		color: rgba(20,24,36,0.7);
	}

	.shop-upgrade-actions {
		display: flex;
		gap: 10px;
		align-items: center;
		flex-wrap: wrap;
	}

	.shop-upgrade-actions button {
		background: linear-gradient(145deg, #ffe580, #ffbd4f);
		border: 1px solid rgba(140, 95, 10, 0.35);
		color: #5a2d00;
		border-radius: 999px;
		padding: 7px 16px;
		font-weight: 700;
		letter-spacing: 0.04em;
		cursor: pointer;
		transition: transform 0.2s ease, box-shadow 0.2s ease;
	}

	.shop-upgrade-actions button:disabled {
		opacity: 0.5;
		cursor: not-allowed;
		transform: none;
		box-shadow: none;
	}

	.shop-upgrade-actions button:not(:disabled):hover {
		transform: translateY(-1px);
		box-shadow: 0 10px 18px rgba(180,120,20,0.26);
	}

	.shop-bonus-container {
		display: grid;
		grid-template-columns: repeat(auto-fill, minmax(220px, 1fr));
		gap: 14px;
		align-items: start;
	}

	.shop-bonus-card {
		display: flex;
		align-items: center;
		justify-content: space-between;
		gap: 12px;
		padding: 10px 14px;
		border-radius: 14px;
		background: rgba(255,255,255,0.78);
		border: 1px solid rgba(40,55,120,0.12);
		box-shadow: 0 14px 26px rgba(12,18,38,0.12);
		height: 100%;
	}

	body.dark-mode .shop-bonus-card {
		background: rgba(28,30,48,0.92);
		border-color: rgba(150,170,240,0.18);
		box-shadow: 0 16px 30px rgba(0,0,0,0.45);
	}

	.shop-bonus-info {
		display: flex;
		align-items: center;
		gap: 10px;
		font-weight: 600;
		color: rgba(26,34,52,0.88);
	}

	body.dark-mode .shop-bonus-info {
		color: rgba(235,238,255,0.88);
	}

	.shop-bonus-swatch {
		width: 20px;
		height: 20px;
		border-radius: 6px;
		border: 2px solid rgba(0,0,0,0.08);
		box-shadow: inset 0 0 0 1px rgba(255,255,255,0.4);
	}

	body.dark-mode .shop-bonus-swatch {
		border-color: rgba(255,255,255,0.12);
		box-shadow: inset 0 0 0 1px rgba(0,0,0,0.35);
	}

	.shop-bonus-actions button {
		background: linear-gradient(145deg, #8be6ff, #44bdf1);
		border: 1px solid rgba(20,60,120,0.24);
		border-radius: 999px;
		padding: 7px 16px;
		font-weight: 700;
		color: #04344f;
		cursor: pointer;
		transition: transform 0.2s ease, box-shadow 0.2s ease;
		box-shadow: 0 12px 20px rgba(68,189,241,0.26);
	}

	.shop-bonus-actions button:hover:not(:disabled) {
		transform: translateY(-1px);
		box-shadow: 0 16px 28px rgba(68,189,241,0.32);
	}

	.shop-bonus-actions button:disabled {
		opacity: 0.45;
		cursor: not-allowed;
		box-shadow: none;
	}

	body.dark-mode .shop-bonus-actions button {
		color: #062f45;
	}
	body.dark-mode .shop-bonus-upgrade-btn {
		background: linear-gradient(145deg, #d8a640, #f0c04f);
		border-color: rgba(255,223,128,0.4);
		color: #fff6d2;
	}

	.shop-bonus-upgrade-btn {
		background: linear-gradient(145deg, #ffe580, #ffbd4f);
		border: 1px solid rgba(140, 95, 10, 0.35);
		color: #5a2d00;
	}

	.shop-bonus-upgrade-btn:hover:not(:disabled) {
		transform: translateY(-1px);
		box-shadow: 0 14px 24px rgba(180,120,20,0.25);
	}

	.shop-bonus-status {
		display: inline-flex;
		align-items: center;
		gap: 6px;
		font-size: 0.78rem;
		font-weight: 700;
		padding: 6px 12px;
		border-radius: 999px;
		background: linear-gradient(135deg, rgba(255,255,255,0.85), rgba(240,245,255,0.75));
		border: 1px solid rgba(120,140,200,0.28);
		color: rgba(26,32,52,0.78);
	}

	body.dark-mode .shop-bonus-status {
		background: linear-gradient(135deg, rgba(40,42,60,0.9), rgba(32,34,52,0.88));
		border-color: rgba(180,196,255,0.26);
		color: rgba(236,240,255,0.85);
	}

	.shop-upgrade-note {
		font-size: 0.72rem;
		color: rgba(20,24,36,0.65);
	}

	.shop-upgrade-card {
		padding: 16px 18px;
		border-radius: 16px;
		background: linear-gradient(155deg, rgba(255,255,255,0.95), rgba(248,250,255,0.9));
		border: 1px solid rgba(40,55,120,0.12);
		box-shadow: 0 8px 24px rgba(12,18,38,0.1);
		display: flex;
		flex-direction: column;
		gap: 12px;
		height: 100%;
		transition: transform 0.2s ease, box-shadow 0.2s ease;
		position: relative;
		overflow: hidden;
	}

	.shop-upgrade-card::before {
		content: '';
		position: absolute;
		top: 0;
		left: 0;
		right: 0;
		height: 3px;
		background: linear-gradient(90deg, #a78bfa, #818cf8, #6366f1);
		opacity: 0.7;
	}

	.shop-upgrade-card:hover {
		transform: translateY(-2px);
		box-shadow: 0 12px 32px rgba(12,18,38,0.15);
	}

	.shop-upgrade-card--locked {
		opacity: 0.6;
	}

	.shop-upgrade-card--locked::before {
		background: linear-gradient(90deg, #9ca3af, #6b7280);
	}

	.shop-upgrade-card--owned::before {
		background: linear-gradient(90deg, #34d399, #10b981, #059669);
	}

	.shop-upgrade-header {
		display: flex;
		align-items: center;
		gap: 10px;
		font-weight: 700;
		font-size: 0.95rem;
		color: #1a2644;
	}

	.upgrade-icon {
		font-size: 1.4rem;
		width: 36px;
		height: 36px;
		display: flex;
		align-items: center;
		justify-content: center;
		background: linear-gradient(145deg, rgba(167,139,250,0.15), rgba(129,140,248,0.1));
		border-radius: 10px;
		flex-shrink: 0;
	}

	.shop-upgrade-desc {
		margin: 0;
		font-size: 0.82rem;
		color: rgba(20,24,36,0.7);
		line-height: 1.45;
	}

	.shop-upgrade-price {
		display: inline-flex;
		align-items: center;
		gap: 4px;
		font-size: 0.85rem;
		font-weight: 700;
		color: #e67e22;
		padding: 4px 10px;
		background: rgba(230, 126, 34, 0.1);
		border-radius: 8px;
		margin-top: auto;
	}

	.shop-upgrade-actions {
		display: flex;
		gap: 10px;
		align-items: center;
		flex-wrap: wrap;
		margin-top: auto;
	}

	.shop-upgrade-actions button {
		background: linear-gradient(145deg, #a78bfa, #818cf8);
		border: none;
		color: #fff;
		border-radius: 10px;
		padding: 10px 18px;
		font-weight: 700;
		font-size: 0.85rem;
		letter-spacing: 0.03em;
		cursor: pointer;
		transition: transform 0.2s ease, box-shadow 0.2s ease;
		box-shadow: 0 4px 12px rgba(129,140,248,0.3);
	}

	.shop-upgrade-actions button:disabled {
		opacity: 0.5;
		cursor: not-allowed;
		transform: none;
		box-shadow: none;
		background: linear-gradient(145deg, #9ca3af, #6b7280);
	}

	.shop-upgrade-actions button:not(:disabled):hover {
		transform: translateY(-2px);
		box-shadow: 0 8px 20px rgba(129,140,248,0.4);
	}

	body.dark-mode .shop-upgrade-note {
		color: rgba(240,242,255,0.65);
	}

	body.dark-mode .shop-upgrade-card {
		background: linear-gradient(155deg, rgba(38,42,58,0.95), rgba(28,32,48,0.95));
		border-color: rgba(150,170,240,0.2);
		box-shadow: 0 8px 24px rgba(0,0,0,0.35);
	}

	body.dark-mode .shop-upgrade-card:hover {
		box-shadow: 0 12px 32px rgba(0,0,0,0.45);
	}

	body.dark-mode .shop-upgrade-header {
		color: #e8ebff;
	}

	body.dark-mode .upgrade-icon {
		background: linear-gradient(145deg, rgba(167,139,250,0.25), rgba(129,140,248,0.15));
	}

	body.dark-mode .shop-upgrade-desc {
		color: rgba(240,242,255,0.7);
	}

	body.dark-mode .shop-upgrade-price {
		color: #ffb84d;
		background: rgba(255, 184, 77, 0.15);
	}

	body.dark-mode .shop-upgrade-actions button {
		background: linear-gradient(145deg, #a78bfa, #818cf8);
		color: #fff;
	}

	body.dark-mode .shop-card-actions button {
		background: linear-gradient(145deg, #ffa940, #ff8835);
		border-color: rgba(255, 255, 255, 0.16);
	}

	.shop-card .card-option {
		flex: 0 0 auto;
		width: 138px;
		min-height: 180px;
		padding: 0;
		display: flex;
		flex-direction: column;
		align-items: center;
		justify-content: center;
		gap: 12px;
		border-radius: 16px;
		background: linear-gradient(165deg, #ffffff 0%, #eef2ff 45%, #dfe4ff 100%);
		border: 1px solid rgba(40,55,120,0.18);
		box-shadow: 0 18px 26px rgba(10,12,20,0.2);
		position: relative;
		overflow: hidden;
		transition: transform 0.2s ease, box-shadow 0.2s ease, border-color 0.2s ease;
	}

	.shop-card .card-option::after {
		content: "";
		position: absolute;
		inset: 0;
		border-radius: inherit;
		background: linear-gradient(120deg, rgba(255,255,255,0.65), rgba(255,255,255,0) 58%);
		opacity: 0.45;
		pointer-events: none;
	}

	.shop-card .card-option > * {
		position: relative;
		z-index: 1;
	}

	.shop-card .card-pattern {
		display: grid;
		gap: 4px;
		align-items: center;
		justify-items: center;
	}

	.shop-card .card-option .card-cell {
		width: 22px;
		height: 22px;
		/* Border-radius: max 5px, minder rond */
		border-radius: min(5px, calc(22px / 5));
		border: 1px solid rgba(12,16,30,0.12);
		box-shadow: inset 0 0 4px rgba(0,0,0,0.18);
		background: rgba(255,255,255,0.95);
	}

	.shop-card .card-label {
		display: inline-flex;
		align-items: center;
		gap: 6px;
		padding: 5px 10px;
		border-radius: 999px;
		background: rgba(30, 40, 70, 0.08);
		font-size: 0.72rem;
		font-weight: 600;
		letter-spacing: 0.04em;
		color: #2a2f45;
		box-shadow: inset 0 0 0 1px rgba(40,55,120,0.16);
	}

	.shop-card .card-label-dot {
		display: inline-block;
		width: 10px;
		height: 10px;
		border-radius: 50%;
		box-shadow: 0 0 6px rgba(0,0,0,0.2);
	}

	.shop-card .card-meta {
		font-size: 0.75rem;
		font-weight: 600;
		letter-spacing: 0.05em;
		text-transform: uppercase;
		color: rgba(30, 35, 60, 0.85);
	}

	body.dark-mode .shop-card .card-option {
		background: rgba(20, 24, 36, 0.82);
		border-color: rgba(255, 255, 255, 0.16);
		box-shadow: 0 18px 36px rgba(0, 0, 0, 0.5);
	}

	body.dark-mode .shop-card .card-option::after {
		background: linear-gradient(120deg, rgba(255,255,255,0.24), rgba(255,255,255,0) 62%);
	}

	body.dark-mode .shop-card .card-option .card-cell {
		border-color: rgba(255,255,255,0.08);
		background: rgba(32, 36, 52, 0.92);
	}

	body.dark-mode .shop-card .card-label {
		background: rgba(255,255,255,0.1);
		color: #f3f4ff;
		box-shadow: inset 0 0 0 1px rgba(255,255,255,0.18);
	}

	body.dark-mode .shop-card .card-meta {
		color: rgba(240, 242, 255, 0.75);
	}

	/* Mobile shop modal optimization */
	@media (max-width: 650px) {
		.game-modal {
			padding: 14px;
			width: clamp(320px, 94vw, 480px);
		}

		#shop-modal {
			width: clamp(320px, 94vw, 480px);
			max-height: 72vh;
			padding: 10px 16px;
			gap: 10px;
			overflow-y: auto;
		}

		#shop-modal h2 {
			font-size: 0.94rem;
			margin: 0 0 4px;
		}

		#shop-modal p {
			font-size: 0.74rem;
			margin: 0 0 6px 0;
		}

		.shop-content-grid {
			display: grid;
			grid-template-columns: minmax(0, 1fr);
			gap: 12px;
			margin-top: 8px;
			align-items: start;
		}

		.shop-section {
			min-width: 220px;
		}

		.shop-cards-section {
			border: none;
			padding-right: 0;
			padding-bottom: 0;
		}

		#shop-card-options {
			max-height: none;
			overflow: visible;
		}

		.shop-card-list {
			display: grid;
			grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
			gap: 10px;
			margin-top: 8px;
		}

		.shop-card {
			padding: 10px;
			gap: 8px;
			align-items: center;
		}

		.shop-card .card-option {
			width: 100%;
			max-width: none;
			min-height: 110px;
			gap: 6px;
		}

		.shop-card .card-pattern {
			gap: 2px;
		}

		.shop-card .card-option .card-cell {
			width: 12px;
			height: 12px;
			/* Border-radius: max 5px, minder rond */
			border-radius: min(5px, calc(12px / 5));
		}

		.shop-card .card-label {
			padding: 3px 6px;
			font-size: 0.6rem;
			gap: 3px;
		}

		.shop-card .card-label-dot {
			width: 6px;
			height: 6px;
		}

		.shop-card .card-meta {
			font-size: 0.62rem;
		}

		.shop-card-price {
			font-size: 0.78rem;
		}

		.shop-card-actions {
			width: 100%;
		}

		.shop-card-actions button {
			padding: 5px 10px;
			font-size: 0.78rem;
		}

		.modal-actions {
			gap: 8px;
			margin-top: 10px;
		}

		.modal-actions button {
			padding: 7px 14px;
			font-size: 0.84rem;
		}

		.shop-upgrade-container {
			padding: 0;
			margin-top: 0;
			display: grid;
			grid-template-columns: repeat(2, minmax(0, 1fr));
			gap: 10px;
		}

		.shop-upgrade-card {
			padding: 8px 10px;
			gap: 6px;
			height: 100%;
		}

		.shop-upgrade-header {
			font-size: 0.8rem;
			gap: 6px;
		}

		.upgrade-icon {
			font-size: 1rem;
		}

		.shop-upgrade-desc {
			font-size: 0.68rem;
			line-height: 1.35;
		}

		.shop-upgrade-price {
			font-size: 0.78rem;
		}

		.shop-upgrade-actions {
			justify-content: flex-start;
		}

		.shop-upgrade-actions button {
			padding: 5px 10px;
			font-size: 0.74rem;
		}
	}


	@media (max-width: 520px) {
		#shop-modal {
			width: clamp(300px, 96vw, 420px);
			max-height: 70vh;
			padding: 10px 14px;
			gap: 8px;
		}

		#shop-modal h2 {
			font-size: 0.9rem;
		}

		#shop-modal p {
			font-size: 0.72rem;
		}

		.shop-content-grid {
			grid-template-columns: minmax(0, 1fr);
			gap: 10px;
		}

		.shop-section-title {
			font-size: 0.8rem;
		}

		.shop-card-list {
			grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
			gap: 8px;
		}

		.shop-card {
			padding: 8px;
			gap: 6px;
		}

		.shop-card .card-option {
			min-height: 104px;
		}

		.shop-card .card-option .card-cell {
			width: 11px;
			height: 11px;
			/* Border-radius erft van base regel */
		}

		.shop-card-header {
			font-size: 0.74rem;
		}

		.shop-card-price {
			font-size: 0.76rem;
		}

		.shop-card-actions button {
			padding: 4px 10px;
			font-size: 0.76rem;
		}

		.modal-actions button {
			padding: 6px 12px;
			font-size: 0.82rem;
		}

		.shop-upgrade-card {
			padding: 7px 9px;
		}

		.shop-upgrade-header {
			font-size: 0.78rem;
		}

		.upgrade-icon {
			font-size: 0.96rem;
		}

		.shop-upgrade-desc {
			font-size: 0.65rem;
		}

		.shop-upgrade-container {
			grid-template-columns: repeat(2, minmax(0, 1fr));
			gap: 9px;
		}

		.shop-upgrade-actions button {
			padding: 4px 10px;
			font-size: 0.72rem;
		}
	}

	@media (max-width: 380px) {
		#shop-modal {
			width: clamp(280px, 96vw, 360px);
			max-height: 68vh;
			padding: 9px 12px;
			gap: 6px;
		}

		#shop-modal h2 {
			font-size: 0.86rem;
		}

		#shop-modal p {
			font-size: 0.68rem;
		}

		.shop-content-grid {
			grid-template-columns: minmax(0, 1fr);
			gap: 9px;
		}

		.shop-section-title {
			font-size: 0.76rem;
		}

		.shop-card-list {
			grid-template-columns: repeat(auto-fit, minmax(115px, 1fr));
			gap: 7px;
		}

		.shop-card {
			padding: 7px;
		}

		.shop-card .card-option {
			min-height: 98px;
		}

		.shop-card .card-option .card-cell {
			width: 10px;
			height: 10px;
			/* Border-radius erft van base regel */
		}

		.shop-card-header {
			font-size: 0.7rem;
		}

		.shop-card-price {
			font-size: 0.72rem;
		}

		.shop-card-actions button {
			padding: 4px 9px;
			font-size: 0.72rem;
		}

		.modal-actions {
			margin-top: 8px;
		}

		.modal-actions button {
			padding: 6px 10px;
			font-size: 0.8rem;
		}

		.shop-upgrade-card {
			padding: 6px 9px;
		}

		.shop-upgrade-header {
			font-size: 0.74rem;
		}

		.upgrade-icon {
			font-size: 0.92rem;
		}

		.shop-upgrade-desc {
			font-size: 0.62rem;
		}

		.shop-upgrade-container {
			grid-template-columns: repeat(2, minmax(0, 1fr));
			gap: 8px;
		}

		.shop-upgrade-actions button {
			padding: 4px 9px;
			font-size: 0.7rem;
		}
	}

	/* VERWIJDERD: Dubbele #card-choice-zone .card-option styling - deze stond al eerder gedefinieerd */

	@keyframes coinPop {
	  0% { transform: translate(-50%, -50%) scale(0); opacity: 0.2; }
	  70% { transform: translate(-50%, -50%) scale(1.3); opacity: 1; }
	  100% { transform: translate(-50%, -50%) scale(1); }
	}

	.objective-toast {
		position: fixed;
		top: 18px;
		left: 50%;
		transform: translateX(-50%);
		background: linear-gradient(135deg, #1f2a4d 0%, #283663 60%, #1e2959 100%);
		color: #f0f4ff;
		padding: 10px 18px;
		border-radius: 999px;
		font-size: 0.85rem;
		font-weight: 600;
		letter-spacing: 0.04em;
		box-shadow: 0 14px 28px rgba(10,22,60,0.35);
		opacity: 0;
		pointer-events: none;
		transition: opacity 0.25s ease, transform 0.25s ease;
		z-index: 1200;
	}

	body.dark-mode .objective-toast {
		background: linear-gradient(135deg, #101423 0%, #1a1f33 65%, #181c2b 100%);
		color: #f7f9ff;
		box-shadow: 0 16px 28px rgba(0,0,0,0.5);
	}

	.objective-toast.show {
		opacity: 1;
		transform: translateX(-50%) translateY(0);
	}


	@keyframes growRoot {
	  from { opacity: 0; transform: scale(0.5); }
	  to { opacity: 1; transform: scale(1); }
	}

	/* === Mobile layout (<=650px): keep compact 23-10 HUD === */
	@media (max-width: 650px) {
		body {
			display: block;
			position: relative;
			width: 100%;
			min-height: 100svh;
			height: 100svh;
			margin: 0;
			padding: 16px 8px calc(var(--bottom-bar-clearance) + 24px);
			padding-top: 62px;
			box-sizing: border-box;
			background: linear-gradient(180deg, #171822 0%, #101018 55%, #0a0b12 100%);
			color: #f5f6ff;
			overflow-x: hidden;
			overflow-y: hidden;
		}

		html {
			background: #101018;
		}

		body.dark-mode {
			background: linear-gradient(180deg, #0b0c10 0%, #040406 100%);
			color: #f5f6ff;
		}

		#mobile-objective-banner {
			display: flex;
			position: fixed;
			top: calc(env(safe-area-inset-top, 0px) + 4px);
			left: 10px;
			right: 10px;
			z-index: calc(var(--z-blur) + 20);
			justify-content: center;
			pointer-events: none;
		}

		body.zoomed-in #mobile-objective-banner {
			filter: none;
		}

		#mobile-objective-banner #objective-zone {
			pointer-events: none;
			width: min(100%, 328px);
			padding: 10px 12px 8px;
			gap: 4px;
			border-radius: 14px;
			box-shadow: 0 12px 26px rgba(10,18,35,0.28);
		}

		/* Mobile: force objective panel to stack (avoid desktop flex-row quirks and odd number spacing). */
		#mobile-objective-banner #objective-zone {
			display: flex;
			flex-direction: column;
			align-items: center;
			justify-content: center;
			text-align: center;
		}
		#mobile-objective-banner #objective-current {
			display: block;
			width: 100%;
			text-align: center;
		}
		#mobile-objective-banner #objective-current strong {
			white-space: nowrap;
		}

		#mobile-objective-banner #objective-zone h2 {
			margin: 0;
			font-size: 0.66rem;
			letter-spacing: 0.08em;
			text-transform: uppercase;
			color: rgba(20,24,36,0.72);
		}

		body.dark-mode #mobile-objective-banner #objective-zone h2 {
			color: rgba(230,235,255,0.8);
		}

		#mobile-objective-banner .objective-current {
			font-size: 0.78rem;
			line-height: 1.35;
		}

		#mobile-objective-banner .objective-history {
			display: none;
		}

		/* ============================================
		   HAMBURGER MENU KNOP (MOBIEL)
		   ============================================
		   Gouden ronde knop linksboven met 3 streepjes
		   Opent/sluit het controls menu
		   Animeer naar X wanneer open (.active class)
		*/
		#menu-toggle {
			position: fixed;
			left: 8px;
			top: 8px;
			display: flex;
			align-items: center;
			justify-content: center;
			flex-direction: column;
			gap: 3px;
			width: 30px;
			height: 30px;
			padding: 6px;
			border-radius: 6px;
			background: linear-gradient(145deg, #ffd560, #ffb23c);
			border: 1px solid rgba(255,255,255,0.35);
			box-shadow: 0 4px 10px rgba(0,0,0,0.28);
			cursor: pointer;
			transition: transform 0.2s ease, box-shadow 0.2s ease;
			z-index: var(--z-menu);
		}

		#menu-toggle:hover {
			transform: scale(1.05);
			box-shadow: 0 6px 14px rgba(0,0,0,0.32);
		}

		#menu-toggle span {
			display: block;
			width: 14px;
			height: 2px;
			background: #1c1c1c;
			border-radius: 2px;
			transition: transform 0.28s ease, opacity 0.28s ease;
		}

		#menu-toggle.active span:nth-child(1) { transform: translateY(6px) rotate(45deg); }
		#menu-toggle.active span:nth-child(2) { opacity: 0; }
		#menu-toggle.active span:nth-child(3) { transform: translateY(-6px) rotate(-45deg); }

		body.dark-mode #menu-toggle {
			background: linear-gradient(145deg, #2f3546, #1c2233);
			border-color: rgba(255,255,255,0.12);
		}

		body.dark-mode #menu-toggle span {
			background: rgba(255,255,255,0.88);
		}

		/* ============================================
		   CONTROLS MENU (MOBIEL)
		   ============================================
		   Pop-up menu met game controls (nieuw spel, reset, dark mode, etc.)
		   Verschijnt naast hamburger knop wanneer .open class wordt toegevoegd
		   Alleen op mobiel (<650px), op desktop is dit altijd fixed zichtbaar
		*/
		#controls {
			position: fixed;
			left: 64px;
			top: 12px;
			right: auto;
			bottom: auto;
			transform: translateX(0);
			opacity: 1;
			pointer-events: auto;
			background: rgba(18,20,28,0.96);
			border: 1px solid rgba(255,255,255,0.14);
			border-radius: 12px;
			padding: 10px 12px;
			box-shadow: 0 8px 20px rgba(0,0,0,0.38);
			transition: transform 0.28s ease, opacity 0.2s ease;
			z-index: calc(var(--z-controls) - 1);
			display: none;
			flex-direction: column;
			gap: 6px;
			min-width: 160px;
		}

		#controls.open {
			transform: translateX(0);
			opacity: 1;
			pointer-events: auto;
			display: flex;
		}

		body.dark-mode #controls {
			background: rgba(8,9,14,0.96);
			border-color: rgba(255,255,255,0.1);
		}

		#controls button {
			background: rgba(255,255,255,0.08);
			border: 1px solid rgba(255,255,255,0.18);
			color: #f5f6ff;
			padding: 10px 14px;
			border-radius: 8px;
			cursor: pointer;
			transition: background 0.2s ease;
			width: 100%;
			text-align: left;
			font-size: 0.9rem;
		}

		#controls button:disabled {
			opacity: 0.55;
			cursor: not-allowed;
		}

		#controls #debug-mode-toggle {
			display: flex;
			align-items: center;
			justify-content: space-between;
			gap: 12px;
			font-weight: 600;
		}

		#controls #debug-mode-toggle.debug-active {
			background: linear-gradient(145deg, rgba(112,198,255,0.28), rgba(72,132,255,0.32));
			border-color: rgba(112, 198, 255, 0.5);
			box-shadow: inset 0 0 0 1px rgba(255,255,255,0.18);
		}

		#controls button:hover:not(:disabled) {
			background: rgba(255,255,255,0.12);
		}

		/* Dark mode toggle binnen het menu (alleen mobiel) */
		#mobile-dark-mode-toggle {
			margin-top: 0;
		}

		body.dark-mode #mobile-dark-mode-toggle::before {
			content: 'â˜€ï¸ ';
		}

		body.dark-mode #mobile-dark-mode-toggle {
			background: rgba(255,255,255,0.12);
		}

		/* ============================================
		   BOTTOM BAR (MOBIEL)
		   ============================================
		   Vaste strip onderaan met kaarten, score en munten
		   Altijd zichtbaar tijdens mobiel spelen
		   Bevat:
		   - Kaart keuze (3 opties)
		   - Score overzicht (compacte dots)
		   - Munten teller
		   - Bonus status
		*/
		#bottom-bar {
			position: fixed;
			left: 0;
			right: 0;
			bottom: var(--bottom-bar-bottom-offset);
			height: auto;
			min-height: var(--bottom-bar-height);
			padding: 0 0 6px;
			padding-left: calc(5px + env(safe-area-inset-left, 0px));
			padding-right: calc(5px + env(safe-area-inset-right, 0px));
			display: flex;
			flex-direction: column;
			background: linear-gradient(180deg, rgba(47,50,68,0.95) 0%, rgba(33,36,52,0.97) 52%, rgba(22,24,36,0.98) 100%);
			border-radius: 18px 18px 0 0;
			border-top: 1px solid rgba(255,255,255,0.16);
			box-shadow: 0 -18px 40px rgba(0,0,0,0.42);
			backdrop-filter: blur(12px);
			-webkit-backdrop-filter: blur(12px);
			overflow-x: hidden;
			overflow-y: hidden;
			overscroll-behavior-y: contain;
			clip-path: none;
			z-index: var(--z-bottom);
		}

		body.dark-mode #bottom-bar {
			background: linear-gradient(180deg, rgba(20,22,32,0.96) 0%, rgba(14,16,26,0.98) 55%, rgba(8,9,16,0.99) 100%);
			border-top-color: rgba(255,255,255,0.1);
		}

		#bottom-bar-cards {
			display: flex;
			align-items: center;
			justify-content: flex-start;
			gap: 0;
			overflow-x: hidden;
			overflow-y: hidden;
			overscroll-behavior: contain;
			touch-action: pan-x;
			scrollbar-width: none; /* Firefox */
			-ms-overflow-style: none; /* IE/Edge legacy */
			padding: 0;
			margin-top: 0;
			transform: none;
			scroll-snap-type: x mandatory;
			border-radius: 0;
			background: transparent;
			border: none;
			flex: 0 0 auto;
			height: 100px;
			min-height: 80px;
			position: relative;
			z-index: 10;
			clip-path: none;
		}

		br {
		display: none;
		}

		.bottom-bar-footer {
			display: flex;
			justify-content: space-between;
			align-items: flex-end;
			gap: 0;
			padding: 0 4px 0;
			transform: none;
		}

		#bottom-bar-score-coins {
			display: flex;
			flex-direction: row;
			align-items: flex-end;
			justify-content: space-between;
			gap: 8px;
			width: 100%;
		}

		#bottom-bar-score,
		#bottom-bar-coins {
			display: flex;
			align-items: center;
		}

		#bottom-bar-score {
			justify-content: flex-start;
			flex: 1 1 auto;
			min-width: 0;
			max-width: 450px;
		}

		#bottom-bar-coins {
			justify-content: flex-end;
			flex: 0 0 auto;
			flex-direction: column;
			align-items: flex-end;
			gap: 4px;
			min-width: 0;
		}

		#bottom-bar-cards::-webkit-scrollbar {
			display: none;
		}

		#card-choice-zone {
			flex: 1 0 auto;
			display: flex;
			flex-direction: column;
			align-items: center;
			justify-content: center;
			background: none;
			width: 100%;
			height: 100%;
			padding: 0;
			margin: 0;
			overflow: visible;
			clip-path: none;
		}

		/* In de mobile bottom bar moet het kaartvlak geen â€œlos panelâ€ zijn.
		   Dit voorkomt een asymmetrische aflopende rand onder de kaarten. */
		#bottom-bar #card-choice-zone {
			background: transparent;
			border: none;
			border-radius: 0;
			box-shadow: none;
			position: relative;
			z-index: 0;
		}

		#card-controls {
			display: flex;
			flex-direction: row;
			align-items: center;
			justify-content: space-between;
			gap: 8px;
			width: 100%;
			position: relative;
			z-index: 12;
			overflow: visible;
			clip-path: none;
		}

		#card-options {
			flex: 1 1 auto;
			min-width: 0;
			max-width: none;
			overflow: visible;
			clip-path: none;
		}

		#card-action-buttons {
			display: flex;
			flex-direction: column;
			gap: 6px;
			align-items: center;
			justify-content: center;
			flex: 0 0 auto;
			width: auto;
			min-width: 0;
			max-width: none;
			margin: 0;
			padding-top: 0;
	}

	#card-action-buttons .deck-preview {
		order: 3;
		margin: 0;
	}

#card-action-buttons #new-cards-btn {
	order: 0;
}	#card-action-buttons #rotate-card-btn,
	#card-action-buttons #mirror-card-btn {
		order: 1;
		display: none; /* Verberg in mobiel, toon alleen in floating preview */
	}

	#card-action-buttons #turn-counter-inline {
		order: 4;
	}		#card-action-buttons .card-action-btn {
			min-height: 50px;
			width: 50px;
			flex: 0 0 auto;
			padding: 0;
			border-radius: 14px;
			display: flex;
			align-items: center;
			justify-content: center;
			gap: 0;
			font-size: 1rem;
			letter-spacing: 0;
			text-transform: none;
			box-shadow: 0 12px 22px rgba(10,12,20,0.25);
		}

		#card-action-buttons .card-action-btn::after {
			display: none;
		}

		#card-action-buttons .card-action-btn::before {
			font-size: 1.6rem;
		}

		/* Deck preview: zelfde stijl als card action buttons */
		#card-action-buttons .deck-preview {
			min-height: 50px;
			width: 50px;
			flex: 0 0 auto;
			padding: 0;
			border-radius: 14px;
			display: flex;
			align-items: center;
			justify-content: center;
			background: linear-gradient(155deg, #eff3ff 0%, #dbe2f6 100%);
			border: 1px solid rgba(26,32,48,0.16);
			box-shadow: 0 12px 22px rgba(10,12,20,0.25);
		}

		#card-action-buttons .deck-preview::after {
			display: none;
		}

	#card-action-buttons .deck-count {
		position: static;
		min-width: auto;
		padding: 0;
		background: none;
		border: none;
		box-shadow: none;
		font-size: 1rem;
		font-weight: 700;
		color: #2b3148;
	}		#turn-counter-inline {
			margin-top: 0;
			padding: 4px 8px;
			font-size: 0.7rem;
			box-shadow: 0 6px 12px rgba(10,12,20,0.18);
			border-radius: 10px;
		}

		#card-choice-zone::-webkit-scrollbar { display: none; }
		#kiesKaartTitel { display: none; }

		#card-controls {
			display: flex;
			flex-direction: row;
			align-items: center;
			justify-content: space-between;
			gap: 8px;
			width: 100%;
			position: relative;
		}

		.hand-scroll-btn {
			display: none;
			position: absolute;
			top: 50%;
			transform: translateY(-50%);
			width: 24px;
			height: 24px;
			border-radius: 999px;
			border: 1px solid rgba(26,32,48,0.16);
			background: rgba(239,243,255,0.7);
			box-shadow: 0 6px 10px rgba(10,12,20,0.14);
			color: rgba(74,82,104,0.85);
			font-size: 16px;
			font-weight: 900;
			line-height: 1;
			align-items: center;
			justify-content: center;
			z-index: 25;
			cursor: pointer;
			user-select: none;
			pointer-events: auto;
		}

		#card-controls.hand-scroll-enabled .hand-scroll-btn {
			display: inline-flex;
		}

		#hand-scroll-left {
			left: calc(6px + env(safe-area-inset-left, 0px));
		}

		#hand-scroll-right {
			/* Keep clear of the action button column on the right. */
			right: calc(58px + env(safe-area-inset-right, 0px));
		}

		#card-controls.hand-scroll-enabled #hand-scroll-left:disabled,
		#card-controls.hand-scroll-enabled #hand-scroll-right:disabled {
			opacity: 0.45;
			cursor: default;
			box-shadow: none;
		}

		#bottom-bar #card-options {
			display: flex;
			gap: 6px;
			align-items: stretch;
			justify-content: flex-start;
			flex-wrap: nowrap;
			scroll-snap-type: x proximity;
			flex: 1 1 auto;
			min-width: 0;
			width: auto;
			max-width: none;
			padding: 0;
			margin: 0;
			transform: translateY(0px);
			position: relative;
			z-index: 20;
			overflow-x: auto;
			overflow-y: hidden;
			touch-action: pan-x;
			clip-path: none;
		}

		#bottom-bar #card-options::-webkit-scrollbar { display: none; }

		#bottom-bar #new-cards-btn {
			display: flex;
			align-items: center;
			justify-content: center;
			height: 44px;
			width: 44px;
			padding: 0;
			margin: 0;
			font-weight: 400;
			font-size: 1.5rem;
			cursor: pointer;
			border-radius: 10px;
			border: 1px solid rgba(26,32,48,0.16);
			background: linear-gradient(155deg, #eff3ff 0%, #dbe2f6 100%);
			box-shadow: 0 8px 14px rgba(10,12,20,0.22);
			transition: transform 0.18s ease, box-shadow 0.18s ease, background 0.3s ease, border-color 0.3s ease;
			position: relative;
		}

		#bottom-bar #new-cards-btn::before {
			content: 'â†’';
			color: #4a5268;
			font-size: 1.8rem;
			font-weight: 700;
			position: absolute;
			top: 50%;
			left: 50%;
			transform: translate(-50%, -50%);
			transition: color 0.3s ease;
		}

		#bottom-bar #new-cards-btn.ready-for-next-turn {
			background: linear-gradient(155deg, #fef8e7 0%, #f0c149 100%);
			border-color: rgba(20,24,36,0.14);
		}

		#bottom-bar #new-cards-btn.ready-for-next-turn::before {
			color: #5a4a1e;
		}

		#bottom-bar #new-cards-btn:disabled {
			background: linear-gradient(155deg, #eff3ff 0%, #dbe2f6 100%);
			border-color: rgba(26,32,48,0.16);
			box-shadow: none;
			opacity: 0.6;
			cursor: default;
			transform: none;
			pointer-events: none;
		}

		#bottom-bar #new-cards-btn:disabled::before {
			color: rgba(74,82,104,0.6);
		}

		#bottom-bar #new-cards-btn.complete-round {
			background: linear-gradient(155deg, #e8f5e9 0%, #66bb6a 100%);
			border-color: rgba(46,125,50,0.3);
		}

		#bottom-bar #new-cards-btn.complete-round::before {
			content: 'âœ“';
			color: #1b5e20;
			font-size: 2rem;
			font-weight: 900;
		}

		@media (max-width: 520px) {
			#card-controls {
				gap: 6px;
			}

			#bottom-bar #new-cards-btn {
				height: 40px;
				width: 40px;
				border-radius: 10px;
			}

			#bottom-bar #new-cards-btn::before {
				font-size: 1.6rem;
			}

			#card-action-buttons .card-action-btn,
			#card-action-buttons .deck-preview {
				min-height: 44px;
				width: 44px;
				border-radius: 12px;
			}

			#hand-scroll-right {
				right: calc(54px + env(safe-area-inset-right, 0px));
			}

			/* Keep only the total coin text in the bottom bar. */
			#bottom-bar .coin,
			#bottom-bar #collected-coins {
				display: none !important;
			}
		}

		#bottom-bar #rotate-card-btn {
			display: none; /* Verberg in mobiel, alleen in floating preview */
		}

		#bottom-bar #rotate-card-btn::before {
			content: 'â†»';
			color: #4a5268;
			font-size: 1.6rem;
			position: absolute;
			top: 50%;
			left: 50%;
			transform: translate(-50%, -50%);
		}

		#bottom-bar #new-cards-btn:hover {
			transform: translateY(-2px);
			box-shadow: 0 12px 20px rgba(10,12,20,0.26);
		}

		#bottom-bar #rotate-card-btn:hover:not(:disabled) {
			transform: translateY(-1px);
			box-shadow: 0 10px 18px rgba(10,12,20,0.26);
		}

		#bottom-bar #rotate-card-btn:disabled {
			opacity: 0.6;
			box-shadow: none;
			transform: none;
		}

		body.dark-mode #bottom-bar #new-cards-btn {
			color: #f5f6ff;
			border-color: rgba(255,255,255,0.16);
			background: linear-gradient(155deg, #3c3f55 0%, #25283a 100%);
			box-shadow: 0 10px 18px rgba(0,0,0,0.4);
		}

		body.dark-mode #bottom-bar #new-cards-btn::before {
			color: rgba(255,255,255,0.75);
		}

		body.dark-mode #bottom-bar #new-cards-btn.ready-for-next-turn {
			background: linear-gradient(155deg, #ffd560 0%, #ffb23c 100%);
			border-color: rgba(255,255,255,0.35);
		}

		body.dark-mode #bottom-bar #new-cards-btn.ready-for-next-turn::before {
			color: #1c1c1c;
		}

		body.dark-mode #bottom-bar #new-cards-btn:disabled {
			background: linear-gradient(155deg, #3c3f55 0%, #25283a 100%);
			border-color: rgba(255,255,255,0.16);
			box-shadow: none;
			opacity: 0.6;
			cursor: default;
			transform: none;
			pointer-events: none;
		}

		body.dark-mode #bottom-bar #new-cards-btn:disabled::before {
			color: rgba(245,246,255,0.6);
		}

		body.dark-mode #bottom-bar #new-cards-btn.complete-round {
			background: linear-gradient(155deg, #2e7d32 0%, #1b5e20 100%);
			border-color: rgba(129,199,132,0.3);
		}

		body.dark-mode #bottom-bar #new-cards-btn.complete-round::before {
			color: #a5d6a7;
		}

		body.dark-mode #bottom-bar #rotate-card-btn {
			color: #f4f6ff;
			border-color: rgba(255,255,255,0.18);
			background: linear-gradient(155deg, #2b3247 0%, #1c2233 100%);
			box-shadow: 0 9px 18px rgba(0,0,0,0.4);
		}

		body.dark-mode #bottom-bar #rotate-card-btn:disabled {
			opacity: 0.5;
			box-shadow: none;
		}

		#bottom-bar #card-choice-zone .card-option {
			flex: 1 1 auto;
			width: var(--hand-card-width, 75px);
			max-width: var(--hand-card-width, 75px);
			min-height: var(--hand-card-height, 100px);
			padding: 4px 5px 6px;
			display: flex;
			flex-direction: column;
			align-items: center;
			justify-content: center;
			gap: 3px;
			border-radius: 12px;
			background: linear-gradient(165deg, #ffffff 0%, #eef2ff 45%, #dfe4ff 100%);
			border: 1px solid rgba(40,55,120,0.16);
			box-shadow: 0 20px 35px rgba(10,12,20,0.35), 0 8px 16px rgba(10,12,20,0.2);
			scroll-snap-align: center;
			transition: transform 0.2s ease, box-shadow 0.2s ease, border-color 0.2s ease;
			position: relative;
			overflow: hidden;
			z-index: 15;
		}

		#bottom-bar #card-choice-zone .card-option::after {
			content: "";
			position: absolute;
			inset: 0;
			border-radius: inherit;
			background: linear-gradient(120deg, rgba(255,255,255,0.65), rgba(255,255,255,0) 58%);
			opacity: 0.45;
			pointer-events: none;
		}

		#bottom-bar #card-choice-zone .card-option > * {
			position: relative;
			z-index: 1;
		}

		#bottom-bar #card-choice-zone .card-option:hover {
			transform: translateY(-6px);
			box-shadow: 0 26px 44px rgba(20,30,60,0.32);
		}

		#bottom-bar #card-choice-zone .card-option.selected {
			border-color: rgba(82,118,255,0.6);
			box-shadow: 0 28px 48px rgba(70,90,180,0.45);
		}

		#bottom-bar #card-choice-zone .card-pattern {
			display: grid;
			gap: var(--preview-gap);
			align-items: center;
			justify-items: center;
		}

		#bottom-bar #card-choice-zone .card-option .card-cell {
			width: 7px;
			height: 7px;
			/* Border-radius: max 5px, minder rond */
			border-radius: min(5px, calc(7px / 5));
			border: 1px solid rgba(12,16,30,0.1);
			box-shadow: inset 0 0 1px rgba(0,0,0,0.12);
		}

		#bottom-bar #card-choice-zone .card-label {
			display: inline-flex;
			align-items: center;
			gap: 2px;
			padding: 2px 5px;
			border-radius: 999px;
			background: rgba(20,24,36,0.06);
			font-size: 0.56rem;
			font-weight: 600;
			letter-spacing: 0.055em;
			text-transform: uppercase;
			color: rgba(20,24,36,0.62);
		}

		#bottom-bar #card-choice-zone .card-label span {
			display: inline-block;
		}

		#bottom-bar #card-choice-zone .card-label-dot {
			width: 6px;
			height: 6px;
			border-radius: 50%;
			box-shadow: 0 0 3px rgba(0,0,0,0.22);
		}

		#bottom-bar #card-choice-zone .card-meta {
			font-size: 0.6rem;
			letter-spacing: 0.045em;
			color: rgba(20,24,36,0.52);
		}

		body.dark-mode #bottom-bar #card-choice-zone .card-option {
			background: linear-gradient(160deg, #2d3142 0%, #232635 45%, #1b1e2c 100%);
			border-color: rgba(120,140,220,0.18);
			box-shadow: 0 20px 34px rgba(0,0,0,0.5);
		}

		body.dark-mode #bottom-bar #card-choice-zone .card-option::after {
			opacity: 0.25;
		}

		body.dark-mode #bottom-bar #card-choice-zone .card-option .card-cell {
			border-color: rgba(255,255,255,0.08);
			box-shadow: inset 0 0 6px rgba(0,0,0,0.35);
		}

		body.dark-mode #bottom-bar #card-choice-zone .card-label {
			background: rgba(255,255,255,0.08);
			color: rgba(255,255,255,0.8);
		}

		body.dark-mode #bottom-bar #card-choice-zone .card-label-dot {
			box-shadow: 0 0 6px rgba(0,0,0,0.45);
		}

		body.dark-mode #bottom-bar #card-choice-zone .card-meta {
			color: rgba(255,255,255,0.65);
		}

		@media (max-width: 450px) {
			#bottom-bar #card-options {
				transform: none;
			}

			#bottom-bar #card-choice-zone .card-option {
				width: var(--hand-card-width, 50px);
				min-height: var(--hand-card-height, 65px);
				padding: 2px;
			}

			#bottom-bar #card-choice-zone .card-option .card-cell {
				width: 7px;
				height: 7px;
			}

			#bottom-bar #card-choice-zone .card-label {
				font-size: 0.4rem;
			}

			#bottom-bar #card-choice-zone .card-meta {
				font-size: 0.45rem;
			}
			
			#turn-counter-inline {
				display: none;
			}
		}

		#bottom-bar #scoreboard {
			width: 100%;
			max-width: none;
			margin: 0;
			padding: 2px 3px;
			background: rgba(18,20,28,0.9);
			border: 1px solid rgba(255,255,255,0.12);
			border-radius: 10px;
			box-shadow: 0 8px 16px rgba(0,0,0,0.26);
			display: flex;
			flex-direction: row;
			flex-wrap: nowrap;
			gap: 4px;
			justify-content: space-between;
			align-items: center;
			color: #f5f6ff;
		}

		body.dark-mode #bottom-bar #scoreboard {
			background: rgba(12,14,22,0.92);
			border-color: rgba(255,255,255,0.14);
			color: #f5f6ff;
		}

		#bottom-bar #scoreboard::-webkit-scrollbar { display: none; }

		#bottom-bar #scoreboard::before,
		#bottom-bar #scoreboard hr {
			display: none;
		}

		#bottom-bar #scoreboard h2 {
			display: none;
		}

		#bottom-bar #scoreboard .score-row {
			display: flex;
			flex-direction: row;
			align-items: center;
			justify-content: center;
			gap: 4px;
			padding: 2px 4px;
			background: rgba(255,255,255,0.08);
			border-radius: 6px;
			color: inherit;
			font-size: 0.64rem;
			min-width: 0;
			flex: 1 1 auto;
		}

		#bottom-bar #scoreboard .score-row .color-box {
			width: 9px;
			height: 9px;
			border-radius: 50%;
			box-shadow: 0 0 5px rgba(0,0,0,0.26);
			flex-shrink: 0;
		}

		#bottom-bar #scoreboard .score-row .label {
			display: none;
		}

		#bottom-bar #scoreboard .score-row .score {
			margin: 0;
			font-weight: 700;
			font-size: 0.7rem;
			line-height: 1;
		}

		#bottom-bar #scoreboard .score-total {
			display: flex;
			flex-direction: row;
			align-items: center;
			justify-content: center;
			gap: 4px;
			padding: 2px 5px;
			background: rgba(255,255,255,0.12);
			border-radius: 6px;
			font-weight: 700;
			font-size: 0.72rem;
			min-width: 0;
			flex: 1 1 auto;
			box-shadow: none;
			border: none;
			color: inherit;
		}

		#bottom-bar #scoreboard .score-total::before {
			content: none;
		}

		#bottom-bar #scoreboard .score-total .label {
			display: inline;
			font-size: 0.6rem;
			letter-spacing: 0.04em;
			opacity: 0.75;
			line-height: 1;
		}

		#bottom-bar #scoreboard .score-total .total-score {
			font-size: 0.88rem;
			font-weight: 700;
			line-height: 1;
		}

		#bottom-bar #scoreboard .trap-summary {
			padding: 4px 6px;
			gap: 3px;
			border: none;
			border-radius: 6px;
			background: rgba(255,255,255,0.08);
		}

		#bottom-bar #scoreboard .trap-summary-header .trap-label,
		#bottom-bar #scoreboard .trap-summary-header .trap-count {
			display: none;
		}

		body.dark-mode #bottom-bar #scoreboard .trap-summary {
			background: rgba(255,255,255,0.04);
		}

		#bottom-bar #scoreboard .trap-summary-header {
			font-size: 0.58rem;
			letter-spacing: 0.05em;
		}

		#bottom-bar #scoreboard .trap-count {
			font-size: 0.62rem;
		}

		#bottom-bar #scoreboard .trap-preview {
			gap: 3px;
			padding-bottom: 0;
		}

		#bottom-bar #scoreboard .trap-preview.trap-preview--compact {
			gap: 4px;
		}

		#bottom-bar #scoreboard .trap-preview:empty::after {
			display: none;
		}

		#bottom-bar #scoreboard .trap-compact-chip {
			font-size: 0.62rem;
			padding: 1px 6px;
			border-radius: 12px;
		}

		#bottom-bar #scoreboard .trap-icon {
			width: 26px;
			height: 26px;
			border-radius: 8px;
			font-size: 1rem;
			box-shadow: 0 3px 6px rgba(196,56,56,0.16);
		}

		#bottom-bar #scoreboard .trap-icon .penalty-chip {
			right: -4px;
			bottom: -4px;
			font-size: 0.55rem;
			padding: 1px 4px;
		}

		#bottom-bar #scoreboard .trap-icon.trap-icon--black-hole {
			box-shadow: 0 4px 8px rgba(80,60,160,0.2);
		}

		#bottom-bar #gold-zone {
			width: auto;
			max-width: 100%;
			margin: 0;
			padding: 2px 6px;
			background: rgba(18,20,28,0.9);
			border: 1px solid rgba(255,255,255,0.12);
			border-radius: 8px;
			box-shadow: 0 8px 16px rgba(0,0,0,0.26);
			display: flex;
			flex-direction: row;
			align-items: center;
			justify-content: center;
			gap: 6px;
			color: #f5f6ff;
			height: auto;
			min-height: 0;
		}

		body.dark-mode #bottom-bar #gold-zone {
			background: rgba(12,14,22,0.92);
			border-color: rgba(255,255,255,0.14);
		}

		#bottom-bar #gold-zone h2 {
			display: none;
		}

		/* Deck preview (binnen card-action-buttons) */
		.deck-preview {
			display: flex;
			flex-direction: column;
			align-items: center;
			justify-content: center;
			gap: 4px;
			flex: 0 0 auto;
			cursor: pointer;
			background: none;
			border: none;
			box-shadow: none;
			padding: 0;
			min-height: 0;
			transition: transform 0.15s ease;
		}

		.deck-preview:hover {
			transform: translateY(-2px);
		}

		#card-action-buttons .deck-preview {
			order: 3;
			width: 100%;
		}
		
		/* Verberg het ðŸ“š icoon in mobiele versie - alleen deck-count tonen */
		#card-action-buttons .deck-preview::before {
			display: none;
		}

		#card-action-buttons .deck-preview::after {
			display: none;
		}

		#card-action-buttons .deck-preview:focus-visible {
			outline: 2px solid rgba(255,215,80,0.7);
			outline-offset: 4px;
		}

		body.dark-mode #card-action-buttons .deck-preview:focus-visible {
			outline-color: rgba(120,160,255,0.65);
		}

		#bottom-bar #card-action-buttons {
			position: relative;
		}

		#bottom-bar #card-action-buttons .deck-preview {
			position: static;
		}

		.deck-count {
			background: linear-gradient(145deg, #ffd560, #ffb23c);
			border: 1px solid rgba(255,255,255,0.35);
			border-radius: 10px;
			padding: 6px 10px;
			font-size: 0.95rem;
			font-weight: 700;
			color: #1c1c1c;
			box-shadow: 0 6px 12px rgba(0,0,0,0.26);
			min-width: 46px;
			text-align: center;
			display: flex;
			align-items: center;
			justify-content: center;
			gap: 4px;
			pointer-events: auto;
		}

		.deck-preview:focus-visible .deck-count {
			outline: 3px solid rgba(255, 215, 80, 0.9);
			outline-offset: 3px;
		}

		body.dark-mode .deck-preview:focus-visible .deck-count {
			outline-color: rgba(120, 160, 255, 0.8);
		}

		.deck-count::before {
			content: 'ðŸ“š';
			font-size: 1.1rem;
		}

		body.dark-mode .deck-count {
			background: linear-gradient(145deg, #2f3546, #1c2233);
			border-color: rgba(255,255,255,0.12);
			color: rgba(255,255,255,0.88);
		}

		.preview-card {
			display: none;
		}


		#bottom-bar #gold-zone h2 {
			display: none;
		}

		/* Mobile: keep coin counter next to the buy button. */
		#bottom-bar #gold-zone::before {
			display: none;
			content: none;
		}
		#bottom-bar #gold-zone::after {
			content: '\1FA99  ' attr(data-coin-text);
			display: inline-flex;
			align-items: center;
			justify-content: center;
			order: 1;
			text-align: center;
			font-size: 0.82rem;
			font-weight: 800;
			color: #f5f6ff;
			padding: 0;
			background: transparent;
			border: none;
			white-space: nowrap;
			opacity: 0.92;
			font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", "Helvetica Neue", Arial, sans-serif, "Segoe UI Emoji", "Apple Color Emoji", "Noto Color Emoji";
		}

		#bottom-bar #collected-coins {
			display: none !important;
		}
		
		/* Mobiele +1 blokplaatsing knop */
		#bottom-bar .buy-placement-btn {
			padding: 4px 8px;
			font-size: 0.7rem;
			border-radius: 6px;
			margin: 0;
			gap: 3px;
		}
		#bottom-bar .buy-placement-arrow {
			font-size: 0.9rem;
		}
		#bottom-bar .buy-placement-rainbow-cell {
			width: 14px;
			height: 14px;
			/* Border-radius: max 5px, minder rond */
			border-radius: min(5px, calc(14px / 5));
		}
		#bottom-bar .buy-placement-cost {
			padding: 1px 4px;
			font-size: 0.65rem;
		}

		#bottom-bar .coin {
			width: 13px;
			height: 13px;
			border-radius: 50%;
			background: rgba(255,255,255,0.18);
			border: 1px solid rgba(255,255,255,0.26);
			box-shadow: inset 0 0 0 1px rgba(0,0,0,0.22), 0 0 4px rgba(0,0,0,0.2);
			transition: transform 0.2s ease, background 0.2s ease, border-color 0.2s ease, box-shadow 0.2s ease;
		}

		#bottom-bar .coin.active {
			background: radial-gradient(circle at 30% 30%, #fff6b5, #f7bb36 70%);
			border-color: #f3b12b;
			box-shadow: 0 0 8px rgba(255,209,90,0.78), inset 0 0 2px rgba(255,255,255,0.85);
			transform: scale(1.05);
		}

		#bottom-bar .coin.used {
			background: rgba(80,82,95,0.65);
			border-color: rgba(120,124,140,0.6);
			box-shadow: inset 0 0 0 1px rgba(0,0,0,0.4);
			transform: scale(1);
		}

		body.dark-mode #bottom-bar .coin {
			background: rgba(255,255,255,0.14);
			border-color: rgba(255,255,255,0.24);
		}

		body.dark-mode #bottom-bar .coin.used {
			background: rgba(60,60,72,0.7);
			border-color: rgba(110,110,130,0.55);
			box-shadow: inset 0 0 0 1px rgba(0,0,0,0.55);
			transform: scale(1);
		}

		body.dark-mode #bottom-bar .coin.active {
			background: radial-gradient(circle at 30% 30%, #ffe58c, #f5b72f 70%);
		}

		/* Mobile bonus-inventory: hide labels, show only swatches + counts */
		@media (max-width: 650px) {
			/* Two-row footer:
			   - row 1 (top): bonus inventory + coin total + buy button
			   - row 2 (bottom): scoreboard
			   Keeps everything visible with minimal height. */
			#bottom-bar-left {
				display: flex;
				flex-direction: column;
				align-items: stretch;
				justify-content: flex-start;
				gap: 6px;
				width: 100%;
				min-width: 0;
			}

			#bottom-bar-bonus {
				display: flex !important;
				flex-direction: row;
				align-items: center;
				justify-content: flex-start;
				gap: 8px;
				min-width: 0;
				padding: 0;
			}

			#bottom-bar-score-coins {
				display: flex;
				flex-direction: row;
				gap: 0;
				align-items: stretch;
			}

			#bottom-bar-score {
				flex: 1 1 auto;
				min-width: 0;
			}

			/* Give the bonus inventory most of the width (70/30 split vs coins) WITHOUT leaving a visible gap. */
			#bottom-bar-bonus {
				gap: 6px;
			}
			#bottom-bar-bonus #bonus-zone {
				flex: 1 1 auto;
				min-width: 0;
			}
			#bottom-bar-bonus #gold-zone {
				flex: 0 0 auto;
				min-width: 0;
			}

			#bottom-bar #gold-zone {
				flex: 0 1 auto;
			}

			#bottom-bar #buy-placement-container {
				flex: 0 1 auto;
				display: flex;
				align-items: center;
				justify-content: center;
				order: 2;
				margin: 0;
				padding: 0;
			}

			/* Inside the bottom bar, the bonus zone should not look like a big panel. */
			#bottom-bar #bonus-zone {
				background: transparent !important;
				border: none !important;
				box-shadow: none !important;
				padding: 0 !important;
				gap: 0 !important;
			}

			#bottom-bar #bonus-zone h2,
			#bottom-bar #bonus-zone .bonus-hint {
				display: none !important;
			}

			/* One-line, low-height bonus badges: must fit 5 side-by-side. */
			#bottom-bar .bonus-inventory {
				display: flex;
				flex-wrap: nowrap;
				gap: 3px;
				align-items: center;
				justify-content: space-between;
				overflow: hidden;
				padding: 0;
			}
			#bottom-bar .bonus-inventory::-webkit-scrollbar { display: none; }

			#bottom-bar .bonus-badge {
				flex: 1 1 0;
				min-width: 0;
				padding: 2px 4px;
				border-radius: 10px;
				gap: 3px;
				font-size: 0.58rem;
				line-height: 1;
				justify-content: center;
			}

			#bottom-bar .bonus-badge .bonus-swatch {
				width: 10px;
				height: 10px;
			}

			#bottom-bar .bonus-badge .bonus-count {
				margin-left: 0;
				font-size: 0.58rem;
				padding: 0 4px;
			}

			/* #gold-zone is styled as a compact pill globally; no special nesting needed. */

			#bottom-bar #gold-zone::after {
				font-size: 0.82rem;
				font-weight: 800;
			}

			#bottom-bar .buy-placement-btn {
				padding: 4px 8px;
				font-size: 0.66rem;
				border-radius: 8px;
				margin-top: 0 !important;
			}

			#bottom-bar .buy-placement-cost {
				font-size: 0.62rem;
				padding: 1px 4px;
			}

			/* Ensure bonus inventory stays one line (no vertical wrap) and looks compact. */
			#bottom-bar-bonus .bonus-inventory {
				display: flex;
				flex-wrap: nowrap;
				gap: 3px;
				justify-content: space-between;
				align-items: center;
				overflow: hidden;
				padding: 0;
			}
			#bottom-bar-bonus .bonus-inventory::-webkit-scrollbar { display: none; }

			#bottom-bar-bonus #bonus-zone {
				background: transparent !important;
				border: none !important;
				box-shadow: none !important;
				padding: 0 !important;
			}

			#bottom-bar-bonus .bonus-badge .bonus-label { display: none !important; }
			#bottom-bar-bonus .bonus-badge .bonus-swatch {
				width: 10px;
				height: 10px;
				border-radius: 3px;
			}
			#bottom-bar-bonus .bonus-badge .bonus-count {
				margin-left: 0;
				font-size: 0.58rem;
				padding: 0 4px;
			}

			/* Mobile: show ONLY the total coin text (under the buy button), never the coin circles. */
			#bottom-bar #gold-zone::before {
				display: none !important;
				content: none !important;
			}
			#bottom-bar #gold-zone::after {
				display: block !important;
			}

			#bottom-bar #collected-coins,
			#bottom-bar .coin {
				display: none !important;
			}

			/* Mobile cards strip: keep buttons fully inside the bar.
			   Reduce left padding and reserve a bit more space on the right. */
			#bottom-bar #card-controls {
				gap: 6px;
			}
			#bottom-bar #card-options {
				padding-left: 2px;
				padding-right: 14px;
				max-width: none;
			}
			#bottom-bar #card-action-buttons {
				flex: 0 0 52px;
			}
		}

		@media (max-width: 550px) {
			/* Compact mode: prevent coins/buy from pushing bonus inventory away. */
			.bottom-bar-footer {
				margin-top: 0 !important;
			}

			#bottom-bar-bonus {
				gap: 6px;
			}
			#bottom-bar-bonus #bonus-zone {
				flex: 7 1 0 !important;
				min-width: 0 !important;
				padding: 0 !important;
			}
			#bottom-bar-bonus #gold-zone {
				flex: 3 1 0 !important;
				min-width: 0 !important;
			}
			#bottom-bar .bonus-inventory,
			#bottom-bar-bonus .bonus-inventory {
				margin: 0 !important;
				overflow: hidden !important;
				flex-wrap: nowrap !important;
				align-items: center;
			}

			#bottom-bar .bonus-badge {
				padding: 2px 5px;
				border-radius: 9px;
				font-size: 0.58rem;
			}
			#bottom-bar .bonus-badge .bonus-swatch {
				width: 10px;
				height: 10px;
			}
			#bottom-bar .bonus-badge .bonus-count {
				font-size: 0.58rem;
				padding: 0 4px;
			}

			#bottom-bar #gold-zone {
				padding: 2px 4px !important;
				background: transparent !important;
				border: none !important;
				box-shadow: none !important;
				gap: 6px !important;
			}

			#bottom-bar #gold-zone::before {
				display: none !important;
				content: none !important;
			}

			#bottom-bar #gold-zone::after {
				font-size: 0.76rem;
				font-weight: 800;
			}

			#bottom-bar .buy-placement-btn {
				margin-top: 0 !important;
				padding: 3px 6px !important;
				gap: 4px !important;
				border: none !important;
				box-shadow: none !important;
				font-size: 0.62rem !important;
			}
			#bottom-bar .buy-placement-arrow { font-size: 0.8rem !important; }
			#bottom-bar .buy-placement-rainbow-cell { width: 12px !important; height: 12px !important; border-radius: min(5px, calc(12px / 5)) !important; }
			#bottom-bar .buy-placement-cost { font-size: 0.58rem !important; padding: 0 3px !important; }

			/* Bonus upgrade shop is no longer accessed via a button. */
			#bonus-shop-btn,
			#bottom-bar #bonus-shop-btn {
				display: none !important;
			}

			/* Make the key action buttons smaller on very compact mobile. */
			#bottom-bar #new-cards-btn,
			#bottom-bar #bonus-shop-btn {
				height: 42px;
				padding: 6px 10px;
				font-size: 0.68rem;
			}

			#card-action-buttons .card-action-btn,
			#card-action-buttons .deck-preview {
				min-height: 42px;
				width: 42px;
				border-radius: 12px;
			}

			#card-action-buttons .deck-count {
				padding: 0;
				font-size: 0.72rem;
				border-radius: 0;
				min-width: 0;
			}
			#card-action-buttons .deck-count::before { display: none; }

			/* Deck: show icon above smaller number (narrower). */
			#card-action-buttons .deck-preview {
				flex-direction: column;
				gap: 2px;
			}
			#card-action-buttons .deck-preview::before {
				content: 'ðŸ“š';
				display: block;
				font-size: 1.05rem;
				line-height: 1;
			}
		}
	}


	.score-popup {
	  position: absolute;
	  font-size: 1.4rem;
	  font-weight: bold;
	  color: #222;
	  text-shadow: 0 0 8px rgba(255, 255, 255, 0.8);
	  pointer-events: none;
	  opacity: 0;
	  transform: translateY(0);
	  animation: floatUp 1s ease-out forwards;
	  z-index: var(--z-score);
	}

	@keyframes floatUp {
	  0% {
		opacity: 1;
		transform: translateY(0);
	  }
	  100% {
		opacity: 0;
		transform: translateY(-40px);
	  }
	}
	
	.sparkle {
	  position: absolute;
	  width: 16px;
	  height: 16px;
	  border-radius: 70%;
	  background: gold;
	  opacity: 0.5;
	  animation: sparkle 1.8s ease-out forwards;
	  pointer-events: none;
	  z-index: var(--z-score);
	}

	@keyframes sparkle {
	  0% { transform: scale(1) translate(0, 0); opacity: 1; }
	  100% { transform: scale(0) translate(var(--dx), var(--dy)); opacity: 0; }
	}
	
		/* Zorg dat .flash overal kan werken */
	.flash {
	  animation: flashAnim 0.4s ease;
	}

	@keyframes flashAnim {
	  0% {
		transform: scale(1.4);
		color: #fff;
		text-shadow: 0 0 8px #fff;
		filter: brightness(2);
	  }
	  100% {
		transform: scale(1);
		text-shadow: none;
		filter: brightness(1);

	  }
}


	/* ============================================
	   DARK MODE TOGGLE BUTTON (DESKTOP)
	   ============================================
	   Ronde knop rechtsboven voor dark/light mode wisselen
	   Alleen zichtbaar op desktop (>650px)
	   Op mobiel zit dark mode toggle in hamburger menu
	*/
	#dark-mode-toggle {
	  position: fixed;
	  top: 15px;
	  right: 15px;
	  background: #fff;
	  color: #333;
	  border: none;
	  border-radius: 50%;
	  width: 40px;
	  height: 40px;
	  font-size: 20px;
	  cursor: pointer;
	  box-shadow: 0 2px 6px rgba(0,0,0,0.25);
	  transition: background 0.3s, transform 0.2s;
	  z-index: 2000;
	}
	/* Dark/light is available in the hamburger menu; hide this floating button to save top space. */
	#dark-mode-toggle { display: none !important; }

	@media (max-width: 650px) {
	  #dark-mode-toggle {
		display: none; /* Op mobiel gebruiken we de knop in het menu */
	  }
	}

	#dark-mode-toggle:hover {
	  transform: scale(1.1);
	}

	/* ============================================
	   DARK MODE ALGEMEEN - DESKTOP/SHARED
	   ============================================
	   Extra dark mode styling voor desktop elementen
	   Basis dark mode staat bovenaan in het bestand
	*/

	/* Titels krijgen lichtblauwe gloed voor betere zichtbaarheid */
	body.dark-mode h1, 
	body.dark-mode #total-score {
	  color: #f0f3ff;
	  text-shadow: 0 0 10px rgba(100, 150, 255, 0.3);
	}

	body.dark-mode h2 {
	  color: #a0a3ad;
	  font-weight: 500;
	}

	/* Cellen: donker met blauwe gloed bij activatie */
	body.dark-mode .cell {
	  background: #272a31;
	  border: 1px solid #3a3d45;
	  color: #ddd;
	  transition: background 0.25s, transform 0.15s;
	}

	body.dark-mode .cell.active {
	  background: #3a6ff7;
	  color: #fff;
	  box-shadow: 0 0 8px rgba(58,111,247,0.4);
	}

	/* Hover effect op cellen */
	body.dark-mode .cell:hover {
	  background: #31343b;
	}

	/* Symbolen iets minder verzadigd in dark mode */
	body.dark-mode .symbol {
	  filter: brightness(0.9) saturate(0.9);
	}

	body.dark-mode .symbol.trap-symbol {
	  background: #555555;
	}

	body.dark-mode .symbol.trap-symbol::after {
	  background: linear-gradient(135deg, rgba(220,220,220,0.25) 0%, rgba(220,220,220,0) 50%);
	}

	body.dark-mode .symbol.trap-symbol.trap-symbol--black-hole {
	  background: radial-gradient(circle, #2a2a3e 0%, #1a1a2e 60%, #0a0a15 100%);
	  border-radius: 50%;
	  box-shadow: 
		0 0 20px rgba(138, 43, 226, 0.8),
		0 0 30px rgba(75, 0, 130, 0.6),
		inset 0 0 25px rgba(138, 43, 226, 0.4);
	  border: 2px solid rgba(138, 43, 226, 0.6);
	}

	body.dark-mode .symbol.trap-symbol.trap-symbol--black-hole::after {
	  background: radial-gradient(circle, rgba(138, 43, 226, 0.3) 0%, transparent 70%);
	  opacity: 1;
	  border-radius: 50%;
	}
	
	/* Gouden vak wordt donkergrijs met scoreboard styling */
	body.dark-mode #gold-zone { 
		background: linear-gradient(145deg, #22252b, #1a1c21);
		border: 1px solid #2d2f36;
		box-shadow: 0 0 12px rgba(0,0,0,0.6);
		color: #e5e5e5;
	}

	/* Scorebord dark mode styling */
	body.dark-mode #scoreboard {
	  background: linear-gradient(145deg, #22252b, #1a1c21);
	  border: 1px solid #2d2f36;
	  box-shadow: 0 0 12px rgba(0,0,0,0.6);
	  color: #e5e5e5;
	}
	
	body.dark-mode .score-row { 
		background: #2a2d35;
		color: #e5e5e5;
	}

	/* Dark mode knop zelf krijgt ook dark styling */
	body.dark-mode #dark-mode-toggle {
	  background: #2d2f35;
	  color: #f0f3ff;
	  box-shadow: 0 2px 6px rgba(0,0,0,0.5);
	}

	/* ============================================
	   KAART SYSTEEM - BASIS
	   ============================================
	   Kaarten die je kunt plaatsen op het bord
	   Gebruikt CSS Grid voor cel-layout binnen kaart
	*/
	.card {
	  display: grid;
	  background: #f0f0f0;
	  border-radius: 8px;
	  transition: transform 0.2s, box-shadow 0.2s;
	}
	
	/* kaarten */
	body.dark-mode .card {
	  background: #333;
	}
	
	.card:hover {
	  transform: scale(1.05);
	  box-shadow: 0 0 6px rgba(0,0,0,0.25);
	}
	.card-cell {
	  width: var(--card-cell-size, 20px);
	  height: var(--card-cell-size, 20px);
	  /* Border-radius: max 5px, minder rond voor kleine cells */
	  border-radius: min(5px, calc(var(--card-cell-size, 20px) / 5));
	}

	.card.selected {
	  outline: 3px solid #7a8aad;
	}
	
	body.dark-mode .card.selected {
	  outline: 3px solid #a7a9ad;
	}

	.draggable {
	  cursor: none;
	  transition: box-shadow 0.2s;
	  z-index: var(--z-draggable);
	}

	.draggable:active {
	  cursor: none;
	  box-shadow: 0 0 10px rgba(0,0,0,0.5);
	}
	
	/* preview styling - cells blijven exact dezelfde grootte als grid cells */
	.cell.preview-allowed {
	  outline: 2px solid rgba(0,200,100,0.8);
	  transition: outline 0.08s;
	}
	.cell.preview-denied {
	  outline: 2px solid rgba(220,20,60,0.8);
	  transition: outline 0.08s;
	}
	
	body.dragging * {
	  cursor: none !important;
	  -webkit-user-select: none !important;
	  user-select: none !important;
	}

	.draggable { touch-action: none; user-select: none; cursor: none; }

	/* ============================================
	   BONUS INVENTORY STYLING (GLOBAL)
	   ============================================
	   Werkt voor zowel desktop (#bonus-zone) als mobiel (#bottom-bar-bonus)
	   Specifieke overrides voor mobiel staan in de mobiele media queries
	*/
	:is(#bonus-zone, #bottom-bar-bonus) .bonus-badge {
		position: relative;
		overflow: hidden;
		appearance: none;
		display: inline-flex;
		align-items: center;
		gap: 6px;
		border: 1px solid transparent;
		border-radius: 12px;
		padding: 6px 10px;
		font-size: 0.74rem;
		color: #1c2434;
		background: linear-gradient(150deg, rgba(255,255,255,0.96) 0%, rgba(236,246,255,0.92) 100%);
		box-shadow: 0 10px 22px rgba(10, 12, 20, 0.22);
		transition: transform 0.15s ease, box-shadow 0.15s ease;
		cursor: pointer;
	}

	:is(#bonus-zone, #bottom-bar-bonus) .bonus-badge::before {
		content: "";
		position: absolute;
		inset: 0;
		background: linear-gradient(120deg, rgba(255,255,255,0.4), rgba(255,255,255,0));
		opacity: 0.45;
		pointer-events: none;
	}

	:is(#bonus-zone, #bottom-bar-bonus) .bonus-badge:not(.disabled):hover {
		transform: translateY(-1px);
		box-shadow: 0 14px 30px rgba(10, 12, 20, 0.28);
	}

	:is(#bonus-zone, #bottom-bar-bonus) .bonus-badge .bonus-count {
		background: rgba(255,255,255,0.32);
		color: inherit;
		margin-left: auto;
		font-variant-numeric: tabular-nums;
		font-weight: 600;
		padding: 2px 6px;
		border-radius: 12px;
	}

	:is(#bonus-zone, #bottom-bar-bonus) .bonus-badge .bonus-swatch {
		width: 14px;
		height: 14px;
		border-radius: 50%;
		flex-shrink: 0;
		box-shadow: inset 0 0 0 1px rgba(0,0,0,0.25);
	}

	:is(#bonus-zone, #bottom-bar-bonus) .bonus-badge .bonus-label {
		position: absolute;
		clip: rect(0 0 0 0);
		clip-path: inset(50%);
		height: 1px;
		width: 1px;
		overflow: hidden;
		white-space: nowrap;
	}

	:is(#bonus-zone, #bottom-bar-bonus) .bonus-badge[data-bonus-color="geel"] {
		background: linear-gradient(135deg, #fff2b0, #f2c94c);
		border-color: rgba(214, 176, 68, 0.6);
		color: #463100;
	}

	:is(#bonus-zone, #bottom-bar-bonus) .bonus-badge[data-bonus-color="rood"] {
		background: linear-gradient(135deg, #ffd6d3, #f58f9c);
		border-color: rgba(212, 112, 122, 0.55);
		color: #4a1420;
	}

	:is(#bonus-zone, #bottom-bar-bonus) .bonus-badge[data-bonus-color="groen"] {
		background: linear-gradient(135deg, #d5f5d2, #8fcfa0);
		border-color: rgba(104, 180, 126, 0.55);
		color: #143720;
	}

	:is(#bonus-zone, #bottom-bar-bonus) .bonus-badge[data-bonus-color="paars"] {
		background: linear-gradient(135deg, #eadcff, #b9a4f9);
		border-color: rgba(146, 110, 209, 0.55);
		color: #2d1955;
	}

	:is(#bonus-zone, #bottom-bar-bonus) .bonus-badge[data-bonus-color="blauw"] {
		background: linear-gradient(135deg, #d3e9ff, #8cbaf5);
		border-color: rgba(94, 138, 196, 0.55);
		color: #123357;
	}

	:is(#bonus-zone, #bottom-bar-bonus) .bonus-badge.active {
		box-shadow: 0 0 0 2px rgba(82,118,255,0.38), 0 12px 28px rgba(48,72,140,0.35);
	}

	:is(#bonus-zone, #bottom-bar-bonus) .bonus-badge.bonus-mastered {
		border-style: solid;
		box-shadow: 0 0 0 2px rgba(255, 215, 0, 0.6), 0 16px 30px rgba(255, 215, 0, 0.35);
	}

	:is(#bonus-zone, #bottom-bar-bonus) .bonus-badge.bonus-mastered .bonus-count {
		background: rgba(255, 255, 255, 0.6);
		color: inherit;
		font-weight: 700;
	}

	:is(#bonus-zone, #bottom-bar-bonus) .bonus-badge.disabled,
	:is(#bonus-zone, #bottom-bar-bonus) .bonus-badge:disabled {
		opacity: 0.9;
		box-shadow: none;
		border-style: dashed;
		color: inherit;
	}

	:is(#bonus-zone, #bottom-bar-bonus) .bonus-badge.bonus-mastered.disabled,
	:is(#bonus-zone, #bottom-bar-bonus) .bonus-badge.bonus-mastered:disabled {
		opacity: 1;
		border-style: solid;
	}

	:is(#bonus-zone, #bottom-bar-bonus) .bonus-badge.disabled::before,
	:is(#bonus-zone, #bottom-bar-bonus) .bonus-badge:disabled::before {
		opacity: 0.2;
	}

	:is(#bonus-zone, #bottom-bar-bonus) .bonus-badge.disabled::after,
	:is(#bonus-zone, #bottom-bar-bonus) .bonus-badge:disabled::after {
		content: "";
		position: absolute;
		inset: 0;
		background: linear-gradient(0deg, rgba(255,255,255,0.55), rgba(255,255,255,0));
		pointer-events: none;
	}

	/* Dark mode bonus badges */
	body.dark-mode :is(#bonus-zone, #bottom-bar-bonus) .bonus-badge {
		box-shadow: 0 16px 32px rgba(0,0,0,0.5);
		color: #f5f6ff;
	}
	body.dark-mode :is(#bonus-zone, #bottom-bar-bonus) .bonus-badge.bonus-mastered {
		box-shadow: 0 0 0 2px rgba(255, 214, 97, 0.7), 0 16px 34px rgba(255, 214, 97, 0.42);
	}

	body.dark-mode :is(#bonus-zone, #bottom-bar-bonus) .bonus-badge::before {
		background: linear-gradient(120deg, rgba(255,255,255,0.18), rgba(255,255,255,0));
		opacity: 0.3;
	}

	body.dark-mode :is(#bonus-zone, #bottom-bar-bonus) .bonus-badge[data-bonus-color="geel"] {
		background: linear-gradient(140deg, rgba(255, 207, 102, 0.24), rgba(198, 147, 44, 0.58));
		border-color: rgba(255, 207, 102, 0.45);
		color: #fff3c0;
	}

	body.dark-mode :is(#bonus-zone, #bottom-bar-bonus) .bonus-badge[data-bonus-color="rood"] {
		background: linear-gradient(140deg, rgba(255, 170, 174, 0.25), rgba(215, 90, 112, 0.6));
		border-color: rgba(215, 90, 112, 0.45);
		color: #ffd6dc;
	}

	body.dark-mode :is(#bonus-zone, #bottom-bar-bonus) .bonus-badge[data-bonus-color="groen"] {
		background: linear-gradient(140deg, rgba(158, 223, 175, 0.2), rgba(78, 148, 102, 0.55));
		border-color: rgba(118, 186, 136, 0.45);
		color: #ddffe7;
	}

	body.dark-mode :is(#bonus-zone, #bottom-bar-bonus) .bonus-badge[data-bonus-color="paars"] {
		background: linear-gradient(140deg, rgba(210, 186, 255, 0.24), rgba(120, 92, 190, 0.65));
		border-color: rgba(167, 132, 230, 0.45);
		color: #f0e9ff;
	}

	body.dark-mode :is(#bonus-zone, #bottom-bar-bonus) .bonus-badge[data-bonus-color="blauw"] {
		background: linear-gradient(140deg, rgba(168, 205, 255, 0.22), rgba(70, 116, 186, 0.6));
		border-color: rgba(120, 162, 226, 0.45);
		color: #e2f1ff;
	}

	body.dark-mode :is(#bonus-zone, #bottom-bar-bonus) .bonus-badge.active {
		box-shadow: 0 0 0 2px rgba(142,174,255,0.38), 0 16px 32px rgba(0,0,0,0.55);
	}

	body.dark-mode :is(#bonus-zone, #bottom-bar-bonus) .bonus-badge.disabled,
	body.dark-mode :is(#bonus-zone, #bottom-bar-bonus) .bonus-badge:disabled {
		opacity: 0.85;
		border-color: rgba(142,174,255,0.35);
	}

	body.dark-mode :is(#bonus-zone, #bottom-bar-bonus) .bonus-badge.disabled::after,
	body.dark-mode :is(#bonus-zone, #bottom-bar-bonus) .bonus-badge:disabled::after {
		background: linear-gradient(0deg, rgba(4,6,14,0.55), rgba(4,6,14,0));
	}

	body.dark-mode :is(#bonus-zone, #bottom-bar-bonus) .bonus-badge .bonus-count {
		background: rgba(12,14,20,0.55);
		color: #f5f6ff;
	}

	

	/* ============================================
	   DESKTOP LAYOUT (>650px)
	   ============================================
	   Op grotere schermen gebruiken we een 4-kolommen layout
	   zonder bottom-bar. Alle controls zijn altijd zichtbaar.
	   
	   Kolom 1: Paars + Rood vak
	   Kolom 2: Groen + Geel vak
	   Kolom 3: Blauw vak
	   Kolom 4: Score, Munten, Bonus, Doelen
	*/
	@media (min-width: 651px) {
	  html {
		background: #2d3142;
		overflow: hidden;
		height: 100%;
	  }

	  html, body {
		scrollbar-width: none;
		-ms-overflow-style: none;
	  }

	  html::-webkit-scrollbar,
	  body::-webkit-scrollbar {
		display: none;
		width: 0;
		height: 0;
	  }

	  body {
		display: grid;
		position: static;
		margin: 0;
		padding: 10px;
		min-height: 100vh;
		min-height: 100svh;
		width: 100%;
		background: #2d3142;
		color: #e5e5e5;
		overflow: hidden;
	  }

	  body.dark-mode {
		background: #1b1d22;
		color: #e5e5e5;
	  }

	  /* ============================================
	     DESKTOP LAYOUT REORGANISATIE
	     ============================================
	     - Doel bovenaan (boven de grids)
	     - Menu linksbovenin
	     - Grids centraal
	     - Score, bonussen en kaarten onderaan
	  */

  /* Wrapper voor desktop layout */
  #desktop-wrapper {
	display: grid;
	grid-template-areas:
	  "menu objective objective"
	  "left grids right"
	  "left bottom right";
		grid-template-columns: minmax(200px, 280px) 1fr minmax(200px, 290px);
	grid-template-rows: auto 1fr auto;
	gap: 16px;
	padding: 12px;
	/* Use 100% instead of 100vw to avoid horizontal clipping inside padded body. */
	width: 100%;
	height: calc(100vh - 20px);
	box-sizing: border-box;
	margin: 0 auto;
	position: relative;
	/* Allow board shadows / scaled content without being clipped by the wrapper. */
	overflow: visible;
	transform-origin: top center;
  }

	  /* Portrait mode: stack (objective -> board -> bottom) so nothing ends up off-screen on narrow widths. */
	  body.desktop-portrait {
		/* No scrolling - everything should fit */
		overflow: hidden;
	  }

	  body.desktop-portrait #desktop-wrapper {
		display: flex;
		flex-direction: column;
		flex-wrap: nowrap;
		align-items: center;
		justify-content: flex-start;
		gap: 4px;
		width: 100%;
		max-width: 100%;
		margin: 0 auto;
		padding: 6px;
		box-sizing: border-box;
		height: calc(100vh - 20px);
		height: calc(100svh - 20px);
		min-height: 0;
		max-height: none;
		overflow: hidden;
	  }

	  /* Hide empty sidebars in portrait: JS moves content into #desktop-bottom. */
	  body.desktop-portrait #desktop-left,
	  body.desktop-portrait #desktop-right {
		display: none !important;
	  }

	  /* Board area - don't stretch, just fit content and scale */
	  body.desktop-portrait #desktop-grids {
		flex: 0 0 auto;
		min-height: 0;
		width: 100%;
		display: flex;
		justify-content: center;
		align-items: flex-start;
		overflow: visible;
	  }

	  /* Scale board to fit in constrained portrait */
	  body.desktop-portrait #desktop-grids .board {
		transform-origin: top center;
	  }

	  body.desktop-portrait #desktop-bottom {
		flex: 0 0 auto;
		width: 100%;
		max-width: 100%;
		margin-top: 2px;
	  }

	  /* Narrow desktop portrait (split-screen / iPad-ish): keep bottom UI compact so the board keeps height. */
	  @media (min-width: 651px) and (max-width: 925px) {
		/* Compact objective in portrait */
		body.desktop-portrait #objective-zone {
			padding: 6px 12px;
			min-height: 32px;
			gap: 8px;
		}
		body.desktop-portrait #objective-zone h2 {
			font-size: 0.85rem;
		}
		body.desktop-portrait #objective-current {
			font-size: 0.8rem;
		}
		
		body.desktop-portrait #desktop-bottom {
			flex-wrap: nowrap;
			justify-content: center;
			align-items: stretch;
			gap: 8px;
			padding: 4px 8px;
			max-height: 160px;
		}

		body.desktop-portrait #desktop-bottom-left {
			flex: 0 0 140px !important;
			min-width: 130px !important;
			max-width: 160px !important;
		}

		body.desktop-portrait #desktop-bottom-center {
			flex: 1 1 auto !important;
			min-width: 180px !important;
			max-width: 350px !important;
			align-items: center;
		}
		
		/* On touch devices (iPad portrait), action buttons go INSIDE bottom-center, below cards */
		body.desktop-portrait.touch-portrait #desktop-bottom-center #card-action-buttons {
			display: flex !important;
			flex-direction: row;
			gap: 6px;
			align-items: center;
			justify-content: center;
			margin-top: 6px;
			padding: 0;
			width: 100%;
		}
		body.desktop-portrait.touch-portrait #desktop-bottom-center .card-action-btn,
		body.desktop-portrait.touch-portrait #desktop-bottom-center .deck-preview {
			width: 36px;
			min-width: 36px;
			height: 36px;
			min-height: 36px;
			padding: 6px;
		}

		body.desktop-portrait #desktop-bottom-buttons {
			flex: 0 0 auto;
			min-width: 0;
			width: auto;
		}

		body.desktop-portrait #desktop-bottom-right {
			flex: 0 0 110px !important;
			min-width: 100px !important;
			max-width: 130px !important;
		}

		/* Card panel: remove extra vertical chrome and force a single row of cards. */
		body.desktop-portrait #card-choice-zone {
			padding: 4px 6px;
		}
		body.desktop-portrait #card-choice-zone h2,
		body.desktop-portrait #kiesKaartTitel,
		body.desktop-portrait #card-choice-zone br {
			display: none !important;
		}
		body.desktop-portrait #desktop-bottom-center #card-controls {
			flex-direction: row;
			justify-content: center;
			width: fit-content;
		}
		body.desktop-portrait #desktop-bottom-center #card-options {
			flex-wrap: nowrap;
			justify-content: center;
			gap: 6px;
			width: fit-content;
		}
		body.desktop-portrait #desktop-bottom-center .card-option {
			width: 60px;
			max-width: 60px;
			min-height: 85px;
			padding: 4px;
			gap: 4px;
			--preview-cell: 12px;
		}
		body.desktop-portrait #desktop-bottom-center .card-option .card-cell {
			width: 10px;
			height: 10px;
		}
		body.desktop-portrait #desktop-bottom-center .card-label {
			font-size: 0.5rem;
			padding: 2px 4px;
		}

		/* Buttons: smaller footprint in the dedicated portrait button column. */
		body.desktop-portrait #desktop-bottom-buttons #card-action-buttons {
			display: flex !important;
			flex-direction: column;
			gap: 4px;
			align-items: center;
			justify-content: flex-start;
			margin: 0;
			padding: 0;
		}
		body.desktop-portrait #desktop-bottom-buttons .card-action-btn,
		body.desktop-portrait #desktop-bottom-buttons .deck-preview {
			width: 36px;
			min-width: 36px;
			max-width: 36px;
			height: 36px;
			min-height: 36px;
			padding: 6px;
		}
		body.desktop-portrait #desktop-bottom-buttons .card-action-btn::before {
			font-size: 0.95rem;
		}
		body.desktop-portrait #desktop-bottom-buttons .deck-preview::before {
			font-size: 0.9rem;
		}
		body.desktop-portrait #desktop-bottom-buttons .deck-count {
			font-size: 0.6rem;
		}

		/* Scoreboard: compact but readable */
		body.desktop-portrait #scoreboard {
			padding: 6px 8px;
			background: rgba(40, 45, 60, 0.9);
			border-radius: 8px;
		}
		body.desktop-portrait #scoreboard h2,
		body.desktop-portrait #scoreboard hr {
			display: none;
		}
		body.desktop-portrait #scoreboard .score-row {
			font-size: 0.75rem;
			padding: 2px 4px;
			gap: 6px;
		}
		body.desktop-portrait #scoreboard .score-row .label {
			display: none;
		}
		body.desktop-portrait #scoreboard .score-row .color-box {
			width: 12px;
			height: 12px;
		}
		body.desktop-portrait #scoreboard .score-total {
			padding: 4px 6px;
			gap: 6px;
			margin-top: 4px;
			border-top: 1px solid rgba(255,255,255,0.2);
		}
		body.desktop-portrait #scoreboard .score-total .label {
			display: inline;
			font-size: 0.7rem;
			opacity: 0.8;
		}
		body.desktop-portrait #scoreboard .score-total .total-score {
			font-size: 0.95rem;
			font-weight: bold;
		}
		body.desktop-portrait #scoreboard .score-total {
			justify-content: center;
		}

		/* Bonus panel: compact */
		body.desktop-portrait #bonus-zone {
			padding: 4px 6px;
			background: rgba(40, 45, 60, 0.9);
			border-radius: 6px;
		}
		body.desktop-portrait #bonus-zone h2,
		body.desktop-portrait #bonus-zone .bonus-hint {
			display: none;
		}
		body.desktop-portrait .bonus-inventory {
			gap: 2px;
			flex-wrap: wrap;
			justify-content: center;
		}
		body.desktop-portrait .bonus-badge {
			padding: 2px 4px;
			font-size: 0.55rem;
		}
		body.desktop-portrait .bonus-count {
			font-size: 0.5rem;
			padding: 1px 3px;
		}

		/* Coins: ultra-compact inline with buy button */
		body.desktop-portrait #gold-zone {
			flex-direction: row;
			align-items: center;
			justify-content: flex-start;
			gap: 4px;
			padding: 4px 6px;
			min-height: 0;
			max-height: 36px;
			background: rgba(40, 45, 60, 0.9);
			border-radius: 6px;
			flex-wrap: nowrap;
			overflow: visible;
		}
		body.desktop-portrait #gold-zone h2 {
			display: none;
		}
		body.desktop-portrait #gold-zone::after {
			content: attr(data-coin-text) ' ðŸª™';
			font-size: 0.7rem;
			font-weight: bold;
			text-align: center;
			color: #ffd700;
			display: inline;
			flex: 0 0 auto;
			white-space: nowrap;
			min-width: 40px;
		}
		body.desktop-portrait #gold-zone #buy-placement-container {
			margin: 0;
			flex: 0 1 auto;
			min-width: 0;
		}
		body.desktop-portrait #gold-zone .buy-placement-btn {
			padding: 3px 5px;
			max-width: 70px;
			width: auto;
			white-space: nowrap;
			font-size: 0.5rem;
			border-radius: 4px;
			overflow: hidden;
			text-overflow: ellipsis;
		}
		body.desktop-portrait #collected-coins {
			display: none !important;
		}

		/* Remove fixed zone heights - let them scale naturally */
		body.desktop-portrait #blue-zone,
		body.desktop-portrait #blue-zone--placeholder,
		body.desktop-portrait #green-zone,
		body.desktop-portrait #green-zone--placeholder {
			height: auto;
			min-height: 0;
		}
	  }

	  /* Short desktop height (<=925px) in landscape: use same compact styles as narrow portrait.
	     This ensures portrait mode kicks in when there's not enough vertical space. */
	  @media (min-width: 926px) and (max-height: 925px) and (orientation: landscape) {
		body.desktop-portrait #objective-zone {
			padding: 6px 12px;
			min-height: 32px;
			gap: 8px;
		}
		body.desktop-portrait #objective-zone h2 {
			font-size: 0.85rem;
		}
		body.desktop-portrait #objective-current {
			font-size: 0.8rem;
		}
		
		body.desktop-portrait #desktop-bottom {
			flex-wrap: nowrap;
			justify-content: center;
			align-items: stretch;
			gap: 8px;
			padding: 4px 8px;
			max-height: 140px;
		}

		body.desktop-portrait #desktop-bottom-left {
			flex: 0 0 140px !important;
			min-width: 130px !important;
			max-width: 160px !important;
		}

		body.desktop-portrait #desktop-bottom-center {
			flex: 1 1 auto !important;
			min-width: 180px !important;
			max-width: 450px !important;
			align-items: center;
		}

		body.desktop-portrait #desktop-bottom-buttons {
			flex: 0 0 auto;
			min-width: 0;
			width: auto;
		}

		body.desktop-portrait #desktop-bottom-right {
			flex: 0 0 100px !important;
			min-width: 90px !important;
			max-width: 140px !important;
		}

		/* Card panel: compact horizontal row */
		body.desktop-portrait #card-choice-zone {
			padding: 4px 6px;
		}
		body.desktop-portrait #card-choice-zone h2,
		body.desktop-portrait #kiesKaartTitel,
		body.desktop-portrait #card-choice-zone br {
			display: none !important;
		}
		body.desktop-portrait #desktop-bottom-center #card-controls {
			flex-direction: row;
			justify-content: center;
			width: fit-content;
		}
		body.desktop-portrait #desktop-bottom-center #card-options {
			flex-wrap: nowrap;
			justify-content: center;
			gap: 6px;
			width: fit-content;
		}
		body.desktop-portrait #desktop-bottom-center .card-option {
			width: 60px;
			max-width: 60px;
			min-height: 85px;
			padding: 4px;
			gap: 4px;
			--preview-cell: 12px;
		}
		body.desktop-portrait #desktop-bottom-center .card-option .card-cell {
			width: 10px;
			height: 10px;
		}
		body.desktop-portrait #desktop-bottom-center .card-label {
			font-size: 0.5rem;
			padding: 2px 4px;
		}

		/* Buttons: compact column */
		body.desktop-portrait #desktop-bottom-buttons #card-action-buttons {
			display: flex !important;
			flex-direction: column;
			gap: 4px;
			align-items: center;
			justify-content: flex-start;
			margin: 0;
			padding: 0;
		}
		body.desktop-portrait #desktop-bottom-buttons .card-action-btn,
		body.desktop-portrait #desktop-bottom-buttons .deck-preview {
			width: 36px;
			min-width: 36px;
			max-width: 36px;
			height: 36px;
			min-height: 36px;
			padding: 6px;
		}

		/* Scoreboard: compact */
		body.desktop-portrait #scoreboard {
			padding: 6px 8px;
			background: rgba(40, 45, 60, 0.9);
			border-radius: 8px;
		}
		body.desktop-portrait #scoreboard h2,
		body.desktop-portrait #scoreboard hr {
			display: none;
		}
		body.desktop-portrait #scoreboard .score-row {
			font-size: 0.75rem;
			padding: 2px 4px;
			gap: 6px;
		}
		body.desktop-portrait #scoreboard .score-row .label {
			display: none;
		}
		body.desktop-portrait #scoreboard .score-row .color-box {
			width: 12px;
			height: 12px;
		}
		body.desktop-portrait #scoreboard .score-total {
			padding: 4px 6px;
			gap: 6px;
			margin-top: 4px;
		}
		body.desktop-portrait #scoreboard .score-total .total-score {
			font-size: 0.95rem;
			font-weight: bold;
		}

		/* Bonus panel: compact */
		body.desktop-portrait #bonus-zone {
			padding: 4px 6px;
			background: rgba(40, 45, 60, 0.9);
			border-radius: 6px;
		}
		body.desktop-portrait #bonus-zone h2,
		body.desktop-portrait #bonus-zone .bonus-hint {
			display: none;
		}
		body.desktop-portrait .bonus-inventory {
			gap: 2px;
			flex-wrap: wrap;
			justify-content: center;
		}
		body.desktop-portrait .bonus-badge {
			padding: 2px 4px;
			font-size: 0.55rem;
		}
		body.desktop-portrait .bonus-count {
			font-size: 0.5rem;
			padding: 1px 3px;
		}

		/* Coins: compact with visible coin icon */
		body.desktop-portrait #gold-zone {
			flex-direction: row;
			align-items: center;
			justify-content: center;
			gap: 6px;
			padding: 4px 8px;
			min-height: 0;
			max-height: 36px;
			background: rgba(40, 45, 60, 0.9);
			border-radius: 6px;
			flex-wrap: nowrap;
			overflow: visible;
		}
		body.desktop-portrait #gold-zone h2 {
			display: none;
		}
		body.desktop-portrait #gold-zone::after {
			content: attr(data-coin-text) ' ðŸª™';
			font-size: 0.8rem;
			font-weight: bold;
			text-align: center;
			color: #ffd700;
			display: inline;
			flex: 0 0 auto;
			white-space: nowrap;
		}
		body.desktop-portrait #gold-zone #buy-placement-container {
			margin: 0;
			flex: 0 1 auto;
			min-width: 0;
		}
		body.desktop-portrait #gold-zone .buy-placement-btn {
			padding: 4px 6px;
			max-width: 100px;
			width: auto;
			white-space: nowrap;
			font-size: 0.55rem;
			border-radius: 4px;
			overflow: hidden;
			text-overflow: ellipsis;
		}
		body.desktop-portrait #collected-coins {
			display: none !important;
		}

		/* Remove fixed zone heights */
		body.desktop-portrait #blue-zone,
		body.desktop-portrait #blue-zone--placeholder,
		body.desktop-portrait #green-zone,
		body.desktop-portrait #green-zone--placeholder {
			height: auto;
			min-height: 0;
		}
	  }

	  #desktop-bottom-left,
	  #desktop-bottom-center,
	  #desktop-bottom-buttons,
	  #desktop-bottom-right {
		display: flex;
		flex-direction: column;
		gap: 12px;
		flex-shrink: 1;
	  }
	  
	  #desktop-bottom-left,
	  #desktop-bottom-right {
		flex: 1 1 220px;
		min-width: 160px;
		max-width: 280px;
	  }
	  
	  #desktop-bottom-buttons {
		display: none; /* Hidden in landscape, shown in portrait */
		flex: 0 0 auto;
	  }

	  /* Portrait mode: elementen verdelen */
	  body.desktop-portrait #desktop-bottom-left {
		flex: 1 1 220px;
		min-width: 160px;
		max-width: 260px;
	  }

	  body.desktop-portrait #desktop-bottom-center {
		flex: 2 1 320px;
		min-width: 220px;
		max-width: 520px;
		align-items: stretch;
	  }

	  body.desktop-portrait #desktop-bottom-right {
		flex: 1 1 200px;
		min-width: 150px;
		max-width: 260px;
	  }
	  
	  body.desktop-portrait #desktop-bottom-buttons {
		display: flex;
		flex-direction: column;
		justify-content: flex-start;
		align-items: center;
		flex: 0 0 auto;
		width: auto;
	  }

  @media (max-width: 400px) {
	body.desktop-portrait #desktop-wrapper {
	  transform: scale(0.75);
	}
  }

  @media (max-width: 350px) {
	body.desktop-portrait #desktop-wrapper {
	  transform: scale(0.7);
	}
  }

  /* iPad / constrained landscape: when right sidebar would overflow, scale the whole layout */
  @media (min-width: 651px) and (max-width: 1650px) and (orientation: landscape) {
	body.desktop-landscape #desktop-wrapper {
		grid-template-columns: minmax(120px, 160px) 1fr minmax(120px, 160px);
		gap: 6px;
		padding: 6px;
		max-width: 100vw;
		overflow: visible;
	}
	
	body.desktop-landscape #desktop-left,
	body.desktop-landscape #desktop-right {
		min-width: 110px;
		max-width: 160px;
		flex-shrink: 0;
	}
	
	body.desktop-landscape #desktop-right #card-choice-zone {
		padding: 6px;
	}
	
	body.desktop-landscape #desktop-right .card-option {
		width: 60px;
		min-height: 80px;
		padding: 5px;
		--preview-cell: 10px;
	}
	
	body.desktop-landscape #desktop-right .card-option .card-cell {
		width: 9px;
		height: 9px;
	}
	
	body.desktop-landscape #desktop-right .card-label {
		font-size: 0.5rem;
	}
	
	body.desktop-landscape #desktop-right #bonus-zone {
		padding: 5px;
	}
	
	body.desktop-landscape #desktop-right .bonus-badge {
		padding: 3px 5px;
		font-size: 0.55rem;
	}
	
	body.desktop-landscape #desktop-left #scoreboard {
		padding: 6px;
	}
	
	body.desktop-landscape #desktop-left #scoreboard h2 {
		font-size: 0.8rem;
	}
	
	body.desktop-landscape #desktop-left #scoreboard .score-row {
		font-size: 0.65rem;
		padding: 2px 3px;
	}
	
	body.desktop-landscape #desktop-left #gold-zone {
		padding: 5px 6px;
	}
  }

  /* Slightly wider screens (1100-1650px): allow a bit more room */
  @media (min-width: 1101px) and (max-width: 1650px) and (orientation: landscape) {
	body.desktop-landscape #desktop-wrapper {
		grid-template-columns: minmax(150px, 200px) 1fr minmax(150px, 200px);
		gap: 10px;
		padding: 10px;
	}
	
	body.desktop-landscape #desktop-left,
	body.desktop-landscape #desktop-right {
		min-width: 140px;
		max-width: 200px;
	}
	
	body.desktop-landscape #desktop-right .card-option {
		width: 75px;
		min-height: 95px;
		padding: 6px;
		--preview-cell: 12px;
	}
	
	body.desktop-landscape #desktop-right .card-option .card-cell {
		width: 11px;
		height: 11px;
	}
	
	body.desktop-landscape #desktop-right .card-label {
		font-size: 0.55rem;
	}
	
	body.desktop-landscape #desktop-left #scoreboard h2 {
		font-size: 0.9rem;
	}
	
	body.desktop-landscape #desktop-left #scoreboard .score-row {
		font-size: 0.7rem;
		padding: 2px 4px;
	}
  }

  /* Very constrained iPad landscape: force portrait-style bottom layout */
  @media (min-width: 651px) and (max-width: 950px) and (max-height: 700px) and (orientation: landscape) {
	body.desktop-landscape #desktop-wrapper {
		display: flex;
		flex-direction: column;
		align-items: center;
	}
	
	body.desktop-landscape #desktop-left,
	body.desktop-landscape #desktop-right {
		display: none !important;
	}
	
	body.desktop-landscape #desktop-bottom {
		display: flex !important;
		flex-wrap: wrap;
		justify-content: center;
		gap: 8px;
		width: 100%;
	}
  }

	  /* Menu linksbovenin - altijd zichtbaar */
	  #desktop-menu {
		grid-area: menu;
		display: flex !important;
		align-items: flex-start;
		justify-content: flex-start;
		z-index: 1002;
		position: sticky;
		top: 0;
	  }

	  /* Hamburger button - altijd zichtbaar in desktop */
	  #desktop-menu-toggle {
		display: none !important;
		flex-direction: column;
		justify-content: center;
		align-items: center;
		width: 50px;
		height: 50px;
		background: #fffbea;
		border: 1px solid #e3e6ea;
		border-radius: 12px;
		cursor: pointer;
		transition: all 0.3s ease;
		box-shadow: 0 2px 8px rgba(0,0,0,0.15);
		position: relative;
		z-index: 1003;
	  }

	  #desktop-menu-toggle:hover {
		background: #fff5d1;
		transform: translateY(-2px);
		box-shadow: 0 4px 12px rgba(0,0,0,0.2);
	  }

	  #desktop-menu-toggle span {
		width: 24px;
		height: 3px;
		background: #2b3148;
		border-radius: 2px;
		transition: all 0.3s ease;
		display: block;
		margin: 3px 0;
	  }

	  #desktop-menu-toggle.active span:nth-child(1) {
		transform: rotate(45deg) translate(8px, 8px);
	  }

	  #desktop-menu-toggle.active span:nth-child(2) {
		opacity: 0;
	  }

	  #desktop-menu-toggle.active span:nth-child(3) {
		transform: rotate(-45deg) translate(8px, -8px);
	  }

	  body.dark-mode #desktop-menu-toggle {
		background: #2d2f36;
		border-color: #4a4c54;
	  }

	  body.dark-mode #desktop-menu-toggle span {
		background: #eee;
	  }

	  body.dark-mode #desktop-menu-toggle:hover {
		background: #3a3c44;
	  }

	  #controls {
		position: fixed !important;
		left: 64px;
		top: 12px;
		opacity: 1 !important;
		pointer-events: auto !important;
		background: #fffbea;
		border: 1px solid #e3e6ea;
		border-radius: 12px;
		box-shadow: 0 4px 16px rgba(0,0,0,0.2);
		padding: 12px;
		display: none !important;
		flex-direction: column;
		gap: 8px;
		width: 220px;
		margin: 0;
		z-index: calc(var(--z-menu) - 1);
	  }

	  #controls.open {
		display: flex !important;
	  }

  /* Doel bovenaan */
  #desktop-objective {
	grid-area: objective;
	display: flex;
	justify-content: center;
	align-items: center;
	width: 100%;
  }

  /* In landscape mode: objective alleen boven grids kolom */
  body:not(.desktop-portrait) #desktop-objective {
	grid-column: 2 / 3; /* Alleen boven de grids kolom */
  }

  #objective-zone {
	margin: 0 auto;
	padding: 14px 24px 10px;
	width: 100%;
	max-width: 100%;
	min-height: 50px;
	display: flex;
	align-items: center;
	gap: 16px;
	justify-content: center;
	text-align: center;
	box-sizing: border-box;
	background: #fffbea;
	border-radius: 10px;
	border: 1px solid #e3e6ea;
	box-shadow: 0 2px 6px rgba(0,0,0,0.12);
  }	  body.dark-mode #objective-zone {
		background: linear-gradient(145deg, #22252b, #1a1c21);
		border: 1px solid #2d2f36;
		box-shadow: 0 4px 10px rgba(0,0,0,0.5);
		color: #e5e5e5;
	  }

	  #objective-zone h2 {
		margin: 0;
		font-size: 1.1rem;
		font-weight: 600;
		white-space: nowrap;
		flex-shrink: 0;
		color: #333;
	  }

	  body.dark-mode #objective-zone h2 {
		color: #e5e5e5;
	  }

	  #objective-current {
		margin: 0;
		padding: 0;
		font-size: 0.95rem;
		line-height: 1.3;
		flex: 1;
		display: flex;
		align-items: center;
		gap: 8px;
	  }

	  /* Verwijder het doelwit icoontje */
	  #objective-current::before {
		content: none;
	  }

	  #objective-history {
		margin: 0;
		padding: 0;
		display: none; /* Verberg history op desktop voor compactheid */
	  }

	  /* Verberg empty state tekst op desktop */
	  .objective-empty-state {
		display: none;
	  }

	  /* Board met grids centraal */
	  #desktop-grids {
		grid-area: grids;
		display: flex;
		justify-content: center;
		align-items: center;
		overflow: visible;
	  }

	  /* Half-screen desktop landscape (â‰ˆ900-1200px): tighten sidebars + gaps so the full board fits. */
	  @media (min-width: 651px) and (max-width: 1200px) and (orientation: landscape) {
		body.desktop-landscape #desktop-wrapper {
			grid-template-columns: minmax(88px, 118px) 1fr minmax(88px, 118px);
			gap: 3px;
			padding: 4px;
			margin: 0;
		}
		body.desktop-landscape #desktop-left,
		body.desktop-landscape #desktop-right {
			min-width: 88px;
			max-width: 118px;
		}
		body.desktop-landscape #desktop-right .card-option {
			width: 54px;
			min-height: 76px;
			padding: 4px;
			--preview-cell: 9px;
		}
		body.desktop-landscape #desktop-right .card-option .card-cell {
			width: 8px;
			height: 8px;
		}
		body.desktop-landscape #desktop-right .card-label {
			font-size: 0.48rem;
		}
		body.desktop-landscape #desktop-left #scoreboard {
			padding: 5px;
		}
		body.desktop-landscape #desktop-left #gold-zone {
			padding: 4px 5px;
		}
	  }

	  /* Extra fit: if the window is narrow, slightly reduce cell-size (keeps proportions consistent). */
	  @media (min-width: 651px) and (max-width: 1200px) and (orientation: landscape) {
		body.desktop-landscape {
			--cell-size: 26px;
		}
	  }

	  /* Extra-tight landscape for small desktop widths: pull sidebars inward so right sidebar stays visible. */
	  @media (min-width: 651px) and (max-width: 1050px) and (orientation: landscape) {
		body.desktop-landscape #desktop-wrapper {
			grid-template-columns: minmax(82px, 108px) 1fr minmax(82px, 108px);
			gap: 2px;
			padding: 2px;
			margin: 0;
		}
		body.desktop-landscape #desktop-left,
		body.desktop-landscape #desktop-right {
			min-width: 82px;
			max-width: 108px;
		}
		body.desktop-landscape #desktop-right .card-option {
			width: 52px;
			min-height: 72px;
			padding: 3px;
			--preview-cell: 8px;
		}
		body.desktop-landscape #desktop-right .card-option .card-cell {
			width: 7px;
			height: 7px;
		}
		body.desktop-landscape #desktop-left #scoreboard,
		body.desktop-landscape #desktop-left #gold-zone {
			padding: 4px;
		}
	  }

	  .board {
		display: flex;
		gap: 12px;
		margin: 0;
		transform: none;
		max-height: none;
	  }

	  .column {
		transform: none;
	  }

	  /* Eerste 3 kolommen (grids) naast elkaar */
	  .column:nth-child(1),
	  .column:nth-child(2),
	  .column:nth-child(3) {
		flex: 0 0 auto;
		width: auto;
	  }

	  /* 4e kolom verbergen op desktop */
	  .column:nth-child(4) {
		display: none;
	  }

	  /* Linker sidebar voor score en munten */
	  #desktop-left {
		grid-area: left;
		display: flex;
		flex-direction: column;
		gap: 12px;
		overflow-y: auto;
		overflow-x: hidden;
		scrollbar-width: thin;
		scrollbar-color: rgba(80, 90, 110, 0.35) transparent;
	  }

	  /* Rechter sidebar voor kaarten en bonussen */
	  #desktop-right {
		grid-area: right;
		display: flex;
		flex-direction: column;
		gap: 12px;
		overflow-y: auto;
		overflow-x: hidden;
		scrollbar-width: thin;
		scrollbar-color: rgba(80, 90, 110, 0.35) transparent;
	  }

	  /* Wanneer de kaartenlijst zelf scrollt (4+ kaarten), laat de sidebar NIET meescrollen.
	     Dit voorkomt dat het muiswiel op #desktop-right "verdwijnt" i.p.v. in #card-options. */
	  #desktop-right.hand-has-scroll {
		overflow-y: hidden;
	  }

	  #desktop-left::-webkit-scrollbar,
	  #desktop-right::-webkit-scrollbar {
		width: 8px;
	  }

	  #desktop-left::-webkit-scrollbar-thumb,
	  #desktop-right::-webkit-scrollbar-thumb {
		background: rgba(80, 90, 110, 0.35);
		border-radius: 10px;
	  }

	  body.dark-mode #desktop-left::-webkit-scrollbar-thumb,
	  body.dark-mode #desktop-right::-webkit-scrollbar-thumb {
		background: rgba(255, 255, 255, 0.16);
	  }

  /* Bottom section voor alle modes */
  #desktop-bottom {
	grid-area: bottom;
	display: flex;
	gap: 12px;
	align-items: start;
	width: 100%;
	flex-wrap: nowrap;
	justify-content: space-between;
  }

  /* Landscape mode: verberg de bottom bar (scores + bonussen zijn in sidebars) */
  body:not(.desktop-portrait) #desktop-bottom {
	display: none;
  }

  /* Portrait mode: toon bottom bar - clean consolidated layout */
  body.desktop-portrait #desktop-bottom {
	display: flex;
	flex-wrap: wrap;
	justify-content: center;
	align-items: flex-start;
	gap: 10px;
	width: 100%;
	max-width: 100%;
	padding: 0 10px;
	box-sizing: border-box;
  }

  #desktop-bottom-left,
  #desktop-bottom-center,
  #desktop-bottom-buttons,
  #desktop-bottom-right {
	display: flex;
	flex-direction: column;
	gap: 10px;
	flex-shrink: 1;
  }

  body.desktop-portrait #desktop-bottom-left {
	flex: 1 1 200px;
	min-width: 140px;
	max-width: 240px;
  }

  body.desktop-portrait #desktop-bottom-center {
	flex: 2 1 300px;
	min-width: 220px;
	max-width: 500px;
  }

  body.desktop-portrait #desktop-bottom-right {
	flex: 1 1 180px;
	min-width: 130px;
	max-width: 220px;
  }

  body.desktop-portrait #desktop-bottom-buttons {
	display: flex;
	flex-direction: column;
	justify-content: flex-start;
	align-items: center;
	flex: 0 0 auto;
	width: auto;
  }

  #desktop-bottom-buttons {
	display: none; /* Hidden in landscape */
  }

	  /* Portrait mode: bonus inventory verticaal */
	  body.desktop-portrait .bonus-inventory {
		flex-direction: column;
		align-items: stretch;
		gap: 4px;
	  }
	  
	  body.desktop-portrait .bonus-badge {
		padding: 6px 8px;
		font-size: 0.7rem;
		min-height: auto;
	  }
	  
	  body.desktop-portrait .bonus-count {
		font-size: 0.65rem;
		padding: 2px 5px;
	  }

	  /* Portrait mode: toon munten onder bonussen */
	  body.desktop-portrait #desktop-bottom-right #gold-zone {
		order: 10;
	  }

	  /* Portrait mode: hide coin grid, show text counter like mobile */
	  body.desktop-portrait #gold-zone {
		display: flex;
		flex-direction: row;
		align-items: center;
		justify-content: flex-start;
		gap: 10px;
		min-height: auto;
		max-height: none;
		padding: 6px 10px;
		min-width: auto;
	  }

	  body.desktop-portrait #gold-zone h2 {
		display: none;
	  }

	  body.desktop-portrait #gold-zone::after {
		content: '\1FA99  ' attr(data-coin-text);
		display: block;
		flex: 0 0 auto;
		text-align: center;
		font-size: 0.95rem;
		font-weight: 700;
		color: #333;
		padding: 0;
		background: transparent;
		border-radius: 0;
		border: none;
		white-space: nowrap;
		font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", "Helvetica Neue", Arial, sans-serif, "Segoe UI Emoji", "Apple Color Emoji", "Noto Color Emoji";
	  }

	  body.desktop-portrait #gold-zone #buy-placement-container {
		margin-top: 0;
		margin-left: auto;
	  }

	  body.desktop-portrait #gold-zone .buy-placement-btn {
		margin-top: 0;
		padding: 6px 10px;
		max-width: 180px;
		width: fit-content;
	  }

	  body.desktop-portrait #collected-coins {
		display: none !important;
	  }

	  body.dark-mode.desktop-portrait #gold-zone::after {
		color: #e5e5e5;
	  }

	  #desktop-bottom-center {
		display: flex;
		flex-direction: column;
		justify-content: flex-start;
		align-items: center;
		flex: 1 1 auto;
		min-width: 0;
		gap: 12px;
	  }

	  /* Portrait mode: card-choice-zone past zich aan */
	  body.desktop-portrait #card-choice-zone {
		width: 100%;
	  }

	  /* Portrait mode: card action buttons in separate middle zone */
	  body.desktop-portrait #card-controls {
		flex-direction: column;
		align-items: center;
	  }
	  
	  body.desktop-portrait #card-options {
		width: 100%;
	  }
	  
	  body.desktop-portrait .card-option {
		max-width: 90px;
		min-height: 140px;
		padding: 8px 6px;
	  }
	  
	  body.desktop-portrait .card-option .card-cell {
		width: 16px;
		height: 16px;
	  }

	  body.desktop-portrait #card-controls #card-action-buttons {
		display: none !important;
	  }
	  
	  body.desktop-portrait #desktop-bottom-buttons #card-action-buttons {
		display: flex !important;
		flex-direction: column;
		align-items: center;
		flex: 0 0 auto;
		width: auto;
	  }

	  /* Kaarten in rechter sidebar: verticaal gestapeld */
	  #desktop-right #card-choice-zone {
		width: 100%;
		background: #fffbea;
		border: 1px solid #e3e6ea;
		border-radius: 10px;
		padding: 12px;
		display: flex;
		flex-direction: column;
		min-height: 0;
	  }

	  body.dark-mode #desktop-right #card-choice-zone {
		background: linear-gradient(145deg, #22252b, #1a1c21);
		border: 1px solid #2d2f36;
	  }

	  #desktop-right #card-options {
		display: flex;
		flex-direction: column;
		gap: 12px;
		align-items: stretch;
		overflow-x: hidden;
		flex: 1 1 auto;
		min-height: 0;
		padding-bottom: 8px;
		padding-right: 10px;
	  }

	  /* Desktop sidebar: cards should use the available width (less cramped). */
	  #desktop-right #card-choice-zone .card-option {
		width: calc(100% - 20px);
		margin-left: auto;
		margin-right: auto;
		min-width: 0;
		box-sizing: border-box;
	  }
	  
	  /* Scrolling alleen wanneer er 4+ kaarten zijn (class toegevoegd via JS) */
	  #desktop-right #card-options.has-scroll {
		max-height: 610px;
		min-height: 0 !important;
		overflow-y: auto !important;
		scrollbar-width: thin;
		scrollbar-color: rgba(100, 120, 180, 0.5) transparent;
	  }
	  
	  #desktop-right #card-options.has-scroll::-webkit-scrollbar {
		width: 6px;
	  }
	  #desktop-right #card-options.has-scroll::-webkit-scrollbar-track {
		background: transparent;
		border-radius: 3px;
	  }
	  #desktop-right #card-options.has-scroll::-webkit-scrollbar-thumb {
		background: linear-gradient(180deg, rgba(100, 120, 180, 0.6), rgba(80, 100, 160, 0.4));
		border-radius: 3px;
	  }
	  #desktop-right #card-options.has-scroll::-webkit-scrollbar-thumb:hover {
		background: linear-gradient(180deg, rgba(120, 140, 200, 0.8), rgba(100, 120, 180, 0.6));
	  }
	  
	  body.dark-mode #desktop-right #card-options.has-scroll {
		scrollbar-color: rgba(140, 160, 220, 0.4) transparent;
	  }
	  body.dark-mode #desktop-right #card-options.has-scroll::-webkit-scrollbar-thumb {
		background: linear-gradient(180deg, rgba(100, 120, 180, 0.5), rgba(80, 100, 160, 0.3));
	  }

	  /* Buttons centreren onder kaarten op desktop */
	  #desktop-right > #card-action-buttons,
	  #card-choice-zone #card-action-buttons {
		display: flex !important;
		flex-direction: row;
		gap: 8px;
		align-items: center;
		justify-content: center;
		margin-top: 12px;
		margin-bottom: 12px;
		width: 100%;
		max-width: 100%;
		box-sizing: border-box;
		flex-wrap: wrap;
		padding: 0 8px;
	  }
	  
	  /* Hide buttons when still in card-controls during landscape layout */
	  body.desktop-landscape #card-controls #card-action-buttons {
		display: none !important;
	  }
	  
	  body.desktop-landscape #desktop-right > #card-action-buttons {
		display: flex !important;
		justify-content: center;
		gap: 10px;
	  }

	  body.desktop-landscape #desktop-right > #card-action-buttons .card-action-btn,
	  body.desktop-landscape #desktop-right > #card-action-buttons .deck-preview {
		flex: 0 0 auto;
		margin: 0;
	  }

	  body.desktop-landscape #gold-zone .buy-placement-btn {
		padding: 8px 10px;
		max-width: 150px;
		white-space: nowrap;
	  }

	  /* Verberg originele wrapper zones op desktop */
	  #original-coins-zone,
	  #original-score-zone,
	  #original-objective-zone,
	  #original-bonus-zone,
	  #original-card-zone,
	  #original-controls-zone {
		display: none;
	  }

	  /* Zone styling op desktop - geen achtergrond (wordt per zone ingesteld) */
	  /* Dark mode borders en shadows worden al bovenaan gedefinieerd */

	  /* Coins display integreren in scoreboard sectie */
	  #gold-zone {
		padding: 12px;
		margin: 0 0 12px 0;
		width: 100%;
		min-height: 140px;
		border-radius: 10px;
		border: 1px solid #e3e6ea;
		box-shadow: 0 2px 6px rgba(0,0,0,0.12);
		background: #fffbea !important;
		text-align: left;
		overflow: hidden;
	  }

	  /* Give the buy-placement button enough width so it never clips in the coin zone. */
	  #gold-zone #buy-placement-container {
		width: 100%;
		justify-content: stretch;
	  }
	  #gold-zone #buy-placement-btn {
		width: 100%;
	  }

	  /* Landscape mode: hide coin grid, show text counter (unless classic mode). */
	  body.desktop-landscape:not(.classic-mode) #gold-zone::after {
		content: '\1FA99  ' attr(data-coin-text);
		display: block;
		font-size: 1.2rem;
		font-weight: 800;
		color: #333;
		margin-top: 2px;
		white-space: nowrap;
		max-width: 100%;
		overflow: hidden;
		text-overflow: ellipsis;
		font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", "Helvetica Neue", Arial, sans-serif, "Segoe UI Emoji", "Apple Color Emoji", "Noto Color Emoji";
	  }
	  body.desktop-landscape:not(.classic-mode) #collected-coins {
		display: none !important;
	  }
	  body.dark-mode.desktop-landscape:not(.classic-mode) #gold-zone::after {
		color: #e5e5e5;
	  }

	  /* Classic mode: keep only the board + coins visible. */
	  body.classic-mode #card-choice-zone,
	  body.classic-mode #bonus-zone,
	  body.classic-mode #scoreboard,
	  body.classic-mode #objective-zone,
	  body.classic-mode #mobile-objective-banner,
	  body.classic-mode #buy-placement-container,
	  body.classic-mode #bottom-bar {
		display: none !important;
	  }

	  /* Classic mode: hide coins + zone info + theme toggle; only board + hamburger remain. */
	  body.classic-mode #original-coins-zone,
	  body.classic-mode #gold-zone,
	  body.classic-mode #collected-coins,
	  body.classic-mode #dark-mode-toggle,
	  body.classic-mode .zone-info-btn,
	  body.classic-mode .zone-info-popover {
		display: none !important;
	  }
	  body.classic-mode #board > .column:last-child {
		display: none !important;
	  }

	  /* Classic mode: hide next turn / shop / deck controls everywhere. */
	  body.classic-mode #card-action-buttons,
	  body.classic-mode #new-cards-btn,
	  body.classic-mode #bonus-shop-btn,
	  body.classic-mode #deck-preview {
		display: none !important;
	  }
	  body.classic-mode #gold-zone::after {
		content: none !important;
	  }
	  /* Classic mode: show max 20 coin slots. */
	  body.classic-mode #collected-coins .coin:nth-child(n+21) {
		display: none !important;
	  }

	  /* Classic mode: hamburger menu shows only essentials. */
	  body.classic-mode #controls button:not(#classic-mode-toggle):not(#print-btn) {
		display: none !important;
	  }

	  /* Classic mode: keep coins visible even on mobile layout. */
	  body.classic-mode #gold-zone {
		position: fixed;
		top: calc(10px + env(safe-area-inset-top, 0px));
		right: calc(10px + env(safe-area-inset-right, 0px));
		width: auto;
		max-width: 220px;
		z-index: calc(var(--z-ui, 200) + 2);
	  }

	  #gold-zone h2 {
		margin: 0 0 8px 0;
		font-size: 1.1rem;
		font-weight: 600;
		color: #333;
	  }

	  body.dark-mode #gold-zone {
		border: 1px solid #2d2f36 !important;
		box-shadow: 0 4px 10px rgba(0,0,0,0.5) !important;
		background: linear-gradient(145deg, #22252b, #1a1c21) !important;
		color: #e5e5e5;
	  }

	  body.dark-mode #gold-zone h2 {
		color: #e5e5e5;
	  }

	  #bonus-zone {
		width: 100%;
		padding: 10px;
		border-radius: 10px;
		border: 1px solid #e3e6ea;
		box-shadow: 0 2px 6px rgba(0,0,0,0.12);
		margin: 0;
		background: #fffbea;
		text-align: left;
	  }

	  #bonus-zone h2 {
		margin: 0 0 8px 0;
		font-size: 1.1rem;
		font-weight: 600;
		color: #333;
		display: block;
		color: #333;
	  }

	  #bonus-zone .bonus-hint {
		display: none;
	  }

	  body.dark-mode #bonus-zone {
		border: 1px solid #2d2f36;
		box-shadow: 0 4px 10px rgba(0,0,0,0.5);
		background: linear-gradient(145deg, #22252b, #1a1c21);
		color: #e5e5e5;
	  }

	  body.dark-mode #bonus-zone h2 {
		color: #e5e5e5;
	  }

	  body.dark-mode #bonus-zone h2 {
		color: #e5e5e5;
	  }

	  /* Desktop bottom columns spacing */
	  #desktop-bottom-left,
	  #desktop-bottom-right {
		display: flex;
		flex-direction: column;
		gap: 12px;
	  }

	  #desktop-bottom-center {
		display: flex;
		justify-content: center;
		align-items: flex-start;
	  }

	  /* Trap summary verbergen tot level 5 op desktop */
	  .trap-summary {
		display: none;
	  }
	  
	  body[data-traps-active="true"] .trap-summary {
		display: block;
	  }

	  /* ============================================
	     MOBIEL UI VERBERGEN OP DESKTOP
	     ============================================
	     Bottom-bar en gerelateerde elementen zijn alleen voor mobiel
	  */
	  #bottom-bar,
	  #bottom-bar-cards,
	  .bottom-bar-footer,
	  #bottom-bar-score,
	  #bottom-bar-coins,
	  #mobile-objective-banner {
		display: none !important;
	  }

	  /* Hamburger menu: fixed overlay so it doesn't take vertical space. */
	  #menu-toggle {
		display: flex;
		position: fixed;
		left: 12px;
		top: 12px;
		z-index: var(--z-menu);
		pointer-events: auto;
		align-items: center;
		justify-content: center;
		flex-direction: column;
		gap: 5px;
		width: 44px;
		height: 44px;
		padding: 10px;
		border-radius: 12px;
		background: linear-gradient(145deg, #ffd560, #ffb23c);
		border: 1px solid rgba(255,255,255,0.35);
		box-shadow: 0 8px 16px rgba(0,0,0,0.28);
		cursor: pointer;
		transition: transform 0.2s ease, box-shadow 0.2s ease;
	  }
	  #menu-toggle span {
		width: 20px;
		height: 2px;
		background: #1c1c1c;
		border-radius: 2px;
		transition: all 0.3s ease;
		display: block;
	  }
	  #menu-toggle.active span:nth-child(1) { transform: translateY(6px) rotate(45deg); }
	  #menu-toggle.active span:nth-child(2) { opacity: 0; }
	  #menu-toggle.active span:nth-child(3) { transform: translateY(-6px) rotate(-45deg); }
	  body.dark-mode #menu-toggle {
		background: linear-gradient(145deg, #2f3546, #1c2233);
		border-color: rgba(255,255,255,0.12);
	  }
	  body.dark-mode #menu-toggle span {
		background: rgba(255,255,255,0.88);
	  }

	  /* Legacy desktop toggle (unused): keep hidden so only #menu-toggle is visible. */
	  #desktop-menu-toggle {
		display: none !important;
	  }

	  /* Dark mode toggle is accessible via the hamburger menu; hide the standalone top-right button. */
	  #dark-mode-toggle {
		display: none !important;
	  }

	  /* Desktop request: remove rotate/mirror buttons from the UI. */
	  #rotate-card-btn,
	  #mirror-card-btn {
		display: none !important;
	  }

	  /* ============================================
	     CONTROLS MENU (DESKTOP)
	     ============================================
	     Op desktop zijn controls altijd zichtbaar in de layout
	  */

	  body.dark-mode #controls {
		background: #2d2f36;
		color: #eee;
		box-shadow: 0 4px 16px rgba(0,0,0,0.4);
		border-color: #4a4c54;
	  }

	  #controls button {
		background: #ffffff;
		border: 1px solid #ddd;
		color: #222;
		padding: 10px 14px;
		border-radius: 8px;
		cursor: pointer;
		transition: all 0.2s ease;
		font-size: 0.9rem;
		width: 100%;
		text-align: left;
	  }

	  #controls button:hover {
		background: #f0f0f0;
		transform: translateY(-1px);
	  }

	  body.dark-mode #controls button {
		background: #3a3c44;
		border-color: #4a4c54;
		color: #eee;
	  }

	  body.dark-mode #controls button:hover {
		background: #454750;
	  }

	#controls #debug-mode-toggle {
		display: inline-flex;
		align-items: center;
		gap: 10px;
		font-weight: 600;
	}

	#controls #debug-mode-toggle.debug-active {
		background: linear-gradient(145deg, #d8f3ff, #b6e2ff);
		border-color: #6fbef3;
		color: #0d3c60;
	}

	body.dark-mode #controls #debug-mode-toggle.debug-active {
		background: linear-gradient(145deg, #17435f, #1f587c);
		border-color: #39a1d9;
		color: #e4f6ff;
	}

	  body.dark-mode #controls button {
		background: #333;
		color: #eee;
		border-color: #555;
	  }

	  #controls button:hover:not(:disabled) {
		background: #f0f0f0;
	  }

	  body.dark-mode #controls button:hover:not(:disabled) {
		background: #444;
	  }

	  /* ============================================
	     KAART KEUZE ZONE (DESKTOP)
	     ============================================
	     Drijvende zone met 3 kaart opties
	     Altijd zichtbaar op vaste positie rechtsonder
	  */
	  #card-choice-zone {
		background: #fffbea;
		border-radius: 10px;
		color: #333;
		font-family: "Segoe UI", sans-serif;
		width: 100%;
		box-shadow: 0 2px 6px rgba(0,0,0,0.12);
		border: 1px solid #e3e6ea;
		margin: 0;
		padding: 10px;
		text-align: left;
	  }

	  #card-choice-zone h2 {
		margin: 0 0 8px 0;
		color: #333;
		font-size: 1.1rem;
		font-weight: 600;
		color: #333;
	  }

	  body.dark-mode #card-choice-zone {
		background: linear-gradient(145deg, #22252b, #1a1c21);
		border: 1px solid #2d2f36;
		box-shadow: 0 4px 10px rgba(0,0,0,0.5);
		color: #e5e5e5;
	  }

	  body.dark-mode #card-choice-zone h2 {
		color: #e5e5e5;
	  }

	  #kiesKaartTitel {
		display: block;
	  }

	  /* Container voor de 3 kaart opties */
	  #card-options {
		display: flex;
		flex-wrap: nowrap;
		gap: 8px;
		justify-content: center;
		align-items: flex-start;
		margin: 14px auto 18px;
	  }

	  /* Individuele kaart in keuze menu (desktop heeft meer ruimte) */
	  #card-choice-zone .card-option {
		display: flex;
		flex-direction: column;
		align-items: center;
		gap: 4px;
		width: auto;
		min-width: 120px;
		min-height: 180px;
		flex: 1 1 0;
		padding: 12px 8px;
		border-radius: 12px;
		background: linear-gradient(165deg, #ffffff 0%, #eef2ff 45%, #dfe4ff 100%);
		border: 1px solid rgba(40,55,120,0.18);
		box-shadow: 0 8px 16px rgba(10,12,20,0.15);
		transition: transform 0.2s, box-shadow 0.2s;
	  }

	  body.dark-mode #card-choice-zone .card-option {
		background: linear-gradient(160deg, #2d3142 0%, #232635 45%, #1b1e2c 100%);
		border: 1px solid rgba(120,140,220,0.2);
		box-shadow: 0 8px 20px rgba(0,0,0,0.4);
	  }

	  #card-choice-zone .card-option:hover {
		transform: scale(1.05);
		box-shadow: 0 0 10px rgba(0,0,0,0.25);
	  }

	  body.dark-mode #card-choice-zone .card-option:hover {
		box-shadow: 0 0 14px rgba(0,0,0,0.5);
	  }

	  #card-choice-zone .card-option.selected {
		outline: 3px solid #3a6ff7;
		border-color: #3a6ff7;
	  }

	  body.dark-mode #card-choice-zone .card-option.selected {
		outline: 3px solid #5a8fff;
		border-color: #5a8fff;
	  }

	  /* Positionering reset voor desktop (geen absolute positioning) */
	  #card-choice-zone .card-option::after {
		display: none;
	  }

	  #card-choice-zone .card-option > * {
		position: static;
	  }

	  /* Labels en metadata zichtbaar op desktop */
	  #card-choice-zone .card-label {
		display: inline-flex;
		margin-top: 8px;
	  }

	  #card-choice-zone .card-meta {
		display: block;
		margin-top: 4px;
	  }

	  /* Kaart patroon (grid met cellen) */
	  #card-choice-zone .card-pattern {
		display: grid;
		gap: var(--preview-gap);
		align-items: center;
		justify-items: center;
	  }

	  #card-choice-zone .card-option .card-cell {
		width: 20px;
		height: 20px;
		border-radius: 3px;
		border: none;
		box-shadow: none;
	  }

	  /* "Nieuwe kaarten" knop (desktop styling) */
	  #new-cards-btn {
		display: inline-flex;
		align-items: center;
		justify-content: flex-start;
		gap: 8px;
		margin: 0 auto;
		padding: 8px 12px;
		border-radius: 8px;
		border: 1px solid #999;
		background: #fafafa;
		color: #222;
		font-weight: 600;
		text-transform: none;
		letter-spacing: normal;
		cursor: pointer;
		transition: background 0.2s ease, transform 0.2s ease;
		position: relative;
	  }

	  #new-cards-btn::before {
		content: 'â†’';
		color: #4a5268;
		font-size: 1.8rem;
		font-weight: 700;
		position: relative;
		top: 0;
		left: 0;
		transform: none;
		transition: color 0.3s ease;
		line-height: 1;
	  }

	  #new-cards-btn.ready-for-next-turn {
		background: linear-gradient(155deg, #fef8e7 0%, #f0c149 100%);
		border-color: rgba(20,24,36,0.14);
	  }

	  #new-cards-btn.ready-for-next-turn::before {
		color: #5a4a1e;
	  }

	  #new-cards-btn:disabled::before {
		color: rgba(74,82,104,0.6);
	  }

	  #new-cards-btn.complete-round {
		background: linear-gradient(155deg, #e8f5e9 0%, #66bb6a 100%);
		border-color: rgba(46,125,50,0.3);
	  }

	  #new-cards-btn.complete-round::before {
		content: 'âœ“';
		color: #1b5e20;
		font-size: 2rem;
		font-weight: 900;
	  }

	  body.dark-mode #new-cards-btn {
		background: linear-gradient(145deg, #22252b, #1a1c21);
		border: 1px solid #2d2f36;
		box-shadow: 0 6px 14px rgba(0,0,0,0.45);
		color: #e5e5e5;
	  }

	  body.dark-mode #new-cards-btn::before {
		color: rgba(255,255,255,0.75);
	  }

	  body.dark-mode #new-cards-btn.ready-for-next-turn {
		background: linear-gradient(155deg, #ffd560 0%, #ffb23c 100%);
		border-color: rgba(255,255,255,0.35);
	  }

	  body.dark-mode #new-cards-btn.ready-for-next-turn::before {
		color: #1c1c1c;
	  }

	  body.dark-mode #new-cards-btn:disabled::before {
		color: rgba(245,246,255,0.6);
	  }

	  body.dark-mode #new-cards-btn.complete-round {
		background: linear-gradient(155deg, #2e7d32 0%, #1b5e20 100%);
		border-color: rgba(129,199,132,0.3);
	  }

	  body.dark-mode #new-cards-btn.complete-round::before {
		color: #a5d6a7;
	  }

	  #new-cards-btn:hover {
		background: #f0f0f0;
		transform: translateY(-2px);
	  }

	  body.dark-mode #new-cards-btn:hover {
		background: linear-gradient(150deg, #2a2d35, #1f2230);
		border-color: #373a42;
		box-shadow: 0 8px 18px rgba(0,0,0,0.5);
	  }

	  /* Compacte kaarten bij weinig ruimte - verberg labels en meta */
	  @media (min-width: 651px) and (max-width: 1100px) {
		#card-choice-zone .card-label,
		#card-choice-zone .card-meta {
		  display: none;
		}
		
		#card-choice-zone .card-option {
		  min-width: 80px;
		  min-height: 140px;
		  padding: 8px 4px;
		}
		
		#card-choice-zone .card-option .card-cell {
		  width: 18px;
		  height: 18px;
		}

		/* Knoppen worden icoon-only */
		#new-cards-btn,
		#rotate-card-btn {
		  width: 44px;
		  height: 44px;
		  padding: 0;
		  font-size: 0;
		  justify-content: center;
		}

		#new-cards-btn::before,
		#rotate-card-btn::before {
		  font-size: 1.8rem;
		  position: absolute;
		  top: 50%;
		  left: 50%;
		  transform: translate(-50%, -50%);
		}

		#rotate-card-btn {
		  margin-top: 8px;
		}

		/* Deck-count compacter maken */
		.deck-count {
		  height: 44px;
		  min-width: 44px;
		  padding: 6px 8px;
		  font-size: 0.95rem;
		}

		/* Deck preview tekst verbergen, alleen icoon en getal */
		.deck-preview {
		  padding: 6px 8px;
		  min-height: 44px;
		  width: auto;
		  gap: 4px;
		}

		.deck-preview::after {
		  display: none;
		}

		/* Turn counter styling - naast buttons */
		#turn-counter-inline {
		  text-align: left;
		  font-size: 0.9rem;
		  padding-left: 8px;
		}

		/* "Beurt" tekst verwijderen */
		#turn-counter-inline::before {
		  content: '';
		}

		/* Objective zone aanpassingen voor smaller schermen */
		#objective-zone {
		  width: 85%;
		  max-width: 900px;
		  padding: 8px 12px;
		}

		/* Zijkolommen kunnen krimpen */
		#desktop-bottom-left,
		#desktop-bottom-right {
		  width: auto;
		  min-width: 280px;
		  max-width: 360px;
		  flex-shrink: 1;
		}

		/* Desktop wrapper minder padding */
		#desktop-wrapper {
		  padding: 8px;
		  gap: 12px;
		}
	  }

	  /* Extra aanpassingen voor zeer smalle desktop schermen */
	  @media (min-width: 651px) and (max-width: 850px) {
		#objective-zone {
		  width: 92%;
		  max-width: 700px;
		  padding: 8px 12px;
		  font-size: 0.9rem;
		}

		#objective-zone h2 {
		  font-size: 0.9rem;
		}

		#objective-current {
		  font-size: 0.85rem;
		}

		#desktop-wrapper {
		  padding: 8px;
		  gap: 10px;
		}

		#desktop-bottom-left,
		#desktop-bottom-right {
		  min-width: 240px;
		  max-width: 320px;
		}

		#desktop-bottom {
		  gap: 8px;
		}
	  }

	  /* Narrow portrait desktop (651-900px): tighter layout to fit all elements */
	  @media (min-width: 651px) and (max-width: 900px) {
		body.desktop-portrait #desktop-bottom {
		  gap: 8px;
		  padding: 0 8px;
		}

		body.desktop-portrait #desktop-bottom-left {
		  flex: 0 1 180px;
		  min-width: 130px;
		  max-width: 200px;
		}

		body.desktop-portrait #desktop-bottom-center {
		  flex: 1 1 340px;
		  min-width: 240px;
		  max-width: 480px;
		}

		body.desktop-portrait #desktop-bottom-right {
		  flex: 0 1 160px;
		  min-width: 120px;
		  max-width: 200px;
		}

		/* Compact scoreboard for narrow widths */
		body.desktop-portrait #scoreboard {
		  max-width: 190px;
		  padding: 4px 5px;
		  font-size: 0.8rem;
		}

		body.desktop-portrait #scoreboard .score-row {
		  padding: 1px 3px;
		  font-size: 0.75rem;
		}

		body.desktop-portrait #scoreboard .score-total {
		  padding: 3px 5px;
		  font-size: 0.78rem;
		}

		body.desktop-portrait #gold-zone {
		  padding: 2px 6px;
		  font-size: 0.85rem;
		}

		body.desktop-portrait .bonus-badge {
		  padding: 4px 6px;
		  font-size: 0.68rem;
		}
	  }

	  #rotate-card-btn {
		display: inline-flex;
		align-items: center;
		justify-content: flex-start;
		gap: 8px;
		margin: 6px auto 0;
		padding: 8px 14px;
		border-radius: 8px;
		border: 1px solid #9aa1b1;
		background: #e9edf7;
		color: #1f2532;
		font-weight: 600;
		text-transform: none;
		letter-spacing: 0.01em;
		cursor: pointer;
		transition: background 0.2s ease, transform 0.2s ease, opacity 0.2s ease;
		position: relative;
	  }

	  #rotate-card-btn::before {
		content: 'â†»';
		color: #4a5268;
		font-size: 1.6rem;
		position: relative;
		top: 0;
		left: 0;
		transform: none;
		line-height: 1;
	  }

	  body.dark-mode #rotate-card-btn {
		background: linear-gradient(145deg, #22252b, #1a1c21);
		border: 1px solid #2d2f36;
		box-shadow: 0 6px 14px rgba(0,0,0,0.45);
		color: #e5e5e5;
	  }

	  body.dark-mode #rotate-card-btn::before {
		color: rgba(255,255,255,0.75);
	  }

	  #rotate-card-btn:hover:not(:disabled) {
		background: #dbe2f2;
		transform: translateY(-1px);
	  }

	  body.dark-mode #rotate-card-btn:hover:not(:disabled) {
		background: linear-gradient(150deg, #2a2d35, #1f2230);
		border-color: #373a42;
		box-shadow: 0 8px 18px rgba(0,0,0,0.5);
	  }

	  #rotate-card-btn:disabled {
		opacity: 0.55;
		cursor: not-allowed;
		transform: none;
	  }

	  #scoreboard {
		background: #fffbea;
		border-radius: 10px;
		padding: 6px;
		color: #333;
		width: 100%;
		box-shadow: 0 2px 6px rgba(0,0,0,0.12);
		border: 1px solid #e3e6ea;
		margin: 0;
	  }

	  #scoreboard h2 {
		margin: 0 0 3px 0;
		font-size: 0.95rem;
	  }

	  #scoreboard .score-row {
		padding: 2px 6px;
		margin-bottom: 1px;
		font-size: 0.85rem;
	  }

	  #scoreboard hr {
		margin: 2px 0;
	  }

	  body.dark-mode #scoreboard {
		background: linear-gradient(145deg, #22252b, #1a1c21);
		border: 1px solid #2d2f36;
		box-shadow: 0 4px 10px rgba(0,0,0,0.5);
		color: #e5e5e5;
	  }

	  #scoreboard h2,
	  #scoreboard hr {
		display: block;
	  }

	  body.dark-mode #scoreboard h2 {
		color: #e5e5e5;
	  }

	  body.dark-mode #scoreboard hr {
		border-color: #3d4048;
	  }

	  #scoreboard .score-row {
		background: #f5f0e4;
		padding: 3px 6px;
		margin-bottom: 2px;
		border-radius: 5px;
		color: #333;
		transition: transform 0.1s ease, background 0.3s;
	  }

	  body.dark-mode #scoreboard .score-row {
		background: #2a2d35;
		color: #e5e5e5;
	  }

	  #scoreboard .score-row:hover {
		transform: scale(1.02);
		background: #ebe4d4;
		color: #222;
	  }

	  body.dark-mode #scoreboard .score-row:hover {
		background: #32353d;
	  }

	  #scoreboard .score-row .label {
		display: inline;
		font-size: 0.8rem;
	  }

	  #scoreboard .score-row .color-box {
		width: 10px;
		height: 10px;
		border-radius: 2px;
	  }

	  #scoreboard .score-total {
		font-size: 0.9rem;
		margin-top: 3px;
		padding: 4px 8px;
		background: #f0ead8;
		border-radius: 6px;
		border: 1px solid #d9d0bd;
		color: #333;
		font-weight: 600;
	  }

	  body.dark-mode #scoreboard .score-total {
		background: #2f3239;
		border-color: #3d4048;
		color: #e5e5e5;
	  }

	#objective-zone {
		display: flex;
		flex-direction: column;
		gap: 8px;
		background: #fffbea;
		border: 1px solid #e3e6ea;
		box-shadow: 0 2px 6px rgba(0,0,0,0.12);
		position: relative;
		z-index: var(--z-zoom);
		text-align: left;
		justify-content: flex-start;
	}

	  #mobile-objective-banner {
		display: none;
	  }

	  body.dark-mode #objective-zone {
		background: linear-gradient(145deg, #22252b, #1a1c21);
		border: 1px solid #2d2f36;
		box-shadow: 0 4px 10px rgba(0,0,0,0.5);
		color: #e5e5e5;
	  }

	  #objective-zone h2 {
		margin-bottom: 4px;
	  }

	  .objective-current {
		font-size: 0.92rem;
		font-weight: 600;
		line-height: 1.35;
	  }

	  .objective-history {
		list-style: none;
		margin: 0;
		padding: 0;
		display: flex;
		flex-direction: column;
		gap: 6px;
		font-size: 0.78rem;
		color: rgba(20,24,36,0.6);
	  }

	  body.dark-mode .objective-history {
		color: rgba(255,255,255,0.6);
	  }

	  .objective-history li {
		display: flex;
		align-items: center;
		gap: 6px;
	  }

	  .objective-history li::before {
		content: "âœ”";
		font-size: 0.8rem;
		color: #2c9a4b;
	  }

	  body.dark-mode .objective-history li::before {
		color: #7fe48e;
	  }

	  .objective-empty-state {
		font-size: 0.76rem;
		color: rgba(20,24,36,0.6);
	  }

	  body.dark-mode .objective-empty-state {
		color: rgba(255,255,255,0.55);
	  }

	  #bonus-zone,
	  #original-bonus-zone .zone {
		display: flex;
		flex-direction: column;
		gap: 10px;
		background: #fffbea;
		border: 1px solid #e3e6ea;
		box-shadow: 0 2px 6px rgba(0,0,0,0.12);
		text-align: left;
	  }

	  /* Desktop Dark Mode voor Bonus Zone - mooie gradient zoals objective-zone */
	  body.dark-mode #bonus-zone,
	  body.dark-mode #original-bonus-zone .zone {
		background: linear-gradient(145deg, #22252b, #1a1c21);
		border: 1px solid #2d2f36;
		box-shadow: 0 4px 10px rgba(0,0,0,0.5);
		color: #e5e5e5;
	  }

	  #bonus-zone h2,
	  #original-bonus-zone .zone h2 {
		margin: 0;
	  }

	  body.dark-mode #bonus-zone h2,
	  body.dark-mode #original-bonus-zone .zone h2 {
		color: #e4e8ff;
	  }

	  .bonus-inventory {
		display: flex;
		flex-wrap: wrap;
		gap: 8px;
	  }

	  /* Bonus badge styling wordt nu volledig afgehandeld door de globale :is(#bonus-zone, #bottom-bar-bonus) .bonus-badge sectie */

	  #bottom-bar-score,
	  #bottom-bar-bonus,
	  #bottom-bar-coins {
		flex: 1 1 0;
	  }

	  .symbol.bonus-used {
		opacity: 0.25;
		filter: grayscale(0.4);
	  }

	  /* Note: Volledige dark mode styling voor desktop zones staat verderop 
	     in de dedicated DESKTOP DARK MODE secties na de #gold-zone styling */
	}

#original-coins-zone:empty,
	#original-score-zone:empty,
	#original-objective-zone:empty,
	#original-card-zone:empty,
	#original-controls-zone:empty,
	#gold-zone:empty,
	#scoreboard:empty,
	#card-choice-zone:empty,
	#controls-zone:empty {
	  display: none;
	}

	/* Extra mobile finetuning for smaller screens */
	@media (max-width: 520px) {
	  #bottom-bar-bonus .bonus-inventory {
		gap: 8px;
	  }

	  #bottom-bar-bonus .bonus-badge {
		padding: 5px 10px;
		font-size: 0.7rem;
	  }

	  #bottom-bar-bonus .bonus-swatch {
		width: 12px;
		height: 12px;
	  }

	  #bottom-bar-bonus .bonus-count {
		font-size: 0.68rem;
		padding: 2px 6px;
	  }
	}

	@media (max-width: 400px) {
	  #bottom-bar-bonus .bonus-inventory {
		gap: 6px;
	  }

	  #bottom-bar-bonus .bonus-badge {
		padding: 4px 8px;
		font-size: 0.66rem;
	  }

	  #bottom-bar-bonus .bonus-swatch {
		width: 10px;
		height: 10px;
	  }

	  #bottom-bar-bonus .bonus-count {
		font-size: 0.64rem;
		padding: 1px 5px;
	  }
	}

	/* print */
	@media print {
	  body {
		background: white;
		margin: 0;
		-webkit-print-color-adjust: exact;
		print-color-adjust: exact;
	  }
	  * {
		-webkit-print-color-adjust: exact;
		print-color-adjust: exact;
	  }
	  .zone { page-break-inside: avoid; }
	  .layout { display: block; }

	  /* Print must contain only the board (and keep hamburger if present). */
	  #dark-mode-toggle,
	  .blur-overlay,
	  #drag-overlay,
	  #floating-preview,
	  #placement-zoom-lens,
	  #mobile-objective-banner,
	  #bottom-bar,
	  #card-choice-zone,
	  #bonus-zone,
	  #scoreboard,
	  #objective-zone,
	  #original-coins-zone,
	  #gold-zone,
	  #collected-coins,
	  #buy-placement-container,
	  #controls,
	  #round-modal-layer,
	  #shop-modal-layer,
	  #upgrade-modal-layer,
	  #deck-modal-layer,
	  #golden-unlock-layer,
	  #blackhole-modal-layer,
	  .objective-toast,
	  .zone-nav-arrow,
	  .zone-info-btn,
	  .zone-info-popover,
	  .zone-delete,
	  .trash-btn {
		display: none !important;
	  }

	  #board {
		display: flex !important;
		position: static !important;
		left: 0 !important;
		top: 0 !important;
		margin: 0 !important;
		transform: none !important;
	  }

	  /* Ensure print contains full grids, not only the visible part of scroll containers. */
	  #yellow-zone,
	  #green-zone,
	  #red-zone,
	  #purple-zone,
	  #blue-zone {
		overflow: visible !important;
		height: auto !important;
		max-height: none !important;
	  }
	  #yellow-grid,
	  #green-grid,
	  #purple-grid,
	  #blue-grid,
	  #red-zone .grid {
		overflow: visible !important;
		max-height: none !important;
	  }
	  .board {
		transform: none !important;
		max-height: none !important;
	  }
	  #board > .column:last-child {
		display: none !important;
	  }
	  #menu-toggle {
		display: inline-flex !important;
	  }
    }

	/*
		EN:
		- FIX: Some desktop "sub-breakpoint" rules are written as nested @media blocks inside
		  `@media (min-width: 651px) { ... }`. CSS nesting support varies by browser.
		- To make behavior consistent, we also include top-level versions of those @media queries here.
		- DUPLICATE: These mirror the nested blocks; keep them in sync if you edit one.
	*/
	@media (min-width: 651px) and (max-width: 1100px) {
		#card-choice-zone .card-label,
		#card-choice-zone .card-meta {
			display: none;
		}

		#card-choice-zone .card-option {
			min-width: 80px;
			min-height: 140px;
			padding: 8px 4px;
		}

		#card-choice-zone .card-option .card-cell {
			width: 18px;
			height: 18px;
		}

		#new-cards-btn,
		#rotate-card-btn {
			width: 44px;
			height: 44px;
			padding: 0;
			font-size: 0;
			justify-content: center;
		}

		#new-cards-btn::before,
		#rotate-card-btn::before {
			font-size: 1.8rem;
			position: absolute;
			top: 50%;
			left: 50%;
			transform: translate(-50%, -50%);
		}

		#rotate-card-btn {
			margin-top: 8px;
		}

		.deck-count {
			height: 44px;
			min-width: 44px;
			padding: 6px 8px;
			font-size: 0.95rem;
		}

		.deck-preview {
			padding: 6px 8px;
			min-height: 44px;
			width: auto;
			gap: 4px;
		}

		.deck-preview::after {
			display: none;
		}

		#turn-counter-inline {
			text-align: left;
			font-size: 0.9rem;
			padding-left: 8px;
		}

		#turn-counter-inline::before {
			content: '';
		}

		#objective-zone {
			width: 85%;
			max-width: 900px;
			padding: 8px 12px;
		}

		#desktop-bottom-left,
		#desktop-bottom-right {
			width: auto;
			min-width: 280px;
			max-width: 360px;
			flex-shrink: 1;
		}

		#desktop-wrapper {
			padding: 8px;
			gap: 12px;
		}
	}

	@media (min-width: 651px) and (max-width: 850px) {
		#objective-zone {
			width: 92%;
			max-width: 700px;
			padding: 8px 12px;
			font-size: 0.9rem;
		}

		#objective-zone h2 {
			font-size: 0.9rem;
		}

		#objective-current {
			font-size: 0.85rem;
		}

		#desktop-wrapper {
			padding: 8px;
			gap: 10px;
		}

		#desktop-bottom-left,
		#desktop-bottom-right {
			min-width: 240px;
			max-width: 320px;
		}

		#desktop-bottom {
			gap: 8px;
		}
	}

	@media (min-width: 651px) and (max-width: 900px) {
		body.desktop-portrait #desktop-bottom {
			gap: 8px;
			padding: 0 8px;
		}

		body.desktop-portrait #desktop-bottom-left {
			flex: 0 1 180px;
			min-width: 130px;
			max-width: 200px;
		}

		body.desktop-portrait #desktop-bottom-center {
			flex: 1 1 340px;
			min-width: 240px;
			max-width: 480px;
		}

		body.desktop-portrait #desktop-bottom-right {
			flex: 0 1 160px;
			min-width: 120px;
			max-width: 200px;
		}

		body.desktop-portrait #scoreboard {
			max-width: 190px;
			padding: 4px 5px;
			font-size: 0.8rem;
		}

		body.desktop-portrait #scoreboard .score-row {
			padding: 1px 3px;
			font-size: 0.75rem;
		}

		body.desktop-portrait #scoreboard .score-total {
			padding: 3px 5px;
			font-size: 0.78rem;
		}

		body.desktop-portrait #gold-zone {
			padding: 2px 6px;
			font-size: 0.85rem;
		}

		body.desktop-portrait .bonus-badge {
			padding: 4px 6px;
			font-size: 0.68rem;
		}
	}

	/* === Mobile zoom: make zoomed zones uniform (user request) === */
	@media (max-width: 650px) {
		body.zoomed-in #yellow-zone.zoom-focus,
		body.zoomed-in #green-zone.zoom-focus,
		body.zoomed-in #blue-zone.zoom-focus,
		body.zoomed-in #purple-zone.zoom-focus,
		body.zoomed-in #red-zone.zoom-focus {
			position: fixed !important;
			left: 0 !important;
			right: 0 !important;
			width: 100vw !important;
			max-width: 100vw !important;
			min-height: var(--mobile-zoom-height, 57svh) !important;
			max-height: var(--mobile-zoom-height, 57svh) !important;
			min-width: 0 !important;
			margin: 0 !important;

			/* Center position matches existing yellow-ish placement; JS clamps to avoid objective/bottom-bar overlap. */
			top: var(--mobile-zoom-center, calc(25% + 30px)) !important;
			height: var(--mobile-zoom-height, 57svh) !important;
			transform: translateY(-50%) !important;
			z-index: var(--z-zoom) !important;
			box-shadow: 0 0 30px rgba(0, 0, 0, 0.5);
		}

		/* If there is extra vertical room in zoom, center the small square grids (like Purple in the screenshot). */
		body.zoomed-in #yellow-zone.zoom-focus,
		body.zoomed-in #purple-zone.zoom-focus {
			justify-content: center !important;
		}
		/* Green zoom: let JS handle scroll-centering to the start cell; don't use align-items which moves the grid. */
		body.zoomed-in #green-zone.zoom-focus {
			align-items: flex-start !important;
			justify-content: flex-start !important;
		}

		/* Red zone: center the 2Ã—2 subgrids vertically within the fixed zoom container. */
		body.zoomed-in #red-zone.zoom-focus.red-group {
			display: grid !important;
			grid-template-columns: repeat(2, max-content) !important;
			justify-content: center !important;
			gap: 18px !important;
			align-content: center !important;
		}

		/* Red zone: ignore legacy min-height so it matches other zoomed zones. */
		body.zoomed-in #red-zone.zoom-focus {
			min-height: 0 !important;
			max-width: 100vw !important;
		}

		/* Keep green/blue scrollable while zoomed. */
		body.zoomed-in #green-zone.zoom-focus,
		body.zoomed-in #blue-zone.zoom-focus {
			overflow: auto !important;
			-webkit-overflow-scrolling: touch;
		}

		/* Red can be bigger than the viewport; allow scrolling in the fixed-height zoom container. */
		body.zoomed-in #red-zone.zoom-focus {
			overflow: auto !important;
			-webkit-overflow-scrolling: touch;
		}
	}

  </style>
  <script>
    // Simple menu toggle: toggles .open on #controls and .active on #menu-toggle
    document.addEventListener('DOMContentLoaded', function() {
        const menuToggle = document.getElementById('menu-toggle');
        const controls = document.getElementById('controls');
		const classicToggle = document.getElementById('classic-mode-toggle');

        if (!menuToggle || !controls) return;

        // ensure initial state: closed
        menuToggle.classList.remove('active');
        controls.classList.remove('open');

        // click toggles open state
        menuToggle.addEventListener('click', function(e) {
            e.stopPropagation();
            const opened = menuToggle.classList.toggle('active');
            if (opened) controls.classList.add('open'); else controls.classList.remove('open');
        });

        // clicking outside closes the menu
        document.addEventListener('click', function(event) {
            if (!menuToggle.contains(event.target) && !controls.contains(event.target)) {
                menuToggle.classList.remove('active');
                controls.classList.remove('open');
            }
        });

		// Classic mode toggle (persisted)
		const CLASSIC_MODE_KEY = 'locusClassicMode';
		const applyClassicModeUi = (enabled) => {
			document.body.classList.toggle('classic-mode', !!enabled);
			if (classicToggle) {
				classicToggle.setAttribute('aria-pressed', enabled ? 'true' : 'false');
				classicToggle.textContent = enabled ? 'Klassieke versie: aan' : 'Klassieke versie: uit';
			}
			// Mobile classic mode should run in landscape when the browser allows it.
			try {
				if (enabled && window.innerWidth <= (typeof MOBILE_BREAKPOINT !== 'undefined' ? MOBILE_BREAKPOINT : 650)) {
					if (screen && screen.orientation && typeof screen.orientation.lock === 'function') {
						screen.orientation.lock('landscape');
					}
				} else if (!enabled) {
					if (screen && screen.orientation && typeof screen.orientation.unlock === 'function') {
						screen.orientation.unlock();
					}
				}
			} catch (e) {}
			if (typeof updateCoinCounter === 'function') {
				updateCoinCounter();
			}
			if (typeof initialiseCoins === 'function') {
				try { initialiseCoins(enabled ? 20 : 50); } catch {}
			}
			if (typeof moveGameElements === 'function') {
				setTimeout(() => {
					try { moveGameElements(); } catch {}
				}, 0);
			}
		};

		try {
			const saved = localStorage.getItem(CLASSIC_MODE_KEY);
			applyClassicModeUi(saved === '1');
		} catch (e) {
			applyClassicModeUi(false);
		}

		if (classicToggle) {
			classicToggle.addEventListener('click', function(e) {
				e.stopPropagation();
				const enabled = !document.body.classList.contains('classic-mode');
				applyClassicModeUi(enabled);
				try {
					localStorage.setItem(CLASSIC_MODE_KEY, enabled ? '1' : '0');
				} catch (err) {}
				// Keep the menu open so the user can immediately toggle back.
				menuToggle.classList.add('active');
				controls.classList.add('open');
			});
		}
    });
  </script>
</head>

<body>
<div class="blur-overlay"></div>
<div id="drag-overlay"></div>

<!-- Floating preview voor touch-vriendelijke plaatsing -->
<div id="floating-preview">
  <div id="floating-preview-pattern"></div>
  <button id="floating-preview-rotate" title="Draai blok (tap of R)">â†»</button>
  <button id="floating-preview-mirror" title="Spiegel blok (tap of M)">â‡„</button>
  <button id="floating-preview-cancel" title="Annuleer selectie">Ã—</button>
</div>

<!-- Zoom-lens voor plaatsing preview (linksboven touch punt) -->
<div id="placement-zoom-lens" style="display: none;">
  <div id="zoom-lens-content"></div>
</div>

  <button id="dark-mode-toggle" title="Schakel donker/licht thema">ðŸŒ™</button>
	<button id="menu-toggle" class="menu-toggle" title="Menu" aria-label="Menu">
    <span></span>
    <span></span>
    <span></span>
  </button>
	<div id="mobile-objective-banner"></div>

	<!-- Mobile Sidebar Layout Container (hidden by default, JS populates for mobile) -->
	<div id="mobile-landscape-wrapper" style="display: none;">
		<div id="ml-sidebar-left"></div>
		<div id="ml-board-center">
			<div id="ml-objective-top" style="display: none;"></div>
		</div>
		<div id="ml-sidebar-right"></div>
	</div>
  
	<div id="board" class="board">
		<!-- Column 1: purple and yellow zones -->
		<div class="column">
		<div class="zone" data-color="paars" id="purple-zone">
			<button class="zone-info-btn" type="button" aria-label="Info: Paars" aria-expanded="false">i</button>
			<div class="zone-info-popover" role="tooltip" aria-hidden="true"></div>
			<div id="purple-grid" class="grid"></div>
		</div>
		<div class="zone" data-color="geel" id="yellow-zone">
			<button class="zone-info-btn" type="button" aria-label="Info: Geel" aria-expanded="false">i</button>
			<div class="zone-info-popover" role="tooltip" aria-hidden="true"></div>
		  <div id="yellow-grid" class="grid"></div>
		</div>
	  </div>
		  <!-- Column 2: green zone on top, red zone below -->
	  <div class="column">
		<div class="zone" data-color="groen" id="green-zone" >
			<button class="zone-info-btn" type="button" aria-label="Info: Groen" aria-expanded="false">i</button>
			<div class="zone-info-popover" role="tooltip" aria-hidden="true"></div>
			<div id="green-grid" class="grid"></div>
		</div>
		<div id="red-zone"  class="zone red-group" data-color="rood">
			<button class="zone-info-btn" type="button" aria-label="Info: Rood" aria-expanded="false">i</button>
			<div class="zone-info-popover" role="tooltip" aria-hidden="true"></div>
		  <div id="red-grid1" data-color="rood" data-zone="red-grid1" class="zone" data-subgrid="1"></div>
		  <div id="red-grid2" data-color="rood" data-zone="red-grid2" class="zone" data-subgrid="2"></div>
		  <div id="red-grid3" data-color="rood" data-zone="red-grid3" class="zone" data-subgrid="3"></div>
		  <div id="red-grid4" data-color="rood" data-zone="red-grid4" class="zone" data-subgrid="4"></div>
		</div>
		<div id="original-card-zone">
		<div class="zone" id="card-choice-zone">
	    <h2 id="kiesKaartTitel">Kies een kaart</h2>
		<br>
		    <div id="card-controls">
		      <div id="card-options"></div>
			  <button id="hand-scroll-left" class="hand-scroll-btn" type="button" aria-label="Scroll kaarten naar links" title="Vorige kaarten">â€¹</button>
			  <button id="hand-scroll-right" class="hand-scroll-btn" type="button" aria-label="Scroll kaarten naar rechts" title="Volgende kaarten">â€º</button>
			  <div id="turn-counter-inline" aria-live="polite">Beurt 1</div>
				<div id="card-action-buttons">
				<button id="new-cards-btn" class="card-action-btn" type="button" data-icon="âžœ" data-label="Volgende hand" aria-label="Volgende hand"></button>
				<button id="rotate-card-btn" class="card-action-btn" type="button" data-icon="âŸ³" data-label="Draai kaart" aria-label="Draai kaart"></button>
				<button id="mirror-card-btn" class="card-action-btn" type="button" data-icon="â‡„" data-label="Spiegel kaart" aria-label="Spiegel kaart"></button>
				<button id="bonus-shop-btn" class="card-action-btn" type="button" data-icon="ðŸª" data-label="Bonuswinkel" aria-label="Open bonuswinkel" style="display: none;"></button>
				<div id="deck-preview" class="deck-preview" role="button" tabindex="0" aria-haspopup="dialog" aria-controls="deck-modal" aria-label="Bekijk het volledige deck" data-label="Deck">
		        <div class="deck-count" data-deck-count="0">0</div>
		        </div>
		      </div>
		    </div>
		</div>
		</div>
	  </div>
	  <!-- Column 3: blue zone (long strip) -->
	  <div class="column">
		  <div class="zone" data-color="blauw" id="blue-zone">
			<button class="zone-info-btn" type="button" aria-label="Info: Blauw" aria-expanded="false">i</button>
			<div class="zone-info-popover" role="tooltip" aria-hidden="true"></div>
			<div id="blue-grid" class="grid"></div>
		  </div>
	  </div>
	   <!-- Column 4: coins, scoreboard, controls -->
	   <div class="column">
			<div id="original-coins-zone">
			<div class="zone" id="gold-zone">
			<h2 id="muntenTitel">Munten</h2>
			<div id="collected-coins"></div>
			<div id="buy-placement-container">
				<button id="buy-placement-btn" class="buy-placement-btn" type="button" title="Koop bonusblok (2 munten)">
					<span class="buy-placement-cost"><span class="coin-icon"></span><span class="coin-icon"></span></span>
					<span class="buy-placement-arrow" aria-hidden="true">â†’</span>
					<span class="buy-placement-rainbow-cell" aria-hidden="true"></span>
				</button>
				<div id="purchased-block-preview" class="purchased-block-preview" style="display: none;">
					<div class="purchased-block-cell"></div>
					<span class="purchased-block-label">Sleep me!</span>
				</div>
			</div>
		  </div>
			</div>
		<div id="original-score-zone">
		<div id="scoreboard" class="zone">
		  <h2>Score</h2>
		  <div class="score-total">
			<span class="label">Totaal</span>
			<span class="total-score" id="total-score">0</span>
		  </div>
		  <hr>
		  <div class="score-row yellow">
			<span class="color-box"></span>
			<span class="label">Geel</span>
			<span class="score" id="yellow-score">0</span>
		  </div>
		  <div class="score-row red">
			<span class="color-box"></span>
			<span class="label">Rood</span>
			<span class="score" id="red-score">0</span>
		  </div>
		  <div class="score-row green">
			<span class="color-box"></span>
			<span class="label">Groen</span>
			<span class="score" id="green-score">0</span>
		  </div>
		  <div class="score-row purple">
			<span class="color-box"></span>
			<span class="label">Paars</span>
			<span class="score" id="purple-score">0</span>
		  </div>
		  <div class="score-row blue">
			<span class="color-box"></span>
			<span class="label">Blauw</span>
			<span class="score" id="blue-score">0</span>
		  </div>
		  <div class="score-row bonus">
			<span class="color-box"></span>
			<span class="label">Bonus</span>
			<span class="score" id="bonus-score">0</span>
		  </div>
		</div>
		</div>
		<div id="original-objective-zone">
		  <div id="objective-zone" class="zone">
			<h2>Doel</h2>
			<div id="objective-current" class="objective-current objective-empty-state">Doelen worden geladenâ€¦</div>
			<ul id="objective-history" class="objective-history"></ul>
		  </div>
		</div>
		<div id="original-bonus-zone">
		  <div class="zone" id="bonus-zone">
			<h2>Bonussen</h2>
			<div id="bonus-inventory" class="bonus-inventory"></div>
			<p class="bonus-hint">Klik op een kleur om een gratis 1Ã—2 blok te plaatsen.</p>
		  </div>
		</div>
		<div class="zone" id="controls">
			<button onclick="undo()">Undo</button>
			<button id="new-game-btn" type="button">Nieuw Spel</button>
			<button id="classic-mode-toggle" type="button" aria-pressed="false">Klassieke versie: uit</button>
			<button id="debug-mode-toggle" type="button" aria-pressed="false">Debug modus: uit</button>
			<button id="print-btn" type="button">Print</button>
			<button id="menu-editor-btn" type="button">ðŸ› ï¸ Editor</button>
			<button id="menu-open-levels-btn" type="button" onclick="showSavedLevelsModal()">Open level</button>
			<button id="mobile-dark-mode-toggle" type="button">ðŸŒ™ Nacht</button>
			<button id="menu-rules-btn" onclick="showRulesModal()">ðŸ“– Spelregels</button>
			<button id="menu-highscore-btn" onclick="showHighScoreModal()">ðŸ† High Score</button>
		</div>
		<div id="original-controls-zone">
		  <div id="original-controls-zone-inner"></div>
		</div>
		<div class="tetris-block" data-shape='[[1,1],[1,1]]' data-color="#f00"></div>
	  </div> 
	</div>
		<!-- Mobile HUD: bottom bar injected via moveGameElements() for <=650px -->
		<div id="bottom-bar">
			<div id="bottom-bar-cards"></div>
			<div class="bottom-bar-footer">
				<div id="bottom-bar-left">
					<div id="bottom-bar-bonus"></div>
					<div id="bottom-bar-score-coins">
						<div id="bottom-bar-score"></div>
						<div id="bottom-bar-coins"></div>
					</div>
				</div>
			</div>
		</div>

		<div id="game-modal-layer" class="modal-overlay">
			<div id="round-modal" class="game-modal" role="dialog" aria-modal="true" aria-labelledby="round-modal-title">
				<h2 id="round-modal-title">Ronde voltooid</h2>
				<p id="round-modal-message">Goed gespeeld! Kies een optie om verder te gaan.</p>
				<div id="round-modal-summary" class="modal-score-summary"></div>
				<div class="modal-actions">
					<button id="round-modal-next">Volgende level</button>
					<button id="round-modal-restart">Opnieuw spelen</button>
				</div>
			</div>
		</div>

		<div id="shop-modal-layer" class="modal-overlay">
			<div id="shop-modal" class="game-modal" role="dialog" aria-modal="true" aria-labelledby="shop-modal-title">
				<div class="shop-modal-header">
					<h2 id="shop-modal-title">Kaarten &amp; Upgrades</h2>
					<button class="modal-close-btn" id="shop-modal-close" aria-label="Sluit winkel">&times;</button>
					<div class="shop-coin-display" id="shop-coin-display">
						<span class="shop-coin-label">Munten</span>
						<span class="shop-coin-balance" id="shop-coin-balance" aria-live="polite" aria-atomic="true">0</span>
					</div>
				</div>
				<p id="shop-modal-message">Besteed je munten aan kaarten, upgrades of bonussen.</p>
				<div class="shop-content-grid">
					<div class="shop-section shop-cards-section">
						<h3 class="shop-section-title">ðŸƒ Kaarten</h3>
						<div id="shop-card-options" class="shop-card-list"></div>
					</div>
					<div class="shop-lower-grid">
						<div class="shop-section shop-upgrades-section">
							<h3 class="shop-section-title">âš™ï¸ Upgrades</h3>
							<div id="shop-upgrade-container" class="shop-upgrade-container"></div>
						</div>
						<div class="shop-section shop-bonus-section">
							<h3 class="shop-section-title">âœ¨ Bonussen</h3>
							<div id="shop-bonus-container" class="shop-bonus-container"></div>
						</div>
						<div class="shop-section shop-freeplace-section">
							<h3 class="shop-section-title">ðŸŽ Extra Plaatsing</h3>
							<div id="shop-freeplace-container" class="shop-freeplace-container"></div>
						</div>
					</div>
				</div>
				<div class="modal-actions">
					<button id="shop-modal-skip">Naar volgend level</button>
				</div>
			</div>
		</div>

		<div id="print-settings-layer" class="modal-overlay" aria-hidden="true">
			<div id="print-settings-modal" class="game-modal" role="dialog" aria-modal="true" aria-labelledby="print-settings-title">
				<div class="shop-modal-header">
					<h2 id="print-settings-title">Print instellingen</h2>
					<button class="modal-close-btn" id="print-settings-close" aria-label="Sluit print instellingen">&times;</button>
				</div>
				<p id="print-settings-hint" style="margin-top: 6px;">Printvriendelijk (geen screenshot): alleen het speelveld, met zo min mogelijk inkt.</p>
				<div class="shop-content-grid" style="grid-template-columns: 1fr; gap: 10px;">
					<div class="shop-section" style="min-width: 0;">
						<h3 class="shop-section-title">Speelveld</h3>
						<label style="display:flex; gap:8px; align-items:center; margin: 6px 0;">
							<input type="radio" name="print-board-source" value="current" checked>
							<span>Huidig speelveld</span>
						</label>
						<label style="display:flex; gap:8px; align-items:center; margin: 6px 0;">
							<input type="radio" name="print-board-source" value="world1">
							<span>Genereer Wereld 1</span>
						</label>
						<label style="display:flex; gap:8px; align-items:center; margin: 6px 0;">
							<input type="radio" name="print-board-source" value="world2">
							<span>Genereer Wereld 2</span>
						</label>
					</div>
					<div class="shop-section" style="min-width: 0;">
						<h3 class="shop-section-title">Opties</h3>
						<label style="display:flex; gap:8px; align-items:center; margin: 6px 0;">
							<input id="print-opt-light" type="checkbox" checked>
							<span>Lichte modus</span>
						</label>
						<label style="display:flex; gap:8px; align-items:center; margin: 6px 0;">
							<input id="print-opt-no-bonuses" type="checkbox" checked>
							<span>Zonder bonussen/symbolen (minder inkt)</span>
						</label>
					</div>
				</div>
				<div class="modal-actions" style="justify-content: flex-end;">
					<button id="print-settings-cancel" type="button">Annuleer</button>
					<button id="print-settings-preview" type="button">Preview</button>
					<button id="print-settings-print" type="button">Print</button>
				</div>
			</div>
		</div>

		<!-- Unlock Modal -->
		<div id="unlock-modal-layer" class="modal-overlay">
			<div id="unlock-modal" class="game-modal unlock-modal" role="dialog" aria-modal="true">
				<div class="unlock-modal-content">
					<div class="unlock-icon" id="unlock-icon">ðŸŽ‰</div>
					<h2 id="unlock-title" class="unlock-title">Nieuwe Content!</h2>
					<div id="unlock-items" class="unlock-items-container"></div>
					<button id="unlock-modal-continue" class="modal-button">Doorgaan</button>
				</div>
			</div>
		</div>

		<div id="rules-modal-layer" class="modal-overlay">
			<div id="rules-modal" class="game-modal" role="dialog" aria-modal="true" aria-labelledby="rules-modal-title">
				<h2 id="rules-modal-title">ðŸ“– Spelregels</h2>
				
				<div class="rules-section">
					<h3>Hoe te spelen</h3>
					<p><strong>Doel:</strong> Voltooi het actieve level-objectief voordat je kaarten op zijn.</p>
				</div>

				<div class="rules-section">
					<h3>ðŸŽ´ Kaarten plaatsen</h3>
					<ul>
						<li>Kies een kaart uit je hand (3-4 kaarten)</li>
						<li>Klik op een kaart om te selecteren, klik opnieuw om te deselecteren</li>
						<li>Gebruik de draaiknop (â†») om de kaart te roteren</li>
						<li>Sleep de kaart naar een zone en plaats de blokken</li>
						<li>Kaarten verdwijnen na plaatsing</li>
					</ul>
				</div>

				<div class="rules-section">
					<h3>ðŸŽ¯ Zones & Scoring</h3>
					<ul>
						<li><strong>ðŸŸ¡ Geel:</strong> Vul hele kolommen voor punten (start: 10pt/kolom, groeit per level)</li>
						<li><strong>ðŸŸ¢ Groen:</strong> +10pt per takje dat je voltooit</li>
						<li><strong>ðŸŸ£ Paars:</strong> +1pt per blok voor elke aangrenzende verbinding</li>
						<li><strong>ðŸ”´ Rood:</strong> Vul alle 4 subgrids voor 10pt elk</li>
						<li><strong>ðŸ”µ Blauw:</strong> Vul rijen voor punten (elke 4e rij = vetgedrukt)</li>
						<li><strong>âœ¨ Gouden kaarten:</strong> Kunnen op elke zone geplaatst worden (unlock via upgrade)</li>
					</ul>
				</div>

				<div class="rules-section">
					<h3><span class="coin-symbol">ðŸª™</span> Munten & Upgrades</h3>
					<ul>
						<li>Verzamel munten door gouden cellen te activeren</li>
						<li>Gebruik munten in de winkel voor nieuwe kaarten of upgrades</li>
						<li>Upgrades: grotere hand, gouden kaarten, bonus boost, lucky draw, etc.</li>
					</ul>
				</div>

				<div class="rules-section">
					<h3>âš¡ Bonussen</h3>
					<ul>
						<li>Vul rijen met symbolen om bonusblokken te verdienen</li>
						<li>Klik op een bonus om een gratis 1Ã—2 blok te plaatsen</li>
						<li>Elke 3 bonuspunten = +1 munt</li>
					</ul>
				</div>

				<div class="rules-section">
					<h3>ðŸ“± Mobiele Bediening</h3>
					<ul>
						<li>Tik op een zone om in te zoomen</li>
						<li>Gebruik â—€â–¶ pijlen om tussen zones te navigeren</li>
						<li>Tik buiten de zone om uit te zoomen</li>
					</ul>
				</div>

				<div class="modal-actions">
					<button id="rules-modal-close">Sluiten</button>
				</div>
			</div>
		</div>

		<div id="upgrade-modal-layer" class="modal-overlay">
			<div id="upgrade-modal" class="game-modal" role="dialog" aria-modal="true" aria-labelledby="upgrade-modal-title">
				<h2 id="upgrade-modal-title">Upgrades (binnenkort)</h2>
				<p id="upgrade-modal-message">Dit scherm is gereserveerd voor toekomstige kaart-upgrades. Suggesties zijn welkom!</p>
				<div class="modal-actions">
					<button id="upgrade-modal-close">Sluiten</button>
				</div>
			</div>
		</div>

		<div id="confirm-complete-layer" class="modal-overlay">
			<div id="confirm-complete-modal" class="game-modal" role="dialog" aria-modal="true" aria-labelledby="confirm-complete-title">
				<h2 id="confirm-complete-title">Ronde voltooien?</h2>
				<p id="confirm-complete-message">Weet je zeker dat je de ronde wil voltooien?</p>
				<p id="confirm-complete-details" class="modal-subtext"></p>
				<div class="modal-actions">
					<button id="confirm-complete-yes">Ja</button>
					<button id="confirm-complete-no">Nee</button>
				</div>
			</div>
		</div>
		
		<div id="confirm-new-game-layer" class="modal-overlay">
			<div id="confirm-new-game-modal" class="game-modal" role="dialog" aria-modal="true" aria-labelledby="confirm-new-game-title">
				<h2 id="confirm-new-game-title">âš ï¸ Nieuw Spel Starten</h2>
				<p id="confirm-new-game-message">Weet je zeker dat je een nieuw spel wil starten?</p>
				<p id="confirm-new-game-details" class="modal-subtext">Je huidige voortgang (level, kaarten, upgrades) wordt permanent verwijderd.</p>
				<div class="modal-actions">
					<button id="confirm-new-game-yes" style="background: #d32f2f;">Ja, nieuw spel</button>
					<button id="confirm-new-game-no">Annuleren</button>
				</div>
			</div>
		</div>
		
		<div id="golden-unlock-layer" class="modal-overlay" aria-hidden="true">
			<div id="golden-unlock-modal" class="game-modal" role="dialog" aria-modal="true" aria-labelledby="golden-unlock-title" tabindex="-1">
				<h2 id="golden-unlock-title">âœ¨ Kies je eerste gouden kaart</h2>
				<p id="golden-unlock-subtext" class="modal-subtext">Je hebt <strong>Gouden Kaarten</strong> ontgrendeld. Kies er 1 uit 3.</p>
				<div id="golden-unlock-content" class="deck-modal-grid" role="list"></div>
			</div>
		</div>
		
		<div id="deck-modal-layer" class="modal-overlay" aria-hidden="true">
			<div id="deck-modal" class="game-modal" role="dialog" aria-modal="true" aria-labelledby="deck-modal-title">
				<h2 id="deck-modal-title">Deckoverzicht</h2>
				<p id="deck-modal-subtext" class="modal-subtext"></p>
				<div id="deck-modal-content" class="deck-modal-grid" role="list"></div>
				<div class="modal-actions">
					<button id="deck-modal-close" type="button">Sluiten</button>
				</div>
			</div>
		</div>
		<div id="blackhole-modal-layer" class="modal-overlay" aria-hidden="true">
			<div id="blackhole-modal" class="game-modal blackhole-modal" role="dialog" aria-modal="true" aria-labelledby="blackhole-modal-title" tabindex="-1">
				<h2 id="blackhole-modal-title">Zwart Gat Challenge</h2>
				<p id="blackhole-modal-subtext" class="modal-subtext"></p>
				<div class="blackhole-stats">
					<span>Kaarten gekozen: <strong id="blackhole-selection-count">0</strong>/<span id="blackhole-selection-limit">0</span></span>
					<span>PotentiÃ«le bonus: <strong id="blackhole-reward">0</strong></span>
					<span class="blackhole-stake">Inzet: <strong id="blackhole-stake-value">0</strong><span class="coin-symbol">ðŸª™</span> (x<strong id="blackhole-stake-mult">1</strong>)
						<input id="blackhole-stake" type="range" min="0" max="10" value="0" step="1" aria-label="Inzet munten" />
					</span>
				</div>
				<div id="blackhole-feedback" class="blackhole-feedback" aria-live="polite"></div>
				<div id="blackhole-card-grid" class="deck-modal-grid blackhole-card-grid" role="list"></div>
				<div class="modal-actions blackhole-actions">
					<button id="blackhole-claim-btn" type="button" disabled>Claim bonus</button>
					<button id="blackhole-forfeit-btn" type="button">Stop (âˆ’5)</button>
				</div>
			</div>
		</div>
		

  <script>
	// ---------- Utilities ----------
	
	// Helper functie om coin symbool te wrappen met correcte font
	// Zorgt voor consistente weergave in Edge en andere browsers
	function coinIcon(count = 1) {
		const coins = 'ðŸª™'.repeat(count);
		return `<span class="coin-symbol">${coins}</span>`;
	}
	
	const historyStack = [];
	const MAX_COINS = Infinity; // Geen limiet meer
	const MOBILE_BREAKPOINT = 650;
	const DESKTOP_LOW_HEIGHT_BREAKPOINT = 1080;
	const TRAP_PENALTY = 5;

	function isCoarsePointer() {
		try {
			return !!(window.matchMedia && window.matchMedia('(pointer: coarse)').matches);
		} catch {
			return false;
		}
	}

	function isMobileViewport() {
		// Mobile = small width OR (phone-landscape style: short height on coarse pointer).
		return window.innerWidth <= MOBILE_BREAKPOINT || (isCoarsePointer() && window.innerHeight <= 600);
	}
	// User request: black holes should be rarer.
	const BLACK_HOLE_DEFAULT_CHANCE = 0.12;
	const BLACK_HOLE_CARD_COUNT = 25; // 5x5 grid
	const BLACK_HOLE_MAX_SELECTION = 25;
	const BLACK_HOLE_POINT_MULTIPLIER = 2;
	const BLACK_HOLE_CARD_COLOR = {
	  name: 'zwart gat',
	  code: 'linear-gradient(135deg, #5f5a93 0%, #3b3662 55%, #191532 100%)'
	};

  function shuffleArray(a){
    for(let i=a.length-1;i>0;i--){
      const j = Math.floor(Math.random()*(i+1));
      [a[i],a[j]] = [a[j],a[i]];
    }
    return a;
  }
  
	let isDragging = false;
	let totalScoreFlashToken = 0;

	let yellow=0, green=0, purple=0, blue=0, red=0, bonus=0;
	let blackHoleBonus = 0;
	let totalBonusesCollected = 0;
	let latestScoreSnapshot = null;
	window.lastPlacementFailure = null;
	let blackHoleState = {
	  trap: null,
	  cards: [],
	  selected: new Set(),
	  reward: 0,
	  stake: 0,
	  feedbackTimeout: null
	};

	const GOLDEN_COLOR = { name: 'gouden', code: '#f5d76e', isGolden: true };
	const GOLDEN_FILL = 'linear-gradient(135deg, #fff4bf, #f5d76e, #d49f32)';
	const GOLDEN_CARD_SHAPES = [
		{ name: 'Gouden Vierkant', matrix: [[1,1],[1,1]], category: 'golden' },
		{ name: 'Gouden L', matrix: [[1,0],[1,0],[1,1]], category: 'golden' },
		{ name: 'Gouden Zuil', matrix: [[1],[1],[1]], category: 'golden' }
	];

	// ========== UPGRADE SYSTEEM ==========
	const UPGRADES = {
		wildcardCards: {
			id: 'wildcardCards',
			name: 'Multikleur Kaarten',
			description: 'Ontgrendel multikleur kaarten die op elk grid geplaatst kunnen worden.',
			cost: 13,
			icon: 'ðŸŒˆ',
			purchased: false,
			shopChance: 0.35,
			onPurchase: () => {
				showObjectiveToast('ðŸŒˆ Multikleur kaarten ontgrendeld! Kies meteen 1 multikleur kaart.');
				setTimeout(() => {
					openMulticolorRewardPicker();
				}, 80);
			}
		},
		miniPack34: {
			id: 'miniPack34',
			name: 'Compact Deck',
			description: 'Koop 3 mini-kaarten (max. 3 blokjes): kies 1 uit 3, drie keer.',
			cost: 8,
			icon: 'ðŸ“¦',
			purchased: false,
			onPurchase: () => {
				showObjectiveToast('ðŸ“¦ Compact Deck gekocht! Kies je 3 kaarten.');
				setTimeout(() => {
					startMini34RewardSequence();
				}, 80);
			}
		},
		goldenCards: {
			id: 'goldenCards',
			name: 'Gouden Kaarten',
			description: 'Ontgrendel gouden kaarten die op elk grid geplaatst kunnen worden.',
			cost: 15,
			icon: 'âœ¨',
			purchased: false,
			onPurchase: () => {
				showObjectiveToast('âœ¨ Gouden kaarten ontgrendeld! Kies meteen 1 gouden kaart.');
				// Immediate reward: let the player pick 1 of 3 golden cards.
				setTimeout(() => {
					openGoldenUnlockModal();
				}, 80);
			}
		},
		extraHandSize: {
			id: 'extraHandSize',
			name: 'Grotere Hand',
			description: 'Toon 1 extra kaart als kopie uit je deck (deck raakt niet sneller op).',
			cost: 17,
			icon: 'ðŸƒ',
			purchased: false,
			onPurchase: () => {
				// Logica staat in drawNextHand - toont kopie uit deck
			}
		},
		bonusBoost: {
			id: 'bonusBoost',
			name: 'Bonus Boost',
			description: 'Krijg 2 bonusblokken per kleur in plaats van 1.',
			cost: 15,
			icon: 'âš¡',
			purchased: false,
			onPurchase: () => {
				// Deze upgrade wijzigt toggleCell bonus logic
			}
		},
		multicolorBoost: {
			id: 'multicolorBoost',
			name: 'Multikleur Boost',
			description: '100% meer kans op multikleur tetris blokken (ook bij random shop).',
			cost: 10,
			icon: 'ðŸŒˆ',
			purchased: false,
			onPurchase: () => {
				showObjectiveToast('ðŸŒˆ Multikleur Boost actief! Dubbele kans op rainbow blokken.');
			}
		},
		luckyDraw: {
			id: 'luckyDraw',
			name: 'Lucky Draw',
			description: '25% kans op een bonuskopie van een kaart die nog in het deck zit.',
			cost: 8,
			icon: 'ðŸ€',
			purchased: false,
			onPurchase: () => {
				// Deze upgrade wijzigt drawNextHand
			}
		},
		coinMaster: {
			id: 'coinMaster',
			name: 'Muntmeester',
			description: 'Krijg 2 extra munten aan het begin van elk level.',
			cost: 6,
			icon: 'ðŸª™',
			purchased: false,
			onPurchase: () => {
				// Geef direct 2 munten
				const goldZone = document.getElementById('collected-coins');
				if (goldZone) {
					const coins = goldZone.querySelectorAll('.coin');
					let added = 0;
					coins.forEach(coin => {
						if (!coin.classList.contains('active') && added < 2) {
							coin.classList.add('active');
							added++;
						}
					});
					updateCoinCounter();
				}
			}
		},
		blackHoleAccess: {
			id: 'blackHoleAccess',
			name: 'Zwart Gat Pas',
			description: 'Ontgrendel het zwart gat bonuslevel wanneer je op een zwart gat landt.',
			cost: 21,
			icon: 'ðŸŒ€',
			purchased: false,
			onPurchase: () => {
				rebuildGameBoards();
				showObjectiveToast('ðŸŒ€ Zwart Gat Pas geactiveerd! Zwarte gaten zijn nu zichtbaar.');
			}
		},
		portals: {
			id: 'portals',
			name: 'Portals',
			description: 'Plaats tegelijkertijd op twee zones met portal verbinding.',
			cost: 20,
			icon: 'ðŸŒ',
			purchased: false,
			onPurchase: () => {
				activatePortals();
				showObjectiveToast('ðŸŒ Portals geactiveerd! Een portal is verschenen op het bord.');
			}
		},
		betterCards: {
			id: 'betterCards',
			name: 'Betere Kaarten',
			description: 'Ontgrendel een extra premium kaart in de shop (grotere vormen, meer kans op goud/multikleur).',
			cost: 25,
			icon: 'â™¦',
			purchased: false,
			onPurchase: () => {
				showObjectiveToast('â™¦ Premium shopkaart ontgrendeld!');
			}
		},
		xlBlocks: {
			id: 'xlBlocks',
			name: 'XL Blokken',
			description: 'Ontgrendel XL tetris vormen (6 blokjes) in de shop.',
			cost: 20,
			icon: 'ðŸ§±',
			purchased: false,
			onPurchase: () => {
				showObjectiveToast('ðŸ§± XL blokken ontgrendeld!');
			}
		},
		extraLargeBlocks: {
			id: 'extraLargeBlocks',
			name: 'XXL Blokken',
			description: 'Ontgrendel XXL tetris vormen (7+ blokjes) in de shop.',
			cost: 25,
			icon: 'ðŸ§±',
			purchased: false,
			onPurchase: () => {
				showObjectiveToast('ðŸ§± XXL blokken ontgrendeld!');
			}
		}
	};

	// Unlock systeem - bepaalt welke content beschikbaar is per level
	const UNLOCK_PROGRESSION = {
		// Kaart categorieÃ«n unlocks
		cardCategories: {
			mini: { unlockedAtLevel: 1, name: 'Mini Kaarten', icon: 'ðŸ“¦', description: 'Compacte kaarten van 2-3 blokjes' },
			standard: { unlockedAtLevel: 1, name: 'Standaard Kaarten', icon: 'ðŸŽ´', description: 'Klassieke Tetris vormen' },
			large: { unlockedAtLevel: 3, name: 'Grote Kaarten', icon: 'ðŸ“', description: 'Uitgebreide vormen met 5+ blokjes' }
		},
		// Speciale features
		features: {
			bonusShop: { unlockedAtWorld: 2, name: 'Bonus Shop', icon: 'ðŸª', description: 'Upgrade je bonussen permanent in de shop!' }
		},
		// Upgrade unlocks (level waarop ze in de shop verschijnen)
		upgrades: {
			miniPack34: { unlockedAtLevel: 5, announcement: 'nieuwe upgrade' },
			wildcardCards: { unlockedAtLevel: 7, announcement: 'nieuwe upgrade' },
			coinMaster: { unlockedAtLevel: 5, announcement: 'nieuwe upgrade' },
			goldenCards: { unlockedAtLevel: 7, announcement: 'nieuwe upgrade' },
			luckyDraw: { unlockedAtLevel: 5, announcement: 'nieuwe upgrade' },
			extraHandSize: { unlockedAtWorld: 2, unlockedAtLevel: 11, announcement: 'nieuwe upgrade' },
			multicolorBoost: { unlockedAtLevel: 11, announcement: 'nieuwe upgrade' },
			bonusBoost: { unlockedAtWorld: 2, unlockedAtLevel: 5, announcement: 'nieuwe upgrade' },
			blackHoleAccess: { unlockedAtLevel: 11, announcement: 'nieuwe uitdaging' },
			portals: { unlockedAtLevel: 11, announcement: 'nieuwe upgrade' },
			betterCards: { unlockedAtLevel: 11, announcement: 'nieuwe upgrade' },
			xlBlocks: { unlockedAtLevel: 7, announcement: 'nieuwe upgrade' },
			extraLargeBlocks: { unlockedAtLevel: 14, announcement: 'nieuwe upgrade' }
		},
		// Elk level track welke content unlocked is
		getLevelUnlocks: function(level, world = 1) {
			const unlocks = {
				cardCategories: [],
				upgrades: [],
				features: [],
				shopType: level % 2 === 0 ? 'full' : 'cards-only' // Elke 2 levels volledige shop (met upgrades)
			};
			
			// Check card categories
			Object.entries(this.cardCategories).forEach(([key, data]) => {
				if (data.unlockedAtLevel === level) {
					unlocks.cardCategories.push({ key, ...data });
				}
			});
			
			// Check features
			Object.entries(this.features || {}).forEach(([key, data]) => {
				if (data.unlockedAtLevel === level) {
					unlocks.features.push({ key, ...data });
				}
			});
			
			// Check upgrades
			Object.entries(this.upgrades).forEach(([key, data]) => {
				if (data.unlockedAtLevel === level && (!data.unlockedAtWorld || world >= data.unlockedAtWorld)) {
					unlocks.upgrades.push({ 
						key, 
						...data, 
						upgradeData: UPGRADES[key] 
					});
				}
			});
			
			return unlocks;
		},
		isUpgradeUnlocked: function(upgradeId, currentLevel, world = 1) {
			const u = this.upgrades[upgradeId];
			if (!u) return false;
			if (u.unlockedAtWorld && world < u.unlockedAtWorld) return false;
			return u.unlockedAtLevel <= currentLevel;
		},
		isCategoryUnlocked: function(category, currentLevel) {
			return this.cardCategories[category] && this.cardCategories[category].unlockedAtLevel <= currentLevel;
		},
		isFeatureUnlocked: function(featureId, level, world = 1) {
			if (!this.features || !this.features[featureId]) return false;
			const feature = this.features[featureId];
			if (feature.unlockedAtWorld) return world >= feature.unlockedAtWorld;
			if (feature.unlockedAtLevel) return level >= feature.unlockedAtLevel;
			return false;
		}
	};

	// Helper functie om upgrade status te checken
	function hasUpgrade(upgradeId) {
		// Back-compat: old saves used 'compactCards'. It now maps to miniPack34.
		if (upgradeId === 'miniPack34') return !!(UPGRADES.miniPack34?.purchased || UPGRADES.compactCards?.purchased);
		if (upgradeId === 'compactCards') return !!(UPGRADES.compactCards?.purchased || UPGRADES.miniPack34?.purchased);
		return UPGRADES[upgradeId]?.purchased || false;
	}

	function isWorld2Upgrade(upgradeId) {
		const meta = UNLOCK_PROGRESSION?.upgrades?.[upgradeId];
		if (!meta) return false;
		if (meta.unlockedAtWorld) return Number(meta.unlockedAtWorld) >= 2;
		const lvl = Number(meta.unlockedAtLevel) || 1;
		const info = (typeof getWorldAndSubLevel === 'function') ? getWorldAndSubLevel(lvl) : { world: 1 };
		return Number(info?.world || 1) >= 2;
	}

	function getEffectiveUpgradeCost(upgradeId) {
		const base = Number(UPGRADES?.[upgradeId]?.cost) || 0;
		if (Number(currentWorld || 1) >= 2 && isWorld2Upgrade(upgradeId)) return base * 2;
		return base;
	}

	// Unlock Modal Functies
	let pendingUnlockCallback = null;
	
	function showUnlockModal(levelUnlocks, callback) {
		const unlockModalLayer = document.getElementById('unlock-modal-layer');
		const unlockIcon = document.getElementById('unlock-icon');
		const unlockTitle = document.getElementById('unlock-title');
		const unlockItems = document.getElementById('unlock-items');
		
		if (!unlockModalLayer || !unlockItems) return;
		
		// Sla de callback op
		pendingUnlockCallback = callback;
		
		// Bepaal de icon en titel op basis van wat er is unlocked
		const hasChallenge = levelUnlocks.upgrades.some(u => u.announcement === 'nieuwe uitdaging');
		
		if (hasChallenge) {
			unlockIcon.textContent = 'âš ï¸';
			unlockTitle.textContent = 'Pas Op!';
		} else {
			unlockIcon.textContent = 'ðŸŽ‰';
			unlockTitle.textContent = 'Nieuwe Content Ontgrendeld!';
		}
		
		// Bouw unlock items
		unlockItems.innerHTML = '';
		
		// Voeg card categories toe
		levelUnlocks.cardCategories.forEach(cat => {
			const item = document.createElement('div');
			item.className = 'unlock-item';
			item.innerHTML = `
				<div class="unlock-item-icon">${cat.icon}</div>
				<div class="unlock-item-content">
					<div class="unlock-item-name">${cat.name}</div>
					<p class="unlock-item-description">${cat.description}</p>
				</div>
			`;
			unlockItems.appendChild(item);
		});
		
		// Voeg features toe (zoals Mega Bonus)
		if (levelUnlocks.features) {
			levelUnlocks.features.forEach(feature => {
				const item = document.createElement('div');
				item.className = 'unlock-item unlock-item--feature';
				item.innerHTML = `
					<div class="unlock-item-icon">${feature.icon}</div>
					<div class="unlock-item-content">
						<div class="unlock-item-name">${feature.name}</div>
						<p class="unlock-item-description">${feature.description}</p>
					</div>
				`;
				unlockItems.appendChild(item);
			});
		}
		
		// Voeg upgrades toe
		levelUnlocks.upgrades.forEach(upgrade => {
			const item = document.createElement('div');
			const isChallenge = upgrade.announcement === 'nieuwe uitdaging';
			item.className = isChallenge ? 'unlock-item unlock-item--challenge' : 'unlock-item';
			item.innerHTML = `
				<div class="unlock-item-icon">${upgrade.upgradeData.icon}</div>
				<div class="unlock-item-content">
					<div class="unlock-item-name">${upgrade.upgradeData.name}</div>
					<p class="unlock-item-description">${upgrade.upgradeData.description}</p>
				</div>
			`;
			unlockItems.appendChild(item);
		});
		
		unlockModalLayer.classList.add('show');
		console.log('ðŸŽ‰ Unlock modal shown');
	}

	function hideUnlockModal() {
		console.log('ðŸŽ‰ hideUnlockModal called');
		const unlockModalLayer = document.getElementById('unlock-modal-layer');
		if (unlockModalLayer) {
			unlockModalLayer.classList.remove('show');
		}
		// Roep de callback aan als die er is
		if (typeof pendingUnlockCallback === 'function') {
			console.log('ðŸŽ‰ Calling unlock callback');
			const cb = pendingUnlockCallback;
			pendingUnlockCallback = null;
			cb();
		} else {
			console.log('ðŸŽ‰ No unlock callback to call');
		}
	}

	// Portal systeem - twee vaste portals per level (Ã©Ã©n in geel, Ã©Ã©n in groen)
	let portalsActive = false;
	let portalCellYellow = null; // De portal cel in yellow-grid
	let portalCellGreen = null;  // De portal cel in green-grid

	function activatePortals() {
		portalsActive = true;
		placePortalsForLevel();
	}

	function placePortalsForLevel() {
		// Verwijder oude portals
		clearPortals();

		// Plaats portal in yellow-grid
		const yellowZone = document.getElementById('yellow-grid');
		if (yellowZone) {
			const yellowCells = Array.from(yellowZone.querySelectorAll('.cell:not(.void-cell):not(.active)'));
			if (yellowCells.length > 0) {
				const randomYellowCell = yellowCells[Math.floor(Math.random() * yellowCells.length)];
				setupPortalCell(randomYellowCell, 'yellow-grid');
				portalCellYellow = randomYellowCell;
			}
		}

		// Plaats portal in green-grid
		const greenZone = document.getElementById('green-grid');
		if (greenZone) {
			const greenCells = Array.from(greenZone.querySelectorAll('.cell:not(.void-cell):not(.active)'));
			if (greenCells.length > 0) {
				const randomGreenCell = greenCells[Math.floor(Math.random() * greenCells.length)];
				setupPortalCell(randomGreenCell, 'green-grid');
				portalCellGreen = randomGreenCell;
			}
		}

		console.log('ðŸŒ Portals placed for this level - Yellow:', !!portalCellYellow, 'Green:', !!portalCellGreen);
	}
	
	function clearPortals() {
		// Verwijder portal in yellow
		if (portalCellYellow) {
			portalCellYellow.classList.remove('portal-cell');
			portalCellYellow.classList.remove('bold-cell');
			const oldSymbol = portalCellYellow.querySelector('.portal-symbol');
			if (oldSymbol) oldSymbol.remove();
			portalCellYellow = null;
		}
		
		// Verwijder portal in green
		if (portalCellGreen) {
			portalCellGreen.classList.remove('portal-cell');
			portalCellGreen.classList.remove('bold-cell');
			const oldSymbol = portalCellGreen.querySelector('.portal-symbol');
			if (oldSymbol) oldSymbol.remove();
			portalCellGreen = null;
		}
	}
	
	function setupPortalCell(cell, zoneId) {
		cell.classList.add('portal-cell');
		cell.classList.add('bold-cell'); // Maak het een bold-cell zodat je vanaf hier kunt plaatsen!
		
		// Voeg portal symbool toe
		const portalSymbol = document.createElement('div');
		portalSymbol.classList.add('portal-symbol');
		portalSymbol.textContent = 'ðŸŒ';
		cell.appendChild(portalSymbol);
		
		console.log('ðŸŒ Portal placed in', zoneId);
	}

	// Mega Bonus systeem - random spawning vanaf level 4
	let megaBonusActive = false;
	let megaBonusCell = null;
	
	// Unified Shop systeem - no longer cell-based, always accessible from level 5
	// (Removed old cell-based shop placement logic)

	// Removed placeMegaBonus - merged into unified shop system

	function openBonusShopModal(specificColor = null) {
		// Toon de bonus sectie als modal
		showObjectiveToast('â™¦ Mega Bonus Shop geopend!');
		// We hergebruiken de bestaande shop modal maar tonen alleen bonussen
		const shopModalLayer = document.getElementById('shop-modal-layer');
		const shopModalTitle = document.getElementById('shop-modal-title');
		const shopModalMessage = document.getElementById('shop-modal-message');
		const shopCardOptions = document.getElementById('shop-card-options');
		const upgradesSection = document.querySelector('.shop-upgrades-section');
		const bonusSection = document.querySelector('.shop-bonus-section');
		const shopBonusContainer = document.getElementById('shop-bonus-container');
		
		if (!shopModalLayer || !shopBonusContainer) return;
		
		// Verberg kaarten en upgrades volledig in bonus shop
		if (shopCardOptions) shopCardOptions.closest('.shop-cards-section').style.display = 'none';
		if (upgradesSection) upgradesSection.style.display = 'none';
		
		// Toon alleen bonussen - zet parent grid om naar single column
		const shopContentGrid = document.querySelector('.shop-content-grid');
		if (shopContentGrid) {
			shopContentGrid.style.gridTemplateColumns = '1fr';
		}
		if (bonusSection) {
			bonusSection.style.display = '';
			const shopLowerGrid = bonusSection.closest('.shop-lower-grid');
			if (shopLowerGrid) shopLowerGrid.style.display = 'none';
			const parent = bonusSection.parentElement;
			if (parent && parent.classList.contains('shop-lower-grid')) {
				shopContentGrid.appendChild(bonusSection);
			}
		}
		
		// Update bonus UI om bonussen te tonen
		updateShopBonusUI();
		updateShopCoinDisplay();
		if (shopModalTitle) shopModalTitle.innerHTML = '<span class="diamond-glyph">â™¦</span> Mega Bonus Shop';
		if (shopModalMessage) {
			const coins = getSpendableCoinCount();
			shopModalMessage.textContent = coins >= 5
				? `Koop een bonus upgrade voor 5 munten!`
				: 'Je hebt niet genoeg munten (5 ðŸª™ nodig).';
		}
		
		// Filter bonus container om alleen de specifieke kleur te tonen als opgegeven
		if (specificColor) {
			shopBonusContainer.innerHTML = '';
			const meta = getBonusMeta(specificColor);
			if (!meta) return;
			
			const coins = getSpendableCoinCount();
			const bonusCard = document.createElement('div');
			bonusCard.classList.add('shop-bonus-card');
			
			const bonusHeader = document.createElement('div');
			bonusHeader.classList.add('shop-bonus-header');
			bonusHeader.innerHTML = `<span class="bonus-icon" style="background-color: ${meta.bgColor}">${meta.icon}</span><span class="bonus-name">${meta.name}</span>`;
			
			const bonusDesc = document.createElement('p');
			bonusDesc.classList.add('shop-bonus-desc');
			bonusDesc.textContent = `Krijg 1 bonus ${meta.name.toLowerCase()} blok.`;
			
			const bonusActions = document.createElement('div');
			bonusActions.classList.add('shop-bonus-actions');
			
			const buyBtn = document.createElement('button');
			const megaBonusCost = 5;
			buyBtn.innerHTML = `Kopen (${megaBonusCost} ${coinIcon()})`;
			buyBtn.disabled = coins < megaBonusCost;
			buyBtn.title = coins < megaBonusCost ? 'Onvoldoende munten' : `Koop ${meta.name} bonus`;
			buyBtn.addEventListener('click', () => {
				if (spendCoins(megaBonusCost)) {
					grantBonusCharge(specificColor);
					shopModalMessage.textContent = `${meta.icon} ${meta.name} bonus gekocht!`;
					updateShopCoinDisplay();
					buyBtn.disabled = true;
					setTimeout(() => {
						shopModalLayer.classList.remove('show');
						// Herstel visibility
						if (shopCardOptions) shopCardOptions.closest('.shop-cards-section').style.display = '';
						if (shopModalTitle) shopModalTitle.textContent = 'Kaarten & Upgrades';
					}, 1000);
				}
			});
			
			bonusActions.appendChild(buyBtn);
			bonusCard.append(bonusHeader, bonusDesc, bonusActions);
			shopBonusContainer.appendChild(bonusCard);
		} else {
			updateShopBonusUI();
		}
		
		updateShopCoinDisplay();
		shopModalLayer.classList.add('show');
		
		// Herstel normale shop bij sluiten
		const shopSkipBtn = document.getElementById('shop-modal-skip');
		if (shopSkipBtn) {
			const originalText = shopSkipBtn.textContent;
			shopSkipBtn.textContent = 'Sluiten';
			const handleClose = () => {
				shopModalLayer.classList.remove('show');
				shopSkipBtn.textContent = originalText;
				// Herstel visibility
				if (shopCardOptions) shopCardOptions.closest('.shop-cards-section').style.display = '';
				if (shopModalTitle) shopModalTitle.textContent = 'Kaarten & Upgrades';
				shopSkipBtn.removeEventListener('click', handleClose);
			};
			shopSkipBtn.addEventListener('click', handleClose, { once: true });
		}
	}

	// Objective templates - each level has 5 random candidates
	const OBJECTIVE_TEMPLATES = {
		1: [ // Level 1: Simple totals and single colors
			{
				id: 'level-1-total-10',
				description: 'Haal 10 punten totaal.',
				short: 'Level 1 - 10 punten totaal',
				check: scores => scores.total >= 10
			},
			{
				id: 'level-1-blue-8',
				description: 'Scoor 8 punten in blauw.',
				short: 'Level 1 - 8 punten blauw',
				check: scores => scores.blue >= 8
			},
			{
				id: 'level-1-yellow-6',
				description: 'Voltooi 1 kolom in geel.',
				short: 'Level 1 - 1 kolom geel',
				check: () => checkYellowFullRows(1)
			},
			{
				id: 'level-1-green-8',
				description: 'Scoor 8 punten in groen.',
				short: 'Level 1 - 8 punten groen',
				check: scores => scores.green >= 8
			},
			{
				id: 'level-1-purple-6',
				description: 'Scoor 6 punten in paars.',
				short: 'Level 1 - 8 punten paars',
				check: scores => scores.purple >= 8
			}
		],
		2: [ // Level 2: Higher totals and two-color combinations
			{
				id: 'level-2-total-20',
				description: 'Haal 20 punten totaal.',
				short: 'Level 2 - 20 punten totaal',
				check: scores => scores.total >= 20
			},
			{
				id: 'level-2-blue-yellow',
				description: 'Scoor 12 punten in geel en 6 in blauw.',
				short: 'Level 2 - 6 blauw + 12 geel',
				check: scores => scores.blue >= 6 && scores.yellow >= 12
			},
			{
				id: 'level-2-green-purple',
				description: 'Scoor 8 punten in groen Ã©n in paars.',
				short: 'Level 2 - 8 groen + 8 paars',
				check: scores => scores.green >= 8 && scores.purple >= 8
			},
			{
				id: 'level-2-bonus-collect-6',
				description: 'Verzamel 6 bonussen.',
				short: 'Level 2 - 6 bonussen',
				check: scores => (scores?.bonusesCollected || 0) >= 6,
				progress: scores => {
					const collected = Math.max(0, Math.min(6, (scores?.bonusesCollected || 0)));
					return `${collected}/6`;
				}
			}
		],
		3: [ // Level 3: Three colors and specific patterns
			{
				id: 'level-3-tricolor',
				description: 'Level 3: Scoor 8 punten in paars, blauw Ã©n geel.',
				short: 'Level 3 - 8 in paars/blauw/geel',
				check: scores => scores.purple >= 8 && scores.blue >= 8 && scores.yellow >= 8
			},
			{
				id: 'level-3-total-30',
				description: 'Level 3: Haal 30 punten totaal.',
				short: 'Level 3 - 30 punten totaal',
				check: scores => scores.total >= 30
			},
			{
				id: 'level-3-yellow-rows-2',
				description: 'Level 3: Voltooi 2 gele kolommen.',
				short: 'Level 3 - 2 gele kolommen',
				check: () => checkYellowFullRows(2),
				progress: () => {
					const yellowConfig = window.yellowGridConfig || {};
					const set = yellowConfig.scoreMode === 'diagonal'
						? (window.scoredYellowSegments || window.scoredYellowDiagonals)
						: window.scoredYellowColumns;
					const current = (set instanceof Set) ? set.size : 0;
					const capped = Math.max(0, Math.min(2, current));
					return `${capped}/2`;
				}
			},
			{
				id: 'level-3-green-red',
				description: 'Level 3: Scoor 8 in rood.',
				short: 'Level 3 - 8 in rood',
				check: scores => scores.red >= 8
			},
			{
				id: 'level-3-blue-14',
				description: 'Level 3: Scoor 20 punten in blauw',
				short: 'Level 3 - 20 punten blauw',
				check: scores => scores.blue >= 20
			}
		],
		4: [ // Level 4: Higher targets and complexity
			{
				id: 'level-4-green-16',
				description: 'Level 4: Bereik 16 punten in groen.',
				short: 'Level 4 - 16 punten groen',
				check: scores => scores.green >= 16
			},
			{
				id: 'level-4-total-40',
				description: 'Level 4: Haal 35 punten totaal.',
				short: 'Level 4 - 35 punten totaal',
				check: scores => scores.total >= 35
			},
			{
				id: 'level-4-all-colors-6',
				description: 'Level 4: Scoor minstens 6 punten in de kleuren geel, groen, paars en blauw.',
				short: 'Level 4 - 6+ in elke kleur',
				check: scores => scores.yellow >= 6 && scores.green >= 6 && scores.purple >= 6 && scores.blue >= 6,
				progress: scores => {
					const parts = [
						(scores.yellow >= 6 ? 'âœ”geel' : 'geel'),
						(scores.green >= 6 ? 'âœ”groen' : 'groen'),
						(scores.purple >= 6 ? 'âœ”paars' : 'paars'),
						(scores.blue >= 6 ? 'âœ”blauw' : 'blauw')
					];
					return parts.join(', ');
				}
			},
			{
				id: 'level-4-bonus-12',
			description: 'Level 4: Verzamel 12 bonussen.',
				short: 'Level4 - 12 bonussen',
				check: scores => (scores?.bonusesCollected || 0) >= 12,
				progress: scores => {
					const collected = Math.max(0, Math.min(12, (scores?.bonusesCollected || 0)));
					return `${collected}/12`;
				}
			},
			{
				id: 'level-4-purple-yellow',
				description: 'Level 4: Scoor 8 in paars en 12 in geel.',
				short: 'Level 4 - 8 paars + 12 geel',
				check: scores => scores.purple >= 8 && scores.yellow >= 12
			}
		],
		5: [ // Level 5: Pattern-based challenges
			{
				id: 'level-5-total-50',
				description: 'Level 5: Haal 40 punten totaal.',
				short: 'Level 5 - 40 punten totaal',
				check: scores => scores.total >= 40
			},
			{
				id: 'level-5-yellow-rows-3',
				description: 'Level 5: Scoor 16 punten in geel.',
				short: 'Level 5 - 16 punten geel',
				check: scores => scores.yellow >= 16
			},
			{
				id: 'level-5-blue-18',
				description: 'Level 5: Scoor 30 punten in blauw.',
				short: 'Level 5 - 30 punten blauw',
				check: scores => scores.blue >= 30
			},
			{
				id: 'level-5-red-12',
				description: 'Level 5: Scoor 12 punten in rood.',
				short: 'Level 5 - 12 punten rood',
				check: scores => scores.red >= 12
			}
		],
		6: [ // Level 6: Complex combinations
			{
				id: 'level-6-total-60',
				description: 'Level 6: Haal 50 punten totaal.',
				short: 'Level 6 - 50 punten totaal',
				check: scores => scores.total >= 50
			},
			{
				id: 'level-6-green-20',
				description: 'Level 6: Scoor 24 punten in groen.',
				short: 'Level 6 - 24 punten groen',
				check: scores => scores.green >= 24
			},
			{
				id: 'level-6-tricolor-advanced',
				description: 'Level 6: Scoor 12+ in paars, blauw Ã©n geel.',
				short: 'Level 6 - 12+ in paars/blauw/geel',
				check: scores => scores.purple >= 12 && scores.blue >= 12 && scores.yellow >= 12
			},
			{
				id: 'level-6-bonus-18',
				description: 'Level 6: Verzamel 18 bonussen.',
				short: 'Level 6 - 18 bonussen',
				check: scores => (scores?.bonusesCollected || 0) >= 18,
				progress: scores => {
					const collected = Math.max(0, Math.min(18, (scores?.bonusesCollected || 0)));
					return `${collected}/18`;
				}
			},
			{
				id: 'level-6-purple-18',
				description: 'Level 6: Scoor 18 punten in paars.',
				short: 'Level 6 - 18 punten paars',
				check: scores => scores.purple >= 18
			},
		],
		7: [ // Level 7: Advanced patterns
			{
				id: 'level-7-total-70',
				description: 'Level 7: Haal 60 punten totaal.',
				short: 'Level 7 - 60 punten totaal',
				check: scores => scores.total >= 60
			},
			{
				id: 'level-7-yellow-rows-5',
				description: 'Level 7: Voltooi 3 gele kolommen.',
				short: 'Level 7 - 3 gele kolommen',
				check: () => checkYellowFullRows(3),
				progress: () => {
					const yellowConfig = window.yellowGridConfig || {};
					const set = yellowConfig.scoreMode === 'diagonal'
						? (window.scoredYellowSegments || window.scoredYellowDiagonals)
						: window.scoredYellowColumns;
					const current = (set instanceof Set) ? set.size : 0;
					const capped = Math.max(0, Math.min(3, current));
					return `${capped}/3`;
				}
			},
			{
				id: 'level-7-all-colors-10',
				description: 'Level 7: Scoor minstens 10 in elke kleur.',
				short: 'Level 7 - 10+ in elke kleur',
				check: scores => scores.yellow >= 10 && scores.red >= 10 && scores.green >= 10 && scores.purple >= 10 && scores.blue >= 10,
				progress: scores => {
					const parts = [
						(scores.yellow >= 10 ? 'âœ”geel' : 'geel'),
						(scores.red >= 10 ? 'âœ”rood' : 'rood'),
						(scores.green >= 10 ? 'âœ”groen' : 'groen'),
						(scores.purple >= 10 ? 'âœ”paars' : 'paars'),
						(scores.blue >= 10 ? 'âœ”blauw' : 'blauw')
					];
					return parts.join(', ');
				}
			},
			{
				id: 'level-7-blue-purple',
				description: 'Level 7: Scoor 50 punten in blauw',
				short: 'Level 7 - 50 punten blauw',
				check: scores => scores.blue >= 50
			},
			{
				id: 'level-7-red-15',
				description: 'Level 7: Scoor 15 punten in rood.',
				short: 'Level 7 - 15 punten rood',
				check: scores => scores.red >= 15
			}
		],
		8: [ // Level 8: Very challenging
			{
				id: 'level-8-total-85',
				description: 'Level 8: Haal 85 punten totaal.',
				short: 'Level 8 - 85 punten totaal',
				check: scores => scores.total >= 85
			},
			{
				id: 'level-8-yellow-rows-6',
				description: 'Level 8: Voltooi 4 gele kolommen.',
				short: 'Level 8 - 4 gele kolommen',
				check: () => checkYellowFullRows(4),
				progress: () => {
					const yellowConfig = window.yellowGridConfig || {};
					const set = yellowConfig.scoreMode === 'diagonal'
						? (window.scoredYellowSegments || window.scoredYellowDiagonals)
						: window.scoredYellowColumns;
					const current = (set instanceof Set) ? set.size : 0;
					const capped = Math.max(0, Math.min(4, current));
					return `${capped}/4`;
				}
			},
			{
				id: 'level-8-green-purple-ring',
				description: 'Level 8: Scoor 24 punten in paars.',
				short: 'Level 8 - 24 punten paars',
				check: scores => scores.purple >= 24
			},
			{
				id: 'level-8-bonus-24',
				description: 'Level 8: Verzamel 24 bonussen.',
				short: 'Level 8 - 24 bonussen',
				check: scores => (scores?.bonusesCollected || 0) >= 24,
				progress: scores => {
					const collected = Math.max(0, Math.min(24, (scores?.bonusesCollected || 0)));
					return `${collected}/24`;
				}
			},
			{
				id: 'level-8-quad-color',
				description: 'Level 8: Scoor 14+ in geel, groen, paars Ã©n blauw.',
				short: 'Level 8 - 14+ in 4 kleuren',
				check: scores => scores.yellow >= 14 && scores.green >= 14 && scores.purple >= 14 && scores.blue >= 14,
				progress: scores => {
					const parts = [
						(scores.yellow >= 14 ? 'âœ”geel' : 'geel'),
						(scores.green >= 14 ? 'âœ”groen' : 'groen'),
						(scores.purple >= 14 ? 'âœ”paars' : 'paars'),
						(scores.blue >= 14 ? 'âœ”blauw' : 'blauw')
					];
					return parts.join(', ');
				}
			}
		],
		9: [ // Level 9: Expert level
			{
				id: 'level-9-total-100',
				description: 'Level 9: Haal 100 punten totaal.',
				short: 'Level 9 - 100 punten totaal',
				check: scores => scores.total >= 100
			},
			{
				id: 'level-9-yellow-rows-7',
				description: 'Level 9: Voltooi 5 gele kolommen.',
				short: 'Level 9 - 5 gele kolommen',
				check: () => checkYellowFullRows(5),
				progress: () => {
					const yellowConfig = window.yellowGridConfig || {};
					const set = yellowConfig.scoreMode === 'diagonal'
						? (window.scoredYellowSegments || window.scoredYellowDiagonals)
						: window.scoredYellowColumns;
					const current = (set instanceof Set) ? set.size : 0;
					const capped = Math.max(0, Math.min(5, current));
					return `${capped}/5`;
				}
			},
			{
				id: 'level-9-all-colors-15',
				description: 'Level 9: Scoor minstens 15 in elke kleur.',
				short: 'Level 9 - 15+ in elke kleur',
				check: scores => scores.yellow >= 15 && scores.red >= 15 && scores.green >= 15 && scores.purple >= 15 && scores.blue >= 15,
				progress: scores => {
					const parts = [
						(scores.yellow >= 15 ? 'âœ”geel' : 'geel'),
						(scores.red >= 15 ? 'âœ”rood' : 'rood'),
						(scores.green >= 15 ? 'âœ”groen' : 'groen'),
						(scores.purple >= 15 ? 'âœ”paars' : 'paars'),
						(scores.blue >= 15 ? 'âœ”blauw' : 'blauw')
					];
					return parts.join(', ');
				}
			},
			{
				id: 'level-9-blue-25',
				description: 'Level 9: Scoor 75 punten in blauw.',
				short: 'Level 9 - 75 punten blauw',
				check: scores => scores.blue >= 75
			},
			{
				id: 'level-9-combo-master',
				description: 'Level 9: Scoor 18 in rood, 2 gele kolommen Ã©n 24 bonus.',
				short: 'Level 9 - Combo master',
				check: scores => scores.red >= 18 && checkYellowFullRows(2) && ((scores?.bonusesCollected || 0) >= 24),
				progress: scores => {
					const yellowConfig = window.yellowGridConfig || {};
					const set = yellowConfig.scoreMode === 'diagonal'
						? (window.scoredYellowSegments || window.scoredYellowDiagonals)
						: window.scoredYellowColumns;
					const rowsDone = (set instanceof Set) ? set.size : 0;
					const rowsCapped = Math.max(0, Math.min(2, rowsDone));
					const bonusesDone = Math.max(0, (scores?.bonusesCollected || 0));
					const bonusesCapped = Math.max(0, Math.min(24, bonusesDone));
					return `gele kolommen: ${rowsCapped}/2 â€¢ bonussen: ${bonusesCapped}/24`;
				}
			}
		],
		10: [ // Level 10: Ultimate challenge
			{
				id: 'level-10-total-120',
				description: 'Level 10: Haal 120 punten totaal.',
				short: 'Level 10 - 120 punten totaal',
				check: scores => scores.total >= 120
			},
			{
				id: 'level-10-yellow-rows-8',
				description: 'Level 10: Voltooi 4 gele kolommen.',
				short: 'Level 10 - 4 gele kolommen',
				check: () => checkYellowFullRows(4),
				progress: () => {
					const yellowConfig = window.yellowGridConfig || {};
					const set = yellowConfig.scoreMode === 'diagonal'
						? (window.scoredYellowSegments || window.scoredYellowDiagonals)
						: window.scoredYellowColumns;
					const current = (set instanceof Set) ? set.size : 0;
					const capped = Math.max(0, Math.min(4, current));
					return `${capped}/4`;
				}
			},
			{
				id: 'level-10-perfect-balance',
				description: 'Level 10: Scoor 18+ in alle 5 kleuren.',
				short: 'Level 10 - Perfecte balans',
				check: scores => scores.yellow >= 18 && scores.red >= 18 && scores.green >= 18 && scores.purple >= 18 && scores.blue >= 18
			},
			{
				id: 'level-10-green-master',
				description: 'Level 10: Scoor 32 punten in groen.',
				short: 'Level 10 - Groen meester',
				check: scores => scores.green >= 32
			},
			{
				id: 'level-10-purple-ring',
				description: 'Level 10: Vul de volledige buitenrand van het paarse veld.',
				short: 'Level 10 - Paarse rand vol',
				check: () => checkPurpleOuterRingComplete()
			}
		],
		
		// WORLD 2 OBJECTIVES (Levels 11-20) - Complexere uitdagingen!
		11: [
			{
				id: 'level-11-world2-intro',
				description: 'Level 11: Welkom in Wereld 2! Scoor 40 punten totaal.',
				short: 'Level 11 - Wereld 2 intro',
				check: scores => ((scores.yellow + scores.red + scores.green + scores.purple + scores.blue) + (scores?.bonus || 0)) >= 40
			},
			{
				id: 'level-11-shape-master',
				description: 'Level 11: Voltooi 1 diagonale lijn van minstens 5 cellen in geel.',
				short: 'Level 11 - Diagonaal meester',
				check: () => {
					// Check of er een diagonaal van 5+ cellen volledig actief is
					const yellowZone = document.getElementById('yellow-zone');
					if (!yellowZone) return false;
					const grid = yellowZone.querySelector('.grid');
					if (!grid) return false;
					const cells = Array.from(grid.querySelectorAll('.cell:not(.void-cell)'));
					// Group cells by diagonal index
					const diagGroups = {};
					cells.forEach(cell => {
						const diag = cell.dataset.diag;
						if (diag !== undefined) {
							if (!diagGroups[diag]) diagGroups[diag] = [];
							diagGroups[diag].push(cell);
						}
					});
					// Check if any diagonal has 5+ cells all active
					for (const diag of Object.keys(diagGroups)) {
						const diagCells = diagGroups[diag];
						if (diagCells.length >= 5) {
							const allActive = diagCells.every(c => c.classList.contains('active'));
							if (allActive) return true;
						}
					}
					return false;
				}
			},
			{
				id: 'level-11-long-path',
				description: 'Level 11: Scoor 24 punten in blauw.',
				short: 'Level 11 - Lange reis',
				check: scores => scores.blue >= 24
			},
			{
				id: 'level-11-purple-expansion',
				description: 'Level 11: Scoor 24 punten in paars.',
				short: 'Level 11 - Paarse expansie',
				check: scores => scores.purple >= 24
			},
		],
		12: [
			{
				id: 'level-12-deep-roots',
				description: 'Level 12: Scoor 40 punten in groen (diepe wortels).',
				short: 'Level 12 - Diepe wortels',
				check: scores => scores.green >= 40
			},
			{
				id: 'level-12-red-connection',
				description: 'Level 12: Scoor 32 punten in rood (meerdere grids).',
				short: 'Level 12 - Rode verbinding',
				check: scores => scores.red >= 32
			},
			{
				id: 'level-12-yellow-precision',
				description: 'Level 12: Activeer alle boldcells in geel.',
				short: 'Level 12 - Gele precisie',
				check: () => {
					const yellowZone = document.getElementById('yellow-zone');
					if (!yellowZone) return false;
					const boldCells = yellowZone.querySelectorAll('.cell.bold-cell');
					const activeBoldCells = yellowZone.querySelectorAll('.cell.bold-cell.active');
					return boldCells.length > 0 && boldCells.length === activeBoldCells.length;
				}
			},
			{
				id: 'level-12-bonus-rush',
				description: 'Level 12: Verzamel 20 bonussen.',
				short: 'Level 12 - Bonus rush',
				check: scores => (scores?.bonusesCollected || 0) >= 20,
				progress: scores => {
					const collected = Math.max(0, Math.min(20, (scores?.bonusesCollected || 0)));
					return `${collected}/20`;
				}
			},
			{
				id: 'level-12-rainbow',
				description: 'Level 12: Scoor 18 punten elke kleur.',
				short: 'Level 12 - Regenboog',
				check: scores => scores.yellow >= 18 && scores.red >= 18 && scores.green >= 18 && scores.purple >= 18 && scores.blue >= 18
			}
		],
		13: [
			{
				id: 'level-13-mega-blue',
				description: 'Level 13: Scoor 40 punten in blauw.',
				short: 'Level 13 - Mega blauw',
				check: scores => scores.blue >= 40
			},
			{
				id: 'level-13-purple-perfect',
				description: 'Level 13: Scoor 40 punten in paars.',
				short: 'Level 13 - Paars 40 punten',
				check: scores => scores.purple >= 40
			},
			{
				id: 'level-13-green-giant',
				description: 'Level 13: Scoor 48 punten in groen.',
				short: 'Level 13 - Groene reus',
				check: scores => scores.green >= 48
			},
			{
				id: 'level-13-red-master',
				description: 'Level 13: Scoor 40 punten in rood.',
				short: 'Level 13 - Rood 40 punten',
				check: scores => scores.red >= 40
			},
			{
				id: 'level-13-yellow-artisan',
				description: 'Level 13: Voltooi 2 diagonale lijnen van minimaal 5 cellen in geel.',
				short: 'Level 13 - Gele artiest',
				check: () => {
					const yellowZone = document.getElementById('yellow-zone');
					if (!yellowZone) return false;
					const grid = yellowZone.querySelector('.grid');
					if (!grid) return false;
					const cells = Array.from(grid.querySelectorAll('.cell:not(.void-cell)'));
					// Group cells by diagonal index
					const diagGroups = {};
					cells.forEach(cell => {
						const diag = cell.dataset.diag;
						if (diag !== undefined) {
							if (!diagGroups[diag]) diagGroups[diag] = [];
							diagGroups[diag].push(cell);
						}
					});
					// Count how many diagonals have 6+ cells all active
					let completedDiagonals = 0;
					for (const diag of Object.keys(diagGroups)) {
						const diagCells = diagGroups[diag];
						if (diagCells.length >= 5) {
							const allActive = diagCells.every(c => c.classList.contains('active'));
							if (allActive) completedDiagonals++;
						}
					}
					return completedDiagonals >= 2;
				}
			}
		],
		14: [
			{
				id: 'level-14-total-score',
				description: 'Level 14: Scoor 160 punten totaal.',
				short: 'Level 14 - Totale score',
				check: scores => ((scores.yellow + scores.red + scores.green + scores.purple + scores.blue) + (scores?.bonus || 0)) >= 160
			},
			{
				id: 'level-14-balanced-power',
				description: 'Level 14: Scoor 30 punten in 4 verschillende kleuren.',
				short: 'Level 14 - Gebalanceerde kracht',
				check: scores => {
					const colorScores = [scores.yellow, scores.red, scores.green, scores.purple, scores.blue];
					return colorScores.filter(s => s >= 30).length >= 4;
				}
			},
			/* REMOVED BONUS OBJECTIVE AS REQUESTED */
			/*
			{
				id: 'level-14-bonus-master',
				description: 'Level 14: Verzamel 40+ bonuspunten.',
				short: 'Level 14 - Bonus meester',
				check: scores => scores.bonus >= 40,
				progress: scores => (scores.bonus >= 40 ? 'â­âœ”' : `â­${Math.max(0, scores.bonus)}/40`)
			},
			*/
			{
				id: 'level-14-blue-marathon',
				description: 'Level 14: Scoor 50 punten in blauw.',
				short: 'Level 14 - Blauwe marathon',
				check: scores => scores.blue >= 50
			},
			{
				id: 'level-14-multi-color-focus',
				description: 'Level 14: Scoor 42 punten in groen en paars.',
				short: 'Level 14 - Multi-kleur focus',
				check: scores => scores.green >= 42 && scores.purple >= 42
			}
		],
		15: [
			{
				id: 'level-15-trap-master',
				description: 'Level 15: Scoor 48 punten in groen en paars.',
				short: 'Level 15 - Val meester',
				check: scores => scores.purple >= 48 && scores.green >= 48
			},
			{
				id: 'level-15-green-legend',
				description: 'Level 15: Scoor 58 punten in groen.',
				short: 'Level 15 - Groene legende',
				check: scores => scores.green >= 58
			},
			{
				id: 'level-15-red-network',
				description: 'Level 15: Scoor 50 punten in rood.',
				short: 'Level 15 - Rood netwerk',
				check: scores => scores.red >= 50
			},
			{
				id: 'level-15-yellow-perfect',
				description: 'Level 15: Scoor 60 punten in geel.',
				short: 'Level 15 - Gele perfectie',
				check: scores => scores.yellow >= 60
			},
			{
				id: 'level-15-ultimate-balance',
				description: 'Level 15: Scoor 32 punten in elke kleur.',
				short: 'Level 15 - Ultieme balans',
				check: scores => scores.yellow >= 32 && scores.red >= 32 && scores.green >= 32 && scores.purple >= 32 && scores.blue >= 32
			}
		],
		16: [
			{
				id: 'level-16-total-domination',
				description: 'Level 16: Scoor 180 punten totaal.',
				short: 'Level 16 - Totale dominantie',
				check: scores => ((scores.yellow + scores.red + scores.green + scores.purple + scores.blue) + (scores?.bonus || 0)) >= 180
			},
			{
				id: 'level-16-blue-epic',
				description: 'Level 16: Scoor 60 punten in blauw.',
				short: 'Level 16 - Blauwe epic',
				check: scores => scores.blue >= 60
			},
			{
				id: 'level-16-purple-titan',
				description: 'Level 16: Scoor 60 punten in paars.',
				short: 'Level 16 - Paarse titaan',
				check: scores => scores.purple >= 60
			},
			{
				id: 'level-16-green-depths',
				description: 'Level 16: Scoor 65 punten in groen.',
				short: 'Level 16 - Groene dieptes',
				check: scores => scores.green >= 65
			},
			{
				id: 'level-16-bonus-legend',
				description: 'Level 16: Verzamel 25 bonuspunten.',
				short: 'Level 16 - Bonus legende',
				check: scores => scores.bonus >= 25,
				progress: scores => (scores.bonus >= 25 ? 'â­âœ”' : `â­${Math.max(0, scores.bonus)}/25`)
			}
		],
		17: [
			{
				id: 'level-17-red-empire',
				description: 'Level 17: Scoor 60 punten in rood.',
				short: 'Level 17 - Rood rijk',
				check: scores => scores.red >= 60
			},
			{
				id: 'level-17-four-pillars',
				description: 'Level 17: Scoor 48 punten in 4 verschillende kleuren.',
				short: 'Level 17 - Vier pilaren',
				check: scores => {
					const colorScores = [scores.yellow, scores.red, scores.green, scores.purple, scores.blue];
					return colorScores.filter(s => s >= 48).length >= 4;
				}
			},
			{
				id: 'level-17-yellow-architect',
				description: 'Level 17: Scoor 80 punten in geel.',
				short: 'Level 17 - Gele architect',
				check: scores => scores.yellow >= 80
			},
			{
				id: 'level-17-blue-odyssey',
				description: 'Level 17: Scoor 70 punten in blauw.',
				short: 'Level 17 - Blauwe odyssee',
				check: scores => scores.blue >= 70
			},
			{
				id: 'level-17-complete-mastery',
				description: 'Level 17: Scoor 48 punten elke kleur.',
				short: 'Level 17 - Complete meesterschap',
				check: scores => scores.yellow >= 48 && scores.red >= 48 && scores.green >= 48 && scores.purple >= 48 && scores.blue >= 48
			}
		],
		18: [
			{
				id: 'level-18-mega-score',
				description: 'Level 18: Scoor 200 punten totaal.',
				short: 'Level 18 - Mega score',
				check: scores => ((scores.yellow + scores.red + scores.green + scores.purple + scores.blue) + (scores?.bonus || 0)) >= 200
			},
			{
				id: 'level-18-green-abyss',
				description: 'Level 18: Scoor 70 punten in groen.',
				short: 'Level 18 - Groene afgrond',
				check: scores => scores.green >= 70
			},
			{
				id: 'level-18-purple-overlord',
				description: 'Level 18: Scoor 60 punten in paars.',
				short: 'Level 18 - Paarse overlord',
				check: scores => scores.purple >= 60
			},
			{
				id: 'level-18-red-megagrid',
				description: 'Level 18: Voltooi minstens 3 van de 4 rode grids.',
				short: 'Level 18 - Rood megagrid (3/4)',
				check: () => {
					const redZones = ['red-grid1-zone', 'red-grid2-zone', 'red-grid3-zone', 'red-grid4-zone'];
					let complete = 0;
					for (const id of redZones) {
						const zone = document.getElementById(id);
						if (!zone) continue;
						const cells = zone.querySelectorAll('.cell');
						const active = zone.querySelectorAll('.cell.active');
						if (cells.length > 0 && cells.length === active.length) complete += 1;
					}
					return complete >= 3;
				}
			},
			{
				id: 'level-18-bonus-titan',
				description: 'Level 18: Verzamel 30 bonuspunten.',
				short: 'Level 18 - Bonus titaan',
				check: scores => scores.bonus >= 30,
				progress: scores => (scores.bonus >= 30 ? 'â­âœ”' : `â­${Math.max(0, scores.bonus)}/30`)
			}
		],
		19: [
			{
				id: 'level-19-blue-legend',
				description: 'Level 19: Scoor 70 punten in blauw.',
				short: 'Level 19 - Blauwe legende',
				check: scores => scores.blue >= 70
			},
			{
				id: 'level-19-all-pillars',
				description: 'Level 19: Scoor 50 punten elke kleur.',
				short: 'Level 19 - Alle pilaren',
				check: scores => scores.yellow >= 50 && scores.red >= 50 && scores.green >= 50 && scores.purple >= 50 && scores.blue >= 50
			},
			{
				id: 'level-19-green-infinite',
				description: 'Level 19: Scoor 80 punten in groen.',
				short: 'Level 19 - Groene oneindigheid',
				check: scores => scores.green >= 80
			},
			{
				id: 'level-19-red-completion',
				description: 'Level 19: Scoor 60 punten in rood.',
				short: 'Level 19 - Rode voltooiing',
				check: scores => scores.red >= 60
			},
			{
				id: 'level-19-perfect-world',
				description: 'Level 19: Voltooi Ã©Ã©n zone perfect (alle cellen actief).',
				short: 'Level 19 - 1 perfecte zone',
				check: () => {
					const zoneIds = ['yellow-zone', 'purple-zone', 'blue-zone', 'green-zone'];
					return zoneIds.some(id => {
						const zone = document.getElementById(id);
						if (!zone) return false;
						const cells = zone.querySelectorAll('.cell');
						const active = zone.querySelectorAll('.cell.active');
						return cells.length > 0 && cells.length === active.length;
					});
				}
			}
		],
		20: [
			{
				id: 'level-20-ultimate',
				description: 'Level 20: Scoor 250 punten totaal (ultieme uitdaging).',
				short: 'Level 20 - Ultiem',
				check: scores => ((scores.yellow + scores.red + scores.green + scores.purple + scores.blue) + (scores?.bonus || 0)) >= 250
			},
			{
				id: 'level-20-perfect-balance',
				description: 'Level 20: Scoor 55 punten in elke kleur.',
				short: 'Level 20 - Perfecte balans',
				check: scores => scores.yellow >= 55 && scores.red >= 55 && scores.green >= 55 && scores.purple >= 55 && scores.blue >= 55,
				progress: scores => {
					const parts = [
						(scores.yellow >= 55 ? 'âœ”geel' : 'geel'),
						(scores.red >= 55 ? 'âœ”rood' : 'rood'),
						(scores.green >= 55 ? 'âœ”groen' : 'groen'),
						(scores.purple >= 55 ? 'âœ”paars' : 'paars'),
						(scores.blue >= 55 ? 'âœ”blauw' : 'blauw')
					];
					return parts.join(', ');
				}
			},
			{
				id: 'level-20-bonus-god',
				description: 'Level 20: Verzamel 30 bonuspunten.',
				short: 'Level 20 - Bonus god',
				check: scores => scores.bonus >= 30,
				progress: scores => (scores.bonus >= 30 ? 'â­âœ”' : `â­${Math.max(0, scores.bonus)}/30`)
			},
			{
				id: 'level-20-complete-all',
				description: 'Level 20: Voltooi minstens 2 zones volledig (alle cellen actief).',
				short: 'Level 20 - 2 volledige zones',
				check: () => {
					const colorZones = ['yellow-zone', 'purple-zone', 'blue-zone', 'green-zone'];
					const redZones = ['red-grid1-zone', 'red-grid2-zone', 'red-grid3-zone', 'red-grid4-zone'];
					let complete = 0;
					const isComplete = (zone) => {
						if (!zone) return false;
						const cells = zone.querySelectorAll('.cell');
						const active = zone.querySelectorAll('.cell.active');
						return cells.length > 0 && cells.length === active.length;
					};
					for (const id of colorZones) {
						const zone = document.getElementById(id);
						if (isComplete(zone)) complete += 1;
					}
					const redComplete = redZones.every(id => isComplete(document.getElementById(id)));
					if (redComplete) complete += 1;
					return complete >= 2;
				}
			},
			{
				id: 'level-20-world2-master',
				description: 'Level 20: Meester van Wereld 2 - Scoor 50 punten in elke kleur en haal 25+ bonus.',
				short: 'Level 20 - Wereld 2 meester',
				check: scores => {
					const colorScores = [scores.yellow, scores.red, scores.green, scores.purple, scores.blue];
					return colorScores.filter(s => s >= 50).length === 5 && scores.bonus >= 25;
				},
				progress: scores => {
					const parts = [
						(scores.yellow >= 50 ? 'âœ”geel' : 'geel'),
						(scores.red >= 50 ? 'âœ”rood' : 'rood'),
						(scores.green >= 50 ? 'âœ”groen' : 'groen'),
						(scores.purple >= 50 ? 'âœ”paars' : 'paars'),
						(scores.blue >= 50 ? 'âœ”blauw' : 'blauw'),
						(scores.bonus >= 25 ? 'â­âœ”' : 'â­' + scores.bonus)
					];
					return parts.join(', ');
				}
			}
		],
		// ========== WORLD 3: ULTIMATE CHALLENGE (Levels 21-30) ==========
		21: [
			{
				id: 'level-21-world3-intro',
				description: 'Level 21: Welkom in Wereld 3! Scoor 100 punten totaal.',
				short: 'Level 21 - Wereld 3 intro',
				check: scores => ((scores.yellow + scores.red + scores.green + scores.purple + scores.blue) + (scores?.bonus || 0)) >= 100
			},
			{
				id: 'level-21-blue-marathon',
				description: 'Level 21: Scoor 24 punten in blauw.',
				short: 'Level 21 - Blauwe marathon',
				check: scores => scores.blue >= 24
			},
			{
				id: 'level-21-green-explorer',
				description: 'Level 21: Scoor 30 punten in groen.',
				short: 'Level 21 - Groene verkenner',
				check: scores => scores.green >= 30
			},
			{
				id: 'level-21-balanced-champion',
				description: 'Level 21: Scoor 16 punten elke kleur.',
				short: 'Level 21 - Gebalanceerde kampioen',
				check: scores => scores.yellow >= 16 && scores.red >= 16 && scores.green >= 16 && scores.purple >= 16 && scores.blue >= 16,
				progress: scores => {
					const parts = [
						(scores.yellow >= 16 ? 'âœ”geel' : 'geel'),
						(scores.red >= 16 ? 'âœ”rood' : 'rood'),
						(scores.green >= 16 ? 'âœ”groen' : 'groen'),
						(scores.purple >= 16 ? 'âœ”paars' : 'paars'),
						(scores.blue >= 16 ? 'âœ”blauw' : 'blauw')
					];
					return parts.join(', ');
				}
			},
			{
				id: 'level-21-bonus-hunter',
				description: 'Level 21: Verzamel 24+ bonuspunten.',
				short: 'Level 21 - Bonus jager',
				check: scores => scores.bonus >= 24,
				progress: scores => (scores.bonus >= 24 ? 'âœ”' : `${Math.max(0, scores.bonus)}/24`)
			}
		],
		22: [
			{
				id: 'level-22-purple-domination',
				description: 'Level 22: Scoor 50 punten in paars.',
				short: 'Level 22 - Paarse dominantie',
				check: scores => scores.purple >= 50
			},
			{
				id: 'level-22-red-network',
				description: 'Level 22: Scoor 45 punten in rood.',
				short: 'Level 22 - Rood netwerk',
				check: scores => scores.red >= 45
			},
			{
				id: 'level-22-yellow-diamond',
				description: 'Level 22: Scoor 55 punten in geel.',
				short: 'Level 22 - Gele diamant',
				check: scores => scores.yellow >= 55
			},
			{
				id: 'level-22-coin-master',
				description: 'Level 22: Verzamel 15+ munten in dit level.',
				short: 'Level 22 - Munt meester',
				check: scores => getCollectedCoinCount(scores) >= 15,
				progress: scores => {
					const collected = Math.max(0, Math.min(15, getCollectedCoinCount(scores)));
					return `${collected}/15`;
				}
			},
			{
				id: 'level-22-dual-focus',
				description: 'Level 22: Scoor 40 punten in groen en blauw.',
				short: 'Level 22 - Dubbele focus',
				check: scores => scores.green >= 40 && scores.blue >= 40
			}
		],
		23: [
			{
				id: 'level-23-total-power',
				description: 'Level 23: Scoor 160 punten totaal.',
				short: 'Level 23 - Totale kracht',
				check: scores => ((scores.yellow + scores.red + scores.green + scores.purple + scores.blue) + (scores?.bonus || 0)) >= 160
			},
			{
				id: 'level-23-blue-split-master',
				description: 'Level 23: Scoor 60 punten in blauw.',
				short: 'Level 23 - Split meester',
				check: scores => scores.blue >= 60
			},
			{
				id: 'level-23-green-depth',
				description: 'Level 23: Scoor 80 punten in groen.',
				short: 'Level 23 - Groene diepte',
				check: scores => scores.green >= 80
			},
			{
				id: 'level-23-triple-threat',
				description: 'Level 23: Scoor 35 punten in 3 kleuren.',
				short: 'Level 23 - Drievoudige dreiging',
				check: scores => {
					const colorScores = [scores.yellow, scores.red, scores.green, scores.purple, scores.blue];
					return colorScores.filter(s => s >= 35).length >= 3;
				}
			},
			{
				id: 'level-23-purple-ring',
				description: 'Level 23: Voltooi de buitenste ring van paars.',
				short: 'Level 23 - Paarse ring',
				check: scores => scores.purple >= 45 && checkPurpleOuterRingComplete()
			}
		],
		24: [
			{
				id: 'level-24-extreme-balance',
				description: 'Level 24: Scoor 35 punten in elke kleur',
				short: 'Level 24 - Extreme balans',
				check: scores => scores.yellow >= 35 && scores.red >= 35 && scores.green >= 35 && scores.purple >= 35 && scores.blue >= 35,
				progress: scores => {
					const parts = [
						(scores.yellow >= 35 ? 'âœ”geel' : 'geel'),
						(scores.red >= 35 ? 'âœ”rood' : 'rood'),
						(scores.green >= 35 ? 'âœ”groen' : 'groen'),
						(scores.purple >= 35 ? 'âœ”paars' : 'paars'),
						(scores.blue >= 35 ? 'âœ”blauw' : 'blauw')
					];
					return parts.join(', ');
				}
			},
			{
				id: 'level-24-yellow-mastery',
				description: 'Level 24: Scoor 70 punten in geel.',
				short: 'Level 24 - Gele meesterschap',
				check: scores => scores.yellow >= 70
			},
			{
				id: 'level-24-red-empire',
				description: 'Level 24: Voltooi 3 van de 4 rode grids volledig.',
				short: 'Level 24 - Rood imperium',
				check: () => {
					const redZones = ['red-grid1-zone', 'red-grid2-zone', 'red-grid3-zone', 'red-grid4-zone'];
					let complete = 0;
					redZones.forEach(id => {
						const zone = document.getElementById(id);
						if (!zone) return;
						const cells = zone.querySelectorAll('.cell');
						const active = zone.querySelectorAll('.cell.active');
						if (cells.length > 0 && cells.length === active.length) complete++;
					});
					return complete >= 3;
				}
			},
			{
				id: 'level-24-bonus-rush',
				description: 'Level 24: Verzamel 30 bonussen.',
				short: 'Level 24 - Bonus rush',
				check: scores => (scores?.bonusesCollected || 0) >= 30,
				progress: scores => {
					const collected = Math.max(0, Math.min(30, (scores?.bonusesCollected || 0)));
					return `${collected}/30`;
				}
			},
			{
				id: 'level-24-blue-depths',
				description: 'Level 24: Scoor 75 punten in blauw.',
				short: 'Level 24 - Blauwe dieptes',
				check: scores => scores.blue >= 75
			}
		],
		25: [
			{
				id: 'level-25-halfway-champion',
				description: 'Level 25: Scoor 250 punten totaal.',
				short: 'Level 25 - Halverwege kampioen',
				check: scores => ((scores.yellow + scores.red + scores.green + scores.purple + scores.blue) + (scores?.bonus || 0)) >= 250
			},
			{
				id: 'level-25-quad-master',
				description: 'Level 25: Scoor 50 punten in 4 kleuren.',
				short: 'Level 25 - Viervoudige meester',
				check: scores => {
					const colorScores = [scores.yellow, scores.red, scores.green, scores.purple, scores.blue];
					return colorScores.filter(s => s >= 50).length >= 4;
				}
			},
			{
				id: 'level-25-green-legend',
				description: 'Level 25: Scoor 100 punten in groen.',
				short: 'Level 25 - Groene legende',
				check: scores => scores.green >= 100
			},
			{
				id: 'level-25-purple-complete',
				description: 'Level 25: Verbind de vier buitenste bold-cells in de paarse zone met actieve cellen.',
				short: 'Level 25 - Paars verbonden',
				check: () => {
					const purpleZone = document.getElementById('purple-zone');
					if (!purpleZone) return false;
					// Find bold corner cells by extremes of bold-cell coordinates
					const boldCells = Array.from(purpleZone.querySelectorAll('.cell.bold-cell:not(.void-cell)'));
					if (boldCells.length === 0) return false;
					const coords = boldCells.map(c => ({ x: Number(c.dataset.x), y: Number(c.dataset.y), el: c }));
					const xs = coords.map(c => c.x);
					const ys = coords.map(c => c.y);
					const minX = Math.min(...xs);
					const maxX = Math.max(...xs);
					const minY = Math.min(...ys);
					const maxY = Math.max(...ys);
					const cornerCoords = [[minX, minY], [minX, maxY], [maxX, minY], [maxX, maxY]];
					const cornerCells = cornerCoords.map(([x, y]) => purpleZone.querySelector(`.cell[data-x="${x}"][data-y="${y}"]`)).filter(Boolean);
					if (cornerCells.length !== 4) return false;
					// Require corner bold-cells to be active
					for (const c of cornerCells) if (!c.classList.contains('active')) return false;
					// Build set of active cell coordinates for BFS
					const activeSet = new Set(Array.from(purpleZone.querySelectorAll('.cell.active:not(.void-cell)')).map(c => `${c.dataset.x},${c.dataset.y}`));
					if (activeSet.size === 0) return false;
					const start = cornerCells[0];
					const startKey = `${start.dataset.x},${start.dataset.y}`;
					const queue = [startKey];
					const visited = new Set([startKey]);
					const neigh = [[1,0],[-1,0],[0,1],[0,-1]];
					while (queue.length) {
						const cur = queue.shift();
						const [cx, cy] = cur.split(',').map(Number);
						for (const [dx, dy] of neigh) {
							const nx = cx + dx;
							const ny = cy + dy;
							const key = `${nx},${ny}`;
							if (visited.has(key)) continue;
							if (!activeSet.has(key)) continue;
							visited.add(key);
							queue.push(key);
						}
					}
					// Ensure all other corner cells are reachable
					for (let i = 1; i < cornerCells.length; i++) {
						const k = `${cornerCells[i].dataset.x},${cornerCells[i].dataset.y}`;
						if (!visited.has(k)) return false;
					}
					return true;
				}
			},
			{
				id: 'level-25-coin-hoarder',
				description: 'Level 25: Verzamel 20+ munten.',
				short: 'Level 25 - Munt verzamelaar',
				check: scores => getCollectedCoinCount(scores) >= 20,
				progress: scores => {
					const collected = Math.max(0, Math.min(20, getCollectedCoinCount(scores)));
					return `${collected}/20`;
				}
			}
		],
		26: [
			{
				id: 'level-26-blue-infinity',
				description: 'Level 26: Scoor 100 punten in blauw.',
				short: 'Level 26 - Blauwe oneindigheid',
				check: scores => scores.blue >= 100
			},
			{
				id: 'level-26-all-reds',
				description: 'Level 26: Voltooi alle 4 rode grids volledig.',
				short: 'Level 26 - Alle roden',
				check: () => {
					const redZones = ['red-grid1-zone', 'red-grid2-zone', 'red-grid3-zone', 'red-grid4-zone'];
					return redZones.every(id => {
						const zone = document.getElementById(id);
						if (!zone) return false;
						const cells = zone.querySelectorAll('.cell');
						const active = zone.querySelectorAll('.cell.active');
						return cells.length > 0 && cells.length === active.length;
					});
				}
			},
			{
				id: 'level-26-extreme-yellow',
				description: 'Level 26: Scoor 85 punten in geel.',
				short: 'Level 26 - Extreem geel',
				check: scores => scores.yellow >= 85
			},
			{
				id: 'level-26-purple-titan',
				description: 'Level 26: Scoor 64 punten in paars.',
				short: 'Level 26 - Paarse titaan',
				check: scores => scores.purple >= 65
			},
			{
				id: 'level-26-five-colors',
				description: 'Level 26: Scoor 40 punten in elke kleur.',
				short: 'Level 26 - Vijf kleuren',
				check: scores => scores.yellow >= 40 && scores.red >= 40 && scores.green >= 40 && scores.purple >= 40 && scores.blue >= 40,
				progress: scores => {
					const parts = [
						(scores.yellow >= 40 ? 'âœ”geel' : 'geel'),
						(scores.red >= 40 ? 'âœ”rood' : 'rood'),
						(scores.green >= 40 ? 'âœ”groen' : 'groen'),
						(scores.purple >= 40 ? 'âœ”paars' : 'paars'),
						(scores.blue >= 40 ? 'âœ”blauw' : 'blauw')
					];
					return parts.join(', ');
				}
			}
		],
		27: [
			{
				id: 'level-27-mega-total',
				description: 'Level 27: Scoor 300 punten totaal.',
				short: 'Level 27 - Mega totaal',
				check: scores => ((scores.yellow + scores.red + scores.green + scores.purple + scores.blue) + (scores?.bonus || 0)) >= 300
			},
			{
				id: 'level-27-green-infinity',
				description: 'Level 27: Scoor 100 punten in groen.',
				short: 'Level 27 - Groene oneindigheid',
				check: scores => scores.green >= 100
			},
			{
				id: 'level-27-dual-domination',
				description: 'Level 27: Scoor 60 punten in geel en paars.',
				short: 'Level 27 - Dubbele dominantie',
				check: scores => scores.yellow >= 60 && scores.purple >= 60
			},
			{
				id: 'level-27-bonus-god',
				description: 'Level 27: Verzamel 30+ bonuspunten.',
				short: 'Level 27 - Bonus god',
				check: scores => scores.bonus >= 30,
				progress: scores => (scores.bonus >= 30 ? 'â­âœ”' : `â­${Math.max(0, scores.bonus)}/30`)
			},
			{
				id: 'level-27-red-perfection',
				description: 'Level 27: Scoor 60 punten in rood.',
				short: 'Level 27 - Rode perfectie',
				check: scores => scores.red >= 60
			}
		],
		28: [
			{
				id: 'level-28-ultimate-balance',
				description: 'Level 28: Scoor 50 punten in elke kleur',
				short: 'Level 28 - Ultieme balans',
				check: scores => scores.yellow >= 50 && scores.red >= 50 && scores.green >= 50 && scores.purple >= 50 && scores.blue >= 50,
				progress: scores => {
					const parts = [
						(scores.yellow >= 50 ? 'âœ”geel' : 'geel'),
						(scores.red >= 50 ? 'âœ”rood' : 'rood'),
						(scores.green >= 50 ? 'âœ”groen' : 'groen'),
						(scores.purple >= 50 ? 'âœ”paars' : 'paars'),
						(scores.blue >= 50 ? 'âœ”blauw' : 'blauw')
					];
					return parts.join(', ');
				}
			},
			{
				id: 'level-28-blue-master',
				description: 'Level 28: Scoor 120 punten in blauw.',
				short: 'Level 28 - Blauwe meester',
				check: scores => scores.blue >= 120
			},
			{
				id: 'level-28-yellow-emperor',
				description: 'Level 28: Scoor 100 punten in geel.',
				short: 'Level 28 - Gele keizer',
				check: scores => scores.yellow >= 100
			},
			{
				id: 'level-28-zone-complete',
				description: 'Level 28: Voltooi 2 zones volledig (alle cellen in geel, paars of groen).',
				short: 'Level 28 - Zone meester',
				check: () => {
					const zones = ['yellow-zone', 'purple-zone', 'green-zone'];
					let complete = 0;
					zones.forEach(id => {
						const zone = document.getElementById(id);
						if (!zone) return;
						const cells = zone.querySelectorAll('.cell');
						const active = zone.querySelectorAll('.cell.active');
						if (cells.length > 0 && cells.length === active.length) complete++;
					});
					return complete >= 2;
				}
			},
			{
				id: 'level-28-coin-emperor',
				description: 'Level 28: Verzamel 35+ munten.',
				short: 'Level 28 - Munt keizer',
				check: scores => getCollectedCoinCount(scores) >= 35,
				progress: scores => {
					const collected = Math.max(0, Math.min(35, getCollectedCoinCount(scores)));
					return `${collected}/35`;
				}
			}
		],
		29: [
			{
				id: 'level-29-penultimate',
				description: 'Level 29: Op naar de finale! Scoor 350+ punten totaal.',
				short: 'Level 29 - Bijna daar',
				check: scores => ((scores.yellow + scores.red + scores.green + scores.purple + scores.blue) + (scores?.bonus || 0)) >= 350
			},
			{
				id: 'level-29-green-god',
				description: 'Level 29: Scoor 150 punten in groen.',
				short: 'Level 29 - Groene god',
				check: scores => scores.green >= 150
			},
			{
				id: 'level-29-triple-60',
				description: 'Level 29: Scoor 90 punten in 3 kleuren naar keuze.',
				short: 'Level 29 - Triple 90',
				check: scores => {
					const colorScores = [scores.yellow, scores.red, scores.green, scores.purple, scores.blue];
					return colorScores.filter(s => s >= 90).length >= 3;
				}
			},
			{
				id: 'level-29-all-zones-active',
				description: 'Level 29: Activeer minstens 75% van alle zones.',
				short: 'Level 29 - Activatie expert',
				check: () => {
					const zones = ['yellow-zone', 'purple-zone', 'blue-zone', 'green-zone', 
								   'red-grid1-zone', 'red-grid2-zone', 'red-grid3-zone', 'red-grid4-zone', 'red-grid5-zone', 'red-grid6-zone'];
					let totalCells = 0;
					let activeCells = 0;
					zones.forEach(id => {
						const zone = document.getElementById(id);
						if (!zone) return;
						const cells = zone.querySelectorAll('.cell');
						const active = zone.querySelectorAll('.cell.active');
						totalCells += cells.length;
						activeCells += active.length;
					});
					return totalCells > 0 && (activeCells / totalCells) >= 0.75;
				}
			},
			{
				id: 'level-29-bonus-master',
				description: 'Level 29: Verzamel 40+ bonuspunten.',
				short: 'Level 29 - Bonus meester',
				check: scores => scores.bonus >= 40,
				progress: scores => (scores.bonus >= 40 ? 'â­âœ”' : `â­${Math.max(0, scores.bonus)}/40`)
			}
		],
		30: [
			{
				id: 'level-30-ultimate-champion',
				description: 'Level 30: FINALE! Scoor 400+ punten totaal.',
				short: 'Level 30 - Ultieme kampioen',
				check: scores => ((scores.yellow + scores.red + scores.green + scores.purple + scores.blue) + (scores?.bonus || 0)) >= 400
			}
		]
	};

	// Generate objectives array with random selection per level
	const OBJECTIVES = [];
	for (let level = 1; level <= 30; level++) { // Uitgebreid naar level 30 voor World 3
		const templates = OBJECTIVE_TEMPLATES[level] || [];
		if (templates.length > 0) {
			// Pick a random objective from the 5 available for this level
			const randomIndex = Math.floor(Math.random() * templates.length);
			const selected = templates[randomIndex];
			OBJECTIVES.push({
				...selected,
				level: level
			});
		}
	}

	let currentObjectiveId = null;
	const completedObjectives = [];
	const completedObjectiveIds = new Set();

	/* ============================================
	   DOELEN (OBJECTIVES) FUNCTIES
	   ============================================
	   Houdt bij welke doelen actief/voltooid zijn
	   Doelen geven extra uitdaging en structuur aan het spel
	*/
	function getObjectiveById(id) {
		if (!id) return null;
		return OBJECTIVES.find(obj => obj.id === id) || null;
	}

	// Parse a Dutch free-text objective (e.g. "Haal 50 punten bij geel" or "Haal 10 punten bij alle kleuren")
	// and return an objective-like object with a `.check(scores)` function.
	function parseObjectiveTextToObjective(text) {
		const raw = (text == null) ? '' : String(text || '').trim();
		const s = raw.toLowerCase();
		// detect numeric target
		const numMatch = s.match(/(\d{1,5})/);
		const target = numMatch ? parseInt(numMatch[1], 10) : null;
		const colorMap = { 'geel':'yellow', 'rood':'red', 'groen':'green', 'paars':'purple', 'blauw':'blue' };
		// find mentioned colors
		const colors = [];
		if (/alle kleuren|bij alle kleuren|alle kleur/.test(s)) {
			Object.keys(colorMap).forEach(k => colors.push(colorMap[k]));
		} else {
			Object.keys(colorMap).forEach(dutch => { if (s.indexOf(dutch) !== -1) colors.push(colorMap[dutch]); });
		}
		// determine if this is a total-target (in totaal) or per-color
		const wantsTotal = /totaal|in totaal|samen|alles samen/.test(s) && !!target;

		const id = `custom:${Date.now().toString(36)}:${Math.random().toString(36).slice(2,8)}`;
		const description = raw || '';
		const short = raw.length > 40 ? raw.slice(0,40) + '...' : raw;

		// Helper: produce a live snapshot of scores from provided object or from the DOM if omitted
		function getCurrentScores(provided) {
			const dutchToKey = { 'geel':'yellow', 'rood':'red', 'groen':'green', 'paars':'purple', 'blauw':'blue' };
			const snapshot = { yellow:0, red:0, green:0, purple:0, blue:0, bonus: (typeof bonus === 'number' ? bonus : 0), bonusesCollected: (typeof totalBonusesCollected === 'number' ? totalBonusesCollected : 0) };
			// If caller provided explicit snapshot, merge it over defaults
			if (provided && typeof provided === 'object') {
				Object.keys(snapshot).forEach(k => { if (provided[k] != null) snapshot[k] = provided[k]; });
				if (provided.total != null) snapshot.total = provided.total;
				return snapshot;
			}
			// Fallback to global numeric variables if present (these are updated during score calc)
			try {
				if (typeof yellow === 'number') snapshot.yellow = yellow;
				if (typeof red === 'number') snapshot.red = red;
				if (typeof green === 'number') snapshot.green = green;
				if (typeof purple === 'number') snapshot.purple = purple;
				if (typeof blue === 'number') snapshot.blue = blue;
			} catch (e) {}
			// If globals are zero-ish, try DOM counts (useful in some edge cases)
			try {
				Object.keys(dutchToKey).forEach(dutch => {
					const key = dutchToKey[dutch];
					if (snapshot[key] && snapshot[key] > 0) return;
					let count = 0;
					const nodes = document.querySelectorAll(`.zone[data-color="${dutch}"] .cell.active`);
					if (nodes && nodes.length) count = nodes.length;
					if (!count) {
						const alt = document.querySelectorAll(`#${key}-grid .cell.active`);
						if (alt && alt.length) count = alt.length;
					}
					if (count) snapshot[key] = count;
				});
			} catch (e) {}
			snapshot.total = (typeof snapshot.total === 'number') ? snapshot.total : (snapshot.yellow + snapshot.red + snapshot.green + snapshot.purple + snapshot.blue + (snapshot.bonus || 0));
			return snapshot;
		}

		function computeTotalFromScores(scores) {
			const s = getCurrentScores(scores);
			return (typeof s.total === 'number') ? s.total : 0;
		}

		// build check function
		let check;
		if (!target) {
			check = () => false;
		} else if (wantsTotal || colors.length === 0) {
			check = (scores) => {
				const total = computeTotalFromScores(scores);
				return total >= target;
			};
		} else {
			// per-color: ensure all mentioned colors meet the target
			const uniqColors = Array.from(new Set(colors));
			check = (scores) => {
				const s = getCurrentScores(scores);
				return uniqColors.every(c => (s[c] || 0) >= target);
			};
		}

		// progress helper returns a short progress string
		function progress(scores) {
			if (!target) return '';
			const s = getCurrentScores(scores);
			if (wantsTotal || colors.length === 0) {
				const total = computeTotalFromScores(s);
				return `${Math.min(total, target)}/${target}`;
			}
			const cols = Array.from(new Set(colors));
			const vals = cols.map(c => (s[c] || 0));
			const minv = Math.min.apply(null, vals.concat([0]));
			return `${Math.min(minv, target)}/${target}`;
		}

		return {
			id,
			description,
			short,
			check,
			progress
		};
	}

	function getObjectiveForLevel(level) {
		return OBJECTIVES.find(obj => obj.level === level) || null;
	}

	function isObjectiveCompleted(id) {
		return !!(id && completedObjectiveIds.has(id));
	}

	function isCurrentObjectiveCompleted() {
		const objective = getObjectiveById(currentObjectiveId);
		if (!objective) return true;
		const snapshot = latestScoreSnapshot || {
			yellow,
			red,
			green,
			purple,
			blue,
			bonus,
			bonusesCollected: totalBonusesCollected,
			total: yellow + red + green + purple + blue + bonus
		};
		try {
			return !!objective.check(snapshot);
		} catch (error) {
			console.warn('Objective check failed', objective.id, error);
			return false;
		}
	}

	function setCurrentObjectiveForLevel(level) {
		const objective = getObjectiveForLevel(level);
		currentObjectiveId = objective ? objective.id : null;
		renderObjectivePanel();
	}
	let objectiveToastTimeout = null;

	/* ============================================
	   DRAG & DROP VARIABELEN
	   ============================================
	   Globale state voor het slepen van kaarten/bonussen
	*/
	let draggedBlock = null;
	// Version marker to help verify deployed updates on GitHub Pages
	window.__locusVersion = window.__locusVersion || '2025-12-29-patch1';
	console.debug && console.debug('Locus version:', window.__locusVersion);
	let draggedShape = null;
	let draggedColor = null;
	let isPointerDragging = false;
	let dragPointerId = null;
	let dragStartClientX = 0;
	let dragStartClientY = 0;
	let dragHasMoved = false;
	let rotateButton = null;
	let mirrorButton = null;
	let startX = 0;
	let startY = 0;
	let offsetX = 0; 
	let offsetY = 0;
	let lastZone = null;
	let lastBaseX = null;
	let lastBaseY = null;
	let skipNextZoneClick = false;
	let bonusCoinMilestones = 0;
	let activeTraps = [];
	let trapIdCounter = 0;
	let lastTrapHighlightId = null;

	function getBoardCellMetrics() {
		// Measure the *rendered* board cell size (accounts for transforms / scaling).
		let cellSizePx = 26;
		try {
			const sampleCell = document.querySelector('#board .grid .cell:not(.void-cell)');
			if (sampleCell) {
				const rect = sampleCell.getBoundingClientRect();
				cellSizePx = Math.min(rect.width, rect.height) || cellSizePx;
			} else {
				cellSizePx = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--cell-size')) || cellSizePx;
			}
		} catch {
			// keep default
		}

		let gapPx = 0;
		try {
			gapPx = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--board-grid-gap')) || 0;
		} catch {
			gapPx = 0;
		}

		return {
			cellSize: cellSizePx,
			gap: gapPx,
			step: cellSizePx + gapPx
		};
	}

	function computeShapeCenterOffsets(shape, cellSize = null) {
			try {
				if (!shape || !shape.length || !shape[0] || !shape[0].length) {
					return { offsetX: 0, offsetY: 0 };
				}
				const metrics = getBoardCellMetrics();
				// If a specific cellSize was passed, use it (gap assumed 0). Otherwise
				// when zoomed-in measure the actual cell size from the active zoom
				// zone so offsets align with the rendered draggable.
				const measuredRoot = (document.body.classList.contains('zoomed-in') && typeof activeZoomZone !== 'undefined' && activeZoomZone) ? activeZoomZone : null;
				const resolvedCellSize = Number.isFinite(cellSize) ? Number(cellSize) : getActualCellSize(measuredRoot) || metrics.cellSize;
				const resolvedGap = Number.isFinite(cellSize) ? 0 : metrics.gap;
				const resolvedStep = resolvedCellSize + resolvedGap;

			const shapeHeight = shape.length;
			const shapeWidth = shape[0].length;
			let minX = shapeWidth, maxX = -1, minY = shapeHeight, maxY = -1;
			for (let y = 0; y < shapeHeight; y++) {
				for (let x = 0; x < shapeWidth; x++) {
					if (shape[y][x]) {
						minX = Math.min(minX, x);
						maxX = Math.max(maxX, x);
						minY = Math.min(minY, y);
						maxY = Math.max(maxY, y);
					}
				}
			}
			if (maxX < 0 || maxY < 0) {
				return { offsetX: (shapeWidth * resolvedStep) / 2, offsetY: (shapeHeight * resolvedStep) / 2 };
			}
			const filledWidth = (maxX - minX + 1);
			const filledHeight = (maxY - minY + 1);
			// Center between first/last filled cell centers, accounting for grid gap.
			const centerCol = minX + (filledWidth - 1) / 2;
			const centerRow = minY + (filledHeight - 1) / 2;
			return {
				offsetX: (centerCol * resolvedStep) + (resolvedCellSize / 2),
				offsetY: (centerRow * resolvedStep) + (resolvedCellSize / 2)
			};
		} catch {
			return { offsetX: 0, offsetY: 0 };
		}
	}

	function beginPointerDrag({ clientX = 0, clientY = 0, pointerId = null } = {}) {
		isPointerDragging = true;
		dragPointerId = (pointerId !== undefined && pointerId !== null) ? pointerId : null;
		dragStartClientX = Number(clientX) || 0;
		dragStartClientY = Number(clientY) || 0;
		dragHasMoved = false;
		// Clear any stale hover/placement state so pointerup can't place immediately.
		lastZone = null;
		lastBaseX = lastBaseY = null;
	}

	function endPointerDragTracking() {
		isPointerDragging = false;
		dragPointerId = null;
		dragHasMoved = false;
	}

	/* ============================================
	   BONUS SYSTEEM
	   ============================================
	   Bonussen zijn speciale power-ups per kleur
	   Elk 10 punten op een kleur = 1 bonus
	   Bonussen kunnen gebruikt worden voor extra plaatsingen
	*/
	const BONUS_ORDER = ['yellow', 'red', 'green', 'purple', 'blue'];
	const BONUS_COLOR_CONFIG = {
		yellow: { label: 'Geel', colorName: 'geel', colorCode: '#cfba51' },
		red: { label: 'Rood', colorName: 'rood', colorCode: '#b56069' },
		green: { label: 'Groen', colorName: 'groen', colorCode: '#92c28c' },
		purple: { label: 'Paars', colorName: 'paars', colorCode: '#8f76b8' },
		blue: { label: 'Blauw', colorName: 'blauw', colorCode: '#5689b0' }
	};
	const BONUS_UPGRADE_COSTS = {
		yellow: 6,
		red: 6,
		green: 6,
		purple: 6,
		blue: 6
	};
	const bonusInventory = BONUS_ORDER.reduce((acc, key) => {
		acc[key] = 0;
		return acc;
	}, {});
	const bonusMasteryState = BONUS_ORDER.reduce((acc, key) => {
		acc[key] = false;
		return acc;
	}, {});
	const BONUS_SHAPES = {
		default: [[1], [1]],
		red: [[1]]
	};
	let activeBonusPlacement = null;
	
	// Free placement system
	let freePlacementsRemaining = 0;

	function isBonusUpgraded(colorKey) {
		return !!bonusMasteryState[colorKey];
	}

	function setBonusUpgraded(colorKey, upgraded = true) {
		if (!BONUS_COLOR_CONFIG[colorKey]) return;
		bonusMasteryState[colorKey] = !!upgraded;
	}

	function getBonusMeta(colorKey) {
		return BONUS_COLOR_CONFIG[colorKey] || null;
	}

	function getBonusShape(colorKey) {
		const upgraded = isBonusUpgraded(colorKey);
		if (colorKey && BONUS_SHAPES[colorKey]) {
			const base = cloneShape(BONUS_SHAPES[colorKey]);
			if (upgraded) {
				base.push([2]);
			}
			return base;
		}
		const base = cloneShape(BONUS_SHAPES.default);
		if (upgraded) {
			base.push([2]);
		}
		return base;
	}

	function checkPurpleOuterRingComplete() {
			const grid = document.getElementById('purple-grid');
			if (!grid) return false;
			const cells = Array.from(grid.querySelectorAll('.cell'));
			if (!cells.length) return false;
			const cols = parseInt(grid.dataset.cols || '0', 10) || (() => {
				const computed = getComputedStyle(grid).gridTemplateColumns;
				return computed ? computed.split(/\s+/).length : Math.round(Math.sqrt(cells.length)) || 1;
			})();
			const rows = parseInt(grid.dataset.rows || '0', 10) || Math.ceil(cells.length / cols);
			if (!cols || !rows) return false;
			for (let index = 0; index < cells.length; index += 1) {
				const row = Math.floor(index / cols);
				const col = index % cols;
				if (row === 0 || col === 0 || row === rows - 1 || col === cols - 1) {
					if (!cells[index].classList.contains('active')) {
						return false;
					}
				}
			}
			return true;
		}

		function checkYellowFullRows(targetColumns = 1) {
			const yellowConfig = window.yellowGridConfig || {};
			if (yellowConfig.scoreMode === 'diagonal') {
				const scoredSegments = window.scoredYellowSegments || window.scoredYellowDiagonals;
				return scoredSegments instanceof Set && scoredSegments.size >= targetColumns;
			}
			const scoredColumns = window.scoredYellowColumns;
			return scoredColumns instanceof Set && scoredColumns.size >= targetColumns;
		}

		function showObjectiveToast(message) {
			if (!message) return;
			let toast = document.querySelector('.objective-toast');
			if (!toast) {
				toast = document.createElement('div');
				toast.className = 'objective-toast';
				document.body.appendChild(toast);
			}
			// Render diamond glyph with special styling when present
			try {
				const safe = String(message).replace(/â™¦/g, '<span class="diamond-glyph">â™¦</span>');
				toast.innerHTML = safe;
			} catch (e) {
				toast.textContent = message;
			}
			toast.classList.add('show');
			if (objectiveToastTimeout) clearTimeout(objectiveToastTimeout);
			objectiveToastTimeout = setTimeout(() => {
				toast.classList.remove('show');
			}, 2400);
		}

		function stripObjectiveSymbols(text) {
			if (text == null) return '';
			let t = String(text);
			// Remove common emoji/symbol ranges + variation selectors.
			try {
				t = t.replace(/[\uFE0E\uFE0F]/g, '');
				t = t.replace(/[\u200D]/g, '');
				t = t.replace(/[\u2600-\u27BF]/g, '');
				t = t.replace(/[\u{1F000}-\u{1FAFF}]/gu, '');
			} catch {
				t = t.replace(/[\uFE0E\uFE0F\u200D\u2600-\u27BF]/g, '');
			}
			return t.replace(/\s{2,}/g, ' ').trim();
		}

		function normalizeObjectiveProgress(progressText) {
			let p = stripObjectiveSymbols(progressText);
			if (!p) return '';
			// If progress starts with "n/m ...", keep only "n/m".
			const m = p.match(/^\s*(\d+)\s*\/\s*(\d+)(?:\s+.*)?$/);
			if (m) return `${m[1]}/${m[2]}`;
			return p;
		}

		function renderObjectivePanel(snapshot = latestScoreSnapshot) {
			// If a custom board with metadata was loaded, show a compiled objective and its progress
			if (window && window.loadedCustomLevelMeta && (window.loadedCustomLevelMeta.name || window.loadedCustomLevelMeta.objective)) {
				const titleEl = document.querySelector('#objective-zone h2');
				const currentEl = document.getElementById('objective-current');
				if (titleEl && window.loadedCustomLevelMeta.name) titleEl.textContent = window.loadedCustomLevelMeta.name;
				const objText = (window.loadedCustomLevelMeta.objective || '').trim() || 'Haal 100 punten';
				const compiled = window.loadedCustomObjectiveCompiled || parseObjectiveTextToObjective(objText);
				const progressSource = snapshot || {
					yellow,
					red,
					green,
					purple,
					blue,
					bonus,
					bonusesCollected: totalBonusesCollected,
					total: yellow + red + green + purple + blue + bonus
				};
				let done = false;
				try { done = !!compiled.check(progressSource); } catch (e) { done = false; }
				if (currentEl) {
					currentEl.classList.toggle('objective-empty-state', false);
					if (done) {
						currentEl.innerHTML = `<strong>Doel:</strong> ${stripObjectiveSymbols(compiled.description)} <span style="opacity: 0.85;">(voltooid)</span>`;
					} else {
						let desc = stripObjectiveSymbols(compiled.description);
						if (typeof compiled.progress === 'function') {
							try {
								const p = normalizeObjectiveProgress(compiled.progress(progressSource));
								if (p) desc = `${desc} (${p})`;
							} catch (err) { /* ignore */ }
						}
						currentEl.innerHTML = `<strong>Doel:</strong> ${desc}`;
					}
				}
				return;
			}
			const currentEl = document.getElementById('objective-current');
			const historyEl = document.getElementById('objective-history');
			const titleEl = document.querySelector('#objective-zone h2');
			if (!currentEl || !historyEl) return;
			
			// Update titel met level nummer EN world indicator
			if (titleEl) {
				const { world, subLevel } = getWorldAndSubLevel(currentLevel);
				if (world === 1) {
					titleEl.textContent = `Level ${currentLevel}`;
					titleEl.style.background = '';
					titleEl.style.webkitBackgroundClip = '';
					titleEl.style.webkitTextFillColor = '';
				} else if (world === 2) {
					titleEl.textContent = `Wereld ${world} - Level ${world}.${subLevel}`;
					titleEl.style.background = 'linear-gradient(135deg, #5689b0, #8f76b8)';
					titleEl.style.webkitBackgroundClip = 'text';
					titleEl.style.webkitTextFillColor = 'transparent';
				} else if (world === 3) {
					titleEl.textContent = `Wereld ${world} - Level ${world}.${subLevel}`;
					titleEl.style.background = 'linear-gradient(135deg, #ff6b35, #f7931e, #ffcc02)';
					titleEl.style.webkitBackgroundClip = 'text';
					titleEl.style.webkitTextFillColor = 'transparent';
				} else {
					titleEl.textContent = `Wereld ${world} - Level ${world}.${subLevel}`;
					titleEl.style.background = 'linear-gradient(135deg, #5689b0, #8f76b8)';
					titleEl.style.webkitBackgroundClip = 'text';
					titleEl.style.webkitTextFillColor = 'transparent';
				}
			}

			historyEl.innerHTML = '';
			const objective = getObjectiveById(currentObjectiveId);
			if (!objective) {
				currentEl.classList.add('objective-empty-state');
				currentEl.textContent = 'Geen actief doel voor dit level.';
			} else {
				const progressSource = snapshot || {
					yellow,
					red,
					green,
					purple,
					blue,
					bonus,
					bonusesCollected: totalBonusesCollected,
					total: yellow + red + green + purple + blue + bonus
				};
				let isDone = false;
				try {
					isDone = !!objective.check(progressSource);
				} catch (error) {
					console.warn('Objective check failed', objective.id, error);
					isDone = false;
				}
				currentEl.classList.toggle('objective-empty-state', false);
				if (isDone) {
					// Voeg vinkje toe voor voltooide doelen, verwijder "Level X:" uit description
					let desc = objective.description.replace(/^Level\s+\d+:\s*/i, '');
					desc = stripObjectiveSymbols(desc);
					currentEl.innerHTML = `<strong>Doel:</strong> ${desc} <span style="opacity: 0.85;">(voltooid)</span>`;
				} else {
					let description = objective.description.replace(/^Level\s+\d+:\s*/i, '');
					description = stripObjectiveSymbols(description);
					if (typeof objective.progress === 'function') {
						try {
							const progressText = normalizeObjectiveProgress(objective.progress(progressSource));
							if (progressText) description = `${description} (${progressText})`;
						} catch (error) {
							console.warn('Objective progress failed', objective.id, error);
						}
					}
					currentEl.innerHTML = `<strong>Doel:</strong> ${description}`;
				}
			}

			// Verberg "nog geen doelen voltooid" op desktop
			if (completedObjectives.length === 0) {
				// Laat leeg op desktop
				historyEl.innerHTML = '';
			} else {
				completedObjectives.forEach(obj => {
					const item = document.createElement('li');
					const raw = obj.short || obj.description;
					item.textContent = stripObjectiveSymbols(String(raw || '').replace(/^Level\s+\d+:\s*/i, ''));
					historyEl.appendChild(item);
				});
			}
		}

		function resetObjectives() {
			currentObjectiveId = null;
			completedObjectives.length = 0;
			completedObjectiveIds.clear();
			latestScoreSnapshot = null;
			if (objectiveToastTimeout) {
				clearTimeout(objectiveToastTimeout);
				objectiveToastTimeout = null;
			}
			const toast = document.querySelector('.objective-toast');
			if (toast) toast.classList.remove('show');
			// Reset UI visueel
			const checkmark = document.querySelector('#objective-status');
			if (checkmark) checkmark.textContent = '';
			// Reset objective highlights
			clearObjectiveHighlights();
			renderObjectivePanel();
		}

		function updateObjectives(scores) {
			// If a custom board was loaded with a free-text objective, evaluate that first
			if (window && window.loadedCustomLevelMeta && window.loadedCustomLevelMeta.objective) {
				const compiled = window.loadedCustomObjectiveCompiled || parseObjectiveTextToObjective(window.loadedCustomLevelMeta.objective || '');
				const snapshotCustom = scores || latestScoreSnapshot || {
					yellow,
					red,
					green,
					purple,
					blue,
					bonus,
					bonusesCollected: totalBonusesCollected,
					total: yellow + red + green + purple + blue + bonus
				};
				latestScoreSnapshot = snapshotCustom;
				let achievedCustom = false;
				try { achievedCustom = !!compiled.check(snapshotCustom); } catch (e) { achievedCustom = false; }
				if (achievedCustom) {
					if (!window.loadedCustomLevelMetaCompleted) {
						window.loadedCustomLevelMetaCompleted = true;
						showObjectiveToast(`Doel behaald: ${compiled.short || compiled.description}`);
					}
				} else if (window.loadedCustomLevelMetaCompleted) {
					window.loadedCustomLevelMetaCompleted = false;
				}
				renderObjectivePanel(snapshotCustom);
				return;
			}
			const objective = getObjectiveById(currentObjectiveId);
			if (!objective) {
				renderObjectivePanel();
				return;
			}
			if (objective.level && objective.level !== currentLevel) {
				renderObjectivePanel();
				return;
			}
			const snapshot = scores || latestScoreSnapshot || {
				yellow,
				red,
				green,
				purple,
				blue,
				bonus,
				bonusesCollected: totalBonusesCollected,
				total: yellow + red + green + purple + blue + bonus
			};
			latestScoreSnapshot = snapshot;
			let achieved = false;
			try {
				achieved = !!objective.check(snapshot);
			} catch (error) {
				console.warn('Objective check failed', objective.id, error);
				return;
			}
			if (achieved) {
				if (!completedObjectiveIds.has(objective.id)) {
					completedObjectiveIds.add(objective.id);
					completedObjectives.push(objective);
					showObjectiveToast(`Doel behaald: ${objective.short || objective.description}`);
				}
			} else if (completedObjectiveIds.has(objective.id)) {
				// Objective can become un-achieved (e.g. undo). Keep UI/state in sync.
				completedObjectiveIds.delete(objective.id);
				const idx = completedObjectives.findIndex(obj => obj && obj.id === objective.id);
				if (idx >= 0) completedObjectives.splice(idx, 1);
			}
			renderObjectivePanel(snapshot);
		}

	function highlightAchievedObjectiveScores(scores) {
		// If a custom loaded objective exists, use that description for highlighting
		let objectiveDesc = null;
		let objectiveId = null;
		if (window && window.loadedCustomLevelMeta && window.loadedCustomLevelMeta.objective) {
			objectiveDesc = window.loadedCustomLevelMeta.objective || '';
			objectiveId = window.loadedCustomLevelMeta.name || 'custom';
		} else {
			const objective = getObjectiveById(currentObjectiveId);
			if (!objective) { clearObjectiveHighlights(); return; }
			objectiveDesc = objective.description || '';
			objectiveId = objective.id || '';
		}
		
		// Eerst alle highlights verwijderen
		clearObjectiveHighlights();
		
		// Controleer welke scores voldoen aan de objective eisen
		// Parse de objective beschrijving om score eisen te vinden
		// Check voor totaal score eisen (meer varianten ondersteunen)
		const extractMinTotal = (desc) => {
			if (!desc) return null;
			const s = String(desc);
			let m;
			m = s.match(/(\d+)\s*(?:punten|pt)\s*(?:totaal|in\s*totaal)/i);
			if (m) return parseInt(m[1], 10);
			m = s.match(/(?:totaal|in\s*totaal|totale\s*score|score\s*totaal|totaalscore)\s*(?:van\s*)?(\d+)/i);
			if (m) return parseInt(m[1], 10);
			return null;
		};
		const minTotal = extractMinTotal(objectiveDesc);
		if (Number.isFinite(minTotal) && scores.total >= minTotal) {
			const totalEl = document.querySelector('#scoreboard .score-total');
			if (totalEl) totalEl.classList.add('objective-achieved');
		}
		
		// Check voor kleur specifieke eisen (ondersteunt ook: "paarse zone", "gele" etc)
		const pickNumber = (m) => {
			if (!m) return null;
			const raw = (m[1] != null ? m[1] : null) || (m[2] != null ? m[2] : null);
			const n = raw != null ? parseInt(raw, 10) : NaN;
			return Number.isFinite(n) ? n : null;
		};
		const colorPatterns = [
			{ name: 'yellow', regex: /(?:in\s*(?:de\s*)?(?:gele|geel)(?:\s*zone)?\s*(?:minstens\s*)?(\d+)\s*(?:punten|pt)?)|(\d+)\s*(?:punten|pt)?\s*(?:in\s*)?(?:de\s*)?(?:gele|geel)(?:\s*zone)?/i },
			{ name: 'red', regex: /(?:in\s*(?:de\s*)?(?:rode|rood)(?:\s*zone)?\s*(?:minstens\s*)?(\d+)\s*(?:punten|pt)?)|(\d+)\s*(?:punten|pt)?\s*(?:in\s*)?(?:de\s*)?(?:rode|rood)(?:\s*zone)?/i },
			{ name: 'green', regex: /(?:in\s*(?:de\s*)?(?:groene|groen)(?:\s*zone)?\s*(?:minstens\s*)?(\d+)\s*(?:punten|pt)?)|(\d+)\s*(?:punten|pt)?\s*(?:in\s*)?(?:de\s*)?(?:groene|groen)(?:\s*zone)?/i },
			{ name: 'purple', regex: /(?:in\s*(?:de\s*)?(?:paarse|paars)(?:\s*zone)?\s*(?:minstens\s*)?(\d+)\s*(?:punten|pt)?)|(\d+)\s*(?:punten|pt)?\s*(?:in\s*)?(?:de\s*)?(?:paarse|paars)(?:\s*zone)?/i },
			{ name: 'blue', regex: /(?:in\s*(?:de\s*)?(?:blauwe|blauw)(?:\s*zone)?\s*(?:minstens\s*)?(\d+)\s*(?:punten|pt)?)|(\d+)\s*(?:punten|pt)?\s*(?:in\s*)?(?:de\s*)?(?:blauwe|blauw)(?:\s*zone)?/i }
		];
		
		colorPatterns.forEach(({ name, regex }) => {
			const match = objectiveDesc.match(regex);
			const minScore = pickNumber(match);
			if (Number.isFinite(minScore) && scores[name] >= minScore) {
				const row = document.querySelector(`.score-row.${name}`);
				if (row) row.classList.add('objective-achieved');
			}
		});
		
		// Check voor "minstens X in elke kleur" patronen
		const allColorsMatch = objectiveDesc.match(/minstens\s*(\d+)\s*(?:punten|pt)?\s*(?:in\s*)?(?:de\s*kleuren|elke\s*kleur)/i);
		if (allColorsMatch) {
			const minScore = parseInt(allColorsMatch[1], 10);
			['yellow', 'red', 'green', 'purple', 'blue'].forEach(color => {
				if (scores[color] >= minScore) {
					const row = document.querySelector(`.score-row.${color}`);
					if (row) row.classList.add('objective-achieved');
				}
			});
		}
		
		// Check voor specifieke patronen zoals "8 punten in paars Ã©n 6 in geel"
		// Ook ondersteund: "8 punten in groen Ã©n in paars" (zelfde drempel voor meerdere kleuren)
		const sharedThresholdMultiColorPattern = /(\d+)\s*(?:punten|pt)?\s*(?:in\s*)?(?:de\s*)?(gele|geel|rode|rood|groene|groen|paarse|paars|blauwe|blauw)\s*(?:zone)?\s*(?:Ã©n|en)\s*(?:in\s*)?(?:de\s*)?(gele|geel|rode|rood|groene|groen|paarse|paars|blauwe|blauw)/gi;
		let sharedMatch;
		while ((sharedMatch = sharedThresholdMultiColorPattern.exec(objectiveDesc)) !== null) {
			const minScore = parseInt(sharedMatch[1], 10);
			const color1Name = sharedMatch[2];
			const color2Name = sharedMatch[3];
			const colorMap = { 'geel': 'yellow', 'gele': 'yellow', 'rood': 'red', 'rode': 'red', 'groen': 'green', 'groene': 'green', 'paars': 'purple', 'paarse': 'purple', 'blauw': 'blue', 'blauwe': 'blue' };
			const color1 = colorMap[color1Name];
			const color2 = colorMap[color2Name];
			if (color1 && scores[color1] >= minScore) {
				const row = document.querySelector(`.score-row.${color1}`);
				if (row) row.classList.add('objective-achieved');
			}
			if (color2 && scores[color2] >= minScore) {
				const row = document.querySelector(`.score-row.${color2}`);
				if (row) row.classList.add('objective-achieved');
			}
		}

		const multiColorPattern = /(\d+)\s*(?:punten|pt)?\s*(?:in\s*)?(?:de\s*)?(gele|geel|rode|rood|groene|groen|paarse|paars|blauwe|blauw)\s*(?:zone)?\s*(?:Ã©n|en)\s*(\d+)\s*(?:punten|pt)?\s*(?:in\s*)?(?:de\s*)?(gele|geel|rode|rood|groene|groen|paarse|paars|blauwe|blauw)\s*(?:zone)?/gi;
		let multiMatch;
		while ((multiMatch = multiColorPattern.exec(objectiveDesc)) !== null) {
			const score1 = parseInt(multiMatch[1], 10);
			const color1Name = multiMatch[2];
			const score2 = parseInt(multiMatch[3], 10);
			const color2Name = multiMatch[4];
			
			const colorMap = { 'geel': 'yellow', 'gele': 'yellow', 'rood': 'red', 'rode': 'red', 'groen': 'green', 'groene': 'green', 'paars': 'purple', 'paarse': 'purple', 'blauw': 'blue', 'blauwe': 'blue' };
			const color1 = colorMap[color1Name];
			const color2 = colorMap[color2Name];
			
			if (color1 && scores[color1] >= score1) {
				const row = document.querySelector(`.score-row.${color1}`);
				if (row) row.classList.add('objective-achieved');
			}
			if (color2 && scores[color2] >= score2) {
				const row = document.querySelector(`.score-row.${color2}`);
				if (row) row.classList.add('objective-achieved');
			}
		}
	}
	
	function clearObjectiveHighlights() {
		// Verwijder alle objective-achieved classes
		document.querySelectorAll('.score-row.objective-achieved').forEach(el => {
			el.classList.remove('objective-achieved');
		});
		const totalEl = document.querySelector('#scoreboard .score-total.objective-achieved');
		if (totalEl) totalEl.classList.remove('objective-achieved');
	}

	function updateBonusInventoryUI() {
		const container = document.getElementById('bonus-inventory');
		if (!container) return;
		container.innerHTML = '';
		
		// Voeg gratis plaatsingen toe (als er zijn)
		if (freePlacementsRemaining > 0) {
			const freePlaceButton = document.createElement('button');
			freePlaceButton.type = 'button';
			freePlaceButton.classList.add('bonus-badge', 'free-placement-badge');
			freePlaceButton.title = `Gratis plaatsing (${freePlacementsRemaining})`;
			freePlaceButton.setAttribute('aria-label', `Gratis plaatsing (${freePlacementsRemaining})`);
			freePlaceButton.dataset.bonusKey = 'free';
			freePlaceButton.style.background = 'linear-gradient(135deg, #FFD700, #FFA500)';
			
			const swatch = document.createElement('div');
			swatch.classList.add('bonus-swatch');
			swatch.textContent = 'ðŸŽ';
			swatch.style.fontSize = '1.2rem';
			
			const label = document.createElement('div');
			label.classList.add('bonus-label');
			label.textContent = 'Gratis';
			
			const countElem = document.createElement('div');
			countElem.classList.add('bonus-count');
			countElem.textContent = String(freePlacementsRemaining);
			
			freePlaceButton.append(swatch, label, countElem);
			freePlaceButton.addEventListener('pointerdown', onBonusPointerDown);
			container.appendChild(freePlaceButton);
		}
		
		BONUS_ORDER.forEach(colorKey => {
			const meta = getBonusMeta(colorKey);
			if (!meta) return;
			const count = bonusInventory[colorKey] || 0;
			const button = document.createElement('button');
			button.type = 'button';
			button.classList.add('bonus-badge');
			button.title = `${meta.label} (${count})`;
			button.setAttribute('aria-label', `${meta.label} (${count})`);
			const upgraded = isBonusUpgraded(colorKey);
			button.classList.toggle('bonus-mastered', upgraded);
			button.dataset.bonusMastered = upgraded ? 'true' : 'false';
			if (count <= 0) {
				button.classList.add('disabled');
				button.disabled = true;
				button.setAttribute('aria-disabled', 'true');
			} else {
				button.disabled = false;
				button.removeAttribute('aria-disabled');
			}
			button.classList.toggle('active', !!(activeBonusPlacement && activeBonusPlacement.colorKey === colorKey));
			if (activeBonusPlacement && activeBonusPlacement.colorKey === colorKey) button.classList.add('active');
			button.dataset.bonusKey = colorKey;
			button.dataset.bonusColor = meta.colorName;
			const swatch = document.createElement('span');
			swatch.classList.add('bonus-swatch');
			swatch.style.background = meta.colorCode;
			const label = document.createElement('span');
			label.classList.add('bonus-label');
			label.textContent = meta.label;
			const countEl = document.createElement('span');
			countEl.classList.add('bonus-count');
			countEl.textContent = String(count);
			button.append(swatch, label, countEl);
			container.appendChild(button);
		});
	}

	function getBonusChargeAmount(colorKey) {
		if (!BONUS_COLOR_CONFIG[colorKey]) return 0;
		let amount = 1;
		if (hasUpgrade('bonusBoost')) amount += 1;
		return amount;
	}	function markActiveBonusButton(colorKey) {
		const container = document.getElementById('bonus-inventory');
		if (!container) return;
		container.querySelectorAll('.bonus-badge').forEach(btn => {
			const key = btn.dataset.bonusKey;
			btn.classList.toggle('active', !!colorKey && key === colorKey);
		});
	}

	function addBonusCharge(colorKey, amount = 1, options = {}) {
		if (!BONUS_COLOR_CONFIG[colorKey]) return 0;
		const count = Math.max(0, Number(amount) || 0);
		if (count === 0) return 0;
		bonusInventory[colorKey] = (bonusInventory[colorKey] || 0) + count;
		if (options.trackCollection !== false) {
			totalBonusesCollected += count;
		}
		updateBonusInventoryUI();
		return count;
	}

	function grantBonusCharge(colorKey) {
		if (!BONUS_COLOR_CONFIG[colorKey]) return 0;
		const chargeAmount = getBonusChargeAmount(colorKey) || 1;
		return addBonusCharge(colorKey, chargeAmount, { trackCollection: true });
	}

	function spendBonusCharge(colorKey) {
		// Handle gratis plaatsing
		if (colorKey === 'free') {
			if (freePlacementsRemaining <= 0) return false;
			freePlacementsRemaining -= 1;
			updateBonusInventoryUI();
			return true;
		}
		
		// Handle gekochte plaatsing (munten al betaald)
		if (colorKey === 'purchased') {
			return true; // Munten zijn al afgeschreven bij aankoop
		}
		
		if (!BONUS_COLOR_CONFIG[colorKey]) return false;
		if ((bonusInventory[colorKey] || 0) <= 0) return false;
		bonusInventory[colorKey] -= 1;
		updateBonusInventoryUI();
		return true;
	}

	function restoreBonusCharge(colorKey) {
		// Handle gratis plaatsing
		if (colorKey === 'free') {
			freePlacementsRemaining += 1;
			updateBonusInventoryUI();
			return;
		}
		// Handle gekochte plaatsing - geef munten terug
		if (colorKey === 'purchased') {
			// Geef de 2 munten terug
			addCoin();
			addCoin();
			updateBuyPlacementButton();
			return;
		}
		if (!BONUS_COLOR_CONFIG[colorKey]) return;
		bonusInventory[colorKey] = (bonusInventory[colorKey] || 0) + 1;
		updateBonusInventoryUI();
	}

	function getBonusKeyFromSymbol(symbolEl) {
		if (!symbolEl) return null;
		return BONUS_ORDER.find(key => symbolEl.classList.contains(key)) || null;
	}

	function createBonusClaim(cell, symbolEl, colorKey, amount = 1) {
		return {
			colorKey,
			cell,
			symbol: symbolEl,
			amount: amount
		};
	}

	function revokeBonusClaim(claim) {
		if (!claim || !claim.colorKey) return;
		const amount = claim.amount || 1;
		totalBonusesCollected = Math.max(0, totalBonusesCollected - amount);
		if (bonusInventory[claim.colorKey] > 0) {
			bonusInventory[claim.colorKey] = Math.max(0, bonusInventory[claim.colorKey] - amount);
		}
		if (claim.cell) {
			delete claim.cell.dataset.bonusConsumed;
		}
		if (claim.symbol && claim.symbol.classList) {
			claim.symbol.classList.remove('bonus-used');
		}
		updateBonusInventoryUI();
	}

	function resetBonusState() {
		cancelActiveBonusPlacement({ updateInventory: false });
		BONUS_ORDER.forEach(key => {
			bonusInventory[key] = 0;
		});
		document.querySelectorAll('.cell[data-bonus-consumed]').forEach(cell => {
			delete cell.dataset.bonusConsumed;
		});
		document.querySelectorAll('.symbol.bonus-used').forEach(symbol => {
			symbol.classList.remove('bonus-used');
		});
		// reset collected counter as well
		totalBonusesCollected = 0;
		updateBonusInventoryUI();
	}

	function grantRandomBonusUpgrade({ silent = false } = {}) {
		const available = BONUS_ORDER
			.filter(key => BONUS_COLOR_CONFIG[key])
			.filter(key => !isBonusUpgraded(key));
		if (!available.length) {
			if (!silent) showObjectiveToast('âœ¨ Alle bonus upgrades zijn al actief.');
			return null;
		}
		const key = available[Math.floor(Math.random() * available.length)];
		setBonusUpgraded(key, true);
		updateBonusInventoryUI();
		if (!silent) {
			const meta = BONUS_COLOR_CONFIG[key];
			showObjectiveToast(`ðŸª Gratis bonus upgrade: ${meta?.colorName || key}!`);
		}
		return key;
	}

	function openRandomFreeBonusUpgradeModal() {
		const available = BONUS_ORDER
			.filter(key => BONUS_COLOR_CONFIG[key])
			.filter(key => !isBonusUpgraded(key));
		if (!available.length) {
			showObjectiveToast('âœ¨ Alle bonus upgrades zijn al actief.');
			return null;
		}
		const colorKey = available[Math.floor(Math.random() * available.length)];
		const meta = getBonusMeta(colorKey);
		if (!meta) {
			// Fallback: behave like the old field event.
			return grantRandomBonusUpgrade();
		}

		const shopModalLayer = document.getElementById('shop-modal-layer');
		const shopModalTitle = document.getElementById('shop-modal-title');
		const shopModalMessage = document.getElementById('shop-modal-message');
		const shopCardOptions = document.getElementById('shop-card-options');
		const upgradesSection = document.querySelector('.shop-upgrades-section');
		const bonusSection = document.querySelector('.shop-bonus-section');
		const freePlaceSection = document.querySelector('.shop-freeplace-section');
		const shopBonusContainer = document.getElementById('shop-bonus-container');
		const shopContentGrid = document.querySelector('.shop-content-grid');
		const shopLowerGrid = document.querySelector('.shop-lower-grid');

		if (!shopModalLayer || !shopBonusContainer || !bonusSection) {
			return grantRandomBonusUpgrade();
		}

		// Snapshot current layout so we can restore on close.
		const cardsSection = shopCardOptions ? shopCardOptions.closest('.shop-cards-section') : null;
		const original = {
			gridTemplateColumns: shopContentGrid ? shopContentGrid.style.gridTemplateColumns : '',
			cardsDisplay: cardsSection ? cardsSection.style.display : '',
			upgradesDisplay: upgradesSection ? upgradesSection.style.display : '',
			bonusDisplay: bonusSection ? bonusSection.style.display : '',
			freePlaceDisplay: freePlaceSection ? freePlaceSection.style.display : '',
			lowerGridDisplay: shopLowerGrid ? shopLowerGrid.style.display : '',
			bonusParent: bonusSection.parentElement,
			bonusNext: bonusSection.nextSibling
		};

		const restoreLayout = () => {
			if (shopContentGrid) shopContentGrid.style.gridTemplateColumns = original.gridTemplateColumns;
			if (cardsSection) cardsSection.style.display = original.cardsDisplay;
			if (upgradesSection) upgradesSection.style.display = original.upgradesDisplay;
			if (bonusSection) bonusSection.style.display = original.bonusDisplay;
			if (freePlaceSection) freePlaceSection.style.display = original.freePlaceDisplay;
			if (shopLowerGrid) shopLowerGrid.style.display = original.lowerGridDisplay;
			try {
				if (original.bonusParent && bonusSection.parentElement !== original.bonusParent) {
					original.bonusParent.insertBefore(bonusSection, original.bonusNext || null);
				}
			} catch {}
		};

		// Show ONLY bonus upgrades with one free offer.
		if (cardsSection) cardsSection.style.display = 'none';
		if (upgradesSection) upgradesSection.style.display = 'none';
		if (freePlaceSection) freePlaceSection.style.display = 'none';
		if (shopLowerGrid) shopLowerGrid.style.display = 'none';
		if (shopContentGrid) shopContentGrid.style.gridTemplateColumns = '1fr';
		if (bonusSection) bonusSection.style.display = '';
		if (shopContentGrid && bonusSection.parentElement !== shopContentGrid) {
			shopContentGrid.appendChild(bonusSection);
		}

		shopBonusContainer.innerHTML = '';
		const card = document.createElement('div');
		card.classList.add('shop-bonus-card');
		const info = document.createElement('div');
		info.classList.add('shop-bonus-info');
		const swatch = document.createElement('span');
		swatch.classList.add('shop-bonus-swatch');
		swatch.style.background = meta.colorCode;
		const label = document.createElement('span');
		label.textContent = meta.label;
		info.append(swatch, label);

		const actions = document.createElement('div');
		actions.classList.add('shop-bonus-actions');
		const claimBtn = document.createElement('button');
		claimBtn.type = 'button';
		claimBtn.classList.add('shop-bonus-upgrade-btn');
		claimBtn.textContent = 'Gratis claimen';
		claimBtn.addEventListener('click', () => {
			if (isBonusUpgraded(colorKey)) return;
			setBonusUpgraded(colorKey, true);
			updateBonusInventoryUI();
			try { updateShopBonusUI(); } catch {}
			try { updateShopCoinDisplay(); } catch {}
			showObjectiveToast(`ðŸª Bonus upgrade geclaimd: ${meta.colorName}!`);
			claimBtn.disabled = true;
			setTimeout(() => {
				// Do NOT trigger the global close handler (it calls skipShop()).
				// We close + restore layout directly to prevent the old shop flashing.
				try { close(); } catch {
					shopModalLayer.classList.remove('show');
					restoreLayout();
				}
			}, 250);
		});
		actions.appendChild(claimBtn);
		card.append(info, actions);
		shopBonusContainer.appendChild(card);

		if (shopModalTitle) shopModalTitle.textContent = 'ðŸª Bonus upgrade';
		if (shopModalMessage) shopModalMessage.textContent = 'Je hebt 1 gratis bonus-upgrade gevonden!';
		try { updateShopCoinDisplay(); } catch {}
		shopModalLayer.classList.add('show');

		const shopSkipBtn = document.getElementById('shop-modal-skip');
		const shopCloseBtn = document.getElementById('shop-modal-close');
		let skipOriginalText = null;
		const close = () => {
			if (shopSkipBtn && skipOriginalText !== null) {
				shopSkipBtn.textContent = skipOriginalText;
			}
			shopModalLayer.classList.remove('show');
			restoreLayout();
		};
		if (shopSkipBtn) {
			skipOriginalText = shopSkipBtn.textContent;
			shopSkipBtn.textContent = 'Sluiten';
			shopSkipBtn.addEventListener('click', () => {
				close();
			}, { once: true });
		}
		if (shopCloseBtn) {
			// Capture phase + stopImmediatePropagation so the global handler (skipShop) won't run.
			shopCloseBtn.addEventListener('click', (e) => {
				e.preventDefault();
				e.stopImmediatePropagation();
				close();
			}, { once: true, capture: true });
			shopCloseBtn.addEventListener('touchend', (e) => {
				e.preventDefault();
				e.stopImmediatePropagation();
				close();
			}, { once: true, capture: true });
		}

		return colorKey;
	}

	function placeBonusUpgradeFieldEvent_World2() {
		const worldInfo = (typeof getWorldAndSubLevel === 'function')
			? getWorldAndSubLevel(currentLevel)
			: { world: Number(currentWorld || 1) || 1 };
		const world = Number(worldInfo?.world || 1) || 1;
		if (world < 2) return false;

		// Prefer blue/green; small chance yellow.
		const zoneRoll = Math.random();
		const preferred = zoneRoll < 0.45 ? 'blue' : (zoneRoll < 0.90 ? 'green' : 'yellow');
		const zoneOrder = preferred === 'yellow'
			? ['yellow', 'blue', 'green']
			: (preferred === 'blue'
				? ['blue', 'green', 'yellow']
				: ['green', 'blue', 'yellow']);

		const pickCandidateCell = (gridId) => {
			const grid = document.getElementById(gridId);
			if (!grid) return null;
			const candidates = Array.from(grid.querySelectorAll('.cell:not(.void-cell)'))
				.filter(cell => cell.dataset.disabled !== 'true')
				.filter(cell => !cell.classList.contains('active'))
				.filter(cell => !cell.classList.contains('bold-cell'))
				.filter(cell => !cell.classList.contains('gold-cell'))
				.filter(cell => !cell.classList.contains('trap-cell'))
				.filter(cell => !cell.querySelector('.symbol'));
			if (!candidates.length) return null;
			return candidates[Math.floor(Math.random() * candidates.length)];
		};

		const zoneToGridId = {
			blue: 'blue-grid',
			green: 'green-grid',
			yellow: 'yellow-grid'
		};

		let target = null;
		let chosenZone = null;
		for (const z of zoneOrder) {
			target = pickCandidateCell(zoneToGridId[z]);
			if (target) {
				chosenZone = z;
				break;
			}
		}
		if (!target) return false;

		target.dataset.bonusUpgradeEvent = 'true';
		const sym = document.createElement('div');
		sym.classList.add('symbol', 'upgrade-shop-symbol');
		// Use the editor's diamond glyph for consistency
		sym.textContent = 'â™¦';
		sym.setAttribute('aria-label', 'Bonus upgrade');
		target.appendChild(sym);
		return true;
	}

	function onBonusPointerDown(event) {
		const badge = event.target.closest('.bonus-badge');
		if (!badge) return;
		const colorKey = badge.dataset.bonusKey;
		
		// Handle gratis plaatsing
		if (colorKey === 'free') {
			if (freePlacementsRemaining <= 0) return;
			if (event.button !== undefined && event.button !== 0) return;
			event.preventDefault();
			event.stopPropagation();
			
			if (activeBonusPlacement && activeBonusPlacement.colorKey === 'free') {
				cancelActiveBonusPlacement();
				return;
			}
			cancelActiveBonusPlacement({ updateInventory: false });
			
			// Gebruik 'multikleur' voor universele plaatsing
			const shape = [[1]]; // 1x1 blok
			const colorObj = { name: 'multikleur', code: 'rainbow' };
			
			const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
			if (isTouchDevice && window.innerWidth <= MOBILE_BREAKPOINT) {
				activeBonusPlacement = {
					colorKey: 'free',
					pointerId: event.pointerId || null,
					sticky: true,
					shape: cloneShape(shape)
				};
				selectedShape = shape;
				selectedColor = colorObj;
				if (rotateButton) rotateButton.disabled = false;
				// For touch-initiated bonus drags, delay showing the mirror control
				// until the block is placed/released to avoid accidental mirrors.
				if (mirrorButton) mirrorButton.disabled = true;
				markActiveBonusButton('free');
				
				badge.setPointerCapture(event.pointerId);
				const freeBlock = makeDraggable(shape, colorObj);
				freeBlock.classList.add('bonus-draggable');
				const overlay = document.getElementById('drag-overlay');
				if (overlay && !overlay.contains(freeBlock)) {
					overlay.appendChild(freeBlock);
					overlay.style.display = 'block';
				}
				draggedBlock = freeBlock;
				draggedShape = freeBlock._shape || shape;
				draggedColor = colorObj;
				beginPointerDrag({ clientX: event.clientX, clientY: event.clientY, pointerId: event.pointerId || null });
				startGlobalDragVisuals();
				({ offsetX, offsetY } = computeShapeCenterOffsets(shape));
				const touchOffsetY = 60;
				draggedBlock.style.left = `${event.clientX - offsetX}px`;
				draggedBlock.style.top = `${event.clientY - offsetY - touchOffsetY}px`;
				// Controls are delayed for touch bonus drags; they will appear on release.
				activeBonusPlacement.delayedControls = true;
			} else {
				activeBonusPlacement = {
					colorKey: 'free',
					pointerId: event.pointerId || null,
					sticky: false,
					shape: cloneShape(shape)
				};
				selectedShape = shape;
				selectedColor = colorObj;
				if (rotateButton) rotateButton.disabled = false;
				if (mirrorButton) mirrorButton.disabled = false;
				markActiveBonusButton('free');
				showFloatingPreview(shape, colorObj);
			}
			return;
		}
		
		if (!colorKey || !BONUS_COLOR_CONFIG[colorKey]) return;
		if ((bonusInventory[colorKey] || 0) <= 0 && (!activeBonusPlacement || activeBonusPlacement.colorKey !== colorKey)) {
			// Even when empty, selecting a bonus badge on mobile should open the zoomed zone.
			event.preventDefault();
			event.stopPropagation();
			if (window.innerWidth <= MOBILE_BREAKPOINT) {
				const meta = BONUS_COLOR_CONFIG[colorKey];
				if (meta) {
					autoZoomToColorZone({ name: meta.colorName, code: meta.colorCode });
				}
			}
			return;
		}
		if (event.button !== undefined && event.button !== 0) return;
		event.preventDefault();
		event.stopPropagation();
		if (activeBonusPlacement && activeBonusPlacement.colorKey === colorKey) {
			cancelActiveBonusPlacement();
			return;
		}
		cancelActiveBonusPlacement({ updateInventory: false });
		const meta = BONUS_COLOR_CONFIG[colorKey];
		const shape = getBonusShape(colorKey);
		const colorObj = { name: meta.colorName, code: meta.colorCode };

		// Auto-zoom naar de juiste zone op basis van kleur (altijd op mobiel)
		if (window.innerWidth <= MOBILE_BREAKPOINT) {
			autoZoomToColorZone(colorObj);
		}

	// Voor touch devices: direct draggable maken (geen floating preview)
	const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
	if (isTouchDevice && window.innerWidth <= MOBILE_BREAKPOINT) {
		// Zet bonus placement variabelen
		activeBonusPlacement = {
			colorKey,
			pointerId: event.pointerId || null,
			sticky: true,
			shape: cloneShape(shape)
		};
		selectedShape = shape;
		selectedColor = colorObj;
		if (rotateButton) rotateButton.disabled = false;
		// For touch-initiated bonus drags, delay showing the mirror control
		// until the block is placed/released to avoid accidental mirrors.
		if (mirrorButton) mirrorButton.disabled = true;
		markActiveBonusButton(colorKey);

		// Maak het blok direct draggable vanaf pointer positie (niet op de badge),
		// zodat het niet direct "op de badge" lijkt te staan en overlap/annuleer-gevoel voorkomt.
		const block = makeDraggable(shape, colorObj);
		block.classList.add('bonus-draggable');
		const shapeWidth = shape[0].length;
		const shapeHeight = shape.length;
		({ offsetX, offsetY } = computeShapeCenterOffsets(shape));
		const touchOffsetY = 60;
		block.style.left = `${event.clientX - offsetX}px`;
		block.style.top = `${event.clientY - offsetY - touchOffsetY}px`;

		// Ensure block immediately matches zoomed cell size if a zoom/lift occurred
		requestAnimationFrame(() => {
			try {
				renderBlock(block, block._shape || shape, colorObj);
				({ offsetX, offsetY } = computeShapeCenterOffsets(block._shape || shape));
				block.style.left = `${event.clientX - offsetX}px`;
				block.style.top = `${event.clientY - offsetY - touchOffsetY}px`;
			} catch (e) {}
		});
		const overlay = document.getElementById('drag-overlay');
		if (overlay && !overlay.contains(block)) {
			overlay.appendChild(block);
			overlay.style.display = 'block';
		}
		draggedBlock = block;
		draggedShape = block._shape || shape;
		draggedColor = colorObj;
		try { badge.setPointerCapture(event.pointerId); } catch {}
		beginPointerDrag({ clientX: event.clientX, clientY: event.clientY, pointerId: event.pointerId || null });
		startGlobalDragVisuals();
		// Delay transform buttons (mirror) for touch bonus drags; they'll appear on release
		activeBonusPlacement.delayedControls = true;

			// Ensure correct sizing after any zoom/lift finishes
			requestAnimationFrame(() => {
				try {
					renderBlock(block, block._shape || shape, colorObj);
					({ offsetX, offsetY } = computeShapeCenterOffsets(block._shape || shape));
					const touchOffsetY2 = 60;
					block.style.left = `${event.clientX - offsetX}px`;
					block.style.top = `${event.clientY - offsetY - touchOffsetY2}px`;
				} catch (e) {}
			});
		return;
	} else if (window.innerWidth <= MOBILE_BREAKPOINT) {
		// Niet-touch mobiel: maak blok direct draggable
		// Buttons worden getoond zodra het blok wordt opgepakt
		activeBonusPlacement = {
			colorKey,
			pointerId: event.pointerId || null,
			sticky: true,
			shape: cloneShape(shape)
		};
		selectedShape = shape;
		selectedColor = colorObj;
		if (rotateButton) rotateButton.disabled = false;
		if (mirrorButton) mirrorButton.disabled = false;
		markActiveBonusButton(colorKey);
		
		// Maak het blok direct draggable
		const block = makeDraggable(shape, colorObj);
		block.classList.add('bonus-draggable');
		const overlay = document.getElementById('drag-overlay');
		if (overlay && !overlay.contains(block)) overlay.appendChild(block);
		draggedBlock = block;
		draggedShape = block._shape || shape;
		draggedColor = colorObj;
		beginPointerDrag({ clientX: event.clientX, clientY: event.clientY, pointerId: event.pointerId || null });
		startGlobalDragVisuals();
		const shapeWidth = shape[0].length;
		const shapeHeight = shape.length;
		({ offsetX, offsetY } = computeShapeCenterOffsets(shape));
		block.style.left = `${event.clientX - offsetX}px`;
		block.style.top = `${event.clientY - offsetY}px`;
		// visuals handled by startGlobalDragVisuals()
		if (overlay) overlay.style.display = 'block';
			// After possible zoom/DOM-lift, re-render to pick up zoomed cell size
			requestAnimationFrame(() => {
				try {
					renderBlock(block, block._shape || shape, colorObj);
					({ offsetX, offsetY } = computeShapeCenterOffsets(block._shape || shape));
					block.style.left = `${event.clientX - offsetX}px`;
					block.style.top = `${event.clientY - offsetY}px`;
				} catch (e) {}
			});
			return;
	}
		// Desktop (mouse): click-to-pickup -> hover-follow -> click-to-drop
		const isMobileLayout = window.innerWidth <= MOBILE_BREAKPOINT;
		if (!isMobileLayout && !isTouchDevice) {
			activeBonusPlacement = {
				colorKey,
				pointerId: null,
				sticky: false,
				shape: cloneShape(shape),
				desktopHover: true
			};
			lastZone = null;
			lastBaseX = null;
			lastBaseY = null;
			selectedCardId = null;
			if (selectedCardElement) {
				selectedCardElement.classList.remove('selected');
			}
			selectedCardElement = null;
			selectedShape = shape;
			selectedColor = colorObj;
			if (rotateButton) rotateButton.disabled = false;
			if (mirrorButton) mirrorButton.disabled = false;
			markActiveBonusButton(colorKey);
			badge.blur();
			startDesktopHoverDragFromSelection(badge, shape, colorObj);
			return;
		}

		// Desktop (touch) fallback: keep original drag behavior
		const block = makeDraggable(shape, colorObj);
		block.classList.add('bonus-draggable');
		const overlay = document.getElementById('drag-overlay');
		if (overlay && !overlay.contains(block)) overlay.appendChild(block);
		draggedBlock = block;
		draggedShape = block._shape || shape;
		draggedColor = colorObj;
		beginPointerDrag({ clientX: event.clientX, clientY: event.clientY, pointerId: event.pointerId || null });
		startGlobalDragVisuals();

		// Compute offsets based on the *actual rendered* board cell size + gap.
		({ offsetX, offsetY } = computeShapeCenterOffsets(draggedShape));
		const localTouchDevice = ('ontouchstart' in window || navigator.maxTouchPoints > 0);
		const touchOffsetY = localTouchDevice ? 60 : 0;
		block.style.left = `${event.clientX - offsetX}px`;
		block.style.top = `${event.clientY - offsetY - touchOffsetY}px`;
		activeBonusPlacement = {
			colorKey,
			pointerId: event.pointerId || null,
			sticky: true,
			shape: cloneShape(shape)
		};
		lastZone = null;
		lastBaseX = null;
		lastBaseY = null;
		selectedCardId = null;
		selectedCardElement = null;
		selectedShape = null;
		selectedColor = null;
		if (rotateButton) rotateButton.disabled = false;
		// visuals handled by startGlobalDragVisuals()
		if (overlay) overlay.style.display = 'block';
		badge.blur();
		markActiveBonusButton(colorKey);
	}
	
	// --- Dark mode toggle ---
	document.addEventListener('DOMContentLoaded', () => {
	  const toggleBtn = document.getElementById('dark-mode-toggle');
	  const mobileToggleBtn = document.getElementById('mobile-dark-mode-toggle');
	  const root = document.documentElement;
	  const body = document.body;
	  if (!body) return;

	  /*
		EN:
		- STATE: source of truth for dark/light theme is localStorage key `theme` + the `dark-mode` class on <html>/<body>.
		- OVERRIDE: This handler runs on DOMContentLoaded and can overwrite earlier theme decisions (e.g. head preload script).
		- DUPLICATE: Theme is handled in two places (head preload + here). If you keep both, ensure they do the same thing.
	*/
	  const savedTheme = localStorage.getItem('theme');
	  const preferDark = (savedTheme ? (savedTheme === 'dark') : true) || root.classList.contains('dark-mode');

	  function applyTheme(isDark) {
		/*
			EN:
			- STATE: toggles classes, updates button labels, persists to localStorage.
			- OVERRIDE: button text here overrides any initial HTML labels.
		*/
		root.classList.toggle('dark-mode', isDark);
		body.classList.toggle('dark-mode', isDark);
		if (toggleBtn) toggleBtn.textContent = isDark ? 'â˜€ï¸' : 'ðŸŒ™';
		if (mobileToggleBtn) mobileToggleBtn.textContent = isDark ? 'â˜€ï¸ Dag' : 'ðŸŒ™ Nacht';
		localStorage.setItem('theme', isDark ? 'dark' : 'light');
	  }

	  applyTheme(preferDark);

	  function handleToggleClick(event) {
		if (event) event.preventDefault();
		const willBeDark = !body.classList.contains('dark-mode');
		applyTheme(willBeDark);
	  }

	  if (toggleBtn) toggleBtn.addEventListener('click', handleToggleClick);
	  if (mobileToggleBtn) mobileToggleBtn.addEventListener('click', handleToggleClick);
	});



	 // ---------- CREATE GRID (general) ----------
	function createGrid(containerId, rows, cols, options = {}) {
		options = Object.assign({
			boldBottom: false,
			goldCells: false,
			symbols: false,
			symbolChance: 0.3,
			minSymbols: 0,
			maxSymbols: 0,
			coinChance: 0.0,
			maxCoins: 0,
			trapChance: 0,
			maxTraps: 0,
			blackHoleChance: BLACK_HOLE_DEFAULT_CHANCE,
			rowLengths: null,
			rowOffsets: null,
			voidCells: null,
			boldRows: [],
			randomBoldCount: null,
			includeDefaultBlueBold: true,
			colorChances: null,
					pointsPerWidthMap: null,
					pointsPerColumn: null,
					avoidAdjacentBold: false,
					diagonalShading: false,
					diagonalLegend: false,
					fixedBoldCells: null,
					outerRingShade: false,
					trimLeft: false,
					trimRight: false,
					randomBoldMinEdgeDistance: 0
		}, options);

		const container = document.getElementById(containerId);
		if (!container) return;

		const normalizedRowLengths = [];
		const normalizedRowOffsets = [];
		const hasCustomRowLengths = Array.isArray(options.rowLengths) && options.rowLengths.length;
		const hasCustomRowOffsets = Array.isArray(options.rowOffsets) && options.rowOffsets.length;

		let usedMaxCols = 0;
		for (let i = 0; i < rows; i++) {
			const lengthSourceIndex = hasCustomRowLengths
				? (i < options.rowLengths.length ? i : options.rowLengths.length - 1)
				: -1;
			const offsetSourceIndex = hasCustomRowOffsets
				? (i < options.rowOffsets.length ? i : options.rowOffsets.length - 1)
				: -1;

			const rawLength = lengthSourceIndex >= 0 ? options.rowLengths[lengthSourceIndex] : cols;
			const normalizedLength = Math.max(0, Number(rawLength) || 0);
			normalizedRowLengths.push(normalizedLength);

			const rawOffset = offsetSourceIndex >= 0 ? options.rowOffsets[offsetSourceIndex] : 0;
			const normalizedOffset = Math.max(0, Number(rawOffset) || 0);
			normalizedRowOffsets.push(normalizedOffset);

			if (normalizedLength > 0) {
				usedMaxCols = Math.max(usedMaxCols, normalizedOffset + normalizedLength);
			}
		}

		let maxCols = Math.max(cols, usedMaxCols);

		// Optional: trim empty leading columns when using rowOffsets.
		// Useful for World 2 blue path, where generation starts at offset>0 (otherwise you get lots of empty space on the left).
		let workingVoidCells = options.voidCells;
		if (options.trimLeft && hasCustomRowOffsets) {
			let minOffset = Infinity;
			for (let r = 0; r < rows; r++) {
				if (normalizedRowLengths[r] > 0) {
					minOffset = Math.min(minOffset, normalizedRowOffsets[r]);
				}
			}
			if (Number.isFinite(minOffset) && minOffset > 0) {
				for (let r = 0; r < rows; r++) {
					normalizedRowOffsets[r] = Math.max(0, (normalizedRowOffsets[r] || 0) - minOffset);
				}
				maxCols = Math.max(1, maxCols - minOffset);
				if (workingVoidCells && workingVoidCells instanceof Set) {
					const shifted = new Set();
					for (const key of workingVoidCells) {
						const parts = String(key).split(',');
						if (parts.length < 2) continue;
						const x = Number(parts[0]);
						const y = parts[1];
						if (!Number.isFinite(x)) continue;
						shifted.add(`${Math.max(0, x - minOffset)},${y}`);
					}
					workingVoidCells = shifted;
				}
			}
		}

		// Optional: trim empty trailing columns (right side). Useful when `cols` is larger than what the active rows actually use.
		if (options.trimRight) {
			let usedRight = 0;
			for (let r = 0; r < rows; r++) {
				const rowLen = normalizedRowLengths[r];
				if (rowLen > 0) {
					usedRight = Math.max(usedRight, (normalizedRowOffsets[r] || 0) + rowLen);
				}
			}
			if (Number.isFinite(usedRight) && usedRight > 0 && usedRight < maxCols) {
				maxCols = usedRight;
				if (workingVoidCells && workingVoidCells instanceof Set) {
					const trimmed = new Set();
					for (const key of workingVoidCells) {
						const parts = String(key).split(',');
						if (parts.length < 2) continue;
						const x = Number(parts[0]);
						if (!Number.isFinite(x)) continue;
						if (x >= 0 && x < maxCols) trimmed.add(key);
					}
					workingVoidCells = trimmed;
				}
			}
		}

		if (!Number.isFinite(maxCols) || maxCols <= 0) maxCols = Math.max(cols, 1);

		container.innerHTML = '';
	container.dataset.rows = String(rows);
	container.dataset.cols = String(maxCols);
		container.dataset.rowLengths = normalizedRowLengths.join(',');
		container.dataset.rowOffsets = normalizedRowOffsets.join(',');
		container.style.gridTemplateColumns = `repeat(${maxCols}, var(--cell-size))`;
		container.style.gridAutoRows = `var(--cell-size)`;

		const activeIndexOffsets = [];
		let activeCellCount = 0;
		for (let r = 0; r < rows; r++) {
			activeIndexOffsets[r] = activeCellCount;
			activeCellCount += normalizedRowLengths[r];
		}
		container.dataset.activeCells = String(activeCellCount);

		const allIdx = Array.from({ length: activeCellCount }, (_, i) => i);

		const indexToCoord = (index) => {
			if (index < 0 || index >= activeCellCount) return null;
			for (let r = rows - 1; r >= 0; r--) {
				const start = activeIndexOffsets[r];
				const rowLen = normalizedRowLengths[r];
				if (rowLen <= 0) continue;
				if (index >= start) {
					const within = index - start;
					if (within < rowLen) {
						const c = normalizedRowOffsets[r] + within;
						return { row: r, col: c };
					}
				}
			}
			return null;
		};

		const boldIndices = new Set();
		const boldRowsSet = new Set(Array.isArray(options.boldRows) ? options.boldRows : []);
		const includeDefaultBlue = options.includeDefaultBlueBold !== false;
		const fixedBoldCells = Array.isArray(options.fixedBoldCells) ? options.fixedBoldCells : [];

		for (let r = 0; r < rows; r++) {
			const rowLen = normalizedRowLengths[r];
			if (rowLen <= 0) continue;
			if (options.boldBottom && r === rows - 1) {
				for (let c = 0; c < rowLen; c++) boldIndices.add(activeIndexOffsets[r] + c);
			}
			if (boldRowsSet.has(r)) {
				for (let c = 0; c < rowLen; c++) boldIndices.add(activeIndexOffsets[r] + c);
			}
			if (includeDefaultBlue && containerId === 'blue-grid' && r % 4 === 0) {
				for (let c = 0; c < rowLen; c++) boldIndices.add(activeIndexOffsets[r] + c);
			}
		}

		// Fixed bold cells (used for World 2 purple corners)
		for (const entry of fixedBoldCells) {
			if (!Array.isArray(entry) || entry.length < 2) continue;
			const r = Number(entry[0]);
			const c = Number(entry[1]);
			if (!Number.isFinite(r) || !Number.isFinite(c)) continue;
			if (r < 0 || r >= rows) continue;
			const rowLen = normalizedRowLengths[r];
			if (!rowLen) continue;
			const rowStart = normalizedRowOffsets[r] || 0;
			const rel = c - rowStart;
			if (rel < 0 || rel >= rowLen) continue;
			boldIndices.add(activeIndexOffsets[r] + rel);
		}

				if (options.boldLeft) {
					for (let r = 0; r < rows; r++) {
						const rowLen = normalizedRowLengths[r];
						if (rowLen <= 0) continue;
						boldIndices.add(activeIndexOffsets[r]);
					}
				}

				if (Array.isArray(options.boldColumns)) {
					const numericColumns = options.boldColumns
						.map(value => Number(value))
						.filter(value => Number.isFinite(value));
							numericColumns.forEach(columnIndex => {
								for (let r = 0; r < rows; r++) {
									const rowLen = normalizedRowLengths[r];
									if (rowLen <= 0) continue;
									const rowStart = normalizedRowOffsets[r];
									const relativeIndex = columnIndex - rowStart;
									if (relativeIndex < 0 || relativeIndex >= rowLen) continue;
									boldIndices.add(activeIndexOffsets[r] + relativeIndex);
								}
							});
				}

		let randomBoldTarget = null;
		if (typeof options.randomBoldCount === 'number' && options.randomBoldCount > 0) {
			randomBoldTarget = Math.min(options.randomBoldCount, activeCellCount);
		} else if (containerId === 'purple-grid' && typeof options.randomBoldCount !== 'number') {
			randomBoldTarget = Math.min(5, activeCellCount);
		}

		const currentBoldCoords = [];
		for (const idx of boldIndices) {
			const coord = indexToCoord(idx);
			if (coord) currentBoldCoords.push(coord);
		}

		if (randomBoldTarget !== null) {
			const shuffled = allIdx.slice();
			shuffleArray(shuffled);
			for (let i = 0; boldIndices.size < randomBoldTarget && i < shuffled.length; i++) {
				const candidate = shuffled[i];
				if (boldIndices.has(candidate)) continue;
				const coord = indexToCoord(candidate);
				if (!coord) continue;
				// World 2 purple request: do not generate random bold cells in the outer rings.
				if (options.randomBoldMinEdgeDistance && options.randomBoldMinEdgeDistance > 0) {
					const edgeDist = Math.min(coord.row, coord.col, (rows - 1 - coord.row), (maxCols - 1 - coord.col));
					if (edgeDist < options.randomBoldMinEdgeDistance) continue;
				}
				if (options.avoidAdjacentBold) {
					let tooClose = false;
					for (const existing of currentBoldCoords) {
						const distance = Math.max(Math.abs(existing.row - coord.row), Math.abs(existing.col - coord.col));
						if (distance < 2) {
							tooClose = true;
							break;
						}
					}
					if (tooClose) continue;
				}
				boldIndices.add(candidate);
				currentBoldCoords.push(coord);
			}
		}

		const minSymbols = Math.max(0, Math.min(options.minSymbols || 0, activeCellCount));
		const maxSymbols = Math.max(minSymbols, Math.min(options.maxSymbols || minSymbols, activeCellCount));
		const symbolCount = maxSymbols > minSymbols
			? Math.floor(Math.random() * (maxSymbols - minSymbols + 1)) + minSymbols
			: minSymbols;
		const shuffledIdx = allIdx.slice();
		shuffleArray(shuffledIdx);
		const symbolIndices = new Set(shuffledIdx.slice(0, symbolCount));

		const coinCandidates = shuffledIdx.filter(i => {
			if (options.maxCoins && options.maxCoins <= 0) return false;
			if (options.goldCells === false && options.coinChance === 0) return false;
			if (boldIndices.has(i)) return false;
			return true;
		});

		const coinIndices = new Set();
		const coinLimit = options.maxCoins > 0 ? options.maxCoins : Infinity;
		for (const idx of coinCandidates) {
			if (coinIndices.size >= coinLimit) break;
			if (Math.random() < (options.coinChance || 0)) {
				coinIndices.add(idx);
			}
		}

		const trapChance = Math.max(0, Math.min(1, Number(options.trapChance) || 0));
		const trapLimit = options.maxTraps > 0 ? options.maxTraps : 0;
		const trapIndices = new Set();
		if (trapChance > 0 && trapLimit !== 0) {
			const trapCandidates = shuffledIdx.filter(i => !symbolIndices.has(i) && !coinIndices.has(i) && !boldIndices.has(i));
			for (const idx of trapCandidates) {
				if (trapIndices.size >= trapLimit) break;
				if (Math.random() < trapChance) {
					trapIndices.add(idx);
				}
			}
		}
		trapIndices.forEach(idx => symbolIndices.delete(idx));

		const frag = document.createDocumentFragment();
			for (let r = 0; r < rows; r++) {
				const rowLen = normalizedRowLengths[r];
				const rowStart = normalizedRowOffsets[r];
				for (let c = 0; c < maxCols; c++) {
				const cell = document.createElement('div');
				cell.classList.add('cell');
			cell.dataset.x = String(c);
			cell.dataset.y = String(r);
			cell.dataset.zoneId = containerId;

					// Check of cell binnen row range valt
					const isOutsideRow = (c < rowStart) || (c >= rowStart + rowLen);
					
					// Check of cell expliciet als void gemarkeerd is (voor gaps in split)
					const cellKey = `${c},${r}`;
					const isMarkedVoid = workingVoidCells && workingVoidCells.has(cellKey);
					
					const isVoid = isOutsideRow || isMarkedVoid;
				if (isVoid) {
					cell.classList.add('void-cell');
					cell.dataset.disabled = 'true';
					frag.appendChild(cell);
					continue;
				}

				// World 2 purple UX: shade the outer 2 rings
				if (containerId === 'purple-grid' && options.outerRingShade) {
					const dist = Math.min(r, c, (rows - 1 - r), (maxCols - 1 - c));
					if (dist === 0) cell.classList.add('outer-ring-0');
					else if (dist === 1) cell.classList.add('outer-ring-1');
				}

					const idx = activeIndexOffsets[r] + (c - rowStart);

					// WORLD 2 (Yellow): tag cells by diagonal so we can style and score diagonals.
					if (containerId === 'yellow-grid' && options.diagonalShading) {
						const diagIndex = c - r; // NW-SE diagonals
						cell.dataset.diag = String(diagIndex);
						const parity = ((diagIndex % 2) + 2) % 2;
						if (parity === 1) cell.classList.add('diag-shade-odd');
						else cell.classList.add('diag-shade-even');
					}

				if (boldIndices.has(idx)) cell.classList.add('bold-cell');

				if (trapIndices.has(idx)) {
					decorateTrapCell(cell, { blackHoleChance: options.blackHoleChance });
				} else if (coinIndices.has(idx)) {
					cell.classList.add('gold-cell');
				} else if (symbolIndices.has(idx) && !boldIndices.has(idx)) {
					const sym = document.createElement('div');
		  sym.classList.add('symbol', 'gray');

					const colorChances = options.colorChances || [
						{ color: 'blue', weight: 1 },
						{ color: 'green', weight: 1 },
						{ color: 'red', weight: 1 },
						{ color: 'purple', weight: 1 },
						{ color: 'yellow', weight: 1 }
					];
					const totalWeight = colorChances.reduce((sum, entry) => sum + entry.weight, 0) || 1;
					let roll = Math.random() * totalWeight;
					for (const entry of colorChances) {
						if (roll < entry.weight) {
							sym.classList.add(entry.color);
							sym.style.setProperty('--symbol.color', entry.color);
							break;
						}
						roll -= entry.weight;
					}
					cell.appendChild(sym);
				}

				cell.addEventListener('pointerdown', (e) => {
					e.preventDefault();
					toggleCell(cell, containerId);
				});
				frag.appendChild(cell);
			}
		}
		container.appendChild(frag);

			if (containerId === 'yellow-grid') {
				const puntenEl = document.getElementById('yellow-punten');
				if (puntenEl) {
					if (options.diagonalLegend) {
						puntenEl.innerHTML = [
							'<strong>Wereld 2: Diagonalen</strong>',
								'Voltooi diagonale rijen (NWâ†’SE Ã©n NEâ†’SW).',
								'Punten per diagonaal (lengte â†’ punten): <strong>4â†’8, 6â†’16, 8â†’32</strong>.'
						].join('<br>');
					} else if (Array.isArray(options.pointsPerColumn) && options.pointsPerColumn.length) {
						const columnTexts = options.pointsPerColumn.map((value, idx) => {
							if (!Number.isFinite(value) || value <= 0) return `Kolom ${idx + 1}`;
							return `Kolom ${idx + 1}: ${value}`;
						});
						puntenEl.innerHTML = columnTexts.join('<br>');
					} else if (normalizedRowLengths.length) {
						const map = options.pointsPerWidthMap || {};
						const rowsTexts = normalizedRowLengths.map((len, idx) => {
							const pts = map[len];
							return pts ? `Rij ${idx + 1}: ${pts}` : `Rij ${idx + 1}`;
						});
						puntenEl.innerHTML = rowsTexts.join('<br>');
					}
				}
			}

		updateScore();
	}


	// --- Zoom helpers ---
		const placeholderSyncQueue = new Set();
		let placeholderSyncFrame = null;
		let activeZoomZone = null;
		let zoneNavLeft = null;
		let zoneNavRight = null;
		let mobileZoomResizeBound = false;

	function isMobileViewport() {
		return window.innerWidth <= 650;
	}

	function applyMobileZoomSizing(zone) {
		if (!zone) return;
		if (!isMobileViewport()) return;
		if (!['yellow-zone', 'green-zone', 'blue-zone', 'purple-zone', 'red-zone'].includes(zone.id)) return;

		const viewportH = Math.round((window.visualViewport && window.visualViewport.height) ? window.visualViewport.height : window.innerHeight);
		const isShortViewport = viewportH <= 650;
		const objectiveBanner = document.getElementById('mobile-objective-banner');
		const bottomBar = document.getElementById('bottom-bar');
		const objectiveBottom = objectiveBanner ? objectiveBanner.getBoundingClientRect().bottom : 0;
		const bottomTop = bottomBar ? bottomBar.getBoundingClientRect().top : viewportH;
		const margin = isShortViewport ? 4 : 10;
		const available = Math.max(120, Math.floor(bottomTop - objectiveBottom - margin * 2));
		// Short screens: slightly smaller zoom height so everything fits without overlapping controls.
		const desired = Math.floor(viewportH * (isShortViewport ? 0.54 : 0.57));
		const height = Math.max(120, Math.min(desired, available));

		const minCenter = objectiveBottom + margin + height / 2;
		const maxCenter = bottomTop - margin - height / 2;
		// Minimize the gap above the zoomed zone: pin as high as allowed (still clamps to avoid overlap).
		let center = Math.round(minCenter + (isShortViewport ? 0 : 2));
		center = Math.max(minCenter, Math.min(maxCenter, center));

		zone.style.setProperty('--mobile-zoom-height', `${Math.round(height)}px`);
		zone.style.setProperty('--mobile-zoom-center', `${Math.round(center)}px`);
	}

	function bindMobileZoomResizeHandler() {
		if (mobileZoomResizeBound) return;
		mobileZoomResizeBound = true;
		window.addEventListener('resize', () => {
			if (activeZoomZone) applyMobileZoomSizing(activeZoomZone);
		}, { passive: true });
		if (window.visualViewport) {
			window.visualViewport.addEventListener('resize', () => {
				if (activeZoomZone) applyMobileZoomSizing(activeZoomZone);
			}, { passive: true });
		}
	}

	function resetGreenZoomScroll(greenZone) {
		if (!greenZone) return;
		const grid = document.getElementById('green-grid');
		if (!grid) return;
		const sx = Number(grid.dataset.startX);
		const sy = Number(grid.dataset.startY);
		let startCell = null;
		if (Number.isFinite(sx) && Number.isFinite(sy)) {
			startCell = getCell(greenZone, sx, sy);
		}
		if (!startCell) {
			startCell = greenZone.querySelector('#green-grid .cell.bold-cell:not(.void-cell)') || null;
		}
		if (!startCell) return;
		// Offset-based centering is more stable across resizes/zoom.
		const maxLeft = Math.max(0, greenZone.scrollWidth - greenZone.clientWidth);
		const maxTop = Math.max(0, greenZone.scrollHeight - greenZone.clientHeight);
		const desiredLeft = (startCell.offsetLeft + startCell.offsetWidth / 2) - (greenZone.clientWidth / 2);
		const desiredTop = (startCell.offsetTop + startCell.offsetHeight / 2) - (greenZone.clientHeight / 2);
		greenZone.scrollLeft = Math.max(0, Math.min(maxLeft, desiredLeft));
		greenZone.scrollTop = Math.max(0, Math.min(maxTop, desiredTop));
	}

	function resetBlueZoomScroll(blueZone) {
		if (!blueZone) return;
		const blueGrid = document.getElementById('blue-grid');
		if (!blueGrid) return;

		// Start at the bottom.
		blueZone.getBoundingClientRect();
		blueZone.scrollTop = blueZone.scrollHeight;

		// Center on the bottom "start" group (prefer bold-cells) at the lowest row.
		let bestY = -Infinity;
		const allCells = Array.from(blueGrid.querySelectorAll('.cell:not(.void-cell)'));
		for (const cell of allCells) {
			const y = Number(cell.dataset.y);
			if (!Number.isFinite(y)) continue;
			if (y > bestY) bestY = y;
		}
		const bottomRowCells = allCells.filter(c => Number(c.dataset.y) === bestY);
		const bottomBold = bottomRowCells.filter(c => c.classList.contains('bold-cell'));
		const anchorCells = bottomBold.length ? bottomBold : bottomRowCells;

		let targetCenter = null;
		if (anchorCells.length) {
			const centers = anchorCells.map(c => c.offsetLeft + c.offsetWidth / 2);
			const minC = Math.min(...centers);
			const maxC = Math.max(...centers);
			targetCenter = (minC + maxC) / 2;
		}
		const maxLeft = Math.max(0, blueZone.scrollWidth - blueZone.clientWidth);
		if (targetCenter !== null) {
			const desiredLeft = targetCenter - (blueZone.clientWidth / 2);
			blueZone.scrollLeft = Math.max(0, Math.min(maxLeft, desiredLeft));
		} else {
			blueZone.scrollLeft = maxLeft > 0 ? Math.round(maxLeft / 2) : 0;
		}
	}

	// --- Per-zone scroll memory (normal vs zoom) ---
	const ZONE_SCROLL_MEMORY = window.__locusZoneScrollMemory || (window.__locusZoneScrollMemory = {});
	function getZoneScrollMemory(zoneId) {
		if (!ZONE_SCROLL_MEMORY[zoneId]) {
			ZONE_SCROLL_MEMORY[zoneId] = {
				normal: { left: 0, top: 0, initialized: false },
				zoom: { left: 0, top: 0, initialized: false }
			};
		}
		return ZONE_SCROLL_MEMORY[zoneId];
	}
	function getZoneScrollMode(zoneEl) {
		if (!zoneEl) return 'normal';
		return (document.body.classList.contains('zoomed-in') && zoneEl.classList.contains('zoom-focus')) ? 'zoom' : 'normal';
	}
	function clampZoneScroll(zoneEl) {
		if (!zoneEl) return;
		const maxLeft = Math.max(0, zoneEl.scrollWidth - zoneEl.clientWidth);
		const maxTop = Math.max(0, zoneEl.scrollHeight - zoneEl.clientHeight);
		zoneEl.scrollLeft = Math.max(0, Math.min(maxLeft, zoneEl.scrollLeft));
		zoneEl.scrollTop = Math.max(0, Math.min(maxTop, zoneEl.scrollTop));
	}
	function ensureZoneScrollTracking(zoneEl) {
		if (!zoneEl || zoneEl.__scrollTrackingBound) return;
		zoneEl.__scrollTrackingBound = true;
		zoneEl.addEventListener('scroll', () => {
			if (zoneEl.dataset.suppressScrollSave === 'true') return;
			const zoneId = zoneEl.id;
			const mode = getZoneScrollMode(zoneEl);
			const mem = getZoneScrollMemory(zoneId);
			mem[mode].left = zoneEl.scrollLeft;
			mem[mode].top = zoneEl.scrollTop;
			mem[mode].initialized = true;
		}, { passive: true });
	}
	function restoreOrAnchorZoneScroll(zoneEl, anchorFn) {
		if (!zoneEl) return;
		ensureZoneScrollTracking(zoneEl);
		const mem = getZoneScrollMemory(zoneEl.id);
		const mode = getZoneScrollMode(zoneEl);
		requestAnimationFrame(() => {
			zoneEl.dataset.suppressScrollSave = 'true';
			try {
				clampZoneScroll(zoneEl);
				if (mem[mode].initialized) {
					zoneEl.scrollLeft = mem[mode].left || 0;
					zoneEl.scrollTop = mem[mode].top || 0;
					clampZoneScroll(zoneEl);
				} else if (typeof anchorFn === 'function') {
					anchorFn(zoneEl);
					clampZoneScroll(zoneEl);
					mem[mode].left = zoneEl.scrollLeft;
					mem[mode].top = zoneEl.scrollTop;
					mem[mode].initialized = true;
				}
			} finally {
				setTimeout(() => { zoneEl.dataset.suppressScrollSave = 'false'; }, 0);
			}
		});
	}

	// Auto-zoom naar de juiste zone op basis van card kleur
	function autoZoomToColorZone(color) {
		if (!color) return;
		
		const colorName = typeof color === 'object' ? color.name : color;
		let targetZoneId = null;
		
		// Bepaal de juiste zone op basis van kleur
		switch(colorName) {
			case 'geel':
				targetZoneId = 'yellow-zone';
				break;
			case 'groen':
				targetZoneId = 'green-zone';
				break;
			case 'paars':
				targetZoneId = 'purple-zone';
				break;
			case 'blauw':
				targetZoneId = 'blue-zone';
				break;
			case 'rood':
				// Rood heeft 4 subgrids, zoom naar de parent red-zone
				targetZoneId = 'red-zone';
				break;
			case 'multikleur':
				// Voor multikleur: houd huidige zone open, spring niet automatisch naar rood
				// Speler kan zelf kiezen waar te plaatsen
				return;
		}
		
	
	if (targetZoneId) {
		const targetZone = document.getElementById(targetZoneId);
		if (targetZone) {
			// Open zoom ook als het dezelfde zone is (voor hernieuwde selectie)
			openZoom(targetZone);
		}
	}
}
	const ZONE_ORDER = ['purple-zone','yellow-zone','green-zone','red-zone','blue-zone'];	function renameIdsForClone(node, suffix) {
	  if (node.id) node.id = `${node.id}${suffix}`;
	  node.querySelectorAll('[id]').forEach(child => {
		child.id = `${child.id}${suffix}`;
	  });
	}

	function createZonePlaceholder(zone) {
	  const clone = zone.cloneNode(true);
	  renameIdsForClone(clone, '--placeholder');
	  clone.classList.remove('zoom-focus');
	  clone.removeAttribute('data-zoom-active');
	  clone.classList.add('zone-placeholder');
	  clone.setAttribute('aria-hidden', 'true');
	  clone.style.removeProperty('top');
	  clone.style.removeProperty('left');
	  clone.style.removeProperty('right');
	  clone.style.removeProperty('bottom');
	  clone.style.removeProperty('transform');
	  return clone;
	}

	function schedulePlaceholderSync(zone) {
	  if (!zone || !zone._placeholder) return;
	  placeholderSyncQueue.add(zone);
	  if (placeholderSyncFrame) return;
	  placeholderSyncFrame = requestAnimationFrame(() => {
		placeholderSyncQueue.forEach(z => {
		  const replacement = createZonePlaceholder(z);
		  z._placeholder.replaceWith(replacement);
		  z._placeholder = replacement;
		});
		placeholderSyncQueue.clear();
		placeholderSyncFrame = null;
	  });
	}

	function syncPlaceholderForCell(cell) {
	  if (!cell) return;
	  const zone = cell.closest('.zone.zoom-focus');
	  if (zone) {
		schedulePlaceholderSync(zone);
	  }
	}

	function liftToBody(el) {
	  if (el._placeholder) return;
	  const placeholder = createZonePlaceholder(el);
	  el._placeholder = placeholder;
	  if (el.parentNode) {
		el.parentNode.insertBefore(placeholder, el);
	  }
	  document.body.appendChild(el);
	}

	function restoreFromBody(el) {
	  const placeholder = el._placeholder;
	  if (placeholder && placeholder.parentNode) {
		placeholder.parentNode.insertBefore(el, placeholder);
		placeholder.remove();
	  }
	  delete el._placeholder;
	}

	function openZoom(zone) {
		// NOTE: Mobile zone zoom is enabled; only the placement zoom-lens is disabled elsewhere.
		if (!zone || excludedZones.includes(zone.id)) return;
		// iPad/tablet UX: zoomed-in zones are unnecessary and can break layout.
		if (window.matchMedia && window.matchMedia('(pointer: coarse)').matches) {
			const w = window.innerWidth;
			const h = window.innerHeight;
			if (Math.min(w, h) >= 700) return;
		}
		if (activeZoomZone === zone) return;
		closeZoom();
		liftToBody(zone);
		document.body.classList.add('zoomed-in');
		zone.classList.add('zoom-focus');
		zone.setAttribute('data-zoom-active', 'true');
		activeZoomZone = zone;
		addZoneNavArrows();
		bindMobileZoomResizeHandler();
		applyMobileZoomSizing(zone);
		if (zone.id === 'green-zone') {
			// Zoom: first time anchor to start; subsequent opens restore last zoom position.
			restoreOrAnchorZoneScroll(zone, (z) => resetGreenZoomScroll(z));
		}
		if (zone.id === 'blue-zone') {
			// Zoom: first time anchor to bottom start; subsequent opens restore last zoom position.
			restoreOrAnchorZoneScroll(zone, (z) => resetBlueZoomScroll(z));
		}
	}

	function closeZoom() {
		if (!activeZoomZone) return;
		const zone = activeZoomZone;
		// Scroll memory is handled via scroll listeners; no dataset storage.
		placeholderSyncQueue.delete(zone);
		zone.classList.remove('zoom-focus');
		zone.removeAttribute('data-zoom-active');
		restoreFromBody(zone);
		activeZoomZone = null;
		document.body.classList.remove('zoomed-in');
		removeZoneNavArrows();
	}

	function addZoneNavArrows() {
		removeZoneNavArrows();
		zoneNavLeft = document.createElement('div');
		zoneNavLeft.className = 'zone-nav-arrow zone-nav-arrow-left';
		zoneNavLeft.innerHTML = 'â—€';
		zoneNavLeft.addEventListener('click', e => { e.stopPropagation(); navigateToAdjacentZone(-1); });
		zoneNavRight = document.createElement('div');
		zoneNavRight.className = 'zone-nav-arrow zone-nav-arrow-right';
		zoneNavRight.innerHTML = 'â–¶';
		zoneNavRight.addEventListener('click', e => { e.stopPropagation(); navigateToAdjacentZone(1); });
		document.body.append(zoneNavLeft, zoneNavRight);
	}

	function removeZoneNavArrows() {
		if (zoneNavLeft && zoneNavLeft.parentNode) zoneNavLeft.parentNode.removeChild(zoneNavLeft);
		if (zoneNavRight && zoneNavRight.parentNode) zoneNavRight.parentNode.removeChild(zoneNavRight);
		zoneNavLeft = null; zoneNavRight = null;
	}

	function navigateToAdjacentZone(direction) {
		if (!activeZoomZone) return;
		const currentId = activeZoomZone.id;
		const idx = ZONE_ORDER.indexOf(currentId);
		if (idx === -1) return;
		let nextIdx = (idx + direction + ZONE_ORDER.length) % ZONE_ORDER.length;
		const nextId = ZONE_ORDER[nextIdx];
		const nextZone = document.getElementById(nextId);
		if (nextZone) {
			// close current and open next
			// slight delay to avoid immediate click propagation issues
			setTimeout(() => openZoom(nextZone), 50);
		}
	}
	
	const excludedZones = ['scoreboard', 'gold-zone', 'card-choice-zone', 'controls', 'bonus-zone', 'bottom-bar'];

	document.querySelectorAll('.zone').forEach(zone => {
	  if (zone.classList.contains('zone-placeholder')) return;
	  zone.addEventListener('click', e => {
		// Allow zoom in mobile portrait AND mobile landscape sidebar mode
		const isMobileSidebarMode = document.body.classList.contains('mobile-sidebar-layout');
		if (window.innerWidth > MOBILE_BREAKPOINT && !isMobileSidebarMode) return;
		if (skipNextZoneClick) {
		  skipNextZoneClick = false;
		  return;
		}
		if (draggedBlock || draggedShape) return;
		const mainZone = zone.closest('.red-group') || zone;
		if (excludedZones.includes(zone.id) || (mainZone.id && excludedZones.includes(mainZone.id))) return;
		if (e.pointerType === 'mouse' || e.pointerType === 'pen' || typeof e.pointerType === 'undefined') {
		  if (e.detail === 0 || e.detail > 1) return;
		}
		e.stopPropagation();
		openZoom(mainZone);
	  });
	});

	document.addEventListener('click', e => {
	  /*
		EN:
		- WHY: Clicking outside the focused zone closes the zoom view.
		- STATE: gated by `.zoomed-in` class on <body>.
		- OVERRIDE/DUPLICATE RISK: This is a global document click handler.
		  If other global click handlers exist (menu close, tap-to-place, etc.),
		  ordering + `stopPropagation()` decides which one â€œwinsâ€.
	*/
	  if (!document.body.classList.contains('zoomed-in')) return;
	  if (draggedBlock) return;
	  if (e.target.closest('.zone.zoom-focus')) return;
	  if (e.target.closest('.zone-placeholder')) return;
	  if (e.target.closest('#bottom-bar') || e.target.closest('#card-choice-zone') || e.target.closest('#controls') || e.target.closest('#gold-zone') || e.target.closest('#scoreboard') || e.target.closest('#menu-toggle')) return;
	  closeZoom();
	});

	document.addEventListener('keydown', e => {
	  /*
		EN:
		- WHY: Keyboard escape hatch for zoom mode.
		- DUPLICATE RISK: Escape is also handled in the drag/shape keydown handler below.
		  Make sure the combined behavior is intentional.
	*/
	  if (e.key === 'Escape') {
		closeZoom();
	  }
	  
	  // Ctrl+Z voor undo
	  if ((e.ctrlKey || e.metaKey) && e.key === 'z' && !e.shiftKey) {
		e.preventDefault();
		if (typeof undo === 'function') {
			undo();
		}
	  }
	});


  // ---------- GENERATE ROOTS (green + red variants) ----------
	function generateRoots(gridId, rows = 12, cols = 12, branchCount = 5, splitChance = 0.25, coinChance = 0.05, minSymbols = 3, maxSymbols = 6, maxCoins = 5, isRed = false, trapChance = 0, maxTraps = 0, blackHoleChance = BLACK_HOLE_DEFAULT_CHANCE) {
	  const container = document.getElementById(gridId);
	  
	  // Check of container bestaat
	  if (!container) {
		console.warn(`âš ï¸ Grid element with ID "${gridId}" not found, skipping generation`);
		return;
	  }
	  
	  container.innerHTML = '';
	container.dataset.rows = String(rows);
	container.dataset.cols = String(cols);
	  container.style.position = 'relative';
	  container.style.width = `calc(${cols} * var(--cell-size))`;
	  container.style.height = `calc(${rows} * var(--cell-size))`;
	
	  const toIndex = (r,c)=> r*cols + c;
	  const isInside = (r,c)=> r>=0 && r<rows && c>=0 && c<cols;

	  const clusterSet = new Set();
	  const clusterMap = {};
	  const dirs = [{r:-1,c:0},{r:1,c:0},{r:0,c:-1},{r:0,c:1}];

	  const colorChances = [
		{color:'blue', weight:1},
		{color:'green', weight:3},
		{color:'red', weight:1},
		{color:'purple', weight:1},
		{color:'yellow', weight:1}
	  ];
	  const totalWeight = colorChances.reduce((s,o)=>s+o.weight,0);

	  const centerR = Math.floor(rows/2);
	  const centerC = Math.floor(cols/2);
	  const centerIdx = toIndex(centerR, centerC);
	  container.dataset.startX = String(centerC);
	  container.dataset.startY = String(centerR);

	  // WORLD 2 green: special generator (mega root in center -> 4 arms with World 1-like branching).
	  const isWorld2Green = !isRed && gridId === 'green-grid' && (rows >= 24 || cols >= 24);

	  // Fallback for tall-green variants (older tuning): fewer, longer continuous branches.
	  const isTallGreen = !isWorld2Green && !isRed && gridId === 'green-grid' && rows >= 40;
	  let growthBudget = Math.max(0, Math.floor(branchCount));
	  const branchAttempts = isTallGreen ? Math.max(18, Math.floor(growthBudget / 10)) : Math.max(1, Math.floor(branchCount));
	  const minBranchLen = isTallGreen ? 8 : 2;
	  const maxBranchLen = isTallGreen ? 18 : 5;

		function makeCell(r,c,isCenter=false, isVoid=false){
		  const el = document.createElement('div');
		  el.classList.add('cell','root-cell');
		  if(isVoid) {
			el.classList.add('void-cell');
			el.style.opacity = '0';
			el.style.pointerEvents = 'none';
		  }
		  if(isCenter && !isRed && !isVoid) el.classList.add('bold-cell');
		  el.style.position = 'absolute';
		  el.style.left = `calc(${c} * var(--cell-size))`;
		  el.style.top  = `calc(${r} * var(--cell-size))`;
		  el.style.zIndex = isCenter ? 10 : 1;
		  // Sla r/c op als data-attributes â€” dit is cruciaal voor de edge-detectie
		  el.dataset.r = String(r);
		  el.dataset.c = String(c);
		  el.dataset.x = c; // kolomindex
		  el.dataset.y = r; // rijindex
		  el.dataset.zoneId = gridId;
	
		  if(!isVoid) {
			// World 2 green UX: allow dragging/panning the grid without accidentally toggling cells.
			// We toggle on pointerup and ignore it if the zone was drag-scrolled.
			if (gridId === 'green-grid' && (rows >= 24 || cols >= 24)) {
				el.addEventListener('pointerup', (e)=>{
					const zoneEl = container.closest('#green-zone');
					if (zoneEl && zoneEl.dataset.dragScrolling === 'true') return;
					e.preventDefault();
					toggleCell(el, gridId);
				});
			} else {
				el.addEventListener('pointerdown', (e)=>{ e.preventDefault(); toggleCell(el, gridId); });
			}
		  }
		  return el;
		}


	  // center
	  const centerCell = makeCell(centerR, centerC, true, false);
	  if (!isRed) centerCell.classList.add('bold-cell');
	  container.appendChild(centerCell);
	  clusterSet.add(centerIdx);
	  clusterMap[centerIdx] = centerCell;

	  // build branches first to determine which cells are active
	  // Verbeterde logica: creÃ«er bredere, speelbaardere gebieden
	  const endpoints = [{r:centerR,c:centerC}];
	  
	  // Helper functie om naburige cellen toe te voegen (voor breedte)
	  const addWidthCell = (r, c, dir) => {
		// Voeg een cel toe perpendiculair aan de richting voor breedte
		const perpendicular = [
		  {r: dir.c, c: -dir.r},  // 90 graden gedraaid
		  {r: -dir.c, c: dir.r}   // -90 graden gedraaid
		];
		const chosen = perpendicular[Math.floor(Math.random() * perpendicular.length)];
		const newR = r + chosen.r;
		const newC = c + chosen.c;
		if (isInside(newR, newC)) {
		  const idx = toIndex(newR, newC);
		  if (!clusterSet.has(idx)) {
			clusterSet.add(idx);
			if (isTallGreen && growthBudget > 0) growthBudget -= 1;
			return true;
		  }
		}
		return false;
	  };
	  
	  // Voor groen grid: zorg voor exact 8 eindpunten
	  const targetEndpoints = !isRed ? 8 : Math.max(1, Math.floor(branchCount * splitChance));
	  
	  if (isWorld2Green) {
		// 1) Build a thick center "mega root" (2-3 wide).
		const thickness = Math.random() < 0.6 ? 2 : 3;
		const halfA = Math.floor((thickness - 1) / 2);
		const halfB = thickness - 1 - halfA;
		const top = Math.max(0, centerR - halfA);
		const bottom = Math.min(rows - 1, centerR + halfB);
		const left = Math.max(0, centerC - halfA);
		const right = Math.min(cols - 1, centerC + halfB);
		for (let rr = top; rr <= bottom; rr++) {
			for (let cc = left; cc <= right; cc++) {
				clusterSet.add(toIndex(rr, cc));
			}
		}

		// 2) Create 4 arms that branch like World 1.
		const armStarts = [];
		if (isInside(top - 1, centerC)) armStarts.push({ r: top - 1, c: centerC, primary: { r: -1, c: 0 } });
		if (isInside(bottom + 1, centerC)) armStarts.push({ r: bottom + 1, c: centerC, primary: { r: 1, c: 0 } });
		if (isInside(centerR, left - 1)) armStarts.push({ r: centerR, c: left - 1, primary: { r: 0, c: -1 } });
		if (isInside(centerR, right + 1)) armStarts.push({ r: centerR, c: right + 1, primary: { r: 0, c: 1 } });
		armStarts.forEach(s => clusterSet.add(toIndex(s.r, s.c)));

		const armBranches = Math.max(10, Math.floor(branchCount / 8));
		const chooseDirForArm = (primaryDir) => {
			// Bias outward + sideways, avoid going back toward the center.
			const weighted = [];
			for (const d of dirs) {
				let w = 1;
				if (d.r === primaryDir.r && d.c === primaryDir.c) w = 5;
				else if (d.r === -primaryDir.r && d.c === -primaryDir.c) w = 0.5;
				else w = 2;
				weighted.push({ d, w });
			}
			const total = weighted.reduce((s, x) => s + x.w, 0);
			let roll = Math.random() * total;
			for (const item of weighted) {
				roll -= item.w;
				if (roll <= 0) return item.d;
			}
			return primaryDir;
		};

		for (const arm of armStarts) {
			const armEndpoints = [{ r: arm.r, c: arm.c }];
			for (let b = 0; b < armBranches; b++) {
				const len = 2 + Math.floor(Math.random() * 4);
				const start = armEndpoints[Math.floor(Math.random() * armEndpoints.length)];
				let r = start.r;
				let c = start.c;
				const dir = chooseDirForArm(arm.primary);
				const makeWide = Math.random() < 0.20;
				for (let i = 0; i < len; i++) {
					r += dir.r;
					c += dir.c;
					if (!isInside(r, c)) break;
					const idx = toIndex(r, c);
					if (clusterSet.has(idx)) continue;
					clusterSet.add(idx);
					if (makeWide || Math.random() < 0.12) addWidthCell(r, c, dir);
					if (armEndpoints.length < targetEndpoints && i > 0 && Math.random() < splitChance) {
						armEndpoints.push({ r, c });
					}
				}
			}
		}
	  } else {
		for(let b=0;b<branchAttempts;b++){
		  if (isTallGreen && growthBudget <= 0) break;
		  const len = minBranchLen + Math.floor(Math.random() * (maxBranchLen - minBranchLen + 1));
		  const start = endpoints[Math.floor(Math.random()*endpoints.length)];
		  let r = start.r, c = start.c;
		  const dir = dirs[Math.floor(Math.random()*dirs.length)];
		  
		  // 25% kans dat deze tak breed wordt (vooral voor groen grid)
		  const makeWide = !isRed && Math.random() < 0.25;

		  for(let i=0;i<len;i++){
			if (isTallGreen && growthBudget <= 0) break;
			r += dir.r; c += dir.c;
			if(!isInside(r,c)) break;
			const idx = toIndex(r,c);
			if(clusterSet.has(idx)) continue;

			clusterSet.add(idx); // Markeer deze cel als actief (niet void)
			if (isTallGreen && growthBudget > 0) growthBudget -= 1;
			
			// Maak de tak breder op deze positie
			if (makeWide || Math.random() < 0.1) {
			  addWidthCell(r, c, dir);
			}

			// Voeg eindpunt toe als we er nog niet genoeg hebben (voor groen grid)
			if (!isRed && endpoints.length < targetEndpoints && i > 0) {
			  if (Math.random() < splitChance) endpoints.push({r,c});
			} else if (isRed && Math.random() < splitChance) {
			  endpoints.push({r,c});
			}
		  }
		}
	  }
	  
	  // NU: Maak ALLE cellen aan - actieve EN void cellen
	  for(let r = 0; r < rows; r++) {
		for(let c = 0; c < cols; c++) {
		  const idx = toIndex(r, c);
		  const isActive = clusterSet.has(idx);
		  const isCenter = (idx === centerIdx);
		  
		  // Als de cel al bestaat (center), skip
		  if(clusterMap[idx]) continue;
		  
		  // Maak de cel - actief of void
		  const cell = makeCell(r, c, isCenter, !isActive);
		  container.appendChild(cell);
		  clusterMap[idx] = cell;
		}
	  }

	  // ---------- assign symbols & coins only to existing cells ----------
	  const clusterIndices = Array.from(clusterSet).filter(i => i !== centerIdx);
	  shuffleArray(clusterIndices);

	  // Voor groen grid: schaal symbolen en coins op basis van aantal actieve cellen
	  let finalMinSymbols = minSymbols;
	  let finalMaxSymbols = maxSymbols;
	  let finalMaxCoins = maxCoins;
	  let finalCoinChance = coinChance;
	  
	  if (!isRed) {
		const clusterSize = clusterIndices.length;
		// Bereken percentage van grid dat gevuld is (ongeveer 15-25% voor symbolen)
		const symbolPercentage = 0.20; // 20% van de cellen krijgen symbolen
		const coinPercentage = 0.08;   // 8% van de cellen krijgen coins
		
		// Voor kleine grids (<20 cellen): halveer de minimale EN maximale waardes
		const isSmallGrid = clusterSize < 20;
		const minSymbolBase = isSmallGrid ? 4 : 8;
		const maxSymbolBase = isSmallGrid ? 6 : 12;
		const maxCoinBase = isSmallGrid ? 2 : 3;
		
		finalMinSymbols = Math.max(minSymbolBase, Math.floor(clusterSize * (symbolPercentage - 0.05)));
		finalMaxSymbols = Math.max(maxSymbolBase, Math.floor(clusterSize * (symbolPercentage + 0.05)));
		finalMaxCoins = Math.max(maxCoinBase, Math.floor(clusterSize * coinPercentage));
		finalCoinChance = 0.15; // Hogere kans maar minder max coins
	  }

	  // SYMBOLS
	  const symCount = Math.min(clusterIndices.length, Math.floor(Math.random()*(finalMaxSymbols-finalMinSymbols+1))+finalMinSymbols);
	  const symbolIndices = new Set(clusterIndices.slice(0, symCount));

	  // COINS
	  const remainingForCoins = clusterIndices.filter(i => !symbolIndices.has(i));
	  shuffleArray(remainingForCoins);
	  const coinSet = new Set();
	  for(const cand of remainingForCoins){
		if(coinSet.size >= finalMaxCoins) break;
		if(Math.random() < finalCoinChance) coinSet.add(cand);
	  }

	  const trapSet = new Set();
	  const trapChanceClamped = Math.max(0, Math.min(1, trapChance || 0));
	  const trapLimit = maxTraps > 0 ? maxTraps : 0;
	  if (trapChanceClamped > 0 && trapLimit !== 0) {
		const trapCandidates = clusterIndices.filter(i => !symbolIndices.has(i) && !coinSet.has(i));
		shuffleArray(trapCandidates);
		for (const cand of trapCandidates) {
		  if (trapSet.size >= trapLimit) break;
		  if (Math.random() < trapChanceClamped) trapSet.add(cand);
		}
	  }
	  trapSet.forEach(idx => {
		symbolIndices.delete(idx);
		coinSet.delete(idx);
	  });

	  // apply symbols & coins
	  for(const idx of clusterSet){
		const cell = clusterMap[idx];
		if(!cell) continue;

		if(trapSet.has(idx)){
		  decorateTrapCell(cell, { blackHoleChance });
		}

		else if(symbolIndices.has(idx)){
		  const sym = document.createElement('div');
		  sym.classList.add('symbol', 'gray');
		  let rr = Math.random()*totalWeight;
		  for(const cc of colorChances){
			if(rr < cc.weight){ sym.classList.add(cc.color); break; }
			rr -= cc.weight;
		  }
		  cell.appendChild(sym);
		}

		else if(coinSet.has(idx)){
		  cell.classList.add('gold-cell');
		}
	  }

	  // ---------- mark endpoints ----------
	  if (!isRed) {
		const greenCfg = (gridId === 'green-grid' && typeof window !== 'undefined') ? (window.greenGridConfig || null) : null;
		const targetMinEndpoints = Math.max(0, Number(greenCfg?.minEndPoints ?? 8) || 8);
		const targetMinEndCells = Math.max(0, Number(greenCfg?.minEndCellPoints ?? targetMinEndpoints) || targetMinEndpoints);
		const targetMaxEndCells = Math.max(targetMinEndCells, Number(greenCfg?.maxEndCellPoints ?? 30) || 30);
		// We want enough candidates to pick from.
		const desiredEndpointPool = Math.max(targetMinEndpoints, targetMinEndCells);
		// End-cell count: clamp to available endpoints, but allow >8 in World 2.
		const desiredEndCellCount = Math.min(targetMaxEndCells, Math.max(targetMinEndCells, desiredEndpointPool));

		// Verzamel alle potentiÃ«le eindpunten (cellen met max 1 buur)
		const potentialEndpoints = [];
		for(const idx of clusterSet){
		  const r = Math.floor(idx/cols), c = idx % cols;
		  let neighbors=0;
		  for(const d of dirs){
			const nr=r+d.r, nc=c+d.c;
			if(isInside(nr,nc) && clusterSet.has(toIndex(nr,nc))) neighbors++;
		  }
		  if(neighbors <= 1 && idx !== centerIdx){
			potentialEndpoints.push(idx);
		  }
		}
		
		// Als we niet genoeg eindpunten hebben, voeg cellen met 2 buren toe
		if (potentialEndpoints.length < desiredEndpointPool) {
		  const additionalEndpoints = [];
		  for(const idx of clusterSet){
			if (potentialEndpoints.includes(idx) || idx === centerIdx) continue;
			const r = Math.floor(idx/cols), c = idx % cols;
			let neighbors=0;
			for(const d of dirs){
			  const nr=r+d.r, nc=c+d.c;
			  if(isInside(nr,nc) && clusterSet.has(toIndex(nr,nc))) neighbors++;
			}
			if(neighbors === 2){
			  additionalEndpoints.push(idx);
			}
		  }
		  shuffleArray(additionalEndpoints);
		  const needed = desiredEndpointPool - potentialEndpoints.length;
		  potentialEndpoints.push(...additionalEndpoints.slice(0, needed));
		}
		
		// Als nog steeds niet genoeg, neem cellen met 3 buren
		if (potentialEndpoints.length < desiredEndpointPool) {
		  const moreEndpoints = [];
		  for(const idx of clusterSet){
			if (potentialEndpoints.includes(idx) || idx === centerIdx) continue;
			const r = Math.floor(idx/cols), c = idx % cols;
			let neighbors=0;
			for(const d of dirs){
			  const nr=r+d.r, nc=c+d.c;
			  if(isInside(nr,nc) && clusterSet.has(toIndex(nr,nc))) neighbors++;
			}
			if(neighbors === 3){
			  moreEndpoints.push(idx);
			}
		  }
		  shuffleArray(moreEndpoints);
		  const needed = desiredEndpointPool - potentialEndpoints.length;
		  potentialEndpoints.push(...moreEndpoints.slice(0, needed));
		}
		
		// Shuffle en selecteer een groter aantal eindpunten (World 2: meer end-cells)
		shuffleArray(potentialEndpoints);
		const selectedEndpoints = potentialEndpoints.slice(0, Math.min(desiredEndCellCount, potentialEndpoints.length));
		
		// Markeer de geselecteerde eindpunten
		for(const idx of selectedEndpoints){
		  const cell = clusterMap[idx];
		  if(cell){
			cell.querySelectorAll('.symbol').forEach(s=>s.remove());
			cell.classList.remove('gold-cell');
			if (trapSet.has(idx)) {
			  cell.classList.remove('trap-cell');
			  delete cell.dataset.trap;
			  cell.querySelectorAll('.trap-symbol').forEach(s => s.remove());
			}
			cell.classList.add('end-cell');
			cell.style.zIndex = 5;
		  }
		}
	  }

	  updateScore();
	  return clusterSet;
	}

  // ---------- toggleCell / coins ----------
	function toggleCell(cell, zoneId, explicitColor = null, partOfShape = false){

	if(!cell) return;
	if(cell.classList.contains('void-cell') || cell.dataset.disabled === 'true') return;

	if (!partOfShape) {
		if (draggedBlock) return;
		const isClassicMode = document.body.classList.contains('classic-mode');
		// Classic mode: allow direct click/tap placement without debug mode and without requiring zoom.
		if (!debugMode && !isClassicMode) {
			if (window.innerWidth <= MOBILE_BREAKPOINT && !document.body.classList.contains('zoomed-in')) {
				return;
			}
			return;
		}
	}
	
    // bepaal of cel voorheen actief was
	  const was = cell.classList.contains('active');

	  // push history (zodat undo werkt)
	  if (!partOfShape) {
		const actionId = ++actionSequence;
		historyStack.push({cell:cell, wasActive: was, sequence: actionId});
	  }

	  // bepaal zone en zoneColor op een robuuste manier
	  let zone = null;
	  if (zoneId) zone = document.getElementById(zoneId);
	  if (!zone) zone = cell.closest('.zone');
	  
	  const zoneColor = explicitColor || zone?.dataset?.color || '';
			
	 if(was) {
		// --- DEACTIVEREN ---
		cell.classList.remove('active');
		cell.classList.remove('preview-allowed', 'preview-denied', 'edge-cell');

		// Cleanup dataset
		delete cell.dataset.clusterScore;
		delete cell.dataset.clusterPending;
		delete cell.dataset.activationSequence;
		delete cell.dataset.placementId;
	  } else {
		cell.classList.add('active');
		cellActivationSequence += 1;
		cell.dataset.activationSequence = String(cellActivationSequence);
		if (partOfShape && currentPlacementId) {
			cell.dataset.placementId = currentPlacementId;
		} else {
			delete cell.dataset.placementId;
		}
		
		// Clean up portal visual elements when portal cell becomes active
		if (cell.classList.contains('portal-cell')) {
			const portalSymbol = cell.querySelector('.portal-symbol');
			if (portalSymbol) portalSymbol.remove();
			cell.classList.remove('portal-cell');
			// Keep bold-cell class for scoring logic
		}
				// zorg dat achtergrond consistent wordt gezet: expliciete kleur (bv. van placeShape) of zoneColor
				try {
					const rainbowGradient = 'linear-gradient(45deg, #f06272, #fff25a, #4ed346, #5d90f0, #a35eff)';
					let appliedBg = '';
					if (explicitColor) appliedBg = (explicitColor === 'rainbow') ? rainbowGradient : explicitColor;
					else if (zoneColor) appliedBg = (zoneColor === 'rainbow') ? rainbowGradient : zoneColor;

					// If this is a designated start-cell in the green zone, force the lighter green (do NOT use dark end-cell color)
					if (cell.classList.contains('start-cell')) {
						const zcol = String(zone && zone.dataset ? (zone.dataset.color || '') : '').toLowerCase();
						if (zcol === 'groen' || zcol === 'green') {
							appliedBg = '#92c28c';
							try { cell.style.borderColor = '#c1ffa8'; } catch (e) {}
						}
					}

					cell.style.background = appliedBg;
				} catch (e) { /* ignore styling errors */ }
	  }
    // If this cell is a coin and is activated, add coin; if deactivated, remove coin
	if(cell.classList.contains('gold-cell')){
      if(cell.classList.contains('active')) { 
	  const rect = cell.getBoundingClientRect();
		const scrollX = window.scrollX || window.pageXOffset;
		const scrollY = window.scrollY || window.pageYOffset;
		sparkleEffect(rect.left + rect.width / 2 + scrollX, rect.top + scrollY);
	  addCoin(); 
	} else removeCoin();
    }
	
	let bonusClaim = null;
	hasSymbol = cell.querySelector('.symbol');
	if(hasSymbol && cell.classList.contains('active') && cell.dataset.bonusConsumed !== 'true'){
		// World 2 field event: bonus upgrade shop (grants 1 free random upgrade)
		if (hasSymbol.classList.contains('upgrade-shop-symbol') || cell.dataset.bonusUpgradeEvent === 'true') {
			cell.dataset.bonusConsumed = 'true';
			delete cell.dataset.bonusUpgradeEvent;
			hasSymbol.classList.add('bonus-used');
			try { hasSymbol.remove(); } catch {}
			openRandomFreeBonusUpgradeModal();
		} else if (hasSymbol.classList.contains('mega-bonus-symbol')) {
			const megaBonusColor = hasSymbol.dataset.megaBonusColor;
			cell.dataset.bonusConsumed = 'true';
			hasSymbol.classList.add('bonus-used');
			const rect = cell.getBoundingClientRect();
			const scrollX = window.scrollX || window.pageXOffset;
			const scrollY = window.scrollY || window.pageYOffset;
			const color = getComputedStyle(hasSymbol).backgroundColor;
			showScoreAnimation(rect.left + rect.width/2 + scrollX, rect.top + rect.height/2 + scrollY, "MEGA BONUS!", color);
			// Bonus shop is now a field event (no modal). Grant a free random upgrade.
			setTimeout(() => {
				grantRandomBonusUpgrade();
			}, 250);
		} else {
			// Normale bonus handling
			const bonusKey = getBonusKeyFromSymbol(hasSymbol);
			const grantedAmount = bonusKey ? grantBonusCharge(bonusKey) : 0;
			if (grantedAmount > 0) {
				cell.dataset.bonusConsumed = 'true';
				hasSymbol.classList.add('bonus-used');
				const rect = cell.getBoundingClientRect();
				const scrollX = window.scrollX || window.pageXOffset;
				const scrollY = window.scrollY || window.pageYOffset;
				const color = getComputedStyle(hasSymbol).backgroundColor;
				showScoreAnimation(rect.left + rect.width/2 + scrollX, rect.top + rect.height/2 + scrollY, "BONUS", color);
				bonusClaim = createBonusClaim(cell, hasSymbol, bonusKey, grantedAmount);
				if (!partOfShape) {
					const lastHistory = historyStack[historyStack.length - 1];
					if (lastHistory && lastHistory.cell === cell) {
						lastHistory.bonusClaims = lastHistory.bonusClaims || [];
						lastHistory.bonusClaims.push(bonusClaim);
					}
				}
			}
		}
	}

	ensureTrapState(cell, zone?.id || zoneId || '');

	updateScore(cell);
	syncPlaceholderForCell(cell);
	return bonusClaim ? { bonusClaim } : null;
	}

	function createCoinElement(index) {
		const coin = document.createElement('div');
		coin.classList.add('coin');
		coin.dataset.index = String(index);
		coin.addEventListener('pointerdown', (e) => {
			e.preventDefault();
			const isActive = coin.classList.contains('active');
			const isUsed = coin.classList.contains('used');
			if (!isActive && !isUsed) return;
			if (isUsed) {
				coin.classList.remove('used');
				coin.classList.add('active');
			} else {
				coin.classList.add('used');
				coin.classList.remove('active');
			}
			updateCoinCounter();
		});
		return coin;
	}

	function initialiseCoins(minCount = 50) {
		const container = document.getElementById('collected-coins');
		if (!container) return;
		const isClassicMode = document.body.classList.contains('classic-mode');
		const desired = isClassicMode ? 20 : Math.max(50, Number(minCount) || 0);
		const existing = container.children.length;
		if (existing >= desired) {
			updateCoinCounter();
			return;
		}
		for (let i = existing; i < desired; i++) {
			container.appendChild(createCoinElement(i));
		}
		updateCoinCounter();
	}

	function resetCoins() {
	  document.querySelectorAll('#collected-coins .coin').forEach(coin => {
		coin.classList.remove('active', 'used');
	  });
	  updateCoinCounter();
	}

	function resetScoreState() {
	  yellow = 0;
	  green = 0;
	  purple = 0;
	  blue = 0;
	  red = 0;
	  bonus = 0;
	  blackHoleBonus = 0;
	  totalBonusesCollected = 0;
	  latestScoreSnapshot = null;
	coinsAwardedFromScore = 0;
	cellActivationSequence = 0;
	placementSequence = 0;
	currentPlacementId = null;
	  resetBlackHoleState();
	  bonusCoinMilestones = 0;
	  window.scoredYellowColumns = new Set();
	  window.scoredYellowDiagonals = new Set();
	  window.scoredYellowSegments = new Set();
	window['blue-grid-scoredRows'] = new Map();
	window['blue-grid-scoredTargets'] = new Map();
	window['blue-grid-rowPlacements'] = new Map();
	window['blue-grid-placementScorings'] = new Map();
	  delete window.purpleConnections;
	  ['red-grid1', 'red-grid2', 'red-grid3', 'red-grid4'].forEach(id => {
		const grid = document.getElementById(id);
		if (grid) {
		  grid.dataset.completed = 'false';
		  grid.dataset.score = '0';
		}
	  });
	  const scoreIds = ['yellow-score','red-score','green-score','purple-score','blue-score','bonus-score'];
	  scoreIds.forEach(id => {
		const el = document.getElementById(id);
		if (el) el.textContent = '0';
	  });
	  const totalScoreEl = document.getElementById('total-score');
	  if (totalScoreEl) {
		totalScoreEl.textContent = '0';
		totalScoreEl.classList.remove('flash');
	  }
	  resetTrapState();
	  resetBonusState();
	}

	function addCoin(){
		const container = document.getElementById('collected-coins');
		if (!container) return;
		const coins = Array.from(container.querySelectorAll('.coin'));
		let next = coins.find(coin => !coin.classList.contains('active') && !coin.classList.contains('used'));
		if (!next) {
			next = createCoinElement(coins.length);
			container.appendChild(next);
		}
		next.classList.add('active');
		next.classList.remove('used');
		updateCoinCounter();
	}

	function removeCoin(){
	  const coins = Array.from(document.querySelectorAll('#collected-coins .coin.active'));
	  const last = coins.pop();
	  if(last) last.classList.remove('active', 'used');
	  updateCoinCounter();
	}

	const TRAP_ZONE_LABELS = {
	  'yellow-grid': 'Geel',
	  'purple-grid': 'Paars',
	  'green-grid': 'Groen',
	  'blue-grid': 'Blauw',
	  'gold-zone': 'Munten',
	  'red-zone': 'Rood'
	};

	function normalizeZoneId(zoneId = '') {
	  return zoneId.replace(/--placeholder$/, '');
	}

	function nextTrapId() {
	  trapIdCounter += 1;
	  return `trap-${trapIdCounter}`;
	}

	function getTrapZoneLabel(zoneId = '') {
	  if (!zoneId) return 'Onbekend';
	  const normalized = normalizeZoneId(zoneId);
	  if (normalized.startsWith('red-grid')) return 'Rood';
	  return TRAP_ZONE_LABELS[normalized] || normalized;
	}

	function decorateTrapCell(cell, options = {}) {
	  if (!cell) return 'pit';
	  const { forceType = null, blackHoleChance = BLACK_HOLE_DEFAULT_CHANCE } = options;
	  let trapType = forceType;
	  if (!trapType) {
		const chance = Math.max(0, Math.min(1, Number(blackHoleChance) || 0));
		trapType = chance > 0 && Math.random() < chance ? 'blackHole' : 'pit';
	  }
	  cell.classList.add('trap-cell');
	  cell.dataset.trap = 'true';
	  cell.dataset.trapType = trapType;
	const shouldRevealTrap = trapType !== 'blackHole' || hasUpgrade('blackHoleAccess');
	if (shouldRevealTrap) {
		const symbol = document.createElement('div');
		symbol.classList.add('symbol', 'trap-symbol');
		if (trapType === 'blackHole') symbol.classList.add('trap-symbol--black-hole');
		else symbol.classList.add('trap-symbol--pit');
		cell.appendChild(symbol);
	}
	  return trapType;
	}

	function resetBlackHoleState() {
	  blackHoleState.trap = null;
	  blackHoleState.cards = [];
	  blackHoleState.selected = new Set();
	  blackHoleState.reward = 0;
	  blackHoleState.coins = 0;
	  blackHoleState.stake = 0;
	  blackHoleState.gameOver = false;
	  if (blackHoleState.feedbackTimeout) {
		clearTimeout(blackHoleState.feedbackTimeout);
		blackHoleState.feedbackTimeout = null;
	  }
	}

	function getTotalTrapPenalty() {
	  return activeTraps.reduce((sum, trap) => {
		const penalty = Number(trap.penalty) || 0;
		return penalty > 0 ? sum + penalty : sum;
	  }, 0);
	}

	function renderTrapSummary(options = {}) {
	  const { highlightId = null } = options;
	  const preview = document.getElementById('scoreboard-trap-preview');
	  const countEl = document.getElementById('trap-count-label');
	  
	  // Als trap-summary niet bestaat (verwijderd uit HTML), stop functie
	  if (!preview || !countEl) return;
	  
	const blackHoleUnlocked = hasUpgrade('blackHoleAccess');
	const visibleTraps = activeTraps.filter(trap => trap.type !== 'blackHole' || blackHoleUnlocked);
	const trapCount = visibleTraps.length;
	
	// Set data attribute op body voor CSS styling (voor toekomstig gebruik)
	if (currentLevel >= 5) {
		document.body.setAttribute('data-traps-active', 'true');
	} else {
		document.body.removeAttribute('data-traps-active');
	}
	
	const totalPenalty = visibleTraps.reduce((sum, trap) => {
		const penalty = Number(trap.penalty) || 0;
		return penalty > 0 ? sum + penalty : sum;
	}, 0);
	const specialCount = blackHoleUnlocked ? visibleTraps.filter(trap => trap.type === 'blackHole').length : 0;
	const penaltyCount = visibleTraps.filter(trap => trap.type !== 'blackHole').length;
	const scoreboardEl = document.getElementById('scoreboard');
	const isScoreboardInBottomBar = !!(scoreboardEl && scoreboardEl.closest('#bottom-bar'));
	const isMobileView = isScoreboardInBottomBar || window.innerWidth <= MOBILE_BREAKPOINT;
	preview.classList.toggle('trap-preview--compact', isMobileView);
	preview.innerHTML = '';
	if (trapCount === 0) {
		countEl.textContent = '0 actief';
		return;
	}
	const summaryParts = [`${trapCount} actief`];
	if (totalPenalty > 0) summaryParts.push(`âˆ’${totalPenalty}`);
	if (specialCount > 0) summaryParts.push(`${specialCount} zwart gat`);
	if (isMobileView) {
		const segments = [];
		if (penaltyCount > 0) segments.push(`âš ï¸ ${penaltyCount}`);
		if (specialCount > 0) segments.push(`ðŸŒ€ ${specialCount}`);
		countEl.textContent = segments.length ? segments.join(' Â· ') : `${trapCount}`;
		if (penaltyCount > 0) {
		  const chip = document.createElement('span');
		  chip.classList.add('trap-compact-chip');
		  chip.dataset.symbol = 'âš ï¸';
		  chip.innerHTML = `<span>${penaltyCount}</span>`;
		  const penaltyLabel = totalPenalty > 0 ? `, -${totalPenalty} punten` : '';
		  const label = `${penaltyCount} valkuil${penaltyCount === 1 ? '' : 'en'} actief${penaltyLabel}`;
		  chip.setAttribute('aria-label', label);
		  chip.title = label;
		  preview.appendChild(chip);
		}
		if (specialCount > 0) {
		  const chip = document.createElement('span');
		  chip.classList.add('trap-compact-chip', 'trap-compact-chip--black-hole');
		  chip.dataset.symbol = 'ðŸŒ€';
		  chip.innerHTML = `<span>${specialCount}</span>`;
		  const label = `${specialCount} zwart gat${specialCount === 1 ? '' : 'en'} actief`;
		  chip.setAttribute('aria-label', label);
		  chip.title = label;
		  preview.appendChild(chip);
		}
		return;
	}
	countEl.textContent = summaryParts.join(' Â· ');
	const sortedTraps = [...visibleTraps].sort((a, b) => a.triggeredAt - b.triggeredAt);
	  sortedTraps.forEach(trap => {
		const icon = document.createElement('div');
		icon.classList.add('trap-icon');
		const isBlackHole = trap.type === 'blackHole';
		icon.classList.toggle('trap-icon--black-hole', isBlackHole);
		icon.classList.toggle('trap-icon--penalty', !isBlackHole || (trap.penalty ?? 0) > 0);
		icon.dataset.trapId = trap.id;
		icon.setAttribute('role', 'listitem');
		const penaltyValue = Number(trap.penalty) || 0;
		const labelBits = [isBlackHole ? 'Zwart gat' : 'Valkuil', 'in', getTrapZoneLabel(trap.zoneId)];
		if (penaltyValue > 0) labelBits.push(`geeft -${penaltyValue} punten`);
		else if (isBlackHole) labelBits.push('bonus beschikbaar');
		icon.setAttribute('aria-label', labelBits.join(' '));
		const symbol = isBlackHole ? 'ðŸŒ€' : 'âš ï¸';
		let markup = `<span>${symbol}</span>`;
		if (penaltyValue > 0) {
		  markup += `<span class="penalty-chip">-${penaltyValue}</span>`;
		} else if (isBlackHole) {
		  markup += `<span class="penalty-chip">bonus</span>`;
		}
		icon.innerHTML = markup;
		preview.appendChild(icon);
	  });
	const highlightTarget = highlightId && visibleTraps.some(trap => trap.id === highlightId) ? highlightId : null;
	if (highlightTarget) {
		requestAnimationFrame(() => {
			const highlightEl = preview.querySelector(`[data-trap-id="${highlightTarget}"]`);
		  if (highlightEl) {
			highlightEl.classList.add('highlight');
			setTimeout(() => {
			  highlightEl.classList.remove('highlight');
			}, 1600);
		  }
		});
	  }
	}

	function handleBlackHoleTrapTrigger(trapRecord, options = {}) {
	  const { upgradeUnlocked = false, silent = false } = options;
	  if (!trapRecord || silent) return;
	  if (upgradeUnlocked) {
		openBlackHoleChallenge(trapRecord);
	  } else {
		showObjectiveToast('ðŸŒ€ Koop de Zwart Gat Pas in de shop om dit speciale level te spelen.');
	  }
	}

	function registerTrapTrigger(cell, zoneId = '', { silent = false } = {}) {
	  if (!cell || cell.dataset.trapTriggered === 'true') return;
	  const trapId = nextTrapId();
	  const normalizedZone = normalizeZoneId(zoneId || cell.dataset.zoneId || cell.closest('.grid')?.id || '');
	const trapType = cell.dataset.trapType || 'pit';
	const isBlackHole = trapType === 'blackHole';
	const blackHoleUnlocked = isBlackHole && hasUpgrade('blackHoleAccess');
	const penaltyValue = isBlackHole ? 0 : TRAP_PENALTY;
	  const trapRecord = {
		id: trapId,
		cell,
		zoneId: normalizedZone,
		penalty: penaltyValue,
		triggeredAt: Date.now(),
		type: trapType
	  };
	  cell.dataset.trapTriggered = 'true';
	  cell.dataset.trapInstanceId = trapId;
	  cell.classList.add('trap-triggered');
	  activeTraps.push(trapRecord);
	  lastTrapHighlightId = trapId;
	  if (!silent && penaltyValue > 0) {
		const rect = cell.getBoundingClientRect();
		const scrollX = window.scrollX || window.pageXOffset;
		const scrollY = window.scrollY || window.pageYOffset;
		showScoreAnimation(
		  rect.left + rect.width / 2 + scrollX,
		  rect.top + rect.height / 2 + scrollY,
		  `-${penaltyValue}`,
		  'rgba(196,56,56,0.9)'
		);
	  }
	const trapVisible = !isBlackHole || blackHoleUnlocked;
	if (silent) renderTrapSummary();
	else if (trapVisible) renderTrapSummary({ highlightId: trapId });
	else renderTrapSummary();
	if (trapType === 'blackHole') {
		handleBlackHoleTrapTrigger(trapRecord, { upgradeUnlocked: blackHoleUnlocked, silent });
	  }
	}

	function releaseTrap(cell) {
	  if (!cell || cell.dataset.trapTriggered !== 'true') return;
	  const trapId = cell.dataset.trapInstanceId;
	  cell.classList.remove('trap-triggered');
	  delete cell.dataset.trapTriggered;
	  delete cell.dataset.trapInstanceId;
	  if (trapId) {
		activeTraps = activeTraps.filter(trap => trap.id !== trapId);
	  }
	  renderTrapSummary();
	}

	function resolveTrapById(trapId) {
	  if (!trapId) return;
	  const trap = activeTraps.find(entry => entry.id === trapId);
	  if (!trap) return;
	  if (trap.cell) {
		releaseTrap(trap.cell);
	  } else {
		activeTraps = activeTraps.filter(entry => entry.id !== trapId);
		renderTrapSummary();
	  }
	}

	function ensureTrapState(cell, zoneId = '', options = {}) {
	  if (!cell || cell.dataset.trap !== 'true') return;
	  const normalizedZone = normalizeZoneId(zoneId || cell.dataset.zoneId || cell.closest('.grid')?.id || '');
	  const isActive = cell.classList.contains('active');
	  const triggered = cell.dataset.trapTriggered === 'true';
	  const { silent = false } = options;
	  if (isActive && !triggered) {
		registerTrapTrigger(cell, normalizedZone, { silent });
	  } else if (!isActive && triggered) {
		releaseTrap(cell);
	  }
	}

	function resetTrapState() {
	  activeTraps = [];
	  lastTrapHighlightId = null;
	  document.querySelectorAll('.cell.trap-triggered, .cell[data-trap-triggered="true"]').forEach(cell => {
		cell.classList.remove('trap-triggered');
		delete cell.dataset.trapTriggered;
		delete cell.dataset.trapInstanceId;
	  });
	  renderTrapSummary();
	}

  /* ============================================
     BONUS MUNT BELONINGEN
     ============================================
     World 1: Elke 10 punten bonus geeft 1 gratis munt
     World 2+: Elke 20 punten bonus geeft 1 gratis munt (50% minder)
     Houdt bij hoeveel milestones al bereikt zijn
  */
  function trackBonusCoinRewards(currentBonus) {
	if (typeof currentBonus !== 'number' || currentBonus <= 0) return;
	const worldInfo = (typeof getWorldAndSubLevel === 'function') ? getWorldAndSubLevel(currentLevel) : { world: 1 };
	const isWorld2Plus = Number(worldInfo?.world || 1) >= 2;
	const bonusPerCoin = isWorld2Plus ? 20 : 10; // World 2+: 50% minder coins
	const milestonesReached = Math.floor(currentBonus / bonusPerCoin);
	if (milestonesReached <= bonusCoinMilestones) return;
	const coinsToGrant = milestonesReached - bonusCoinMilestones;
	for (let i = 0; i < coinsToGrant; i += 1) addCoin();
	bonusCoinMilestones = milestonesReached;
  }

	/* Bereken hoeveel coins je krijgt voor een bepaalde score
	   World 1: 1 coin per 10 punten
	   World 2+: Getrapte schaal:
	     - 0-50 punten: 1 coin per 10 punten (max 5)
	     - 50-150 punten: 1 coin per 25 punten (max 4 extra = 9 totaal)
	     - 150+ punten: 1 coin per 50 punten
	*/
	function calculateCoinsForScore(score, isWorld2Plus = false) {
	  if (!isWorld2Plus) {
		return Math.floor(score / 10);
	  }
	  // World 2+ tiered system
	  let coins = 0;
	  if (score <= 50) {
		coins = Math.floor(score / 10);
	  } else if (score <= 150) {
		coins = 5 + Math.floor((score - 50) / 25);
	  } else {
		coins = 5 + 4 + Math.floor((score - 150) / 50);
	  }
	  return coins;
	}

	function grantRoundScoreCoins(finalScore) {
	  if (!Number.isFinite(finalScore) || finalScore <= 0) return;
	  const worldInfo = (typeof getWorldAndSubLevel === 'function') ? getWorldAndSubLevel(currentLevel) : { world: 1 };
	  const isWorld2Plus = Number(worldInfo?.world || 1) >= 2;
	  const targetCoins = calculateCoinsForScore(finalScore, isWorld2Plus);
	  if (targetCoins <= coinsAwardedFromScore) return;
	  const coinsToGrant = targetCoins - coinsAwardedFromScore;
	  for (let i = 0; i < coinsToGrant; i += 1) addCoin();
	  coinsAwardedFromScore = targetCoins;
	  if (coinsToGrant > 0) {
		const label = coinsToGrant === 1 ? 'munt' : 'munten';
		showObjectiveToast(`ðŸ’° +${coinsToGrant} ${label} voor je score!`);
	  }
	}

  /* ============================================
     SCORE BEREKENING - HOOFDFUNCTIE
     ============================================
     Berekent de totale score voor alle kleuren:
     - GROEN: 8 punten per ingevulde eindcel
     - BLAUW: Punten voor kolommen (4/8/12 voor 2/3/4 cellen)
     - ROOD: 2 punten per cel in volledig gevulde grids
     - GEEL: Punten per volledig gevulde rij (10 + upgrades)
     - PAARS: Punten voor patronen (2x2, 3x3, lijn van 4+, enz)
     
     Toont ook animaties bij score veranderingen
  */
  function updateScore(cell){

		try { console.debug('updateScore:called', { cellId: cell ? (cell.id || null) : null, time: Date.now() }); } catch(e) {}

    /* === GROEN SCORE === 
       Elke ingevulde eindcel = 8 punten */
	(() => {
		const greenGrid = document.getElementById('green-grid');
		const worldInfo = (typeof getWorldAndSubLevel === 'function') ? getWorldAndSubLevel(currentLevel) : { world: currentWorld };
		const isWorld2 = Number(worldInfo?.world || currentWorld || 1) >= 2;
		const activeEndCells = Array.from(document.querySelectorAll('#green-grid .cell.end-cell.active'));
		if (!isWorld2 || !greenGrid) {
			green = activeEndCells.length * 8;
			if (cell != null && cell.classList.contains('end-cell') && cell.classList.contains('active')) {
				const rect = cell.getBoundingClientRect();
				const scrollX = window.scrollX || window.pageXOffset;
				const scrollY = window.scrollY || window.pageYOffset;
				showScoreAnimation(rect.left + rect.width / 2 + scrollX, rect.top + rect.height / 2 + scrollY, "+ 8", "green");
			}
			return;
		}

		const greenCfg = window.greenGridConfig || {};
		const minPts = Math.max(0, Number(greenCfg.minEndCellPoints) || 8);
		const maxPts = Math.max(minPts, Number(greenCfg.maxEndCellPoints) || 30);
		const rows = Number(greenGrid.dataset.rows) || 0;
		const cols = Number(greenGrid.dataset.cols) || 0;
		const startX = Number(greenGrid.dataset.startX);
		const startY = Number(greenGrid.dataset.startY);
		const safeStartX = Number.isFinite(startX) ? startX : Math.floor(cols / 2);
		const safeStartY = Number.isFinite(startY) ? startY : Math.floor(rows / 2);
		const cornerDists = [
			Math.abs(0 - safeStartX) + Math.abs(0 - safeStartY),
			Math.abs((cols - 1) - safeStartX) + Math.abs(0 - safeStartY),
			Math.abs(0 - safeStartX) + Math.abs((rows - 1) - safeStartY),
			Math.abs((cols - 1) - safeStartX) + Math.abs((rows - 1) - safeStartY)
		];
		const maxDist = Math.max(1, ...cornerDists.filter(Number.isFinite));
		const pointsFor = (endCell) => {
			const x = Number(endCell.dataset.x ?? endCell.dataset.c);
			const y = Number(endCell.dataset.y ?? endCell.dataset.r);
			if (!Number.isFinite(x) || !Number.isFinite(y)) return minPts;
			const dist = Math.abs(x - safeStartX) + Math.abs(y - safeStartY);
			const t = Math.max(0, Math.min(1, dist / maxDist));
			return Math.round(minPts + t * (maxPts - minPts));
		};
		green = activeEndCells.reduce((sum, c) => sum + pointsFor(c), 0);

		if (cell != null && cell.classList.contains('end-cell') && cell.classList.contains('active')) {
			const rect = cell.getBoundingClientRect();
			const scrollX = window.scrollX || window.pageXOffset;
			const scrollY = window.scrollY || window.pageYOffset;
			const pts = pointsFor(cell);
			showScoreAnimation(rect.left + rect.width / 2 + scrollX, rect.top + rect.height / 2 + scrollY, `+ ${pts}`, "green");
		}
	})();

	/* === BLAUW SCORE ===
	   Per rij met â‰¥1 actieve bold-cel: 1e rij â†’ 6, 2e â†’ 8, 3e â†’ 10, enz. */
	blue = calculateBlueScore('blue-grid', 3, 4, 8, cell);	/* === ROOD SCORE ===
   Elk volledig gevuld grid = 2 punten per cel
   Score verdwijnt als grid weer leeg gemaakt wordt */
['red-grid1', 'red-grid2', 'red-grid3', 'red-grid4'].forEach(id => {
  const grid = document.getElementById(id);
  if (!grid) return;

  const allCells = grid.querySelectorAll('.cell:not(.void-cell)');
  const activeCells = grid.querySelectorAll('.cell.active');

  const isFull = allCells.length > 0 && allCells.length === activeCells.length;
  const wasFull = grid.dataset.completed === "true";
  const gained = allCells.length * 2;	  // ðŸŸ¥ Grid wordt net VOLTOOID
	  if (isFull && !wasFull) {
	  	highlightEdgeCells(grid);
		grid.dataset.completed = "true";
		grid.dataset.score = gained; // sla eigen score op


		red += gained;

		const middleIndex = Math.floor(allCells.length / 2);
		const cell = allCells[middleIndex];
		const rect = cell.getBoundingClientRect();
		const scrollX = window.scrollX || window.pageXOffset;
		const scrollY = window.scrollY || window.pageYOffset;

		showScoreAnimation(
		  rect.left + rect.width / 2 + scrollX,
		  rect.top + rect.height / 2 + scrollY,
		  "+" + gained,
		  "red"
		);
	  }

	  // ðŸ”» Grid wordt net ONTVOLLEDIGD (van vol â†’ niet vol)
	  if (!isFull && wasFull) {
		grid.dataset.completed = "false";
		const lost = parseInt(grid.dataset.score || gained);
		red -= lost;
		grid.dataset.score = 0;

		const middleIndex = Math.floor(allCells.length / 2);
		const cell = allCells[middleIndex];
	  }
	});


    /* === GEEL SCORE ===
       Volle rijen geven punten: basis 10 + 4 per upgrade level
       Bijv level 3 = 10 + 2*4 = 18 punten per rij */
	const yellowContainer = document.getElementById('yellow-grid');
	const yellowConfig = window.yellowGridConfig || {};
	const fallbackRowCount = Number(yellowContainer?.dataset?.rows || yellowConfig.rows || 0);
	const parsedRowLengths = (() => {
	  if (Array.isArray(yellowConfig.rowLengths)) return yellowConfig.rowLengths;
	  const raw = yellowContainer?.dataset?.rowLengths;
	  if (!raw) return [];
	  return raw.split(',').map(val => Number(val) || 0);
	})();
	const rowLengths = parsedRowLengths.length ? parsedRowLengths : Array.from({ length: fallbackRowCount }, () => Number(yellowContainer?.dataset?.cols || yellowConfig.cols || 0));
	const parsedRowOffsets = (() => {
	  if (Array.isArray(yellowConfig.rowOffsets)) return yellowConfig.rowOffsets;
	  const rawOffsets = yellowContainer?.dataset?.rowOffsets;
	  if (!rawOffsets) return Array.from({ length: rowLengths.length }, () => 0);
	  return rawOffsets.split(',').map(val => Number(val) || 0);
	})();
	const yellowCols = Number(yellowConfig.cols) || Number(yellowContainer?.dataset?.cols || 0) || 0;
	const columnPoints = Array.isArray(yellowConfig.pointsByColumn) ? yellowConfig.pointsByColumn : [];
	const fallbackColumnPoints = yellowConfig.pointsPerColumn || yellowConfig.pointsPerRow || 0;
	const playableYellowCells = yellowContainer ? Array.from(yellowContainer.querySelectorAll('.cell:not(.void-cell)')) : [];
	if (yellowConfig.scoreMode === 'diagonal') {
	  // World 2: score *segments* on diagonals (irregular shapes can have gaps)
	  // Points scale as requested: 4â†’8, 6â†’16, 8â†’32 (doubling every +2 length)
	  const minLen = Math.max(1, Number(yellowConfig.minDiagonalLength) || 4);
	  const computeSegmentPoints = (len) => {
		if (!Number.isFinite(len) || len < minLen) return 0;
		const halfSteps = Math.floor(len / 2) + 1;
		return Math.pow(2, halfSteps);
	  };
	  window.scoredYellowSegments = window.scoredYellowSegments || new Set();
	  // Back-compat: keep old set in sync so objectives/checks don't regress.
	  window.scoredYellowDiagonals = window.scoredYellowDiagonals || new Set();
	  const cellByCoord = new Map();
	  for (const c of playableYellowCells) {
		const x = Number(c.dataset.x);
		const y = Number(c.dataset.y);
		if (!Number.isFinite(x) || !Number.isFinite(y)) continue;
		cellByCoord.set(`${x},${y}`, c);
	  }

	  const tryGet = (x, y) => cellByCoord.get(`${x},${y}`) || null;
	  const collectSegments = (dx, dy, prefix) => {
		const segments = [];
		for (const startCell of cellByCoord.values()) {
			const x0 = Number(startCell.dataset.x);
			const y0 = Number(startCell.dataset.y);
			if (!Number.isFinite(x0) || !Number.isFinite(y0)) continue;
			// Segment start if previous neighbor in this diagonal direction doesn't exist
			if (tryGet(x0 - dx, y0 - dy)) continue;
			const segmentCells = [];
			let x = x0;
			let y = y0;
			while (true) {
				const cellHere = tryGet(x, y);
				if (!cellHere) break;
				segmentCells.push(cellHere);
				x += dx;
				y += dy;
			}
			if (segmentCells.length) {
				segments.push({
					key: `${prefix}:${x0},${y0}`,
					cells: segmentCells,
					points: computeSegmentPoints(segmentCells.length)
				});
			}
		}
		return segments;
	  };

	  // World 2 request: score BOTH diagonal directions.
	  const segments = [
		...collectSegments(1, 1, 'segNWSE'),
		...collectSegments(1, -1, 'segNESW')
	  ];

	  for (const seg of segments) {
		if (!seg.points) {
		  window.scoredYellowSegments.delete(seg.key);
		  continue;
		}
		const full = seg.cells.every(c => c.classList.contains('active'));
		const wasFull = window.scoredYellowSegments.has(seg.key);
		if (full && !wasFull) {
		  yellow += seg.points;
		  window.scoredYellowSegments.add(seg.key);
		  window.scoredYellowDiagonals.add(seg.key);
		  const anchorCell = seg.cells[0];
		  if (anchorCell) {
			const rect = anchorCell.getBoundingClientRect();
			const scrollX = window.scrollX || window.pageXOffset;
			const scrollY = window.scrollY || window.pageYOffset;
			showScoreAnimation(
			  rect.left + rect.width / 2 + scrollX,
			  rect.top + rect.height / 2 + scrollY,
			  `+${seg.points}`,
			  "yellow"
			);
		  }
		} else if (!full && wasFull) {
		  yellow -= seg.points;
		  window.scoredYellowSegments.delete(seg.key);
		  window.scoredYellowDiagonals.delete(seg.key);
		  const anchorCell = seg.cells[0];
		  if (anchorCell) {
			const rect = anchorCell.getBoundingClientRect();
			const scrollX = window.scrollX || window.pageXOffset;
			const scrollY = window.scrollY || window.pageYOffset;
			showScoreAnimation(
			  rect.left + rect.width / 2 + scrollX,
			  rect.top + rect.height / 2 + scrollY,
			  `âˆ’${seg.points}`,
			  "yellow"
			);
		  }
		}
	  }
	} else {
	  const columnCellMap = new Map();
	  playableYellowCells.forEach(cell => {
		const colIndex = Number(cell.dataset.x);
		if (!Number.isFinite(colIndex)) return;
		if (!columnCellMap.has(colIndex)) columnCellMap.set(colIndex, []);
		columnCellMap.get(colIndex).push(cell);
	  });

	  let maxColumnIndex = -1;
	  columnCellMap.forEach((_, key) => { if (key > maxColumnIndex) maxColumnIndex = key; });
	  const effectiveColumnCount = Math.max(yellowCols, columnPoints.length, maxColumnIndex + 1);
	  const columnHeights = (() => {
		if (Array.isArray(yellowConfig.columnHeights) && yellowConfig.columnHeights.length >= effectiveColumnCount) {
		  return yellowConfig.columnHeights;
		}
		const heights = Array.from({ length: effectiveColumnCount }, () => 0);
		for (let row = 0; row < rowLengths.length; row++) {
		  const rowLen = rowLengths[row];
		  if (rowLen <= 0) continue;
		  const rowStart = parsedRowOffsets[row] || 0;
		  for (let col = rowStart; col < rowStart + rowLen; col++) {
			if (col >= heights.length) break;
			heights[col] += 1;
		  }
		}
		return heights;
	  })();

	  window.scoredYellowColumns = window.scoredYellowColumns || new Set();

	  for (let col = 0; col < effectiveColumnCount; col++) {
		const expectedHeight = columnHeights[col] || 0;
		if (expectedHeight <= 0) {
		  window.scoredYellowColumns.delete(col);
		  continue;
		}

		const colCells = (columnCellMap.get(col) || []).slice().sort((a, b) => Number(a.dataset.y) - Number(b.dataset.y));
		const full = colCells.length === expectedHeight && colCells.every(cell => cell.classList.contains('active'));
		const wasFull = window.scoredYellowColumns.has(col);
		// Yellow request: every 2 columns share the same bonus.
		// e.g. columns 1-2 => 12 each, 3-4 => 18 each, 5-6 => 24 each, ...
		const columnPairIndex = Math.floor(col / 2);
		const columnPointsValue = 12 + (columnPairIndex * 6);
		if (!columnPointsValue || columnPointsValue <= 0) {
		  if (wasFull) window.scoredYellowColumns.delete(col);
		  continue;
		}

		if (full && !wasFull) {
		  yellow += columnPointsValue;
		  window.scoredYellowColumns.add(col);

		  const anchorCell = colCells[0];
		  if (anchorCell) {
			const rect = anchorCell.getBoundingClientRect();
			const scrollX = window.scrollX || window.pageXOffset;
			const scrollY = window.scrollY || window.pageYOffset;
			showScoreAnimation(
			  rect.left + rect.width / 2 + scrollX,
			  rect.top + rect.height / 2 + scrollY,
			  `+${columnPointsValue}`,
			  "yellow"
			);
		  }

		} else if (!full && wasFull) {
		  yellow -= columnPointsValue;
		  window.scoredYellowColumns.delete(col);

		  const anchorCell = colCells[0];
		  if (anchorCell) {
			const rect = anchorCell.getBoundingClientRect();
			const scrollX = window.scrollX || window.pageXOffset;
			const scrollY = window.scrollY || window.pageYOffset;
			showScoreAnimation(
			  rect.left + rect.width / 2 + scrollX,
			  rect.top + rect.height / 2 + scrollY,
			  `âˆ’${columnPointsValue}`,
			  "yellow"
			);
		  }
		}
	  }
	}

	// ---------- Purple clusters (floodfill BFS on active cells) ----------
	const purpleContainer = document.getElementById('purple-grid');
	if (purpleContainer) {
	  // Bind 1 delegated click handler (instead of rebinding onclick for every cell on every score tick)
	  if (!purpleContainer._clusterClickBound) {
		purpleContainer.addEventListener('click', (ev) => {
			const cell = ev.target && ev.target.closest ? ev.target.closest('.cell.bold-cell.active') : null;
			if (!cell || !purpleContainer.contains(cell)) return;
			const storedScore = Number(cell.dataset.clusterScore || '0');
			if (cell.dataset.clusterPending === "true" && storedScore > 0) {
				const rect = cell.getBoundingClientRect();
				const scrollX = window.scrollX || window.pageXOffset;
				const scrollY = window.scrollY || window.pageYOffset;
				showScoreAnimation(
					rect.left + rect.width / 2 + scrollX,
					rect.top + rect.height / 2 + scrollY,
					`+${storedScore}`,
					"purple"
				);
				cell.dataset.clusterPending = "false";
			}
		}, { passive: true });
		purpleContainer._clusterClickBound = true;
	  }

	  const purpleCells = Array.from(purpleContainer.querySelectorAll('.cell'));
	  const totalPurple = purpleCells.length;
	  let purpleCols = Number(purpleContainer.dataset.cols) || 0;
	  const styleCols = purpleContainer.style.gridTemplateColumns;
	  const repeatMatch = styleCols && styleCols.match(/repeat\(\s*(\d+)\s*,/i);
	  if (!purpleCols && repeatMatch) purpleCols = parseInt(repeatMatch[1], 10);
	  else if (!purpleCols) {
		const computed = getComputedStyle(purpleContainer).gridTemplateColumns;
		purpleCols = computed ? computed.split(/\s+/).length : Math.round(Math.sqrt(totalPurple)) || 1;
	  }
	  const purpleRows = Math.ceil(totalPurple / purpleCols);
	  const visited = new Array(totalPurple).fill(false);
	  const connections = [];
	  const purpleConfig = window.purpleGridConfig || {};
	  const isWorld2Purple = purpleConfig.world2 === true;

	  for (let i = 0; i < totalPurple; i++) {
		if (visited[i]) continue;
		if (!purpleCells[i].classList.contains('active')) { visited[i] = true; continue; }

		const stack = [i];
		visited[i] = true;
		const cluster = [];

		while (stack.length) {
		  const cur = stack.pop();
		  cluster.push(cur);
		  const r = Math.floor(cur / purpleCols), c = cur % purpleCols;
		  const neigh = [];
		  if (r > 0) neigh.push((r - 1) * purpleCols + c);
		  if (r < purpleRows - 1) neigh.push((r + 1) * purpleCols + c);
		  if (c > 0) neigh.push(r * purpleCols + (c - 1));
		  if (c < purpleCols - 1) neigh.push(r * purpleCols + (c + 1));
		  for (const n of neigh) {
			if (n < 0 || n >= totalPurple) continue;
			if (!visited[n] && purpleCells[n].classList.contains('active')) {
			  visited[n] = true;
			  stack.push(n);
			} else if (!visited[n] && !purpleCells[n].classList.contains('active')) visited[n] = true;
		  }
		}

		const boldCount = cluster.reduce(
		  (acc, idx) => acc + (purpleCells[idx].classList.contains('bold-cell') ? 1 : 0),
		  0
		);

		let clusterScore = 0;
		if (isWorld2Purple) {
		  // World 2 request:
		  // - Outer ring connections: 20 points per new connection (only the outer ring)
		  // - Inner bold connections: 8 points per new connection (starting at 8)
		  const perOuterConn = Number(purpleConfig.outerRingBonusPerBold) || 20;
		  const perInnerConn = Number(purpleConfig.innerBoldConnectionPoints) || 8;
		  const outerBoldCount = cluster.reduce((acc, idx) => {
			const cell = purpleCells[idx];
			if (!cell.classList.contains('bold-cell') || !cell.classList.contains('active')) return acc;
			const isOuter = cell.classList.contains('outer-ring-0') || cell.classList.contains('outer-ring-1');
			return acc + (isOuter ? 1 : 0);
		  }, 0);
		  const innerBoldCount = Math.max(0, boldCount - outerBoldCount);
		  if (outerBoldCount >= 2) clusterScore += (outerBoldCount - 1) * perOuterConn;
		  if (innerBoldCount >= 2) clusterScore += (innerBoldCount - 1) * perInnerConn;
		} else {
		  if (boldCount >= 2) clusterScore = (boldCount - 1) * 8;
		}
		const hasClusterScore = clusterScore > 0;

		// Sla cluster info op bij elke bold & actieve cell
		cluster.forEach(idx => {
		  const cell = purpleCells[idx];
		  if (cell.classList.contains('bold-cell') && cell.classList.contains('active')) {
			cell.dataset.clusterScore = String(clusterScore);
			cell.dataset.clusterPending = hasClusterScore ? "true" : "false";
		  }
		});

		connections.push({ indices: cluster, boldCount, score: clusterScore });
	  }

	  purple = connections.reduce((s, c) => s + c.score, 0);
	  window.purpleConnections = connections;
	}
	
	const waarden = [yellow, green, purple, blue, red];
	// Additional scoring: any active end-cell outside the green grid grants 8 points to its zone's color
	try {
		const extraEndCells = Array.from(document.querySelectorAll('.cell.end-cell.active'));
		extraEndCells.forEach(c => {
			// skip green because green scoring already handles variable points
			if (c.closest && c.closest('#green-grid')) return;
			let zone = c.closest && c.closest('.zone') ? c.closest('.zone') : null;
			let colorKey = zone && zone.dataset ? String(zone.dataset.color || '').toLowerCase() : '';
			if (!colorKey) {
				const g = c.closest && c.closest('.grid') ? c.closest('.grid') : null;
				if (g && g.id) {
					if (g.id.indexOf('yellow') !== -1) colorKey = 'geel';
					else if (g.id.indexOf('purple') !== -1 || g.id.indexOf('paars') !== -1) colorKey = 'paars';
					else if (g.id.indexOf('blue') !== -1) colorKey = 'blauw';
					else if (g.id.indexOf('red') !== -1) colorKey = 'rood';
				}
			}
			if (colorKey === 'geel' || colorKey === 'yellow') yellow += 8;
			else if (colorKey === 'paars' || colorKey === 'purple') purple += 8;
			else if (colorKey === 'blauw' || colorKey === 'blue') blue += 8;
			else if (colorKey === 'rood' || colorKey === 'red') red += 8;
		});
	} catch (e) {}
	const baseBonus = Math.min(...waarden);
	const totalBonusScore = baseBonus + Math.max(0, blackHoleBonus || 0);
	bonus = totalBonusScore;
	trackBonusCoinRewards(totalBonusScore);

	
    // update DOM
	const bonusEl = document.getElementById('bonus-score');
	if (bonusEl) {
	  bonusEl.textContent = totalBonusScore;
	  bonusEl.setAttribute('data-blackhole-extra', String(Math.max(0, blackHoleBonus || 0)));
	}
	document.getElementById('yellow-score').textContent = yellow;
	document.getElementById('green-score').textContent = green;
	document.getElementById('purple-score').textContent = purple;
	document.getElementById('blue-score').textContent = blue;
	document.getElementById('red-score').textContent = red;
	
	// element ophalen
	const totalScoreEl = document.getElementById('total-score');

	// bereken nieuwe total
	const newScore = (yellow + green + purple + blue + red + totalBonusScore);
	const trapPenalty = getTotalTrapPenalty();
	const displayScore = newScore - trapPenalty;

	// huidige getoonde waarde (als number, fallback 0)
	const currentScore = Number(totalScoreEl.textContent) || 0;

	if (currentScore !== displayScore) {
	  // update waarde in DOM
	  totalScoreEl.textContent = displayScore;

	  // Check for High Score
	  if (typeof updateHighScore === 'function') {
		updateHighScore(displayScore);
	  }

	  // ---- restart animatie op een nette manier ----
	  // 1) verwijder class als die er is
	  totalScoreEl.classList.remove('flash');

	  // 2) force reflow om de class-add echt te "resetten"
	  void totalScoreEl.offsetWidth;

	  // 3) voeg class toe zodat animatie opnieuw start
	  totalScoreEl.classList.add('flash');

	  // 4) verwijder class wanneer de animatie klaar is.
	  // Token voorkomt dat een eerder 'animationend' een nieuwere flash stopt.
	  const token = ++totalScoreFlashToken;
	  const onEnd = () => {
		if (token !== totalScoreFlashToken) return;
		totalScoreEl.classList.remove('flash');
		totalScoreEl.removeEventListener('animationend', onEnd);
	  };
	  totalScoreEl.addEventListener('animationend', onEnd);
	}

	const scoreSnapshot = {
	  yellow,
	  red,
	  green,
	  purple,
	  blue,
	  bonus: totalBonusScore,
	  blackHoleBonus,
	  baseBonus,
	  bonusesCollected: totalBonusesCollected,
	  total: displayScore,
	  trapPenalty,
	  baseTotal: newScore
	};
	latestScoreSnapshot = scoreSnapshot;
	updateObjectives(scoreSnapshot);
	highlightAchievedObjectiveScores(scoreSnapshot);
  }
	
	

	  // ---------- Blue score (per bold-row with >=1 active cell) ----------
	// FIX: Use dataset.y for proper visual row detection instead of index-based calculation
	function calculateBlueScore(gridId='blue-grid', cols=null, boldInterval=4, pointsPerBold=8) {
		try { console.debug('calculateBlueScore:called', { gridId, time: Date.now() }); } catch(e) {}
		const container = document.getElementById(gridId);
		if (!container) {
			try { console.debug('calculateBlueScore:no-container', { gridId }); } catch(e) {}
			return 0;
		}
		const cells = Array.from(container.querySelectorAll('.cell:not(.void-cell)'));
		if (cells.length === 0) return 0;

		// Determine number of columns used by the grid.
		// Prefer explicit `cols` param or `data-cols`, otherwise infer from data-x values
		// or fallback to a square-root heuristic.
		let deducedCols = 0;
		if (cols && Number.isFinite(Number(cols))) {
			deducedCols = Number(cols);
		} else if (container && container.dataset && container.dataset.cols) {
			deducedCols = Number(container.dataset.cols) || 0;
		}
		if (!deducedCols) {
			const xs = new Set();
			cells.forEach(c => {
				const vx = Number(c.dataset.x);
				if (Number.isFinite(vx)) xs.add(vx);
			});
			deducedCols = xs.size || Math.max(1, Math.round(Math.sqrt(cells.length)));
		}

		const scoredKey = `${gridId}-scoredRows`;
		let scoredRows = window[scoredKey];
		if (scoredRows instanceof Set) {
			const migrated = new Map();
			scoredRows.forEach(rowIdx => migrated.set(rowIdx, pointsPerBold));
			scoredRows = migrated;
		}
		if (!(scoredRows instanceof Map)) {
			scoredRows = new Map();
		}
		window[scoredKey] = scoredRows;

		// Build a map of visual rows (using dataset.y) to their bold cells
		const rowToBoldCells = new Map();
		const rowToActiveBoldCells = new Map();
		
		cells.forEach(cell => {
			if (!cell.classList.contains('bold-cell')) return;
			const visualRow = Number(cell.dataset.y);
			if (!Number.isFinite(visualRow)) return;
			
			if (!rowToBoldCells.has(visualRow)) {
				rowToBoldCells.set(visualRow, []);
				rowToActiveBoldCells.set(visualRow, []);
			}
			rowToBoldCells.get(visualRow).push(cell);
			if (cell.classList.contains('active')) {
				rowToActiveBoldCells.get(visualRow).push(cell);
			}
		});

		// Debug: report counts to help diagnose missing blue scoring
		try {
			console.debug('calculateBlueScore:start', {
				gridId,
				totalCells: cells.length,
				deducedCols,
				boldCells: Array.from(rowToBoldCells.entries()).reduce((sum, [, arr]) => sum + arr.length, 0),
				activeBoldCells: Array.from(rowToActiveBoldCells.entries()).reduce((sum, [, arr]) => sum + arr.length, 0)
			});
		} catch (e) {}
		
		// Get all unique visual rows sorted
		const allVisualRows = Array.from(rowToBoldCells.keys()).sort((a, b) => a - b);
		const rows = allVisualRows.length > 0 ? Math.max(...allVisualRows) + 1 : 0;

		// Blue scoring: allow all bold rows (not only the bottom-most one).
		let visualRowsToProcess = allVisualRows;

		const targetKey = `${gridId}-scoredTargets`;
		let rowTargets = window[targetKey];
		if (!(rowTargets instanceof Map)) {
			rowTargets = new Map();
			window[targetKey] = rowTargets;
		}

		const rowPlacementKey = `${gridId}-rowPlacements`;
		let rowPlacements = window[rowPlacementKey];
		if (!(rowPlacements instanceof Map)) {
			rowPlacements = new Map();
			window[rowPlacementKey] = rowPlacements;
		}

		const showChangePopup = (cell, diff) => {
			if (!cell || diff === 0) return;
			const rect = cell.getBoundingClientRect();
			const scrollX = window.scrollX || window.pageXOffset;
			const scrollY = window.scrollY || window.pageYOffset;
			const amountText = diff > 0 ? `+${diff}` : `-${Math.abs(diff)}`;
			showScoreAnimation(
				rect.left + rect.width / 2 + scrollX,
				rect.top + rect.height / 2 + scrollY,
				amountText,
				"blue"
			);
		};

		const scoredRowIndices = [];
		let positivePopupShown = false;
		const currentPlacementId = window.currentPlacementId || '';

		// Track welke placements al punten hebben toegekend voor welke rijen
		const placementScoringKey = `${gridId}-placementScorings`;
		let placementScorings = window[placementScoringKey];
		if (!(placementScorings instanceof Map)) {
			placementScorings = new Map();
			window[placementScoringKey] = placementScorings;
		}

		// Iterate over the visual rows we've chosen to process
		for (const r of visualRowsToProcess) {
			const boldCells = rowToBoldCells.get(r) || [];
			const activeBoldCells = rowToActiveBoldCells.get(r) || [];

			const previousPoints = scoredRows.get(r) || 0;
			const wasScored = scoredRows.has(r);
			const previousPlacement = rowPlacements.get(r) || '';

			if (boldCells.length === 0) {
				const previousTarget = rowTargets.get(r) || null;
				if (previousTarget && previousPoints > 0) {
					showChangePopup(previousTarget, -previousPoints);
				}
				rowTargets.delete(r);
				rowPlacements.delete(r);
				scoredRows.delete(r);
				placementScorings.delete(r);
				continue;
			}

			const activeCount = activeBoldCells.length;
			if (activeCount === 0) {
				const previousTarget = rowTargets.get(r) || boldCells[0] || null;
				if (previousTarget && previousPoints > 0) {
					showChangePopup(previousTarget, -previousPoints);
				}
				rowTargets.delete(r);
				rowPlacements.delete(r);
				scoredRows.delete(r);
				placementScorings.delete(r);
				continue;
			}

			let targetBoldCell = null;
			const storedTarget = rowTargets.get(r);
			if (storedTarget && storedTarget.classList.contains('active')) {
				targetBoldCell = storedTarget;
			} else {
				let bestSequence = Number.POSITIVE_INFINITY;
				activeBoldCells.forEach(cell => {
					const sequenceValue = Number(cell.dataset.activationSequence);
					if (Number.isFinite(sequenceValue) && sequenceValue < bestSequence) {
						bestSequence = sequenceValue;
						targetBoldCell = cell;
					}
				});
				if (!targetBoldCell && activeBoldCells.length > 0) {
					targetBoldCell = activeBoldCells[0];
				}
			}
			if (!targetBoldCell) {
				rowTargets.delete(r);
				rowPlacements.delete(r);
				scoredRows.delete(r);
				placementScorings.delete(r);
				continue;
			}

		rowTargets.set(r, targetBoldCell);
		
		// Verzamel ALLE placementIds van alle actieve bold-cells in deze rij
		const placementIds = new Set();
		activeBoldCells.forEach(cell => {
			const pid = cell.dataset.placementId;
			if (pid) placementIds.add(pid);
		});
		
		// Check of deze placement al heeft gescoord voor deze rij
		const previousScoredPlacement = placementScorings.get(r) || '';
		const currentPlacementId = Array.from(placementIds)[0] || ''; // Neem eerste placementId
		const hasPlacementScored = currentPlacementId && previousScoredPlacement === currentPlacementId;
		
		// Een rij is "nieuw gescoord" alleen als:
		// 1. De rij nog nooit eerder punten had (wasScored = false)
		// 2. EN deze placement heeft nog NIET gescoord voor deze rij
		const isNewScoring = !wasScored && currentPlacementId && !hasPlacementScored;
		
		if (isNewScoring) {
			// Mark placement als scored voor deze rij METEEN
			placementScorings.set(r, currentPlacementId);
			scoredRows.set(r, 0);
			scoredRowIndices.push(r);
		}
		
		if (currentPlacementId) {
			rowPlacements.set(r, currentPlacementId);
		}
	}		scoredRowIndices.sort((a, b) => a - b);
		
		const allScoredRows = Array.from(scoredRows.keys()).sort((a, b) => a - b);
		let runningTotal = 0;
		
		allScoredRows.forEach((r, idx) => {
			const basePoints = idx === 0 ? 6 : 8 + (idx - 1) * 2;
			const previousPoints = scoredRows.get(r) || 0;
			const diff = basePoints - previousPoints;
			scoredRows.set(r, basePoints);
			runningTotal += basePoints;
			
			if (scoredRowIndices.includes(r)) {
				const target = rowTargets.get(r);
				if (target && !positivePopupShown) {
					showChangePopup(target, basePoints);
					positivePopupShown = true;
				}
			} else if (diff !== 0) {
				const target = rowTargets.get(r);
				if (target) {
					showChangePopup(target, diff);
				}
			}
		});

		const rowsToRemove = [];
		scoredRows.forEach((pts, r) => {
			if (!allScoredRows.includes(r)) {
				const boldCells = [];
				const activeBoldCells = [];
				for (let c = 0; c < deducedCols; c++) {
					const idx = r * deducedCols + c;
					const cell = cells[idx];
					if (!cell || cell.classList.contains('void-cell')) continue;
					if (cell.classList.contains('bold-cell')) {
						boldCells.push(cell);
						if (cell.classList.contains('active')) {
							activeBoldCells.push(cell);
						}
					}
				}
				if (activeBoldCells.length === 0) {
					const previousTarget = rowTargets.get(r) || boldCells[0] || null;
					if (previousTarget && pts > 0) {
						showChangePopup(previousTarget, -pts);
					}
					rowsToRemove.push(r);
				}
			}
		});
		rowsToRemove.forEach(r => {
			scoredRows.delete(r);
			rowTargets.delete(r);
			rowPlacements.delete(r);
		});

		return runningTotal;
	}
	
	// showScoreAnimation: positioneert tov viewport (fixed) zodat getBoundingClientRect() direct werkt
	function showScoreAnimation(x, y, text = "+1", color = "black") {
	  const el = document.createElement("div");
	  el.className = "score-popup";
	  el.style.left = `${x}px`;
	  el.style.top  = `${y}px`;
	  el.textContent = text;
	  document.body.appendChild(el);
	  setTimeout(() => el.remove(), 1000);
	}
	
	// Sparkle effect
	function sparkleEffect(x, y, count = 8) {
	  for (let i = 0; i < count; i++) {
		const s = document.createElement("div");
		s.className = "sparkle";
		const angle = Math.random() * 2 * Math.PI;
		const distance = 40 + Math.random() * 20;
		s.style.left = `${x}px`;
		s.style.top = `${y}px`;
		s.style.setProperty("--dx", `${Math.cos(angle) * distance}px`);
		s.style.setProperty("--dy", `${Math.sin(angle) * distance}px`);
		document.body.appendChild(s);
		setTimeout(() => s.remove(), 800);
	  }
	}
	
	
	function highlightEdgeCells(gridOrId) {
	const grid = typeof gridOrId === 'string' ? document.getElementById(gridOrId) : gridOrId;
	const gridLabel = typeof gridOrId === 'string' ? gridOrId : (gridOrId && gridOrId.id) || '(anonymous zone)';
	console.log("highlightEdgeCells called with:", gridLabel);
	    console.log("grid found?", !!grid);

	  if (!grid) return;
	  console.log('test2');

	  const cells = Array.from(grid.querySelectorAll('.cell'));
	  if (cells.length === 0) return;

	  // Haal gridafmetingen op uit dataset of bepaal automatisch
	  const rows = parseInt(grid.dataset.rows || '12', 10);
	  const cols = parseInt(grid.dataset.cols || '12', 10);

	  // Map opbouwen van "r,c" â†’ element
	  const map = new Map();
	  for (const cell of cells) {
		const r = parseInt(cell.dataset.r ?? "-1", 10);
		const c = parseInt(cell.dataset.c ?? "-1", 10);
		if (r >= 0 && c >= 0) map.set(`${r},${c}`, cell);
	  }

	  // Reset edge-styling
	  cells.forEach(c => c.classList.remove('edge-cell'));

	  const dirs = [
		{dr: -1, dc: 0},
		{dr: 1,  dc: 0},
		{dr: 0,  dc: -1},
		{dr: 0,  dc: 1},
	  ];

	  let edgeCount = 0;

	  for (const [key, cell] of map.entries()) {
		if (!cell.classList.contains('active')) continue;

		const [rStr, cStr] = key.split(',');
		const r = parseInt(rStr, 10);
		const c = parseInt(cStr, 10);

		let isEdge = false;

		for (const d of dirs) {
		  const nr = r + d.dr, nc = c + d.dc;
		  const neighbor = map.get(`${nr},${nc}`);
		  if (!neighbor || !neighbor.classList.contains('active')) {
			isEdge = true;
			break;
		  }
		}

		if (isEdge) {
		  cell.classList.add('edge-cell');
		  edgeCount++;
		}
	  }

	  // Debug info in console
	  console.log(`[${gridLabel}] edge-cells found:`, edgeCount);

		  const zoomZone = grid.closest('.zone.zoom-focus');
		  if (zoomZone) schedulePlaceholderSync(zoomZone);
	}

	let lastTap = 0;

	const board = document.querySelector('.board');

	board.addEventListener('touchend', function(e) {
	  const currentTime = new Date().getTime();
	  const tapLength = currentTime - lastTap;
	  if (tapLength < 300 && tapLength > 0) {
		e.preventDefault(); // voorkomt dubbel-tap zoom
	  }
	  lastTap = currentTime;
	});


  // ---------- Undo / Clear ----------
  function undo(){
	const lastPlacement = cardPlacementHistory.length ? cardPlacementHistory[cardPlacementHistory.length - 1] : null;
	const lastToggle = historyStack.length ? historyStack[historyStack.length - 1] : null;
	const placementSeq = lastPlacement?.sequence ?? -Infinity;
	const toggleSeq = lastToggle?.sequence ?? -Infinity;
	if (placementSeq === -Infinity && toggleSeq === -Infinity) return;

	if (placementSeq >= toggleSeq) {
	  const placement = cardPlacementHistory.pop();
	  if (!placement) return;
	  const { cells = [], coinSnapshotBefore = [], handIndex = 0, cardState, cardRef, bonuses = [], isBonusPlacement = false, bonusKey = null, bonusSpent = false } = placement;
	  cells.forEach(cell => {
		if (!cell) return;
		cell.classList.remove('active', 'preview-allowed', 'preview-denied', 'edge-cell');
		cell.style.removeProperty('background');
		delete cell.dataset.clusterScore;
		delete cell.dataset.clusterPending;
		syncPlaceholderForCell(cell);
	  });
	  restoreCoinState(coinSnapshotBefore);
	  if (Array.isArray(bonuses) && bonuses.length) {
		bonuses.forEach(revokeBonusClaim);
	  }
	  updateScore();
	  if (isBonusPlacement) {
		if (bonusSpent && bonusKey) restoreBonusCharge(bonusKey);
		selectedCardId = null;
		selectedCardElement = null;
		selectedShape = null;
		selectedColor = null;
		if (rotateButton) rotateButton.disabled = true;
		updateDrawButtonState();
		recomputeTurnCardFlags();
		applyTurnCardLocks();
		return;
	  }
	  const discardIdx = cardState ? discardPile.findIndex(card => card.id === cardState.id) : -1;
	  let restoredCard = null;
	  if (discardIdx !== -1) {
		restoredCard = discardPile.splice(discardIdx, 1)[0];
	  } else if (cardRef) {
		restoredCard = cardRef;
	  }
	  if (!restoredCard && cardState) {
		restoredCard = {
		  id: cardState.id,
		  blueprintId: cardState.blueprintId,
		  shapeName: cardState.shapeName,
		  matrix: cloneShape(cardState.matrix),
		  category: cardState.category,
		  color: cloneColor(cardState.color)
		};
	  } else if (restoredCard && cardState) {
		restoredCard.matrix = cloneShape(cardState.matrix);
		restoredCard.shapeName = cardState.shapeName;
		restoredCard.category = cardState.category;
		restoredCard.color = cloneColor(cardState.color);
	  }
	  if (restoredCard) {
		const insertIndex = Math.max(0, Math.min(handIndex, currentHand.length));
		currentHand.splice(insertIndex, 0, restoredCard);
	  }
	  cardsPlayedThisTurn = Math.max(0, cardsPlayedThisTurn - 1);
	  selectedCardId = null;
	  selectedCardElement = null;
	  selectedShape = null;
	  selectedColor = null;
	  if (rotateButton) rotateButton.disabled = true;
	  renderCurrentHand();
	  updateDrawButtonState();
	  recomputeTurnCardFlags();
	  applyTurnCardLocks();
	  return;
	}

	const last = historyStack.pop();
	if(!last) return;
	if(last.wasActive) last.cell.classList.add('active'); else last.cell.classList.remove('active');
	ensureTrapState(last.cell, last.cell.dataset.zoneId || last.cell.closest('.grid')?.id || '', { silent: true });
	if(last.cell.classList.contains('gold-cell')){
	  if(last.cell.classList.contains('active')) addCoin(); else removeCoin();
	}
	if (Array.isArray(last.bonusClaims) && last.bonusClaims.length) {
		last.bonusClaims.forEach(revokeBonusClaim);
	}
	updateScore(last.cell);
	syncPlaceholderForCell(last.cell);
	// Recompute per-turn flags after toggling a cell state which may have affected bonuses
	recomputeTurnCardFlags();
	applyTurnCardLocks();
  }
	function clearBoard(){
	  if (!debugMode) return;
	  document.querySelectorAll('.cell').forEach(c=>c.classList.remove('active'));
	  resetCoins();
	  addCoin();
	  historyStack.length = 0;
	  resetScoreState();
	  updateScore();
	if (activeZoomZone) schedulePlaceholderSync(activeZoomZone);
	}
	
  
  // bewaar originele inline cursor instellingen zodat we ze kunnen herstellen
	let _origCursorHtml = null;
	let _origCursorBody = null;

	// helper: start dragging visuals (hide cursor globally)
	function startGlobalDragVisuals() {
	  document.body.classList.add('dragging');

	  // Sla inline stijl op en zet inline cursor: none !important (overruled bijna alles)
	  const html = document.documentElement;
	  const body = document.body;

	  // bewaar oude inline waarde
	  _origCursorHtml = html.style.getPropertyValue('cursor') || null;
	  _origCursorBody = body.style.getPropertyValue('cursor') || null;

	  // zet inline style met priority 'important'
	  html.style.setProperty('cursor', 'none', 'important');
	  body.style.setProperty('cursor', 'none', 'important');
	}

	// helper: stop dragging visuals (restore cursor)
	function stopGlobalDragVisuals() {
	  document.body.classList.remove('dragging');

	  const html = document.documentElement;
	  const body = document.body;

	  if (_origCursorHtml !== null) html.style.setProperty('cursor', _origCursorHtml);
	  else html.style.removeProperty('cursor');

	  if (_origCursorBody !== null) body.style.setProperty('cursor', _origCursorBody);
	  else body.style.removeProperty('cursor');

	  _origCursorHtml = _origCursorBody = null;
	}
  
  
	// ========================
	// DRAG & DROP LOGICA (verfijnd)
	// ========================

	function makeDraggable(shape, color) {
	  const block = document.createElement('div');
	  block.classList.add('draggable');
	  block.style.position = 'fixed';
	  block.style.left = '0px';
      block.style.top = '0px';
	  block.style.zIndex = 1000;


	
	  const allowedZones =
		color.name === 'rood'
		  ? ['red-grid1', 'red-grid2', 'red-grid3', 'red-grid4']
		  : [color.name];
	  block.dataset.allowedZones = JSON.stringify(allowedZones);

	  let currentShape = JSON.parse(JSON.stringify(shape));
	  block._shape = currentShape;
	  
	  
	  renderBlock(block, currentShape, color);
	  document.body.appendChild(block);

	  // ================
	  // START DRAG
	  // ================
	  block.addEventListener('pointerdown', ev => {
        ev.preventDefault();
		// If the block has been rotated/mirrored via buttons, use the updated shape.
		currentShape = block._shape || currentShape;
		beginPointerDrag({ clientX: ev.clientX, clientY: ev.clientY, pointerId: ev.pointerId });

        draggedBlock = block;
        draggedColor = color;
		draggedShape = currentShape;
		
		// Offsets based on the current shape and actual board cell size.
		({ offsetX, offsetY } = computeShapeCenterOffsets(currentShape));

		// Voor touch devices: voeg extra upward offset toe zodat blok boven vinger verschijnt
		const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
		const touchOffsetY = isTouchDevice ? 60 : 0; // 60px boven vinger

		// Start drag direct: plaats blok op cursor positie met offset
		const overlay = document.getElementById('drag-overlay');
		if (overlay) {
			overlay.appendChild(block);
			overlay.style.display = 'block';
		}
		startGlobalDragVisuals();

		// Positioneer blok direct op de pointer positie
		block.style.left = (ev.clientX - offsetX) + 'px';
		block.style.top = (ev.clientY - offsetY - touchOffsetY) + 'px';

        block.setPointerCapture(ev.pointerId);
        block.style.transition = 'transform 0.1s ease';
        block.style.opacity = '0.3';
	  });

	  // ROTATIE VIA SCROLL
	  block.addEventListener('wheel', ev => {
		if (draggedBlock !== block) return;
		ev.preventDefault();
		currentShape = rotateShape(currentShape);
		block._shape = currentShape;
		draggedShape = currentShape;
		renderBlock(draggedBlock, currentShape, draggedColor);
		({ offsetX, offsetY } = computeShapeCenterOffsets(currentShape));
	  });
	  
  return block;
}

// ROTATIE VIA R en SPIEGEL VIA T
/*
	EN:
	- WHY: Keyboard shortcuts while a shape exists (dragging OR selected card).
	- STATE: reads/writes `draggedBlock`, `draggedShape`, `selectedShape`, `selectedColor`, `offsetX/offsetY`.
	- DUPLICATE: Rotation/mirror also exists via buttons (floating preview buttons) and mouse wheel rotate.
	- NOTE: Offsets are based on measured board cell size + `--board-grid-gap` for consistent scaling.
	- Escape: cancels current drag OR cancels bonus placement.
*/
document.addEventListener('keydown', ev => {
  // Check of we een shape hebben (draggedBlock of selectedShape)
  const hasShape = draggedBlock || (selectedShape && selectedColor);
  if (!hasShape) return;
  
  if (ev.key === 'Escape' && draggedBlock) {
	ev.preventDefault();
	if (activeBonusPlacement) {
		cancelActiveBonusPlacement();
	} else {
		cleanupDragState({ clearBonus: false });
	}
	return;
  }
  
	// Rotatie met 'r'
	if (ev.key.toLowerCase() === 'r') {
		ev.preventDefault();
		if (draggedBlock) {
			draggedShape = rotateShape(draggedShape);
			draggedBlock._shape = draggedShape;
			renderBlock(draggedBlock, draggedShape, draggedColor);
			({ offsetX, offsetY } = computeShapeCenterOffsets(draggedShape));
		} else if (selectedShape) {
			rotateSelectedCard();
		}
	}  // Spiegel met 't'
  if (ev.key.toLowerCase() === 't') {
	ev.preventDefault();
	if (draggedBlock) {
		draggedShape = mirrorShape(draggedShape);
		draggedBlock._shape = draggedShape;
		renderBlock(draggedBlock, draggedShape, draggedColor);
			({ offsetX, offsetY } = computeShapeCenterOffsets(draggedShape));
	} else if (selectedShape) {
		mirrorSelectedCard();
	}
  }
});

// =============
// SLEPEN (drag)
// =============
/*
	EN:
	- WHY: This is the core â€œdrag the placed shape over the boardâ€ loop.
	- STATE: moves `draggedBlock` into `#drag-overlay` so it renders above everything.
	- COORDINATES: Uses `elementFromPoint()` per filled cell in the shape to find underlying grid cells.
	  This is more robust than only using the cursor point, but it is heavier.
	- OVERRIDE: Preview rendering is currently disabled (showPreview/clearPreview calls are commented out).
	- FIX NOTE: `showZoomLens(...)` uses `cursorX`/`cursorY` from the pointer event for correct positioning.
*/

document.addEventListener('pointermove', ev => {
	if (!draggedBlock || !isPointerDragging) return;
	if (dragPointerId !== null && ev.pointerId !== dragPointerId) return;

	if (!dragHasMoved) {
		const isTouchDevice = ('ontouchstart' in window || navigator.maxTouchPoints > 0);
		const moveThreshold = isTouchDevice ? 10 : 5;
		const dx = Math.abs((Number(ev.clientX) || 0) - dragStartClientX);
		const dy = Math.abs((Number(ev.clientY) || 0) - dragStartClientY);
		if ((dx + dy) >= moveThreshold) {
			dragHasMoved = true;
		}
	}

	const overlay = document.getElementById('drag-overlay');		document.body.classList.add('dragging'); // optioneel, voor extra styling
		overlay.style.display = 'block';

		// Voeg draggedBlock als kind van overlay, zodat hij altijd boven alles zweeft
		overlay.appendChild(draggedBlock);

		// Verberg echte cursor
		document.body.style.cursor = 'none';
		document.documentElement.style.cursor = 'none';

	// Toon control buttons in mobiel zonder touch tijdens drag
	const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
	if (window.innerWidth <= MOBILE_BREAKPOINT && !isTouchDevice) {
		addCardControlButtons();
	}

	  // PREVIEW MEESLEPEN
	  const cursorX = ev.clientX;
	  const cursorY = ev.clientY;

	  // Voor touch devices: voeg extra upward offset toe
	  const touchOffsetY = isTouchDevice ? 60 : 0;

	  // ===== Verplaats visueel het draggable blok =====
	  draggedBlock.style.left = (cursorX - offsetX) + 'px';
	  draggedBlock.style.top  = (cursorY - offsetY - touchOffsetY) + 'px';

	// ===== Vind zones en cellen onder ALLE gevulde cellen van het blok =====
	const blockRect = draggedBlock.getBoundingClientRect();

	// Derive per-cell spacing from the rendered draggable block so
	// sampling points match what the user actually sees. This keeps
	// visual size unchanged while aligning elementFromPoint checks.
	const shapeHeight = draggedShape.length;
	const shapeWidth = draggedShape[0].length;
	const stepX = shapeWidth > 0 ? (blockRect.width / shapeWidth) : 0;
	const stepY = shapeHeight > 0 ? (blockRect.height / shapeHeight) : 0;

	// Verzamel alle hits van gevulde cellen
	const cellHits = [];
	  
	  // Schakel pointer events uit voor het gedraaide blok
	  const prevPointerEvents = draggedBlock.style.pointerEvents;
	  draggedBlock.style.pointerEvents = 'none';
	  
	  // Check elke gevulde cel in de shape
	  for (let row = 0; row < shapeHeight; row++) {
		for (let col = 0; col < shapeWidth; col++) {
		  // Optional (value 2) cells should NOT drive hit-testing / anchoring.
		  if (isSolidShapeCell(draggedShape[row][col])) {
			// Bereken de positie van deze cel in het visuele blok
			const cellX = blockRect.left + (col * stepX) + (stepX / 2);
			const cellY = blockRect.top + (row * stepY) + (stepY / 2);
			
			// Vind de grid cel onder dit punt
			const elem = document.elementFromPoint(cellX, cellY);
			const gridCell = elem ? elem.closest('.cell') : null;
			
			if (gridCell && gridCell.dataset.x !== undefined && gridCell.dataset.y !== undefined) {
			  const cellZone = gridCell.closest('.zone');
			  if (cellZone && !cellZone.classList.contains('zone-placeholder')) {
				cellHits.push({
				  gridCell: gridCell,
				  zone: cellZone,
				  shapeRow: row,
				  shapeCol: col,
				  gridX: parseInt(gridCell.dataset.x, 10),
				  gridY: parseInt(gridCell.dataset.y, 10)
				});
			  }
			}
		  }
		}
	  }
	  
	  // Herstel pointer events
	  draggedBlock.style.pointerEvents = prevPointerEvents || '';
	  
	  // Als we geen hits hebben, bail
	  if (cellHits.length === 0) {
		// Preview uitgeschakeld
		// if (lastZone) clearPreview(lastZone);
		lastZone = null;
		lastBaseX = lastBaseY = null;
		return;
	  }
	  
	  // Kies de meest voorkomende zone (of eerste hit)
	  const zoneCounts = {};
	  cellHits.forEach(hit => {
		const zoneId = hit.zone.id;
		zoneCounts[zoneId] = (zoneCounts[zoneId] || 0) + 1;
	  });
	  const bestZoneId = Object.keys(zoneCounts).reduce((a, b) => zoneCounts[a] > zoneCounts[b] ? a : b);
	  let zone = document.getElementById(bestZoneId);
	  
	  // Filter hits naar alleen deze zone
	  const zoneHits = cellHits.filter(hit => hit.zone.id === bestZoneId);
	  if (zoneHits.length === 0) {
		lastZone = null;
		lastBaseX = lastBaseY = null;
		return;
	  }
	  
	  // Bereken de baseX/baseY vanuit de eerste hit (of gemiddelde)
	  const firstHit = zoneHits[0];
	  let hoveredCell = firstHit.gridCell;
	  let baseX = firstHit.gridX - firstHit.shapeCol;
	  let baseY = firstHit.gridY - firstHit.shapeRow;

	const cellZone = hoveredCell.closest('.zone');
	if (cellZone && !cellZone.classList.contains('zone-placeholder')) {
	  zone = cellZone;
	}

	if (!zone) {
	  // Preview uitgeschakeld
	  // if (lastZone) clearPreview(lastZone);
	  lastZone = null;
	  lastBaseX = lastBaseY = null;
	  return;
	}

	if (zone !== lastZone) {
	  // Preview uitgeschakeld
	  // if (lastZone) clearPreview(lastZone);
	  lastZone = zone;
	  lastBaseX = lastBaseY = null;
	}

	// baseX en baseY zijn nu al berekend uit de cell hits
	// shapeWidth en shapeHeight zijn al gedeclareerd boven

	const metrics = getZoneMetrics(zone);
	if (!metrics || metrics.maxX < metrics.minX || metrics.maxY < metrics.minY) {
	  // Preview uitgeschakeld
	  // clearPreview(zone);
	  lastBaseX = lastBaseY = null;
	  return;
	}

	const solidBounds = getSolidShapeBounds(draggedShape);
	const minStartX = metrics.minX - solidBounds.minX;
	const minStartY = metrics.minY - solidBounds.minY;
	let maxStartX = metrics.maxX - solidBounds.maxX;
	let maxStartY = metrics.maxY - solidBounds.maxY;
	if (!Number.isFinite(maxStartX)) maxStartX = metrics.maxX;
	if (!Number.isFinite(maxStartY)) maxStartY = metrics.maxY;
	if (maxStartX < minStartX) maxStartX = minStartX;
	if (maxStartY < minStartY) maxStartY = minStartY;

	// Sla originele baseX/baseY op voordat speciale zone aanpassingen
	const originalBaseX = baseX;
	const originalBaseY = baseY;

	if (zone.id === 'yellow-zone') {
	  const yellowPlacement = getYellowPlacement(zone, baseX, baseY, draggedShape, metrics);
	  baseX = yellowPlacement.baseX;
	  baseY = yellowPlacement.baseY;
	} else if (zone.id === 'blue-zone') {
	  baseY = getStickyBaseY(zone, baseX, baseY, draggedShape);
	}

	// Check of het blok NA de speciale zone aanpassingen nog steeds binnen de grenzen is
	// Zo niet, dan is het niet plaatsbaar (geen forceren binnen grenzen)
	const wouldFitX = baseX >= minStartX && baseX <= maxStartX;
	const wouldFitY = baseY >= minStartY && baseY <= maxStartY;
	
	if (!wouldFitX || !wouldFitY) {
		// Blok valt buiten de grid na speciale zone logica - niet plaatsbaar
		if (draggedBlock) {
			draggedBlock.style.opacity = '0.3';
		}
		lastBaseX = baseX;
		lastBaseY = baseY;
		return;
	}

	  // ===== Toon preview alleen bij verandering =====
	  if (baseX !== lastBaseX || baseY !== lastBaseY) {
		lastBaseX = baseX;
		lastBaseY = baseY;

		const zoneColor =
		  zone.dataset.color ||
		  zone.closest('.zone')?.dataset.color ||
		  (zone.id.startsWith('red-grid') ? 'rood' : null);

		const colorOk =
		  zoneColor === draggedColor.name ||
		  draggedColor.name === 'multikleur' ||
		  (draggedColor.name === 'rood' && zoneColor === 'rood');

		const allowed = colorOk && canPlace(zone, baseX, baseY, draggedShape);
		
		// Update draggedBlock opacity gebaseerd op plaatsbaarheid
		if (draggedBlock) {
			if (allowed) {
				draggedBlock.style.opacity = '1';
			} else {
				draggedBlock.style.opacity = '0.3';
			}
		}
		
		// Preview uitgeschakeld
		// showPreview(zone, baseX, baseY, draggedShape, draggedColor, allowed);
		
		// Zoom-lens disabled (remove the extra in-zoom placement preview panel).
		hideZoomLens();
	  }
	});

	/*
		EN:
		- LEGACY/DUPLICATE: Older alternative drag algorithm kept as a block comment.
		  It uses different logic (zones under cursor rather than per-cell elementFromPoint).
		  Keeping both can confuse future edits; consider deleting once the new approach is stable.
	
	document.addEventListener('pointermove', ev => {
		if (!draggedBlock) return;

		const visualOffsetX = 40; // kleine offset zodat het blok onder de vinger zit
		const visualOffsetY = 20; // kleine offset zodat het blok onder de vinger zit

		// Gebruik clientX/Y in plaats van pageX/Y
		const x = ev.clientX;
		const y = ev.clientY;

		// ===== Verplaats visueel het draggable blok =====
		draggedBlock.style.left = (x - offsetX  - visualOffsetX) + 'px';
		draggedBlock.style.top  = (y - offsetY - visualOffsetY) + 'px';

			
		
		// Detecteer alle zones (inclusief subgrids)
		const zones = [...document.querySelectorAll('.zone')].filter(z => !z.classList.contains('zone-placeholder'));

		// Vind alle zones onder de cursor
		const hoveredZones = zones.filter(z => {
		  const r = z.getBoundingClientRect();
		  return x >= r.left && x <= r.right && y >= r.top && y <= r.bottom;
		});

		// Kies de meest specifieke zone:
		// - Als je boven een subgrid hangt, gebruik die
		// - Anders (bijv. voor blauw/geel) gebruik de gewone zone
		let zone = null;
		if (hoveredZones.length > 0) {
		  // Geef prioriteit aan subgrids binnen de rode zone
		  zone = hoveredZones.find(z => z.id.startsWith('red-grid')) || hoveredZones[0];
		}

		if (!zone) {
			if (lastZone) clearPreview(lastZone);
			lastZone = null;
			lastBaseX = lastBaseY = null;
			return;
		}

		lastZone = zone;
		
		
		  // ===== Bereken correcte positie binnen de zone =====
		  const zRect = zone.getBoundingClientRect();
		  
		  
		  // --- Bepaal aantal kolommen op betrouwbare manier ---
		  // Probeer eerst dataset of style, fallback op computed gridTemplateColumns of een cell
		  let cols = parseInt(zone.dataset.cols || '0', 10);
		  if (!cols) {
			const inline = zone.style.gridTemplateColumns;
			if (inline) {
			  const m = inline.match(/repeat\(\s*(\d+)/i);
			  cols = m ? parseInt(m[1],10) : 0;
			}
		  }
		  // fallback: bereken uit eerste rij van cells (meest robuust)
		  const cells = Array.from(zone.querySelectorAll('.cell'));
		  if (!cols && cells.length) {
			// probeer columns = aantal verschillende data-x waarden
			const xs = new Set(cells.map(c => c.dataset.x).filter(Boolean));
			cols = xs.size || Math.round(Math.sqrt(cells.length)) || 1;
		  }
		  cols = Math.max(1, cols);


		  const sampleCell = zone.querySelector('.cell');
	      const cellSize = sampleCell ? sampleCell.getBoundingClientRect().width : (zRect.width / cols);


	  // ===== Relatieve positie binnen de zone =====
	  const rect = draggedBlock.getBoundingClientRect();
	  const relX = rect.left + rect.width/2 - zRect.left;
	  const relY = rect.top  + rect.height/2 - zRect.top;
	  
	  // ===== Bereken grid positie direct vanaf cursor positie =====
	  // Gebruik de cursor positie zonder offset correctie voor exacte alignment
	  let baseX = Math.floor(relX / cellSize);
	  let baseY = Math.floor(relY / cellSize);
		// Alleen blauw/geel: laat het blok "vallen" naar beneden
		if (zone.id === 'blue-zone' || zone.id === 'yellow-zone') {
			if (zone.id === 'blue-zone' || zone.id === 'yellow-zone') {
				baseY = getStickyBaseY(zone, baseX, baseY, draggedShape);
				// clamp again in case sticky geeft buiten-range
				const rows = Math.max(1, Math.ceil(cells.length / cols));
				const shapeHeightCells = draggedShape.length;
		        baseY = Math.max(0, Math.min(rows - shapeHeightCells, baseY));
			}
		}

		if (baseX !== lastBaseX || baseY !== lastBaseY) {
			lastBaseX = baseX;
			lastBaseY = baseY;
			
			// ===== Toon de preview =====
			// Zorg dat we altijd de juiste kleur pakken
			const zoneColor =
			  zone.dataset.color ||
			  zone.closest('.zone')?.dataset.color ||
			  (zone.id.startsWith('red-grid') ? 'rood' : null);
			const colorOk = zoneColor === draggedColor.name || draggedColor.name === 'multikleur' || (draggedColor.name === 'rood' && zoneColor === 'rood');
			const allowed = colorOk && canPlace(zone, baseX, baseY, draggedShape);
			// Preview uitgeschakeld
			// showPreview(zone, baseX, baseY, draggedShape, draggedColor, allowed);
		}
	});
	
	*/

	// =============
	// LOSLATEN
	// =============
	document.addEventListener('pointerup', ev => {
			// If a pointer is captured (e.g. purchased preview in #gold-zone), ev.target can be misleading.
			// Use the real element under the pointer at release for drop logic.
			const releaseTarget = (typeof ev.clientX === 'number' && typeof ev.clientY === 'number')
				? (document.elementFromPoint(ev.clientX, ev.clientY) || ev.target)
				: ev.target;

		// Negeer als we op een control button klikken
			if (releaseTarget && releaseTarget.classList && releaseTarget.classList.contains('card-control-btn')) {
			return;
		}
		
		// Negeer clicks op gold-zone (buy button, coin display, etc.)
			if (releaseTarget && releaseTarget.closest && releaseTarget.closest('#gold-zone') && !draggedBlock) {
			return;
		}
		
		if (!draggedBlock) return;
		if (dragPointerId !== null && ev.pointerId !== dragPointerId) return;
		const bonusContext = activeBonusPlacement;
		const isMobileLayout = window.innerWidth <= MOBILE_BREAKPOINT;
		const isTouchDevice = ('ontouchstart' in window || navigator.maxTouchPoints > 0);
		// Desktop hover-drag: do not drop on pointerup (click-to-drop handles placement).
		if (desktopHoverDragActive && !isMobileLayout && !isTouchDevice && (!bonusContext || bonusContext.desktopHover)) {
			return;
		}
		// Mobile UX: a short tap should not instantly place a block.
		// Only allow placing on release if the user actually dragged (moved a bit).
		if (isMobileLayout && !dragHasMoved) {
			enterStickyDragPreview();
			return;
		}

		if (lastZone && lastBaseX !== null && lastBaseY !== null) {
			const zoneColor =
			  lastZone.dataset.color ||
			  lastZone.closest('.zone')?.dataset.color ||
			  (lastZone.id.startsWith('red-grid') ? 'rood' : null);
			const colorOk = zoneColor === draggedColor.name || draggedColor.name === 'multikleur' || (draggedColor.name === 'rood' && zoneColor === 'rood');
			const allowed = colorOk && canPlace(lastZone, lastBaseX, lastBaseY, draggedShape);

			clearPreview(lastZone);

			if (allowed) {
				const coinSnapshotBefore = getCoinStateSnapshot();
				const placementResult = placeShape(lastZone, lastBaseX, lastBaseY, draggedShape, draggedColor);
				if (bonusContext) {
					finalizeBonusPlacement(placementResult, coinSnapshotBefore, bonusContext);
					cleanupDragState({ clearBonus: true, updateInventory: false });
					hideFloatingPreview(); // Verberg na succesvolle plaatsing
					removeCardControlButtons(); // Verberg buttons na plaatsing
				} else {
					finalizeCardPlacement(placementResult, coinSnapshotBefore);
					cleanupDragState({ clearBonus: false });
					hideFloatingPreview(); // Verberg na succesvolle plaatsing
					removeCardControlButtons(); // Verberg buttons na plaatsing
				}
				return;
			}
		}

		if (bonusContext) {
			// Check of purchased placement buiten grid of op gold-zone is losgelaten
			if (bonusContext.colorKey === 'purchased') {
				const goldZone = document.getElementById('gold-zone');
				const previewDiv = document.getElementById('purchased-block-preview');
				const clickedOnGoldZone = goldZone && releaseTarget && goldZone.contains(releaseTarget);
				const clickedOnPreview = previewDiv && releaseTarget && previewDiv.contains(releaseTarget);
				
				// Als geklikt op gold-zone/preview, annuleer
				if (clickedOnGoldZone || clickedOnPreview) {
					cancelActiveBonusPlacement({ updateInventory: true });
					return;
				}
				
				// Als we GEEN lastZone hebben (echt buiten grid), annuleer
				if (!lastZone) {
					cancelActiveBonusPlacement({ updateInventory: true });
					return;
				}
				
				// We hebben een zone, probeer te plaatsen op laatste positie
				if (lastZone && lastBaseX !== null && lastBaseY !== null) {
					const zoneColor =
						lastZone.dataset.color ||
						lastZone.closest('.zone')?.dataset.color ||
						(lastZone.id.startsWith('red-grid') ? 'rood' : null);
					const colorOk = zoneColor === draggedColor.name || draggedColor.name === 'multikleur' || (draggedColor.name === 'rood' && zoneColor === 'rood');
					const allowed = colorOk && canPlace(lastZone, lastBaseX, lastBaseY, draggedShape);
					
					if (allowed) {
						const coinSnapshotBefore = getCoinStateSnapshot();
						const placementResult = placeShape(lastZone, lastBaseX, lastBaseY, draggedShape, draggedColor);
						finalizeBonusPlacement(placementResult, coinSnapshotBefore, bonusContext);
						cleanupDragState({ clearBonus: true, updateInventory: false });
						hideFloatingPreview();
						removeCardControlButtons();
						return;
					} else {
						// Plaatsing niet geldig, annuleer en geef munten terug
						cancelActiveBonusPlacement({ updateInventory: true });
						return;
					}
				}
				
				// Geen geldige positie gevonden, annuleer
				cancelActiveBonusPlacement({ updateInventory: true });
				return;
			}
			// Als sticky false is (touch mode) voor ANDERE bonussen, annuleer bij invalide plaatsing
			if (!bonusContext.sticky && bonusContext.colorKey !== 'purchased') {
				cancelActiveBonusPlacement({ updateInventory: true });
				return;
			}
			// Keep the bonus block visible so player can rotate/mirror or reposition after releasing.
			enterStickyDragPreview();
			return;
		}

		// Desktop: on invalid release, the piece disappears.
		if (!isMobileLayout) {
			const overlay = document.getElementById('drag-overlay');
			try { draggedBlock.remove(); } catch {}
			draggedBlock = null;
			draggedShape = null;
			draggedColor = null;
			lastZone = null;
			lastBaseX = lastBaseY = null;
			desktopHoverDragActive = false;
			suppressDesktopDropUntil = 0;
			endPointerDragTracking();
			if (overlay) overlay.style.display = 'none';
			document.body.classList.remove('dragging');
			document.body.style.cursor = '';
			document.documentElement.style.cursor = '';
			stopGlobalDragVisuals();
			removeCardControlButtons();
			return;
		}

		// Mobile: keep the card block on screen on invalid release.
		enterStickyDragPreview();
		// Floating preview blijft zichtbaar - alleen kruisje of succesvolle plaatsing verbergt het
	});

	// Desktop hover-drag: second click drops the piece.
	document.addEventListener('pointerdown', ev => {
		if (!desktopHoverDragActive) return;
		if (activeBonusPlacement && !activeBonusPlacement.desktopHover) return;
		if (ev.button !== 0) return;
		const isMobileLayout = window.innerWidth <= MOBILE_BREAKPOINT;
		const isTouchDevice = ('ontouchstart' in window || navigator.maxTouchPoints > 0);
		if (isMobileLayout || isTouchDevice) return;
		if (Date.now() < suppressDesktopDropUntil) return;

		// If the user clicks the hand/cards area while a sticky block is active, interpret that as
		// â€œlet goâ€ (otherwise it can feel like the block is stuck).
		// Allow clicks on cards to continue so the player can switch cards in one action.
		const clickedCard = ev.target.closest ? ev.target.closest('.card-option') : null;
		if (ev.target.closest && ev.target.closest('#card-choice-zone')) {
			if (clickedCard) {
				cleanupDragState({ clearBonus: false, hidePreview: true });
				return;
			}
			cleanupDragState({ clearBonus: false, hidePreview: true });
			ev.preventDefault();
			ev.stopPropagation();
			return;
		}

		// Ignore clicks on UI areas; drop should happen on the board.
		if (ev.target.closest('button') || ev.target.closest('#controls') || ev.target.closest('#floating-preview')) {
			return;
		}

		ev.preventDefault();
		ev.stopPropagation();

		if (lastZone && lastBaseX !== null && lastBaseY !== null) {
			const zoneColor =
				lastZone.dataset.color ||
				lastZone.closest('.zone')?.dataset.color ||
				(lastZone.id.startsWith('red-grid') ? 'rood' : null);
			const colorOk = zoneColor === draggedColor.name || draggedColor.name === 'multikleur' || (draggedColor.name === 'rood' && zoneColor === 'rood');
			const allowed = colorOk && canPlace(lastZone, lastBaseX, lastBaseY, draggedShape);
			clearPreview(lastZone);
			if (allowed) {
				const coinSnapshotBefore = getCoinStateSnapshot();
				const placementResult = placeShape(lastZone, lastBaseX, lastBaseY, draggedShape, draggedColor);
				if (activeBonusPlacement && activeBonusPlacement.desktopHover) {
					finalizeBonusPlacement(placementResult, coinSnapshotBefore, activeBonusPlacement);
					desktopHoverDragActive = false;
					suppressDesktopDropUntil = 0;
					cleanupDragState({ clearBonus: true, updateInventory: false });
					hideFloatingPreview();
					removeCardControlButtons();
					return;
				}
				finalizeCardPlacement(placementResult, coinSnapshotBefore);
				desktopHoverDragActive = false;
				suppressDesktopDropUntil = 0;
				cleanupDragState({ clearBonus: false });
				hideFloatingPreview();
				return;
			}
		}

		// Invalid drop: on desktop the piece disappears.
		cancelDesktopHoverDragKeepSelection({ showPreview: false });
	}, true);

	function enterStickyDragPreview() {
		if (!draggedBlock) return;
		// Pointer capture / touch can synthesize a click right after release.
		// Prevent that click from toggling card selection and calling cleanup.
		suppressCardSelectUntil = Date.now() + 650;
		endPointerDragTracking();
		lastZone = null;
		lastBaseX = lastBaseY = null;

		const overlay = document.getElementById('drag-overlay');
		if (overlay && overlay.contains(draggedBlock)) {
			document.body.appendChild(draggedBlock);
		}
		if (overlay) overlay.style.display = 'none';

		document.body.classList.remove('dragging');
		document.body.style.cursor = '';
		document.documentElement.style.cursor = '';
		stopGlobalDragVisuals();

		// Ensure the rotate/mirror controls are available.
		if (rotateButton) rotateButton.disabled = false;
		if (mirrorButton) {
			// Only enable mirror now if controls were not intentionally delayed
			if (!activeBonusPlacement || !activeBonusPlacement.delayedControls) {
				mirrorButton.disabled = false;
			}
		}
		addCardControlButtons();
		// If mirror was delayed for this bonus drag, reveal it now and re-position
		try {
			// Only reveal delayed mirror if this was NOT a bonus placement
			if (activeBonusPlacement && activeBonusPlacement.delayedControls && !(activeBonusPlacement && activeBonusPlacement.colorKey)) {
				const mb = document.querySelector('.card-control-mirror');
				if (mb) {
					mb.disabled = false;
					mb.classList.add('visible');
					mb.removeAttribute('data-delayed');
					// Re-position buttons using the centralized positioning logic
					try { addCardControlButtons(); } catch (e) {}
				}
				activeBonusPlacement.delayedControls = false;
			}
		} catch (e) {}
	}

	function findCellInZone(zone, clientX, clientY) {
		if (!zone) return null;
		const cells = zone.querySelectorAll('.cell');
		for (const cell of cells) {
			const rect = cell.getBoundingClientRect();
			if (clientX >= rect.left && clientX <= rect.right && clientY >= rect.top && clientY <= rect.bottom) {
				return cell;
			}
		}
		return null;
	}

	function cleanupDragState({ clearBonus = false, updateInventory = false, hidePreview = false } = {}) {
		const overlay = document.getElementById('drag-overlay');
		endPointerDragTracking();
		desktopHoverDragActive = false;
		suppressDesktopDropUntil = 0;
		if (draggedBlock) {
			draggedBlock.remove();
		}
		draggedBlock = null;
		draggedShape = null;
		draggedColor = null;
		lastZone = null;
		lastBaseX = lastBaseY = null;
		if (overlay) overlay.style.display = 'none';
		document.body.classList.remove('dragging');
		document.body.style.cursor = '';
		document.documentElement.style.cursor = '';
		
		// Verberg control buttons altijd als drag/selection wordt opgeruimd.
		removeCardControlButtons();
		
	// Verwijder kaart selectie
	if (selectedCardElement) {
		selectedCardElement.classList.remove('selected');
		selectedCardElement = null;
	}
	selectedCardId = null;
	selectedShape = null;
	selectedColor = null;
	
	// Reset card locks zodat andere kaarten weer klikbaar zijn
	applyTurnCardLocks();
	
	// Verberg zoom-lens altijd
	hideZoomLens();
	
	// Verberg floating preview alleen als expliciet gevraagd
		if (hidePreview) {
			hideFloatingPreview();
		}
		
		if (clearBonus && activeBonusPlacement) {
			// Geef gekochte plaatsing munten terug bij annuleren
			if (updateInventory && activeBonusPlacement.colorKey === 'purchased') {
				addCoin();
				addCoin();
				clearPurchasedPlacement();
			}
			activeBonusPlacement = null;
			markActiveBonusButton(null);
			if (updateInventory) updateBonusInventoryUI();
		}
		skipNextZoneClick = true;
		setTimeout(() => { skipNextZoneClick = false; }, 80);
		stopGlobalDragVisuals();
		if (!selectedCardElement && !activeBonusPlacement && rotateButton) {
		  rotateButton.disabled = true;
		}
	}

	function cancelActiveBonusPlacement(options = {}) {
		const { updateInventory = true, hidePreview = false } = options;
		if (!activeBonusPlacement && !draggedBlock) return;
		cleanupDragState({ clearBonus: true, updateInventory, hidePreview });
	}
	

	// ========================
	// HELPER FUNCTIES
	// ========================

	function getOptionalCells(shape) {
	  const coords = [];
	  if (!shape || !shape.length) return coords;
	  for (let y = 0; y < shape.length; y++) {
		const row = shape[y];
		for (let x = 0; x < row.length; x++) {
		  if (row[x] === 2) {
			coords.push({ x, y });
		  }
		}
	  }
	  return coords;
	}

	function isOptionalShapeCell(value) {
	  return value === 2;
	}

	function isSolidShapeCell(value) {
	  return value === 1;
	}

	function getSolidShapeBounds(shape) {
	  let minX = Infinity;
	  let maxX = -Infinity;
	  let minY = Infinity;
	  let maxY = -Infinity;
	  if (!Array.isArray(shape) || !shape.length) {
		return { minX: 0, maxX: -1, minY: 0, maxY: -1, width: 0, height: 0 };
	  }
	  for (let y = 0; y < shape.length; y++) {
		const row = shape[y];
		if (!Array.isArray(row)) continue;
		for (let x = 0; x < row.length; x++) {
		  if (!isSolidShapeCell(row[x])) continue;
		  if (x < minX) minX = x;
		  if (x > maxX) maxX = x;
		  if (y < minY) minY = y;
		  if (y > maxY) maxY = y;
		}
	  }
	  if (!Number.isFinite(minX) || !Number.isFinite(minY)) {
		return { minX: 0, maxX: -1, minY: 0, maxY: -1, width: 0, height: 0 };
	  }
	  return {
		minX,
		maxX,
		minY,
		maxY,
		width: (maxX - minX + 1),
		height: (maxY - minY + 1)
	  };
	}

	function hasOptionalCells(shape) {
	  return getOptionalCells(shape).length > 0;
	}

	function trimOptionalCells(shape) {
	  if (!shape || !shape.length) return shape;
	  const optionalCells = getOptionalCells(shape);
	  if (!optionalCells.length) return shape;
	  const trimmed = shape.map(row => row.slice());
	  optionalCells.forEach(({ x, y }) => {
		if (trimmed[y] && typeof trimmed[y][x] === 'number') {
		  trimmed[y][x] = 0;
		}
	  });
	  // Verwijder lege rijen
	  let filtered = trimmed.filter(row => row.some(value => value !== 0));
	  if (!filtered.length) {
		return trimmed;
	  }
	  const colCount = filtered[0].length;
	  const activeCols = [];
	  for (let col = 0; col < colCount; col++) {
		if (filtered.some(row => row[col] !== 0)) {
		  activeCols.push(col);
		}
	  }
	  if (!activeCols.length) {
		return trimmed;
	  }
	  filtered = filtered.map(row => activeCols.map(index => row[index] || 0));
	  return filtered;
	}

	function rotateShape(shape) {
	  const rows = shape.length;
	  const cols = shape[0].length;
	  return Array.from({ length: cols }, (_, x) =>
		Array.from({ length: rows }, (_, y) => shape[rows - 1 - y][x])
	  );
	}

	function mirrorShape(shape) {
	  // Spiegel het blok horizontaal (flip left-right)
	  return shape.map(row => [...row].reverse());
	}

	function cloneShape(shape) {
	  return shape.map(row => row.slice());
	}

	function updateCardPattern(card, shape, color) {
	  if (!card || !shape || !shape.length) return;
	  color = color || {};
	  const cssCellSizeRaw = (card.style && card.style.getPropertyValue('--preview-cell')) || '';
	  const computedCellSizeRaw = !cssCellSizeRaw ? (getComputedStyle(card).getPropertyValue('--preview-cell') || '') : '';
	  const overrideCellSize = parseFloat((cssCellSizeRaw || computedCellSizeRaw || '').trim());
	  const { cellSize: defaultCellSize } = getCardSizing();
	  const cellSize = Number.isFinite(overrideCellSize) && overrideCellSize > 0 ? overrideCellSize : defaultCellSize;
	  card.dataset.shapeCols = String(shape[0].length);
	  card.dataset.shapeRows = String(shape.length);
	  const pattern = card.querySelector('.card-pattern');
	  if (pattern) {
		pattern.innerHTML = '';
		pattern.style.gridTemplateColumns = `repeat(${shape[0].length}, ${cellSize}px)`;
		pattern.style.gridTemplateRows = `repeat(${shape.length}, ${cellSize}px)`;
		// Gap is controlled via CSS (`--preview-gap`) so all previews stay consistent.
		pattern.style.removeProperty('gap');
		shape.forEach(row => {
		  row.forEach(cell => {
			const div = document.createElement('div');
			div.classList.add('card-cell');
			div.style.width = `${cellSize}px`;
			div.style.height = `${cellSize}px`;
			// Border-radius: max 5px, minder rond voor kleine cells
			div.style.borderRadius = `${Math.min(5, cellSize / 5)}px`;
			if (cell) {
			  let background;
			  let shadow;
			  if (color.code === 'rainbow') {
				background = 'linear-gradient(45deg, #f06272, #fff25a, #4ed346, #5d90f0, #a35eff)';
				shadow = '0 0 6px rgba(0,0,0,0.3)';
			  } else {
				// Golden is a card modifier; do not paint blocks gold.
				background = (color.code || '#a0a0a0');
				const isGradient = typeof background === 'string' && background.includes('gradient');
				shadow = isGradient ? '0 0 4px rgba(90,80,160,0.4)' : `0 0 4px ${background}`;
			  }
			  div.style.background = background;
			  div.style.boxShadow = shadow;
			} else {
			  div.style.background = 'transparent';
			  div.style.boxShadow = 'none';
			}
			pattern.appendChild(div);
		  });
		});
	  }
	  const meta = card.querySelector('.card-meta');
	  if (meta) meta.textContent = `${shape.length}Ã—${shape[0].length}`;
	  card.cardShape = shape;
	}

	function getActualCellSize(root = null) {
		// Bereken de werkelijke cel-grootte op basis van een cel in het opgegeven root
		// (of het globale speelveld als geen root gegeven). Dit houdt rekening met
		// board/zone scaling and any DOM lifts performed during mobile zoom.
		try {
			// Mobile behaviour: always prefer the unscaled CSS cell size (the
			// "zoomed-in" visual size) for mobile layouts so previews match the
			// zoomed experience even before the zone is opened.
			if (window && typeof window.innerWidth === 'number' && window.innerWidth <= (typeof MOBILE_BREAKPOINT !== 'undefined' ? MOBILE_BREAKPOINT : 650)) {
				const cssSize = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--cell-size')) || 26;
				return cssSize;
			}

			let sampleCell = null;
			if (root instanceof Element) {
				sampleCell = root.querySelector('.grid .cell:not(.void-cell)');
			} else if (typeof root === 'string') {
				sampleCell = document.querySelector(root + ' .grid .cell:not(.void-cell)');
			} else {
				sampleCell = document.querySelector('#board .grid .cell:not(.void-cell)');
			}

			if (sampleCell) {
				const rect = sampleCell.getBoundingClientRect();
				return Math.min(rect.width, rect.height);
			}
		} catch (e) {
			// ignore and fallback
		}
		const cssSize = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--cell-size')) || 26;
		return cssSize;
	}

	function renderBlock(block, shape, color, useActualCellSize = true) {
	block.innerHTML = '';
	block.style.display = 'grid';
	// Ensure floating/draggable previews remain visible on top when rotated
	try {
		const isFloatingPreview = (block.id === 'floating-preview' || block.id === 'purchased-block-preview' || (block.classList && (block.classList.contains('draggable') || block.classList.contains('bonus-draggable'))));
		if (isFloatingPreview) {
			if (!block.style.position) block.style.position = 'fixed';
			block.style.zIndex = block.style.zIndex || '10000';
			const overlay = document.getElementById('drag-overlay') || document.body;
			if (overlay && !overlay.contains(block)) overlay.appendChild(block);
		}
	} catch (e) {}
	  
	  // Bepaal de cel-grootte: gebruik de werkelijke speelveld cel-grootte als niet ingezoomd
	  const isZoomed = document.body.classList.contains('zoomed-in');
	  let cellSize;
	  let cellSizeStr;
	  
	if (useActualCellSize) {
		// If a zoomed zone is active, measure cell size from that zone so
		// the draggable matches the zoomed-in cells exactly. Otherwise
		// measure from the default board.
		const measuredRoot = (document.body.classList.contains('zoomed-in') && typeof activeZoomZone !== 'undefined' && activeZoomZone) ? activeZoomZone : null;
		cellSize = getActualCellSize(measuredRoot);
		cellSizeStr = `${cellSize}px`;
	} else {
		// Fallback: use CSS variable when explicit actual sizing is not requested.
		cellSize = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--cell-size')) || 26;
		cellSizeStr = 'var(--cell-size)';
	}
	  
	  // Border-radius is altijd size / 4
	  const borderRadius = `${cellSize / 4}px`;
	  
	  block.style.gridTemplateColumns = `repeat(${shape[0].length}, ${cellSizeStr})`;
	  block.style.gridTemplateRows = `repeat(${shape.length}, ${cellSizeStr})`;
	  // Keep spacing consistent with the board grid.
	  block.style.gap = 'var(--board-grid-gap)';
	  block.style.opacity = '0.8';
	  const optionalSet = new Set(getOptionalCells(shape).map(({ x, y }) => `${x},${y}`));
	  
	  shape.forEach((row, rowIdx) => {
		row.forEach((cell, colIdx) => {
			const div = document.createElement('div');
			div.style.width = cellSizeStr;
			div.style.height = cellSizeStr;
			div.style.margin = '0px';
			// Border-radius consistent met speelveld: size / 4
			div.style.borderRadius = borderRadius;
			div.style.boxSizing = 'border-box';
			const key = `${colIdx},${rowIdx}`;
			const isOptional = optionalSet.has(key);
			if (cell && !isOptional) {
			  let background;
			  let shadow;
			  if (color.code === 'rainbow') {
				background = 'linear-gradient(45deg, #f06272, #fff25a, #4ed346, #5d90f0, #a35eff)';
				shadow = '0 0 6px rgba(0,0,0,0.3)';
			  } else {
				// Golden is a card modifier; do not paint blocks gold.
				background = (color.code || '#a0a0a0');
				const isGradient = typeof background === 'string' && background.includes('gradient');
				shadow = isGradient ? '0 0 4px rgba(90,80,160,0.4)' : `0 0 4px ${background}`;
			  }
			  div.style.background = background;
			  div.style.boxShadow = shadow;
			} else if (isOptional) {
			  let background;
			  if (color.code === 'rainbow') {
				background = 'linear-gradient(45deg, #f06272, #fff25a, #4ed346, #5d90f0, #a35eff)';
			  } else {
				background = color.code || '#a0a0a0';
			  }
			  div.style.background = background;
			  div.style.opacity = '0.6';
			  div.style.border = '2px dashed rgba(255,255,255,0.85)';
			  div.style.boxShadow = 'none';
			} else {
			  div.style.visibility = 'hidden';
			}
			block.appendChild(div);
		});
	  });
	}

	function hexToRGBA(hex, alpha = 1) {
	  if (!hex) return `rgba(0,0,0,${alpha})`;
	  let c = hex.replace('#','');
	  if (c.length === 3) c = c.split('').map(ch => ch+ch).join('');
	  const r = parseInt(c.substr(0,2),16);
	  const g = parseInt(c.substr(2,2),16);
	  const b = parseInt(c.substr(4,2),16);
	  return `rgba(${r},${g},${b},${alpha})`;
	}

	function clearPreview(zone) {
	  zone.querySelectorAll('.cell.preview-allowed, .cell.preview-denied').forEach(c=>{
		c.classList.remove('preview-allowed','preview-denied');
		if (!c.classList.contains('active')) c.style.background = '';
	  });
	}

	function getZoneMetrics(zone) {
	  const empty = {
		cols: 0,
		rows: 0,
		minX: 0,
		maxX: -1,
		minY: 0,
		maxY: -1
	  };
	  if (!zone) return empty;
	  const cells = zone.querySelectorAll('.cell');
	  if (!cells.length) return empty;
	  let minX = Infinity;
	  let maxX = -Infinity;
	  let minY = Infinity;
	  let maxY = -Infinity;
	  cells.forEach(cell => {
		if (cell.classList.contains('void-cell') || cell.dataset.disabled === 'true') return;
		const col = Number(cell.dataset.x);
		const row = Number(cell.dataset.y);
		if (!Number.isNaN(col)) {
		  if (col < minX) minX = col;
		  if (col > maxX) maxX = col;
		}
		if (!Number.isNaN(row)) {
		  if (row < minY) minY = row;
		  if (row > maxY) maxY = row;
		}
	  });
	  if (!Number.isFinite(minX) || !Number.isFinite(maxX)) return empty;
	  if (!Number.isFinite(minY) || !Number.isFinite(maxY)) return empty;
	  return {
		cols: maxX - minX + 1,
		rows: maxY - minY + 1,
		minX,
		maxX,
		minY,
		maxY
	  };
	}

	function getZonePriority(zone) {
	  if (!zone || zone.classList.contains('zone-placeholder')) return -Infinity;
	  if (zone.classList.contains('zoom-focus')) return 1000;
	  const style = window.getComputedStyle(zone);
	  const zIndex = parseInt(style.zIndex, 10);
	  return Number.isFinite(zIndex) ? zIndex : 0;
	}


	// Helper om de juiste cell in een zone te pakken
	function getCell(zone, x, y) {
	  if (!zone) return null;
	  const cell = zone.querySelector(`.cell[data-x="${x}"][data-y="${y}"]`);
	  if (!cell) return null;
	  if (cell.classList.contains('void-cell') || cell.dataset.disabled === 'true') return null;
	  return cell;
	}

	function collectPlacementCells(zone, baseX, baseY, shape) {
	  if (!zone || !Array.isArray(shape) || !shape.length) return null;
	  const pending = [];
	  window.lastPlacementFailure = null;
	  
	  // Gebruik gewoon de normale coÃ¶rdinaten-gebaseerde aanpak
	  // Nu werkt dit ook voor root-based grids omdat alle cellen bestaan!
	  for (let y = 0; y < shape.length; y++) {
		for (let x = 0; x < shape[y].length; x++) {
		  const cellVal = shape[y][x];
		  if (!cellVal) continue; // Skip lege posities in de shape
		  const isOptional = isOptionalShapeCell(cellVal);
		  const target = getCell(zone, baseX + x, baseY + y);
		  
		  if (!target) {
			if (isOptional) continue;
			window.lastPlacementFailure = {
			  zoneId: zone?.id || null,
			  reason: 'missing-cell',
			  x: baseX + x,
			  y: baseY + y
			};
			return null;
		  }
		  if (target.classList.contains('active')) {
			if (isOptional) continue;
			window.lastPlacementFailure = {
			  zoneId: zone?.id || null,
			  reason: 'occupied',
			  x: baseX + x,
			  y: baseY + y
			};
			return null;
		  }
		  
		  pending.push(target);
		}
	  }
	  
	  return pending;
	}
	
	// Speciaal voor root-based grids: zoek cellen op fysieke positie op het scherm
	function collectPlacementCellsForRootGrid(zone, baseX, baseY, shape) {
	  console.log('ðŸŒ³ Root grid - searching by SCREEN position');
	  
	  // Vind de eerste gevulde cel in de shape (anchor point)
	  let anchorShapeX = -1, anchorShapeY = -1;
	  for (let y = 0; y < shape.length && anchorShapeY === -1; y++) {
		for (let x = 0; x < shape[y].length; x++) {
		  if (shape[y][x]) {
			anchorShapeX = x;
			anchorShapeY = y;
			break;
		  }
		}
	  }
	  
	  // Probeer de anchor cell te vinden via coÃ¶rdinaten
	  const anchorX = baseX + anchorShapeX;
	  const anchorY = baseY + anchorShapeY;
	  const anchorCell = getCell(zone, anchorX, anchorY);
	  
	  if (!anchorCell || anchorCell.classList.contains('active')) {
		console.log('âŒ Anchor cell not available');
		return null;
	  }
	  
	  console.log('âœ… Anchor cell found, now searching by screen position...');
	  
	  // Get de fysieke positie van de anchor cell
	  const anchorRect = anchorCell.getBoundingClientRect();
	  const cellSize = anchorRect.width;
	  
	  // Get alle beschikbare cellen in deze zone
	  const allCells = Array.from(zone.querySelectorAll('.cell:not(.void-cell)'))
		.filter(c => !c.classList.contains('active') && c.dataset.disabled !== 'true');
	  
	  // Bouw een map: fysieke positie (in grid units) -> cel
	  const positionMap = new Map();
	  for (const cell of allCells) {
		const rect = cell.getBoundingClientRect();
		// Bereken grid positie relatief tot anchor (in hele cellen)
		const gridX = Math.round((rect.left - anchorRect.left) / cellSize);
		const gridY = Math.round((rect.top - anchorRect.top) / cellSize);
		const key = `${gridX},${gridY}`;
		positionMap.set(key, cell);
		
		console.log(`Cell at screen grid position (${gridX}, ${gridY}):`, cell.dataset.x, cell.dataset.y);
	  }
	  
	  // Nu loop door de shape en zoek elke cel op basis van FYSIEKE positie
	  const result = [];
	  for (let shapeY = 0; shapeY < shape.length; shapeY++) {
		for (let shapeX = 0; shapeX < shape[shapeY].length; shapeX++) {
		  if (!shape[shapeY][shapeX]) continue; // Skip lege posities
		  
		  // Bereken relatieve positie t.o.v. anchor
		  const relX = shapeX - anchorShapeX;
		  const relY = shapeY - anchorShapeY;
		  const key = `${relX},${relY}`;
		  
		  console.log(`Looking for shape position (${shapeX},${shapeY}) at relative grid (${relX},${relY})`);
		  
		  const cell = positionMap.get(key);
		  if (!cell) {
			console.log(`âŒ No cell found at relative position (${relX},${relY})`);
			return null;
		  }
		  
		  console.log(`âœ… Found cell at (${relX},${relY}):`, cell.dataset.x, cell.dataset.y);
		  result.push(cell);
		}
	  }
	  
	  console.log(`âœ… All ${result.length} cells found successfully!`);
	  return result;
	}
	
	// Bouw een grafiek van welke cellen fysiek aan elkaar grenzen
	function buildCellAdjacencyGraph(cells) {
	  const graph = new Map();
	  
	  for (const cell of cells) {
		const rect = cell.getBoundingClientRect();
		const centerX = rect.left + rect.width / 2;
		const centerY = rect.top + rect.height / 2;
		const cellSize = rect.width;
		
		const neighbors = [];
		
		for (const other of cells) {
		  if (cell === other) continue;
		  
		  const otherRect = other.getBoundingClientRect();
		  const otherCenterX = otherRect.left + otherRect.width / 2;
		  const otherCenterY = otherRect.top + otherRect.height / 2;
		  
		  const dx = Math.abs(centerX - otherCenterX);
		  const dy = Math.abs(centerY - otherCenterY);
		  
		  // Check of ze horizontaal of verticaal naast elkaar liggen
		  const isHorizontal = dx > cellSize * 0.8 && dx < cellSize * 1.2 && dy < cellSize * 0.3;
		  const isVertical = dy > cellSize * 0.8 && dy < cellSize * 1.2 && dx < cellSize * 0.3;
		  
		  if (isHorizontal || isVertical) {
			// Bepaal richting
			let direction = null;
			if (isHorizontal) {
			  direction = otherCenterX > centerX ? 'right' : 'left';
			} else {
			  direction = otherCenterY > centerY ? 'down' : 'up';
			}
			
			neighbors.push({ cell: other, direction });
		  }
		}
		
		graph.set(cell, neighbors);
	  }
	  
	  return graph;
	}
	
	// Vind cellen die de shape vorm volgen vanaf de anchor
	function findShapeCellsInGraph(anchorCell, shape, anchorShapeX, anchorShapeY, graph, allCells) {
	  const result = [];
	  const cellToShapePos = new Map();
	  
	  // Start met de anchor
	  cellToShapePos.set(anchorCell, { x: anchorShapeX, y: anchorShapeY });
	  result.push(anchorCell);
	  
	  // BFS om andere cellen te vinden
	  const queue = [anchorCell];
	  const visited = new Set([anchorCell]);
	  
	  while (queue.length > 0) {
		const current = queue.shift();
		const currentPos = cellToShapePos.get(current);
		
		const neighbors = graph.get(current) || [];
		
		for (const { cell: neighbor, direction } of neighbors) {
		  if (visited.has(neighbor)) continue;
		  
		  // Bereken waar deze neighbor zou zijn in de shape
		  let neighborShapeX = currentPos.x;
		  let neighborShapeY = currentPos.y;
		  
		  if (direction === 'right') neighborShapeX++;
		  else if (direction === 'left') neighborShapeX--;
		  else if (direction === 'down') neighborShapeY++;
		  else if (direction === 'up') neighborShapeY--;
		  
		  // Check of deze positie in de shape bestaat en gevuld is
		  if (neighborShapeY >= 0 && neighborShapeY < shape.length &&
			  neighborShapeX >= 0 && neighborShapeX < shape[neighborShapeY].length &&
			  shape[neighborShapeY][neighborShapeX]) {
			
			visited.add(neighbor);
			cellToShapePos.set(neighbor, { x: neighborShapeX, y: neighborShapeY });
			result.push(neighbor);
			queue.push(neighbor);
		  }
		}
	  }
	  
	  return result;
	}
	
	// Tel hoeveel cellen gevuld zijn in een shape
	function countFilledCells(shape) {
	  let count = 0;
	  for (let y = 0; y < shape.length; y++) {
		for (let x = 0; x < shape[y].length; x++) {
		  if (shape[y][x]) count++;
		}
	  }
	  return count;
	}
	
	// Check of cellen fysiek aangrenzend zijn volgens de shape structuur
	function areCellsPhysicallyConnected(cells, shape) {
	  if (cells.length <= 1) return true;
	  
	  // Bouw een map van x,y naar cel
	  const cellMap = new Map();
	  for (const cell of cells) {
		const x = parseInt(cell.dataset.x);
		const y = parseInt(cell.dataset.y);
		cellMap.set(`${x},${y}`, cell);
	  }
	  
	  // Start BFS vanaf de eerste cel
	  const visited = new Set();
	  const queue = [cells[0]];
	  visited.add(cells[0]);
	  
	  while (queue.length > 0) {
		const current = queue.shift();
		const cx = parseInt(current.dataset.x);
		const cy = parseInt(current.dataset.y);
		
		// Check alle 4 aangrenzende posities
		const neighbors = [
		  [cx - 1, cy],
		  [cx + 1, cy],
		  [cx, cy - 1],
		  [cx, cy + 1]
		];
		
		for (const [nx, ny] of neighbors) {
		  const key = `${nx},${ny}`;
		  const neighborCell = cellMap.get(key);
		  
		  if (neighborCell && !visited.has(neighborCell)) {
			// Check of deze neighbor ook aangrenzend is volgens de shape
			// (niet alleen in de grid, maar ook in de verwachte vorm)
			if (areCellsVisuallyAdjacent(current, neighborCell)) {
			  visited.add(neighborCell);
			  queue.push(neighborCell);
			}
		  }
		}
	  }
	  
	  return visited.size === cells.length;
	}
	
	// Check of twee cellen visueel aangrenzend zijn (binnen ~1 celgrootte afstand)
	function areCellsVisuallyAdjacent(cell1, cell2) {
	  const rect1 = cell1.getBoundingClientRect();
	  const rect2 = cell2.getBoundingClientRect();
	  
	  const center1X = rect1.left + rect1.width / 2;
	  const center1Y = rect1.top + rect1.height / 2;
	  const center2X = rect2.left + rect2.width / 2;
	  const center2Y = rect2.top + rect2.height / 2;
	  
	  const dx = Math.abs(center1X - center2X);
	  const dy = Math.abs(center1Y - center2Y);
	  
	  const cellSize = rect1.width; // Aanname: vierkante cellen
	  
	  // Cellen zijn aangrenzend als ze horizontaal OF verticaal naast elkaar liggen
	  // Tolerantie van 1.5x celgrootte voor kleine positioneringsverschillen
	  const isHorizontallyAdjacent = dx <= cellSize * 1.5 && dy <= cellSize * 0.5;
	  const isVerticallyAdjacent = dy <= cellSize * 1.5 && dx <= cellSize * 0.5;
	  
	  return isHorizontallyAdjacent || isVerticallyAdjacent;
	}
	
	// Check of alle cellen in een lijst met elkaar verbonden zijn (aangrenzend)
	function areCellsConnected(cells) {
	  if (cells.length <= 1) return true;
	  
	  const visited = new Set();
	  const queue = [cells[0]];
	  visited.add(cells[0]);
	  
	  while (queue.length > 0) {
		const current = queue.shift();
		const cx = parseInt(current.dataset.x);
		const cy = parseInt(current.dataset.y);
		
		// Check alle cellen in de lijst of ze aangrenzend zijn aan current
		for (const cell of cells) {
		  if (visited.has(cell)) continue;
		  
		  const x = parseInt(cell.dataset.x);
		  const y = parseInt(cell.dataset.y);
		  
		  // Check of deze cel aangrenzend is (Manhattan distance = 1)
		  if (Math.abs(x - cx) + Math.abs(y - cy) === 1) {
			visited.add(cell);
			queue.push(cell);
		  }
		}
	  }
	  
	  // Als alle cellen bezocht zijn, zijn ze verbonden
	  return visited.size === cells.length;
	}

	function cellsAreAdjacent(cellA, cellB) {
	  if (!cellA || !cellB) return false;
	  const ax = Number(cellA.dataset.x);
	  const ay = Number(cellA.dataset.y);
	  const bx = Number(cellB.dataset.x);
	  const by = Number(cellB.dataset.y);
	  if (!Number.isFinite(ax) || !Number.isFinite(ay) || !Number.isFinite(bx) || !Number.isFinite(by)) return false;
	  return Math.abs(ax - bx) + Math.abs(ay - by) === 1;
	}

	// ========================
	// CAN PLACE
	// ========================
	function canPlace(zone, baseX, baseY, shape) {
	  const pendingCells = collectPlacementCells(zone, baseX, baseY, shape);
	  return !!(pendingCells && pendingCells.length > 0 && passesPlacementRules(zone, pendingCells));
	}

	function passesPlacementRules(zone, pendingCells) {
	  if (!zone || !pendingCells.length) return false;
	  const zoneId = zone.id || '';
	if (zoneId === 'yellow-zone') return validateYellowPlacement(zone, pendingCells);
	if (zoneId === 'blue-zone') return validateBluePlacement(zone, pendingCells);
	if (zoneId === 'green-zone') return validateGreenPlacement(zone, pendingCells);
	if (zoneId.startsWith('red-grid')) return validateRedPlacement(zone, pendingCells);
	if (zoneId === 'purple-zone') return validatePurplePlacement(zone, pendingCells);
	  return true;
	}

	function zoneHasActiveCells(zone) {
	  return !!zone.querySelector('.cell.active');
	}

	function hasAdjacentActiveCell(zone, cell) {
	  if (!zone || !cell) return false;
	  const x = Number(cell.dataset.x);
	  const y = Number(cell.dataset.y);
	  if (!Number.isFinite(x) || !Number.isFinite(y)) return false;
	  const neighbors = [
		getCell(zone, x - 1, y),
		getCell(zone, x + 1, y),
		getCell(zone, x, y - 1),
		getCell(zone, x, y + 1)
	  ];
	  return neighbors.some(neighbor => neighbor && neighbor.classList.contains('active'));
	}

	function validateYellowPlacement(zone, pendingCells) {
	  const hasActive = zoneHasActiveCells(zone);
	  const touchesStartColumn = pendingCells.some(cell => cell.classList.contains('bold-cell'));
	  if (!hasActive) return touchesStartColumn;
	  if (touchesStartColumn) return true;
	  return pendingCells.some(cell => hasAdjacentActiveCell(zone, cell));
	}

	function validateBluePlacement(zone, pendingCells) {
	  const metrics = getZoneMetrics(zone);
	  const floorY = Number.isFinite(metrics.maxY) ? metrics.maxY : null;
	  const touchesFloor = floorY !== null && pendingCells.some(cell => Number(cell.dataset.y) === floorY);
	  // Blue: allow starting/anchoring from ANY bold-cell (not only the bottom row).
	  // This matches the request to be able to place from any bold-cell without breaking scoring.
	  const touchesBold = pendingCells.some(cell => cell && cell.classList && cell.classList.contains('bold-cell'));
	  const hasActive = zoneHasActiveCells(zone);
	  // If no active cells exist yet, allow placement when it touches floor OR a bold start cell
	  if (!hasActive) return touchesFloor || touchesBold;
	  // If there are active cells, touching floor or bold-cell is acceptable
	  if (touchesFloor || touchesBold) return true;
	  return pendingCells.some(cell => hasAdjacentActiveCell(zone, cell));
	}

	function validateGreenPlacement(zone, pendingCells) {
	  const hasActive = zoneHasActiveCells(zone);
	  // Allow ANY bold-cell in the green zone to serve as a start anchor (not just the first match)
	  const boldCells = Array.from(zone.querySelectorAll('.cell.bold-cell:not(.void-cell)'));
	  const touchesAnchor = boldCells.length ? boldCells.some(b => pendingCells.includes(b)) : false;
	  
	  // Als er nog geen actieve cellen zijn
	  if (!hasActive) {
		if (!boldCells.length) return true;
		return touchesAnchor;
	  }
	  
	  // Als er wel actieve cellen zijn, check:
	  // 1. Touch anchor directly
	  if (touchesAnchor) return true;
	  
	  // 2. Adjacent to any active cell (including the anchor if it's active)
	  return pendingCells.some(cell => hasAdjacentActiveCell(zone, cell));
	}

	function validateRedPlacement(zone, pendingCells) {
	  // Rood: altijd vrij plaatsen, geen adjacency check nodig
	  return true;
	}

	function validatePurplePlacement(zone, pendingCells) {
	  // World 2 paars: je mag niet starten op de buitenste 2 ringen
	  // tenzij je aangrenzend bent aan een actieve cel
	  const hasActive = zoneHasActiveCells(zone);
	  
	  // Als er nog geen actieve cellen zijn, moet je NIET op outer ring starten
	  if (!hasActive) {
		// Check of alle pending cells NIET op de buitenste 2 ringen zitten
		const allInner = pendingCells.every(cell => {
		  return !cell.classList.contains('outer-ring-0') && !cell.classList.contains('outer-ring-1');
		});
		return allInner;
	  }
	  
	  // Als er wel actieve cellen zijn, moet je aangrenzend zijn
	  return pendingCells.some(cell => hasAdjacentActiveCell(zone, cell));
	}

	// ========================
	// SHOW PREVIEW
	// ========================
	function showPreview(zone, baseX, baseY, shape, color, allowed) {
	  clearPreview(zone);
	  const optionalCells = getOptionalCells(shape);
	  const optionalSet = new Set(optionalCells.map(({ x, y }) => `${x},${y}`));
	  let effectiveShape = shape;
	  let trimmedMode = false;
	  const fullCells = collectPlacementCells(zone, baseX, baseY, shape);
	  const fullValid = fullCells && fullCells.length > 0 && passesPlacementRules(zone, fullCells);
	  if (!fullValid && optionalCells.length) {
		const trimmed = trimOptionalCells(shape);
		if (trimmed.length > 0 && trimmed[0].length > 0) {
		  const trimmedCells = collectPlacementCells(zone, baseX, baseY, trimmed);
		  if (trimmedCells && trimmedCells.length > 0 && passesPlacementRules(zone, trimmedCells)) {
			effectiveShape = trimmed;
			trimmedMode = true;
		  }
		}
	  }
	  const highlightSet = trimmedMode ? new Set() : optionalSet;
	  effectiveShape.forEach((row, y) => {
		row.forEach((cell, x) => {
		  if (!cell) return;
		  const target = getCell(zone, baseX + x, baseY + y);
		  if (target) {
			const key = `${x},${y}`;
			const isOptional = highlightSet.has(key);
			target.classList.add(allowed ? 'preview-allowed' : 'preview-denied');
			if (allowed) {
			  const baseColor = color.name === 'multikleur'
				  ? 'linear-gradient(45deg, #f06272, #fff25a, #4ed346, #5d90f0, #a35eff)'
				  : hexToRGBA(color.code, isOptional ? 0.25 : 0.5);
			  target.style.background = baseColor;
			  if (isOptional) {
				target.style.border = '2px dashed rgba(255,255,255,0.6)';
			  }
			}
		  }
		});
	  });
	}
	
	// kan het blijven plakken aan een ander blok
	function getStickyBaseY(zone, baseX, baseY, shape) {
		if (!zone || zone.id !== 'blue-zone') return baseY;
		
		const metrics = getZoneMetrics(zone);
		if (!metrics || metrics.maxY < metrics.minY) return baseY;
		
		// GEEN magnetisch effect meer - alleen checken of positie geldig is
		// Een positie is geldig als:
		// 1. Het blok raakt de bodem (boldBottom cells), OF
		// 2. Het blok grenst aan een al geplaatst blok (boven/onder/links/rechts)
		
		let touchesBottom = false;
		let touchesActiveBlock = false;
		
		for (let y = 0; y < shape.length; y++) {
			for (let x = 0; x < shape[0].length; x++) {
				if (!isSolidShapeCell(shape[y][x])) continue;
				
				const cellX = baseX + x;
				const cellY = baseY + y;
				const cell = getCell(zone, cellX, cellY);
				
				// Check of deze cel de bodem raakt (bold-cell onderaan)
				if (cell && cell.classList.contains('bold-cell')) {
					touchesBottom = true;
				}
				
				// Check of cel onder deze actief is (staat erop)
				const cellBelow = getCell(zone, cellX, cellY + 1);
				if (cellBelow && cellBelow.classList.contains('active')) {
					touchesActiveBlock = true;
				}
				
				// Check aangrenzende cellen (boven, links, rechts - niet onder want dat is hierboven)
				const adjacentPositions = [
					{ x: cellX - 1, y: cellY },     // links
					{ x: cellX + 1, y: cellY },     // rechts
					{ x: cellX, y: cellY - 1 }      // boven
				];
				
				for (const pos of adjacentPositions) {
					const adjacentCell = getCell(zone, pos.x, pos.y);
					if (adjacentCell && adjacentCell.classList.contains('active')) {
						touchesActiveBlock = true;
						break;
					}
				}
				
				if (touchesBottom || touchesActiveBlock) break;
			}
			if (touchesBottom || touchesActiveBlock) break;
		}
		
		// Als het blok noch de bodem noch een actief blok raakt, is de positie ongeldig
		if (!touchesBottom && !touchesActiveBlock) {
			return -9999; // Onmogelijke positie
		}
		
		// Positie is geldig, return origineel
		return baseY;
	}

	function getYellowPlacement(zone, baseX, baseY, shape, metrics) {
	  if (!zone || zone.id !== 'yellow-zone') return { baseX, baseY };
	  
	  // Check of deze gele zone bold-cells heeft (World 2 mechaniek)
	  const hasBoldCells = zone.querySelectorAll('.cell.bold-cell').length > 0;
	  
	  // Als er geen bold-cells zijn (World 1), gebruik oude gedrag: geen restricties
	  if (!hasBoldCells) {
		return { baseX, baseY };
	  }
	  
	  // WORLD 2: Voor gele zone met bold-cells: GEEN magnetisch effect
	  // Het blok moet exact op de juiste positie staan
	  // EN Ã©Ã©n van de cellen moet een bold-cell aanraken OF aangrenzen aan een actieve cel
	  
	  // Check of er een bold-cell wordt aangeraakt OF aangrenzen aan actieve cel
	  let touchesBoldCell = false;
	  let adjacentToActive = false;
	  
	  for (let row = 0; row < shape.length; row++) {
		for (let col = 0; col < shape[0].length; col++) {
		  if (isSolidShapeCell(shape[row][col])) {
			const cellX = baseX + col;
			const cellY = baseY + row;
			const cell = getCell(zone, cellX, cellY);
			
			// Check bold-cell
			if (cell && cell.classList.contains('bold-cell')) {
			  touchesBoldCell = true;
			  break;
			}
			
			// Check aangrenzende cellen (boven, onder, links, rechts)
			const adjacentPositions = [
			  { x: cellX - 1, y: cellY },     // links
			  { x: cellX + 1, y: cellY },     // rechts
			  { x: cellX, y: cellY - 1 },     // boven
			  { x: cellX, y: cellY + 1 }      // onder
			];
			
			for (const pos of adjacentPositions) {
			  const adjacentCell = getCell(zone, pos.x, pos.y);
			  if (adjacentCell && adjacentCell.classList.contains('active')) {
				adjacentToActive = true;
				break;
			  }
			}
			
			if (adjacentToActive) break;
		  }
		}
		if (touchesBoldCell || adjacentToActive) break;
	  }
	  
	  // Als geen bold-cell wordt aangeraakt EN niet aangrenzend aan actieve cel
	  // dan is dit geen geldige positie (alleen voor World 2)
	  if (!touchesBoldCell && !adjacentToActive) {
		return { baseX: -9999, baseY: -9999 };
	  }
	  
	  // Anders: retourneer de originele positie (geen aanpassing)
	  return { baseX, baseY };
	}
		
	// ========================
	// PLACE SHAPE
	// ========================
	function placeShape(zone, baseX, baseY, shape, color) {
	  if (!zone) return null;
	  const colorCode = typeof color === 'string'
		? color
		: (color?.code);
	  const effectiveShape = shape;
	  // Validate using the required cells only (optional cells are skipped by collectPlacementCells).
	  const pendingCells = collectPlacementCells(zone, baseX, baseY, effectiveShape);
	  if (!pendingCells || pendingCells.length <= 0 || !passesPlacementRules(zone, pendingCells)) {
		return null;
	  }
	  
	  const placements = [];
	  const bonuses = [];
	  const previousPlacementId = currentPlacementId;
	  placementSequence += 1;
	  currentPlacementId = `placement-${placementSequence}`;
	  
	effectiveShape.forEach((row, y) => {
		row.forEach((cellVal, x) => {
		  if (!cellVal) return;
		  const target = getCell(zone, baseX + x, baseY + y);
		  if (!target) return;
		  // Optional cells (value 2) are a bonus extension: place them only when they fit.
		  if (isOptionalShapeCell(cellVal) && target.classList.contains('active')) return;
		  if (!target.classList.contains('active')) {
			placements.push(target);
			const toggleInfo = toggleCell(target, zone.id, colorCode, true);
			if (toggleInfo && toggleInfo.bonusClaim) {
				bonuses.push(toggleInfo.bonusClaim);
			}
		  }
		});
	});
	
	// Portals blijven op hun plaats staan voor het hele level
	
	currentPlacementId = previousPlacementId;
	return {
		zoneId: zone.id,
		cells: placements,
		bonuses
	};
}	// ========== KAARTEN SYSTEEM ==========
	// Centraal systeem voor alle kaart blueprints
	const CARD_BLUEPRINTS = {
		// Mini kaarten (2-3 blokjes)
		mini: [
			{ name: 'Domino verticaal', matrix: [[1],[1]], weight: 1 },
			{ name: 'Domino horizontaal', matrix: [[1,1]], weight: 1 },
			{ name: 'Tri-bar horizontaal', matrix: [[1,1,1]], weight: 1 },
			{ name: 'Tri-bar verticaal', matrix: [[1],[1],[1]], weight: 1 },
			{ name: 'Mini L', matrix: [[1,0],[1,1]], weight: 1 },
			{ name: 'Mini J', matrix: [[0,1],[1,1]], weight: 1 }
		],
		// Standaard Tetris (4 blokjes)
		standard: [
			{ name: 'I verticaal', matrix: [[1],[1],[1],[1]], weight: 1 },
			{ name: 'I horizontaal', matrix: [[1,1,1,1]], weight: 1 },
			{ name: 'O', matrix: [[1,1],[1,1]], weight: 1 },
			{ name: 'T omhoog', matrix: [[1,0],[1,1],[1,0]], weight: 1 },
			{ name: 'T omlaag', matrix: [[0,1],[1,1],[0,1]], weight: 1 },
			{ name: 'L klassiek', matrix: [[1,0],[1,0],[1,1]], weight: 1 },
			{ name: 'J klassiek', matrix: [[0,1],[0,1],[1,1]], weight: 1 },
			{ name: 'S horizontaal', matrix: [[1,1,0],[0,1,1]], weight: 1 },
			{ name: 'S verticaal', matrix: [[0,1],[1,1],[1,0]], weight: 1 },
			{ name: 'Z horizontaal', matrix: [[0,1,1],[1,1,0]], weight: 1 },
			{ name: 'Z verticaal', matrix: [[1,0],[1,1],[0,1]], weight: 1 }
		],
		// Grote/creatieve vormen
		large: [
			{ name: 'Plus', matrix: [[0,1,0],[1,1,1],[0,1,0]], weight: 1 },
			{ name: 'U vorm', matrix: [[1,0,1],[1,1,1]], weight: 1 },
			{ name: 'L groot', matrix: [[1,0],[1,0],[1,0],[1,1]], weight: 1 },
			{ name: 'Trap', matrix: [[1,0,0],[1,1,0],[0,1,1]], weight: 1 },
			{ name: 'Hoefijzer', matrix: [[1,1,0],[1,0,0],[1,1,0]], weight: 1 },
			{ name: 'Pijl', matrix: [[0,0,1],[1,1,1],[0,1,0]], weight: 1 },
			{ name: 'Lang 5 horizontaal', matrix: [[1,1,1,1,1]], weight: 1 },
			{ name: 'Lang 5 verticaal', matrix: [[1],[1],[1],[1],[1]], weight: 1 },
			{ name: 'Hinge', matrix: [[1,1,0],[0,1,1],[0,0,1]], weight: 1 },
			{ name: 'Z dubbel', matrix: [[0,1],[1,0],[1,1]], weight: 1 },
			{ name: 'S dubbel rechts', matrix: [[1,0],[1,1],[0,1,1]], weight: 1 },
			{ name: 'Hoekspiegel', matrix: [[1,0,0],[1,1,1],[0,0,1]], weight: 1 }
		],
		// Gouden kaarten (speciale category)
		golden: [
			{ name: 'Gouden Vierkant', matrix: [[1,1],[1,1]], weight: 1 },
			{ name: 'Gouden L', matrix: [[1,0],[1,0],[1,1]], weight: 1 },
			{ name: 'Gouden Zuil', matrix: [[1],[1],[1]], weight: 1 }
		]
	};

	// Extra grote (7 blokjes) vormen: zeldzaam + pas na upgrade.
	const EXTRA_LARGE_7_SHAPES = [
		{ name: 'Extra Groot (7) - Randhoek', matrix: [[1,1,1],[1,0,0],[1,1,1]], weight: 0.08 },
		{ name: 'Extra Groot (7) - Dubbele balk', matrix: [[1,1,1],[0,1,0],[1,1,1]], weight: 0.08 }
	];

	// XL vormen (6 blokjes): pas na upgrade.
	const XL_6_SHAPES = [
		{ name: 'XL (6) - 2x3', matrix: [[1,1,1],[1,1,1]], weight: 1 },
		{ name: 'XL (6) - Lang 6 horizontaal', matrix: [[1,1,1,1,1,1]], weight: 1 },
		{ name: 'XL (6) - Lang 6 verticaal', matrix: [[1],[1],[1],[1],[1],[1]], weight: 1 }
	];

	const SHAPE_CATEGORY_WEIGHTS = {
		mini: 0.35,      
		standard: 1,     
		large: 0.35      
	};

	// Bouw shapePool dynamisch op basis van upgrades
	function buildShapePool() {
		const pool = [];
		const weights = { ...SHAPE_CATEGORY_WEIGHTS };
		
		// Pas weights aan op basis van upgrades
		if (hasUpgrade('miniPack34')) {
			weights.mini = 0.65;  // Meer mini kaarten
		}
		
		// Voeg alleen unlocked categories toe aan pool
		Object.entries(CARD_BLUEPRINTS).forEach(([category, cards]) => {
			if (category === 'golden') return; // Skip golden, die worden apart toegevoegd
			
			// Check of category unlocked is
			if (!UNLOCK_PROGRESSION.isCategoryUnlocked(category, currentLevel)) {
				return; // Skip niet-unlocked categorieÃ«n
			}
			
			cards.forEach(card => {
				const categoryWeight = weights[category] ?? 1;
				pool.push({
					name: card.name,
					category: category,
					weight: card.weight * categoryWeight,
					matrix: card.matrix
				});
			});
		});

		// Extra grote 7-blok vormen zijn upgrade-gated en zeldzaam.
		if (hasUpgrade('extraLargeBlocks')) {
			EXTRA_LARGE_7_SHAPES.forEach(card => {
				pool.push({
					name: card.name,
					category: 'large',
					weight: card.weight,
					matrix: card.matrix
				});
			});
		}

		// XL 6-blok vormen zijn upgrade-gated.
		if (hasUpgrade('xlBlocks')) {
			XL_6_SHAPES.forEach(card => {
				pool.push({
					name: card.name,
					category: 'large',
					weight: card.weight,
					matrix: card.matrix
				});
			});
		}
		
		return pool;
	}

	// shapePool wordt later geÃ¯nitialiseerd na currentLevel declaratie
	let shapePool = [];

	function getRandomShapeEntry() {
	  const totalWeight = shapePool.reduce((sum, entry) => {
		const categoryWeight = SHAPE_CATEGORY_WEIGHTS[entry.category] ?? 1;
		return sum + entry.weight * categoryWeight;
	  }, 0);
	  let target = Math.random() * totalWeight;
	  for (const entry of shapePool) {
		const categoryWeight = SHAPE_CATEGORY_WEIGHTS[entry.category] ?? 1;
		const adjustedWeight = entry.weight * categoryWeight;
		if (target < adjustedWeight) return entry;
		target -= adjustedWeight;
	  }
	  return shapePool[shapePool.length - 1];
	}

	// gewone kleuren + multikleur
	const colors = [
	  { name: 'rood',   code: '#b56069' },
	  { name: 'groen',  code: '#92c28c' },
	  { name: 'blauw',  code: '#5689b0' },
	  { name: 'geel',   code: '#cfba51' },
	  { name: 'paars',  code: '#8f76b8' },
	  { name: 'multikleur', code: 'rainbow' } // speciale wildcard
	];
	const NON_WILDCARD_COLORS = colors.filter(c => c.name !== 'multikleur').map(c => ({ ...c }));
	const EXTRA_HAND_BONUS = 1;
	const LUCKY_DRAW_COPY_CHANCE = 0.25;
	let goldenColorRotation = 0;

	// Variabelen die nodig zijn voor buildShapePool
	let currentLevel = 1;
	let currentWorld = 1; // Nieuwe variabele om bij te houden in welke wereld we zitten

	// Helper functie om world en subLevel te bepalen
	function getWorldAndSubLevel(level) {
		if (level <= 10) return { world: 1, subLevel: level };
		if (level <= 20) return { world: 2, subLevel: level - 10 };
		if (level <= 30) return { world: 3, subLevel: level - 20 };
		return { world: Math.floor((level - 1) / 10) + 1, subLevel: ((level - 1) % 10) + 1 };
	}

	function isAtLeastWorldAndSubLevel(targetWorld, targetSubLevel, level = currentLevel) {
		const info = getWorldAndSubLevel(Number(level) || 1);
		const world = Number(info?.world || 1);
		const subLevel = Number(info?.subLevel || 1);
		if (world > targetWorld) return true;
		if (world < targetWorld) return false;
		return subLevel >= targetSubLevel;
	}

	// Vanaf level 1.7 (en later) zijn multikleur + gouden modifiers beschikbaar.
	function isSpecialModifiersUnlocked(level = currentLevel) {
		return isAtLeastWorldAndSubLevel(1, 7, level);
	}

	let ownedDeckBlueprints = [];
	let drawPile = [];
	let discardPile = [];
	let currentHand = [];
	let pendingShopCallback = null;
	let lastRoundWasSuccess = false;
	let lastRoundFailureReason = null;
	let selectedCardId = null;
	let selectedCardElement = null;
	let cardPlacementHistory = [];
	let cardsPlayedThisTurn = 0;
	let goldenCardPlayedThisTurn = false;
	let nonGoldenCardPlayedThisTurn = false;
	let actionSequence = 0;
	let cellActivationSequence = 0;
	let placementSequence = 0;
	let currentPlacementId = null;
	let coinsAwardedFromScore = 0;
	let cardSelectionLocked = false;
	  // NOTE: Turn counter UI is handled via turnCount/updateTurnCounterDisplay().
	let debugMode = false;
	let isLoadingGame = false;
	let savedDeckState = null;

	// Initialiseer shapePool nu currentLevel beschikbaar is
	shapePool = buildShapePool();

	let cardBlueprintCounter = 0;
	let cardInstanceCounter = 0;

	function nextBlueprintId() {
	  cardBlueprintCounter += 1;
	  return `bp-${cardBlueprintCounter}`;
	}

	function nextCardInstanceId() {
	  cardInstanceCounter += 1;
	  return `card-${cardInstanceCounter}`;
	}

	function cloneColor(color) {
		if (!color) return { name: '', code: '#ffffff' };
		return { name: color.name, code: color.code, isGolden: !!color.isGolden };
	}

	function createCardBlueprint(shapeEntry, colorOverride, extras = {}) {
		return {
			blueprintId: nextBlueprintId(),
			shapeName: shapeEntry.name,
			matrix: cloneShape(shapeEntry.matrix),
			category: shapeEntry.category,
			color: cloneColor(colorOverride),
			...extras
		};
	}

	function instantiateBlueprint(blueprint) {
		const safeColor = cloneColor(blueprint.color);
		// Backward compatible: old saves might mark golden on the color object.
		// Golden is a card modifier, NOT a block color.
		const isGolden = !!(blueprint && (blueprint.isGolden || blueprint.color?.isGolden));
		if (isGolden) safeColor.isGolden = false;
		return {
			id: nextCardInstanceId(),
			blueprintId: blueprint.blueprintId,
			shapeName: blueprint.shapeName,
			matrix: cloneShape(blueprint.matrix),
			category: blueprint.category,
			color: safeColor,
			isGolden
		};
	}

	function buildStandardDeckBlueprint() {
	  const standardShapes = shapePool.filter(entry => entry.category === 'standard');
	  
	  // Als shapePool leeg is of geen standard shapes heeft, rebuild de pool
	  if (standardShapes.length === 0) {
		console.warn('âš ï¸ No standard shapes in pool, rebuilding shapePool');
		shapePool = buildShapePool();
		const retryStandardShapes = shapePool.filter(entry => entry.category === 'standard');
		if (retryStandardShapes.length === 0) {
		  console.error('âŒ Still no standard shapes after rebuild!');
		  // Fallback: gebruik alle shapes als laatste redmiddel
		  return shapePool.slice(0, 9).map((entry, idx) => {
			const color = NON_WILDCARD_COLORS[idx % NON_WILDCARD_COLORS.length];
			return createCardBlueprint(entry, color);
		  });
		}
	  }
	  
	  const shuffled = shuffleArray([...standardShapes]);
	  const picks = shuffled.slice(0, 9);
	  const baseColors = [...NON_WILDCARD_COLORS];
	  let colorIndex = 0;
	  return picks.map(entry => {
		const color = baseColors[colorIndex % baseColors.length];
		colorIndex += 1;
		return createCardBlueprint(entry, color);
	  });
	}

	function getRandomGoldenShape() {
		if (!GOLDEN_CARD_SHAPES.length) {
			return { name: 'Gouden Vierkant', matrix: [[1,1],[1,1]], category: 'golden' };
		}
		const index = Math.floor(Math.random() * GOLDEN_CARD_SHAPES.length);
		return GOLDEN_CARD_SHAPES[index];
	}

	function createGoldenCardBlueprint() {
		const shapeEntry = getRandomGoldenShape();
		const palette = [...NON_WILDCARD_COLORS];
		const baseColor = palette.length ? palette[goldenColorRotation % palette.length] : { name: 'multikleur', code: 'rainbow' };
		goldenColorRotation = palette.length ? (goldenColorRotation + 1) % palette.length : goldenColorRotation;
		// Golden card = golden frame; keep the block color the base color.
		return createCardBlueprint(shapeEntry, baseColor, { isGolden: true, category: 'golden' });
	}

	function addGoldenCardBlueprints(count = 1) {
		for (let i = 0; i < count; i += 1) {
			ownedDeckBlueprints.push(createGoldenCardBlueprint());
		}
	}

	function addMiniCardBlueprints(count = 1) {
		const miniShapes = CARD_BLUEPRINTS.mini || [];
		const palette = NON_WILDCARD_COLORS.length ? NON_WILDCARD_COLORS : [{ name: 'grijs', code: '#a0a0a0' }];
		if (!miniShapes.length || !palette.length) return;
		for (let i = 0; i < count; i += 1) {
			const shapeEntry = miniShapes[Math.floor(Math.random() * miniShapes.length)];
			const entryWithCategory = { ...shapeEntry, category: 'mini' };
			const baseColor = palette[Math.floor(Math.random() * palette.length)];
			const blueprint = createCardBlueprint(entryWithCategory, baseColor);
			ownedDeckBlueprints.push(blueprint);
		}
	}

	function getSpendableCoinCount() {
	  return document.querySelectorAll('#collected-coins .coin.active').length;
	}

// Return a coin count usable by objective checks/progress.
// Priority: explicit `scores.coins` or `scores.coinsCollected` if provided,
// then DOM `getSpendableCoinCount()`, then fallback to deriving from
// bonus points (1 coin per 3 bonus points) if available.
function getCollectedCoinCount(scores) {
	if (scores && typeof scores.coins === 'number') return scores.coins;
	if (scores && typeof scores.coinsCollected === 'number') return scores.coinsCollected;
	if (typeof getSpendableCoinCount === 'function') return getSpendableCoinCount();
	if (scores && typeof scores.bonusesCollected === 'number') return Math.floor(scores.bonusesCollected / 3);
	return 0;
}

	function updateShopCoinDisplay() {
		if (!window.updateShopCoinDisplayElement) {
			const balanceEl = document.getElementById('shop-coin-balance');
			const displayEl = document.getElementById('shop-coin-display');
			window.updateShopCoinDisplayElement = { balanceEl, displayEl };
		}
		const refs = window.updateShopCoinDisplayElement;
		if (!refs || !refs.balanceEl) return;
		const coins = getSpendableCoinCount();
		refs.balanceEl.textContent = String(coins);
		refs.balanceEl.setAttribute('data-coins', String(coins));
		if (refs.displayEl) {
			refs.displayEl.classList.toggle('is-empty', coins === 0);
		}
	}

	function updateCoinCounter() {
	  const goldZone = document.getElementById('gold-zone');
	  if (!goldZone) return;
	  const activeCoins = getSpendableCoinCount();
	  goldZone.setAttribute('data-coin-text', `${activeCoins}`);
	  updateShopCoinDisplay();
	  updateBuyPlacementButton();
	}

	function updateBuyPlacementButton() {
	  const btn = document.getElementById('buy-placement-btn');
	  const preview = document.getElementById('purchased-block-preview');
	  if (!btn) return;
	  
	  // Als er een gekochte plaatsing actief is, toon preview en verberg knop
	  if (window.hasPurchasedPlacement) {
		btn.style.display = 'none';
		if (preview) preview.style.display = 'flex';
		// Ensure preview cell matches zoomed cell size when zoomed
		try {
			if (document.body.classList.contains('zoomed-in')) {
				const cellSize = Math.round(getActualCellSize(typeof activeZoomZone !== 'undefined' && activeZoomZone ? activeZoomZone : null));
				const cellEl = preview.querySelector('.purchased-block-cell');
				if (cellEl && Number.isFinite(cellSize) && cellSize > 6) {
					cellEl.style.width = cellEl.style.height = `${cellSize}px`;
					cellEl.style.borderRadius = `${Math.min(8, Math.round(cellSize / 4))}px`;
				}
			} else {
				// restore default CSS sizing
				const cellEl = preview.querySelector('.purchased-block-cell');
				if (cellEl) {
					cellEl.style.removeProperty('width');
					cellEl.style.removeProperty('height');
					cellEl.style.removeProperty('border-radius');
				}
			}
		} catch (e) {}
		return;
	  }
	  
	  // Anders toon knop en verberg preview
	  btn.style.display = 'flex';
	  if (preview) preview.style.display = 'none';
	  
	  const coins = getSpendableCoinCount();
	  const cost = 2;
	  btn.disabled = coins < cost;
	  btn.title = coins < cost 
		? `Onvoldoende munten (${coins}/${cost})` 
		: 'Koop bonusblok (2 munten)';
	}

	function onBuyPlacementClick() {
	  const coins = getSpendableCoinCount();
	  const cost = 2;
	  if (coins < cost) {
		showObjectiveToast('âŒ Onvoldoende munten voor blokplaatsing');
		return;
	  }
	  
	  // Betaal de munten
	  if (!spendCoins(cost)) {
		showObjectiveToast('âŒ Kon munten niet afschrijven');
		return;
	  }
	  
	  // Markeer dat er een gekochte plaatsing klaar staat
	  window.hasPurchasedPlacement = true;
	  updateBuyPlacementButton();
	  
	  showObjectiveToast('ðŸŒˆ Blok gekocht! Sleep het icoon om te plaatsen.');
	}

	function onPurchasedBlockPreviewClick(event) {
	  if (!window.hasPurchasedPlacement) return;
	  const isMobileLayout = window.innerWidth <= MOBILE_BREAKPOINT;
	  const isTouchDevice = ('ontouchstart' in window || navigator.maxTouchPoints > 0);
	  const isPointerDown = !!(event && typeof event.type === 'string' && event.type.indexOf('pointer') === 0);
	  const preferDirectDrag = !!(event && event.type === 'pointerdown' && event.pointerType === 'mouse');
	  
	  // Als er al een purchased placement drag actief is, doe niets (voorkom toggle)
	  if (activeBonusPlacement && activeBonusPlacement.colorKey === 'purchased') {
		return;
	  }
	  
	  // Cancel eventuele actieve bonus plaatsing
	  cancelActiveBonusPlacement({ updateInventory: false });
	  
	  // Maak een 1x1 multikleur blok en start het slepen
	  const shape = [[1]];
	  const colorObj = { name: 'multikleur', code: 'rainbow' };
	  
	  // Stel de geselecteerde vorm in
	  selectedShape = shape;
	  selectedColor = colorObj;
	  
	  const previewEl = document.getElementById('purchased-block-preview');
	  // Touch devices and mobile: always use direct drag (no hover mode)
	  // Desktop mouse can also use direct drag for purchased blocks (simpler UX)
	  // Skip hover-follow mode for purchased placement entirely.

	  // Touch: direct drag behavior - blok volgt de vinger
	  const block = makeDraggable(shape, colorObj);
	  block.classList.add('bonus-draggable', 'purchased-placement');
	  const overlay = document.getElementById('drag-overlay');
	  if (overlay && !overlay.contains(block)) overlay.appendChild(block);
	  if (overlay) overlay.style.display = 'block';
	  
	  draggedBlock = block;
	  draggedShape = block._shape || shape;
	  draggedColor = colorObj;
	  
	  // Start de pointer drag tracking
	  beginPointerDrag({ clientX: event.clientX, clientY: event.clientY, pointerId: event.pointerId || null });
	  
	  // Positioneer het blok bij de pointer positie (met touch offset)
	  const startX = event.clientX || window.innerWidth / 2;
	  const startY = event.clientY || window.innerHeight / 2;
	  ({ offsetX, offsetY } = computeShapeCenterOffsets(draggedShape));
	  const touchOffsetY = isTouchDevice ? 60 : 0; // Offset zodat vinger het blok niet bedekt
	  draggedBlock.style.left = `${startX - offsetX}px`;
	  draggedBlock.style.top = `${startY - offsetY - touchOffsetY}px`;

	// Ensure the purchased draggable immediately measures zoomed cell size
	// (in case zoom/lift just occurred). Re-render on next frame.
	requestAnimationFrame(() => {
		try {
			renderBlock(block, block._shape || shape, colorObj);
			({ offsetX, offsetY } = computeShapeCenterOffsets(block._shape || shape));
			block.style.left = `${startX - offsetX}px`;
			block.style.top = `${startY - offsetY - touchOffsetY}px`;
		} catch (e) {}
	});
	  
	  activeBonusPlacement = {
		colorKey: 'purchased',
		pointerId: event.pointerId || null,
		sticky: false, // Direct plaatsen bij release
		shape: cloneShape(shape),
		purchasedPlacement: true
	  };
	  
	  startGlobalDragVisuals();
	  // Don't show rotate/mirror buttons for purchased placement (1x1 block doesn't need them)
	  // addCardControlButtons() is skipped for purchased placement
	}

	function clearPurchasedPlacement() {
	  window.hasPurchasedPlacement = false;
	  updateBuyPlacementButton();
	}

	function setDebugMode(enabled) {
		debugMode = !!enabled;
		document.body.classList.toggle('debug-mode', debugMode);
		const toggleBtn = document.getElementById('debug-mode-toggle');
		if (toggleBtn) {
			toggleBtn.classList.toggle('debug-active', debugMode);
			toggleBtn.setAttribute('aria-pressed', String(debugMode));
			toggleBtn.textContent = debugMode ? 'Debug modus: aan' : 'Debug modus: uit';
		}
		const clearBtn = document.getElementById('clear-board-btn');
		if (clearBtn) {
			clearBtn.disabled = !debugMode;
			if (debugMode) clearBtn.removeAttribute('aria-disabled');
			else clearBtn.setAttribute('aria-disabled', 'true');
			clearBtn.title = debugMode ? 'Leeg het bord en reset munten (debug)' : 'Debug modus vereist om het bord te legen';
		}
		localStorage.setItem('debugModeEnabled', debugMode ? 'true' : 'false');
	}

	function toggleDebugMode() {
		setDebugMode(!debugMode);
	}

	const deckModalLayer = document.getElementById('deck-modal-layer');
	const deckModalContent = document.getElementById('deck-modal-content');
	const deckModalSubtext = document.getElementById('deck-modal-subtext');
	const deckModalClose = document.getElementById('deck-modal-close');
	const deckPreviewEl = document.getElementById('deck-preview');
	const goldenUnlockLayer = document.getElementById('golden-unlock-layer');
	const goldenUnlockModal = document.getElementById('golden-unlock-modal');
	const goldenUnlockTitle = document.getElementById('golden-unlock-title');
	const goldenUnlockContent = document.getElementById('golden-unlock-content');
	const goldenUnlockSubtext = document.getElementById('golden-unlock-subtext');
	const GOLDEN_UNLOCK_DEFAULT_TITLE = goldenUnlockTitle ? goldenUnlockTitle.textContent : 'âœ¨ Kies je eerste gouden kaart';
	const GOLDEN_UNLOCK_DEFAULT_SUBTEXT = goldenUnlockSubtext ? goldenUnlockSubtext.innerHTML : 'Je hebt <strong>Gouden Kaarten</strong> ontgrendeld. Kies er 1 uit 3.';
	const blackHoleModalLayer = document.getElementById('blackhole-modal-layer');
	const blackHoleModal = document.getElementById('blackhole-modal');
	const blackHoleSubtext = document.getElementById('blackhole-modal-subtext');
	const blackHoleCardGrid = document.getElementById('blackhole-card-grid');
	const blackHoleSelectionCount = document.getElementById('blackhole-selection-count');
	const blackHoleSelectionLimit = document.getElementById('blackhole-selection-limit');
	const blackHoleRewardEl = document.getElementById('blackhole-reward');
	const blackHoleStakeInput = document.getElementById('blackhole-stake');
	const blackHoleStakeValueEl = document.getElementById('blackhole-stake-value');
	const blackHoleStakeMultEl = document.getElementById('blackhole-stake-mult');
	const blackHoleClaimBtn = document.getElementById('blackhole-claim-btn');
	const blackHoleForfeitBtn = document.getElementById('blackhole-forfeit-btn');
	const blackHoleFeedbackEl = document.getElementById('blackhole-feedback');

	if (blackHoleStakeInput) {
		blackHoleStakeInput.addEventListener('input', () => {
			const maxStake = Math.max(0, Number(blackHoleStakeInput.max) || 10);
			const raw = Number(blackHoleStakeInput.value) || 0;
			const minStake = maxStake > 0 ? 1 : 0;
			blackHoleState.stake = Math.max(minStake, Math.min(maxStake, raw));
			updateBlackHoleSelectionUI();
		});
	}

	function buildDeckModalCard(blueprint, index) {
	  if (!blueprint || !deckModalContent) return null;
	  const rows = Array.isArray(blueprint.matrix) ? blueprint.matrix.length : 0;
	  const cols = rows > 0 && Array.isArray(blueprint.matrix[0]) ? blueprint.matrix[0].length : 0;
		const card = document.createElement('div');
		card.classList.add('card', 'card-option', 'deck-modal-card');
		card.setAttribute('role', 'listitem');
		card.dataset.shapeCols = String(cols);
		card.dataset.shapeRows = String(rows);
		if (blueprint.blueprintId) card.dataset.blueprintId = blueprint.blueprintId;
		if (blueprint.shapeName) card.dataset.shapeName = blueprint.shapeName;
	  card.tabIndex = -1;
	  card.style.cursor = 'default';
	  card.style.pointerEvents = 'none';
	  const isGolden = !!(blueprint.isGolden || blueprint.color?.isGolden);
	  const colorObj = cloneColor(blueprint.color || { name: '', code: '#cccccc' });
	  // Golden is a card modifier; do not paint the blocks gold.
	  if (isGolden) colorObj.isGolden = false;
	  card.dataset.golden = isGolden ? 'true' : 'false';
		const baseLabel = blueprint.shapeName || (colorObj.name ? `${colorObj.name} kaart` : 'Kaart');
		card.dataset.cardLabel = baseLabel;
		card.setAttribute('aria-label', baseLabel);
	  if (isGolden) card.classList.add('card-golden');
	  const pattern = document.createElement('div');
	  pattern.classList.add('card-pattern');
	  card.appendChild(pattern);
	  updateCardPattern(card, blueprint.matrix, colorObj);
	  const label = document.createElement('div');
	  label.classList.add('card-label');
	  const swatch = document.createElement('span');
	  swatch.classList.add('card-label-dot');
	  // Golden is a modifier; keep the swatch showing the base color.
	  const fill = (colorObj.code === 'rainbow'
		? 'linear-gradient(135deg, #f06272, #fff25a, #4ed346, #5d90f0, #a35eff)'
		: (colorObj.code || '#a0a0a0'));
	  swatch.style.background = fill;
	  const labelText = document.createElement('span');
	  labelText.textContent = isGolden
		? 'GOUDEN'
		: (colorObj.name ? colorObj.name.toUpperCase() : 'KAART');
	  label.append(swatch, labelText);
	  const meta = document.createElement('div');
	  meta.classList.add('card-meta');
	  meta.textContent = rows && cols ? `${rows}Ã—${cols}` : '';
	  card.append(label, meta);
	  return card;
	}

	let handScrollControlsInitialized = false;

	function updateHandScrollControls() {
	  const container = document.getElementById('card-options');
	  const cardControls = document.getElementById('card-controls');
	  const leftBtn = document.getElementById('hand-scroll-left');
	  const rightBtn = document.getElementById('hand-scroll-right');
	  if (!container || !cardControls || !leftBtn || !rightBtn) return;

	  const isMobile = window.innerWidth <= MOBILE_BREAKPOINT;
	  if (!isMobile) {
		cardControls.classList.remove('hand-scroll-enabled');
		leftBtn.disabled = true;
		rightBtn.disabled = true;
		return;
	  }

	  // UX rule: only show arrows when there are 5+ cards in hand.
	  const cardCount = container.querySelectorAll('.card-option').length;
	  if (cardCount < 5) {
		cardControls.classList.remove('hand-scroll-enabled');
		leftBtn.disabled = true;
		rightBtn.disabled = true;
		return;
	  }

	  const canScroll = container.scrollWidth > (container.clientWidth + 4);
	  cardControls.classList.toggle('hand-scroll-enabled', canScroll);

	  if (!canScroll) {
		leftBtn.disabled = true;
		rightBtn.disabled = true;
		return;
	  }

	  const maxScrollLeft = Math.max(0, container.scrollWidth - container.clientWidth);
	  const current = container.scrollLeft;
	  leftBtn.disabled = current <= 1;
	  rightBtn.disabled = current >= (maxScrollLeft - 1);
	}

	function initHandScrollControls() {
	  if (handScrollControlsInitialized) return;
	  handScrollControlsInitialized = true;

	  const container = document.getElementById('card-options');
	  const leftBtn = document.getElementById('hand-scroll-left');
	  const rightBtn = document.getElementById('hand-scroll-right');
	  if (!container || !leftBtn || !rightBtn) return;

	  const getScrollDelta = () => {
		const firstCard = container.querySelector('.card-option');
		const cardWidth = firstCard ? firstCard.getBoundingClientRect().width : 110;
		const gapRaw = getComputedStyle(container).gap || '0px';
		const gap = parseFloat(gapRaw) || 0;
		return Math.max(48, Math.round(cardWidth + gap));
	  };

	  leftBtn.addEventListener('click', (e) => {
		e.preventDefault();
		if (leftBtn.disabled) return;
		container.scrollBy({ left: -getScrollDelta(), behavior: 'smooth' });
	  });

	  rightBtn.addEventListener('click', (e) => {
		e.preventDefault();
		if (rightBtn.disabled) return;
		container.scrollBy({ left: getScrollDelta(), behavior: 'smooth' });
	  });

	  container.addEventListener('scroll', () => {
		updateHandScrollControls();
	  }, { passive: true });

	  window.addEventListener('resize', () => {
		updateHandScrollControls();
	  }, { passive: true });
	}

	function populateDeckModalContent() {
	  if (!deckModalContent) return;
	  deckModalContent.innerHTML = '';
	  const total = ownedDeckBlueprints.length;
	  // Respect scenario restrictions when present.
	  const allowedColors = Array.isArray(window.scenarioAllowedColors) ? window.scenarioAllowedColors : null;
	  if (deckModalSubtext) {
		deckModalSubtext.textContent = total === 1
		  ? 'Je hebt 1 kaart in je deck'
		  : `Je hebt ${total} kaarten in je deck`;
	  }
	  if (total === 0) {
		const empty = document.createElement('div');
		empty.classList.add('deck-modal-empty');
		empty.textContent = 'Je deck is leeg. Koop of verdien nieuwe kaarten om ze hier te zien.';
		deckModalContent.appendChild(empty);
		return;
	  }
		const getDeckKeyFromMatrix = matrix => {
			try {
				return JSON.stringify(matrix || []);
			} catch {
				return '[]';
			}
		};
		const getDeckSignature = (category, matrix, color, isGolden) => {
			// IMPORTANT: Use a deterministic signature that survives refresh/save/load.
			// We intentionally do NOT include blueprintId, shapeName, or color.code here,
			// because those can change or be missing across sessions.
			const safeColor = color || {};
			const golden = !!(isGolden || safeColor.isGolden);
			return [
				category || '',
				getDeckKeyFromMatrix(matrix),
				safeColor.name || '',
				golden ? 'gold' : 'normal'
			].join('|');
		};
		const getBlueprintKey = blueprint => {
			if (!blueprint) return 'sig|';
			return `sig|${getDeckSignature(blueprint.category, blueprint.matrix, blueprint.color, blueprint.isGolden)}`;
		};
		const getCardKey = card => {
			if (!card) return 'sig|';
			return `sig|${getDeckSignature(card.category, card.matrix, card.color, card.isGolden)}`;
		};
		const buildCountMap = (arr, keyFn) => {
			const map = new Map();
			(arr || []).forEach(item => {
				const k = keyFn(item);
				map.set(k, (map.get(k) || 0) + 1);
			});
			return map;
		};
		const dec = (map, key) => {
			const cur = map.get(key) || 0;
			if (cur <= 1) map.delete(key);
			else map.set(key, cur - 1);
		};
		// Use a filtered draw pile for availability calculations so inactive colors
		// (restricted by scenarios) are treated as 'not in draw'.
		const filteredDrawPile = allowedColors
			? drawPile.filter(c => c && (allowedColors.includes((c.color && c.color.name) || '') || (c.color && c.color.name) === 'multikleur'))
			: drawPile;
		const remainingCounts = buildCountMap(filteredDrawPile, getCardKey);
		const handCounts = buildCountMap(currentHand, getCardKey);
		const discardCounts = buildCountMap(discardPile, getCardKey);
		const statusOrder = {
			'available': 0,
			'in-hand': 1,
			'used': 2,
			'discarded': 3,
			'inactive': 99
		};
		const orderedBlueprints = ownedDeckBlueprints
			.map((blueprint, index) => {
				const key = getBlueprintKey(blueprint);
				let status = 'available';
				// If scenario restrictions exist, mark blueprints whose base color is
				// not allowed as 'inactive' so they are shown but marked unusable.
				const bpColorName = (blueprint && blueprint.color && blueprint.color.name) || '';
				const isBpAllowed = !allowedColors || allowedColors.includes(bpColorName) || bpColorName === 'multikleur';
				if (!isBpAllowed) {
					status = 'inactive';
				}
				let isInHand = false;
				let isInDrawPile = false;
				let isDiscarded = false;

				// IMPORTANT: Use counts so duplicates don't all get flagged.
				if ((handCounts.get(key) || 0) > 0) {
					status = 'in-hand';
					isInHand = true;
					dec(handCounts, key);
				} else if ((remainingCounts.get(key) || 0) > 0) {
					status = 'available';
					isInDrawPile = true;
					dec(remainingCounts, key);
				} else if ((discardCounts.get(key) || 0) > 0) {
					status = 'discarded';
					isDiscarded = true;
					dec(discardCounts, key);
				} else {
					status = 'used';
				}

				const sortKey = statusOrder[status] ?? 99;
				return { blueprint, index, status, isInDrawPile, isInHand, isDiscarded, sortKey };
			})
			.sort((a, b) => {
				if (a.sortKey !== b.sortKey) return a.sortKey - b.sortKey;
				return a.index - b.index;
			});
		orderedBlueprints.forEach(entry => {
			const { blueprint, index, status } = entry;
			const card = buildDeckModalCard(blueprint, index);
			if (!card) return;
			const baseLabel = card.dataset.cardLabel || blueprint.shapeName || 'Kaart';
			let statusText = 'Nog in deck';
			switch (status) {
				case 'in-hand':
					card.classList.add('deck-modal-card--depleted', 'deck-modal-card--in-hand');
					statusText = 'Nu in je hand';
					break;
				case 'available':
					statusText = 'Nog in deck';
					break;
				case 'inactive':
					card.classList.add('deck-modal-card--inactive');
					statusText = 'Niet bruikbaar voor dit niveau!';
					// Add an explicit badge element so it displays reliably over the card preview.
					try {
						const badge = document.createElement('div');
						badge.className = 'deck-modal-inactive-badge';
						badge.textContent = '?';
						// Avoid adding badge on multikleur cards (they have their own mark)
						const label = (card.dataset.cardLabel || '').toLowerCase();
						if (!label.includes('multikleur') && !label.includes('rainbow')) card.appendChild(badge);
					} catch (e) {}
					break;
				case 'used':
					card.classList.add('deck-modal-card--depleted');
					statusText = 'Al getrokken';
					break;
				case 'discarded':
					card.classList.add('deck-modal-card--depleted');
					statusText = 'Al gespeeld';
					break;
			}
			card.dataset.cardStatus = status;
			card.setAttribute('aria-label', `${baseLabel} â€“ ${statusText}`);
			card.title = `${baseLabel} â€¢ ${statusText}`;
			deckModalContent.appendChild(card);
		});
	  applyCardSizing();
	  deckModalContent.scrollTop = 0;
	}

	function openDeckModal() {
	  if (!deckModalLayer) return;
	  populateDeckModalContent();
	  deckModalLayer.classList.add('show');
	  deckModalLayer.setAttribute('aria-hidden', 'false');
	}

	function closeDeckModal() {
	  if (deckModalLayer) {
		deckModalLayer.classList.remove('show');
		deckModalLayer.setAttribute('aria-hidden', 'true');
	  }
	  if (deckPreviewEl) deckPreviewEl.focus();
	}

	function buildGoldenUnlockChoices(count = 3) {
		const candidates = shapePool.filter(e => e && (e.category === 'mini' || e.category === 'standard'));
		const pool = candidates.length ? shuffleArray([...candidates]) : shuffleArray([...shapePool]);
		const picks = pool.slice(0, Math.max(1, count));
		const palette = NON_WILDCARD_COLORS.length ? NON_WILDCARD_COLORS : colors;
		return picks.map(entry => {
			const baseColor = palette[Math.floor(Math.random() * palette.length)];
			const color = cloneColor(baseColor);
			const blueprint = createCardBlueprint(entry, color, { isGolden: true });
			return { blueprint, card: instantiateBlueprint(blueprint) };
		});
	}

	function setGoldenUnlockModalCopy(titleText, subtextHtml) {
		if (goldenUnlockTitle && typeof titleText === 'string') goldenUnlockTitle.textContent = titleText;
		if (goldenUnlockSubtext && typeof subtextHtml === 'string') goldenUnlockSubtext.innerHTML = subtextHtml;
	}

	function restoreGoldenUnlockModalCopy() {
		setGoldenUnlockModalCopy(GOLDEN_UNLOCK_DEFAULT_TITLE, GOLDEN_UNLOCK_DEFAULT_SUBTEXT);
	}

	function buildRewardChoices({ count = 3, filterFn = null, color = null, blueprintOptions = null } = {}) {
		const fallbackColor = color || { name: 'grijs', code: '#a0a0a0' };
		const candidates = shapePool.filter(e => {
			if (!e || !e.matrix) return false;
			if (typeof filterFn === 'function' && !filterFn(e)) return false;
			return true;
		});
		const pool = candidates.length ? shuffleArray([...candidates]) : shuffleArray([...shapePool]);
		const picks = pool.slice(0, Math.max(1, count));
		return picks.map(entry => {
			const blueprint = createCardBlueprint(entry, fallbackColor, blueprintOptions || undefined);
			return { blueprint, card: instantiateBlueprint(blueprint) };
		});
	}

	function populateRewardPickerModal(choices, onPick) {
		if (!goldenUnlockContent) return;
		goldenUnlockContent.innerHTML = '';
		goldenUnlockContent.classList.remove('selection-disabled');
		(choices || []).forEach(({ blueprint, card }) => {
			const el = createCardElement(card, true, {
				onSelect: (pickedCard) => {
					if (goldenUnlockContent.classList.contains('selection-disabled')) return;
					goldenUnlockContent.classList.add('selection-disabled');
					try {
						if (typeof onPick === 'function') onPick({ blueprint, card: pickedCard });
					} catch (err) {
						console.error('Reward selection failed:', err);
						goldenUnlockContent.classList.remove('selection-disabled');
						showObjectiveToast('âš ï¸ Kon selectie niet verwerken. Probeer opnieuw.');
					}
				}
			});
			el.setAttribute('role', 'listitem');
			el.tabIndex = 0;
			goldenUnlockContent.appendChild(el);
		});
		applyCardSizing();
		goldenUnlockContent.scrollTop = 0;
	}

	function showRewardPickerModal({ titleText, subtextHtml, choices, onPick }) {
		if (!goldenUnlockLayer) return;
		setGoldenUnlockModalCopy(titleText, subtextHtml);
		populateRewardPickerModal(choices, onPick);
		goldenUnlockLayer.classList.add('show');
		goldenUnlockLayer.setAttribute('aria-hidden', 'false');
		if (goldenUnlockModal) goldenUnlockModal.focus();
	}

	function grantPickedBlueprintReward({ blueprint, card }) {
		ownedDeckBlueprints.push(blueprint);
		currentHand.push(card);
		updateDeckPreview();
		saveGameState();
		renderCurrentHand();
	}

	function openMulticolorRewardPicker() {
		const rainbowColor = { name: 'multikleur', code: 'rainbow' };
		const choices = buildRewardChoices({
			count: 3,
			filterFn: (e) => e && (e.category === 'mini' || e.category === 'standard' || e.category === 'large'),
			color: rainbowColor
		});
		showRewardPickerModal({
			titleText: 'ðŸŒˆ Kies je multikleur kaart',
			subtextHtml: 'Je hebt <strong>Multikleur Kaarten</strong> ontgrendeld. Kies er 1 uit 3.',
			choices,
			onPick: ({ blueprint, card }) => {
				grantPickedBlueprintReward({ blueprint, card });
				closeGoldenUnlockModal();
				restoreGoldenUnlockModalCopy();
			}
		});
	}

	function startMini34RewardSequence() {
		const steps = 3;
		let step = 1;
		const colorPalette = NON_WILDCARD_COLORS.length ? NON_WILDCARD_COLORS : colors;
		const pickColor = () => {
			const base = colorPalette[Math.floor(Math.random() * colorPalette.length)] || { name: 'grijs', code: '#a0a0a0' };
			return cloneColor(base);
		};
		const filterMini34 = (e) => {
			if (!e || !e.matrix) return false;
			const blocks = (typeof countShapeBlocks === 'function') ? countShapeBlocks(e.matrix) : null;
			if (!Number.isFinite(blocks)) return (e.category === 'mini' || e.category === 'standard');
			return blocks <= 3;
		};
		const showStep = () => {
			const choices = buildRewardChoices({
				count: 3,
				filterFn: filterMini34,
				color: pickColor()
			});
			showRewardPickerModal({
				titleText: `ðŸ§© Kies je mini-kaart (${step}/${steps})`,
				subtextHtml: 'Je koopt een <strong>mini pakket</strong> (max. 3 blokjes). Kies 3 kaarten (telkens 1 uit 3).',
				choices,
				onPick: ({ blueprint, card }) => {
					grantPickedBlueprintReward({ blueprint, card });
					step += 1;
					if (step > steps) {
						closeGoldenUnlockModal();
						restoreGoldenUnlockModalCopy();
						return;
					}
					setTimeout(showStep, 60);
				}
			});
		};
		showStep();
	}

	function populateGoldenUnlockModal() {
		if (!goldenUnlockContent) return;
		goldenUnlockContent.innerHTML = '';
		goldenUnlockContent.classList.remove('selection-disabled');
		const choices = buildGoldenUnlockChoices(3);
		choices.forEach(({ blueprint, card }) => {
			const el = createCardElement(card, true, {
				onSelect: (pickedCard) => {
					// Safety: prevent double selection (double-click / mobile tap quirks).
					if (goldenUnlockContent.classList.contains('selection-disabled')) return;
					goldenUnlockContent.classList.add('selection-disabled');
					// Permanent reward: add the picked golden card to your owned deck (and keep it in future saves).
					try {
						ownedDeckBlueprints.push(blueprint);
						// Immediate reward: also give an instantiated copy right now.
						currentHand.push(pickedCard);
						updateDeckPreview();
						saveGameState();
						renderCurrentHand();
						closeGoldenUnlockModal();
					} catch (err) {
						console.error('Golden card selection failed:', err);
						goldenUnlockContent.classList.remove('selection-disabled');
						showObjectiveToast('âš ï¸ Kon gouden kaart niet opslaan. Probeer opnieuw.');
					}
				}
			});
			el.setAttribute('role', 'listitem');
			el.tabIndex = 0;
			goldenUnlockContent.appendChild(el);
		});
		applyCardSizing();
		goldenUnlockContent.scrollTop = 0;
	}

	function openGoldenUnlockModal() {
		if (!goldenUnlockLayer) return;
		// Only meaningful if the upgrade is unlocked.
		if (!hasUpgrade('goldenCards')) return;
		restoreGoldenUnlockModalCopy();
		populateGoldenUnlockModal();
		goldenUnlockLayer.classList.add('show');
		goldenUnlockLayer.setAttribute('aria-hidden', 'false');
		if (goldenUnlockModal) {
			goldenUnlockModal.focus();
		}
	}

	function closeGoldenUnlockModal() {
		if (!goldenUnlockLayer) return;
		goldenUnlockLayer.classList.remove('show');
		goldenUnlockLayer.setAttribute('aria-hidden', 'true');
	}

	function showBlackHoleFeedback(message = '', tone = 'info', duration = 2000) {
	  if (!blackHoleFeedbackEl) return;
	  blackHoleFeedbackEl.textContent = message;
	  blackHoleFeedbackEl.dataset.tone = tone;
	  blackHoleFeedbackEl.classList.toggle('show', !!message);
	  if (blackHoleState.feedbackTimeout) {
		clearTimeout(blackHoleState.feedbackTimeout);
		blackHoleState.feedbackTimeout = null;
	  }
	  if (message && duration > 0) {
		blackHoleState.feedbackTimeout = setTimeout(() => {
		  blackHoleFeedbackEl.textContent = '';
		  blackHoleFeedbackEl.classList.remove('show');
		  blackHoleState.feedbackTimeout = null;
		}, duration);
	  }
	}

	function generateBlackHoleCards(count = BLACK_HOLE_CARD_COUNT) {
	  const cards = [];
	  const randInt = (min, max) => (min + Math.floor(Math.random() * (max - min + 1)));
	  // 1 Black Hole
	  cards.push({ type: 'blackhole', value: 0, label: 'âš«' });
	  
	  // 2 Multipliers
	  cards.push({ type: 'multiplier', value: 2, label: 'x2' });
	  cards.push({ type: 'multiplier', value: 2, label: 'x2' });
	  
	  // Remaining are small rewards: mostly 1-10 points, sometimes 1-3 coins.
	  const remaining = count - 3;
	  for (let i = 0; i < remaining; i++) {
		const roll = Math.random();
		if (roll < 0.18) {
			const coins = Math.random() < 0.65 ? 1 : (Math.random() < 0.85 ? 2 : 3);
			cards.push({ type: 'coins', value: coins, label: `<span class="coin-symbol">ðŸª™</span>+${coins}` });
		} else {
			const points = randInt(1, 10);
			cards.push({ type: 'points', value: points, label: `+${points}` });
		}
	  }
	  
	  return shuffleArray(cards);
	}

	function buildBlackHoleModalCard(cardData, index) {
	  if (!cardData) return null;
	  const card = document.createElement('div');
	  card.classList.add('card', 'blackhole-card');
	  card.dataset.cardIndex = String(index);
	  card.tabIndex = 0;
	  
	  // Initial state: Face down
	  card.textContent = '?';
	  card.style.aspectRatio = '1';
	  card.style.display = 'flex';
	  card.style.alignItems = 'center';
	  card.style.justifyContent = 'center';
	  card.style.fontSize = '24px';
	  card.style.fontWeight = 'bold';
	  card.style.background = 'linear-gradient(135deg, #444, #222)';
	  card.style.color = '#fff';
	  card.style.cursor = 'pointer';
	  
	  card.addEventListener('click', () => handleBlackHoleCardClick(index));
	  card.addEventListener('keydown', event => {
		if (event.key === 'Enter' || event.key === ' ') {
		  event.preventDefault();
		  handleBlackHoleCardClick(index);
		}
	  });
	  return card;
	}

	function revealCardVisuals(card, cardData) {
		card.innerHTML = cardData.label;
		card.style.background = '#fff';
		card.style.color = '#000';
		card.style.cursor = 'default';
		
		if (cardData.type === 'blackhole') {
			card.style.background = '#000';
			card.style.color = 'red';
			card.style.border = '2px solid red';
		} else if (cardData.type === 'multiplier') {
			card.style.background = '#ffd700'; // Gold
		} else if (cardData.type === 'coins') {
			card.style.background = '#e8fff0';
			card.style.border = '1px solid rgba(60, 170, 90, 0.55)';
		} else {
			card.style.background = '#e0e0e0';
		}
	}

	function renderBlackHoleCards() {
	  if (!blackHoleCardGrid) return;
	  blackHoleCardGrid.innerHTML = '';
	  blackHoleCardGrid.style.display = 'grid';
	  blackHoleCardGrid.style.gridTemplateColumns = 'repeat(5, 1fr)';
	  blackHoleCardGrid.style.gap = '8px';
	  
	  blackHoleState.cards.forEach((cardData, index) => {
		const card = buildBlackHoleModalCard(cardData, index);
		if (!card) return;
		if (blackHoleState.selected.has(index)) {
			revealCardVisuals(card, cardData);
		}
		blackHoleCardGrid.appendChild(card);
	  });
	}

	function updateBlackHoleSelectionStyles() {
		// No-op
	}

	function getBlackHoleStakeMultiplier(stake) {
		const s = Math.max(0, Math.min(10, Number(stake) || 0));
		// Map 0..10 stake -> 1..5 multiplier (0 means no stake).
		// 0-2 => x1, 3-4 => x2, 5-6 => x3, 7-8 => x4, 9-10 => x5
		if (s <= 2) return 1;
		return 1 + Math.floor((s - 1) / 2);
	}

	function syncBlackHoleStakeUI() {
		const stake = Math.max(0, Number(blackHoleState.stake) || 0);
		const mult = getBlackHoleStakeMultiplier(stake);
		if (blackHoleStakeInput) blackHoleStakeInput.value = String(stake);
		if (blackHoleStakeValueEl) blackHoleStakeValueEl.textContent = String(stake);
		if (blackHoleStakeMultEl) blackHoleStakeMultEl.textContent = String(mult);
	}

	function updateBlackHoleSelectionUI() {
	  const selectionSize = blackHoleState.selected.size;
	  const reward = Math.max(0, blackHoleState.reward || 0);
	  const coins = blackHoleState.coins || 0;
	  const stake = Math.max(0, Number(blackHoleState.stake) || 0);
	  const mult = getBlackHoleStakeMultiplier(stake);
	  const rewardWithStake = reward * mult;
	  
	  if (blackHoleSelectionCount) blackHoleSelectionCount.textContent = String(selectionSize);
	  if (blackHoleSelectionLimit) blackHoleSelectionLimit.textContent = String(BLACK_HOLE_CARD_COUNT);
	  if (blackHoleRewardEl) blackHoleRewardEl.textContent = String(rewardWithStake);
	  syncBlackHoleStakeUI();
	  
	  if (blackHoleClaimBtn) {
		blackHoleClaimBtn.disabled = selectionSize === 0 || blackHoleState.gameOver;
		blackHoleClaimBtn.textContent = blackHoleState.gameOver 
			? 'Game Over' 
			: (selectionSize === 0 ? 'Kies een kaart' : (coins > 0 ? `Claim +${rewardWithStake} (+${coins}ðŸª™)` : `Claim +${rewardWithStake}`));
	  }
	}

	function handleBlackHoleCardClick(index) {
	  if (blackHoleState.gameOver) return;
	  if (typeof index !== 'number' || !blackHoleState.cards[index]) return;
	  if (blackHoleState.selected.has(index)) return;

	  const cardData = blackHoleState.cards[index];
	  blackHoleState.selected.add(index);
	  
	  const cardEl = blackHoleCardGrid.children[index];
	  if (cardEl) revealCardVisuals(cardEl, cardData);

	  if (cardData.type === 'blackhole') {
		blackHoleState.reward = 0;
		blackHoleState.coins = 0;
		blackHoleState.gameOver = true;
		const penalty = Math.min(getSpendableCoinCount(), TRAP_PENALTY || 5);
		for (let i = 0; i < penalty; i++) removeCoin();
		showBlackHoleFeedback(penalty > 0 ? `âš« ZWART GAT! -${penalty}ðŸª™` : 'âš« ZWART GAT!', 'warn');
		
		// Reveal all
		blackHoleState.cards.forEach((c, i) => {
			if (!blackHoleState.selected.has(i)) {
				const el = blackHoleCardGrid.children[i];
				if (el) revealCardVisuals(el, c);
			}
		});
		
		const forfeitBtn = document.getElementById('blackhole-forfeit-btn');
		if (forfeitBtn) forfeitBtn.textContent = 'Sluiten';
		
	  } else if (cardData.type === 'multiplier') {
		blackHoleState.reward *= cardData.value;
		showBlackHoleFeedback(`Bonus x${cardData.value}!`, 'info');
	  } else if (cardData.type === 'coins') {
		blackHoleState.coins = (blackHoleState.coins || 0) + (Number(cardData.value) || 0);
		showBlackHoleFeedback(`+${cardData.value}ðŸª™`, 'info');
	  } else {
		blackHoleState.reward += cardData.value;
		showBlackHoleFeedback(`+${cardData.value} punten`, 'info');
	  }

	  updateBlackHoleSelectionUI();
	}

	function openBlackHoleChallenge(trapRecord) {
	  if (!blackHoleModalLayer || !blackHoleModal) return;
	  resetBlackHoleState();
	  blackHoleState.trap = trapRecord;
	  blackHoleState.cards = generateBlackHoleCards();
	  
	  if (blackHoleSubtext) {
		blackHoleSubtext.textContent = `Draai kaarten om voor punten. Pas op voor het Zwarte Gat! (Stoppen of zwart gat: âˆ’${TRAP_PENALTY}ðŸª™)`;
	  }

	  // Stake UI (optional): 0..10 coins, scaled multiplier x1..x5.
	  const coinsAvailable = getSpendableCoinCount();
	  const maxStake = Math.max(0, Math.min(10, coinsAvailable));
	  blackHoleState.stake = maxStake > 0 ? 1 : 0;
	  if (blackHoleStakeInput) {
		blackHoleStakeInput.max = String(maxStake);
		blackHoleStakeInput.min = maxStake > 0 ? '1' : '0';
		blackHoleStakeInput.disabled = maxStake <= 0;
	  }
	  syncBlackHoleStakeUI();
	  
	  const forfeitBtn = document.getElementById('blackhole-forfeit-btn');
	  if (forfeitBtn) forfeitBtn.textContent = 'Stop';
	  
	  renderBlackHoleCards();
	  updateBlackHoleSelectionUI();
	  showBlackHoleFeedback('ðŸŒ€ Tijd voor bonuspunten!');
	  blackHoleModalLayer.classList.add('show');
	  blackHoleModalLayer.setAttribute('aria-hidden', 'false');
	  if (blackHoleModal.focus) {
		setTimeout(() => blackHoleModal.focus(), 80);
	  }
	}

	function closeBlackHoleModal() {
	  if (!blackHoleModalLayer) return;
	  blackHoleModalLayer.classList.remove('show');
	  blackHoleModalLayer.setAttribute('aria-hidden', 'true');
	  showBlackHoleFeedback('');
	  resetBlackHoleState();
	}

	function claimBlackHoleReward() {
	  const baseReward = Math.max(0, blackHoleState.reward || 0);
	  const coinsReward = Math.max(0, blackHoleState.coins || 0);
	  const stake = Math.max(0, Number(blackHoleState.stake) || 0);
	  const mult = getBlackHoleStakeMultiplier(stake);
	  const reward = baseReward * mult;
	  const trapRecord = blackHoleState.trap;
	  if ((baseReward <= 0 && coinsReward <= 0) || !trapRecord) {
		showBlackHoleFeedback('Selecteer eerst kaarten', 'warn');
		return;
	  }
	  if (stake > 0) {
		const coinsAvailable = getSpendableCoinCount();
		if (coinsAvailable < stake) {
			showBlackHoleFeedback('Niet genoeg munten voor deze inzet.', 'warn');
			return;
		}
		if (!spendCoins(stake)) {
			showBlackHoleFeedback('Inzet kon niet worden afgeschreven.', 'warn');
			return;
		}
	  }
	  if (reward > 0) blackHoleBonus += reward;
	  if (coinsReward > 0) {
		for (let i = 0; i < coinsReward; i++) addCoin();
	  }
	  const stakeLabel = stake > 0 ? ` (inzet ${stake}ðŸª™ Ã—${mult})` : '';
	  showObjectiveToast(coinsReward > 0 ? `ðŸŒ€ Bonus +${reward} en +${coinsReward}ðŸª™!${stakeLabel}` : `ðŸŒ€ Bonus +${reward}!${stakeLabel}`);
	  resolveTrapById(trapRecord.id);
	  closeBlackHoleModal();
	  updateScore();
	}

	function forfeitBlackHoleChallenge() {
	  const trapRecord = blackHoleState.trap;
	  if (!blackHoleState.gameOver) {
		const penalty = Math.min(getSpendableCoinCount(), TRAP_PENALTY || 5);
		for (let i = 0; i < penalty; i++) removeCoin();
		if (penalty > 0) showObjectiveToast(`ðŸŒ€ Gestopt: -${penalty}ðŸª™`);
	  }
	  if (trapRecord) {
		if (activeTraps.some(trap => trap.id === trapRecord.id)) {
			showObjectiveToast('ðŸŒ€ Geen bonus deze keer.');
			resolveTrapById(trapRecord.id);
		}
	  }
	  closeBlackHoleModal();
	  updateScore();
	}

	function updateDeckPreview() {
	  const deckCount = document.querySelector('.deck-count');
	  const deckPreview = document.getElementById('deck-preview');
	  if (deckCount) {
		// UX request: show turns remaining instead of raw cards.
		// Assumption: a "turn" consumes 3 cards from the draw pile.
		const remainingCards = drawPile.length;
		const turnsRemaining = Math.ceil(remainingCards / 3);
		deckCount.textContent = turnsRemaining;
		deckCount.setAttribute('data-deck-count', turnsRemaining);
		if (deckPreview) {
			deckPreview.title = `Beurten over: ${turnsRemaining}`;
		}
	  }
	  if (deckModalLayer && deckModalLayer.classList.contains('show')) {
		populateDeckModalContent();
	  }
	}

	function spendCoins(amount) {
	  const coins = Array.from(document.querySelectorAll('#collected-coins .coin.active'));
	  if (coins.length < amount) return false;
	  coins.slice(0, amount).forEach(coin => {
		coin.classList.remove('active');
		coin.classList.add('used');
	  });
	  updateCoinCounter();
	  return true;
	}

	function getCoinStateSnapshot() {
	  return Array.from(document.querySelectorAll('#collected-coins .coin')).map(coin => ({
		active: coin.classList.contains('active'),
		used: coin.classList.contains('used')
	  }));
	}

	function restoreCoinState(snapshot) {
	  const coins = Array.from(document.querySelectorAll('#collected-coins .coin'));
	  coins.forEach((coin, idx) => {
		const state = snapshot[idx] || { active: false, used: false };
		coin.classList.toggle('active', !!state.active);
		coin.classList.toggle('used', !!state.used);
	  });
	}

	function buildCardSummaryHTML(score, coins, bonusCoins = 0) {
	  const hasBonus = Number.isFinite(bonusCoins) && bonusCoins > 0;
	  const bonusText = hasBonus ? `+${bonusCoins} bonus` : 'Geen bonus deze keer';
	  const bonusClass = hasBonus ? 'round-summary-bonus' : 'round-summary-bonus round-summary-bonus--muted';
	  return `
		<div class="round-summary-cards">
			<div class="round-summary-card">
				<span class="round-summary-icon">ðŸ†</span>
				<span class="round-summary-label">Totaalscore</span>
				<span class="round-summary-value">${score}</span>
			</div>
			<div class="round-summary-card round-summary-card--coins">
				<span class="round-summary-icon">ðŸª™</span>
				<span class="round-summary-label">Munten beschikbaar</span>
				<span class="round-summary-value">${coins}</span>
				<span class="${bonusClass}">${bonusText}</span>
			</div>
		</div>`;
	}

	function countShapeBlocks(matrix) {
	  return matrix.reduce((sum, row) => sum + row.reduce((acc, val) => acc + (val ? 1 : 0), 0), 0);
	}

	function calculateCardCost(cardData) {
	  const blocks = countShapeBlocks(cardData.matrix);
	  // Tier-based prijzen per blokgrootte
	  let baseCost = 2; // 1-3 blocks
	  if (blocks === 4) baseCost = 4;
	  else if (blocks === 5) baseCost = 6;
	  else if (blocks === 6) baseCost = 8;
	  else if (blocks >= 7) baseCost = 10;
	  // Golden modifier +2
	  const isGolden = !!(cardData.isGolden || cardData.color?.isGolden);
	  if (isGolden) baseCost += 2;
	  // Multikleur modifier +2
	  if (cardData.color.name === 'multikleur') baseCost += 2;
	  return baseCost;
	}

	function createRandomShopCardWithRarity() {
		// Random card: keep it simple/consistent so cards don't feel â€œmissingâ€.
		// Rarity order (sequential):
		// 1) Extra large (7 blocks): 5% (only if upgrade unlocked)
		// 2) Gold modifier: small chance
		// 3) Multikleur: small chance
		let entry = null;
		const extraLargeChance = hasUpgrade('extraLargeBlocks') ? 0.05 : 0;
		if (extraLargeChance > 0 && Math.random() < extraLargeChance && Array.isArray(EXTRA_LARGE_7_SHAPES) && EXTRA_LARGE_7_SHAPES.length) {
			const pick = EXTRA_LARGE_7_SHAPES[Math.floor(Math.random() * EXTRA_LARGE_7_SHAPES.length)];
			entry = { name: pick.name, matrix: pick.matrix, category: 'large' };
		} else {
			const baseShapes = shapePool.filter(e => e && countShapeBlocks(e.matrix) !== 7);
			entry = baseShapes.length
				? baseShapes[Math.floor(Math.random() * baseShapes.length)]
				: getRandomShapeEntry();
		}

		const palette = NON_WILDCARD_COLORS.length ? NON_WILDCARD_COLORS : colors;
		// Gouden en multikleur kaarten verschijnen ALLEEN als je de upgrade hebt gekocht
		// Dit is de random kaart aankoop, dus hier mogen ze wel met kleine kans
		const goldenChance = hasUpgrade('goldenCards') ? 0.04 : 0;
		const multicolorChance = hasUpgrade('multicolorBoost') ? 0.04 : 0;
		const isGolden = Math.random() < goldenChance;
		const isMulticolor = !isGolden && Math.random() < multicolorChance;
		const baseColor = isMulticolor
			? { name: 'multikleur', code: 'rainbow' }
			: palette[Math.floor(Math.random() * palette.length)];
		const color = cloneColor(baseColor);
		return instantiateBlueprint(createCardBlueprint(entry, color, { isGolden }));
	}

	function createGoldenShopCard() {
		// Dedicated purchasable golden card (unlocked via goldenCards upgrade).
		// Golden is treated as a modifier: any normal shape with a golden card frame.
		const candidates = shapePool.filter(e => e && (e.category === 'mini' || e.category === 'standard'));
		const entry = candidates.length
			? candidates[Math.floor(Math.random() * candidates.length)]
			: getRandomShapeEntry();
		const palette = NON_WILDCARD_COLORS.length ? NON_WILDCARD_COLORS : colors;
		const baseColor = palette[Math.floor(Math.random() * palette.length)];
		const color = cloneColor(baseColor);
		return instantiateBlueprint(createCardBlueprint(entry, color, { isGolden: true }));
	}

	function createShopCard(choice, isRandomCard = false) {
		if (isRandomCard) {
			return createRandomShopCardWithRarity();
		}
		const entry = choice ?? getRandomShapeEntry();
		// Multikleur kaarten: beschikbaar vanaf level 1.7
		// Multicolor boost upgrade verdubbelt de kans (van 0.35 naar 0.70)
		const baseWildcardChance = 0.35;
		const wildcardChance = hasUpgrade('multicolorBoost') ? baseWildcardChance * 2 : baseWildcardChance;
		const allowWildcard = isSpecialModifiersUnlocked() && hasUpgrade('multicolorBoost') && Math.random() < wildcardChance;
		const palette = allowWildcard ? colors : NON_WILDCARD_COLORS;
		const color = cloneColor(palette[Math.floor(Math.random() * palette.length)]);
		const allowModifiers = isSpecialModifiersUnlocked();
		// Gouden kaarten alleen als je de upgrade hebt
		const isGolden = allowModifiers && hasUpgrade('goldenCards') && color.name !== 'multikleur' && Math.random() < 0.05;
		return instantiateBlueprint(createCardBlueprint(entry, color, { isGolden }));
	}

	function getPremiumShapeEntry() {
		const largeShapes = shapePool.filter(entry => entry.category === 'large');
		const candidates = largeShapes.filter(entry => countShapeBlocks(entry.matrix) >= 6);
		const pool = candidates.length ? candidates : largeShapes;
		if (!pool.length) return getRandomShapeEntry();
		return pool[Math.floor(Math.random() * pool.length)];
	}

	function createPremiumShopCard() {
		// Premium shop card: always a large shape, with boosted golden/multikleur odds.
		// Maar ALLEEN als je de relevante upgrade hebt gekocht!
		const entry = getPremiumShapeEntry();
		const roll = Math.random();
		
		// Gouden kaarten alleen met upgrade
		if (hasUpgrade('goldenCards') && roll < 0.25) {
			const palette = NON_WILDCARD_COLORS.length ? NON_WILDCARD_COLORS : colors;
			const baseColor = cloneColor(palette[Math.floor(Math.random() * palette.length)]);
			return instantiateBlueprint(createCardBlueprint(entry, baseColor, { isGolden: true }));
		}
		// Multikleur alleen met upgrade
		if (hasUpgrade('multicolorBoost') && roll < 0.55) {
			const rainbowColor = { name: 'multikleur', code: 'rainbow' };
			return instantiateBlueprint(createCardBlueprint(entry, rainbowColor));
		}
		// Anders: normale kleur
		const palette = NON_WILDCARD_COLORS.length ? NON_WILDCARD_COLORS : colors;
		const color = cloneColor(palette[Math.floor(Math.random() * palette.length)]);
		return instantiateBlueprint(createCardBlueprint(entry, color));
	}
	

	function placeActionButtons() {
		const actionWrap = document.getElementById('card-action-buttons');
		if (!actionWrap) return;
		const newCardsBtn = document.getElementById('new-cards-btn');
		const rotateBtn = document.getElementById('rotate-card-btn');
		const mirrorBtn = document.getElementById('mirror-card-btn');
		const deckPreview = document.getElementById('deck-preview');
		const turnCounter = document.getElementById('turn-counter-inline');
		[newCardsBtn, rotateBtn, mirrorBtn, deckPreview, turnCounter].forEach(el => {
			if (el && el.parentElement !== actionWrap) {
				actionWrap.appendChild(el);
			}
		});
	}

	const turnCounterEl = document.getElementById('turn-counter-inline');
	let turnCount = 0;
	function updateTurnCounterDisplay() {
		if (!turnCounterEl) return;
		const displayTurn = Math.max(turnCount, 1);
		turnCounterEl.style.display = '';
		turnCounterEl.textContent = `Beurt ${displayTurn}`;
		turnCounterEl.setAttribute('data-turn', String(displayTurn));
	}

	function setCardSelectionLock(lock, activeCardEl = null, options = {}) {
		const { allowGolden = false, allowNormal = false } = options;
		cardSelectionLocked = !!lock;
		const cards = document.querySelectorAll('#card-choice-zone .card-option');
		cards.forEach(card => {
			const isActive = card === activeCardEl;
			const isGoldenCard = card.dataset.golden === 'true';
			
			// Disable als: locked en niet actief en (niet toegestaan OF niet plaatsbaar)
			const lockedOut = cardSelectionLocked && !isActive && !(
				(allowGolden && isGoldenCard) || (allowNormal && !isGoldenCard)
			);
			// PERFORMANCE:
			// Do not call `isCardPlayable()` here. That function performs expensive full-board scans
			// (especially for multikleur), and this lock runs after each placement.
			const disable = lockedOut;
			
			card.classList.toggle('selection-disabled', disable);
			if (disable) {
				card.setAttribute('aria-disabled', 'true');
			} else {
				card.removeAttribute('aria-disabled');
			}
		});
	}

	function allowGoldenCardsInHand() {
		return !!document.querySelector('#card-choice-zone .card-option[data-golden="true"]');
	}

	function hasNonGoldenCardsInHand() {
		return !!document.querySelector('#card-choice-zone .card-option[data-golden="false"]');
	}

	function resetTurnCardFlags() {
		goldenCardPlayedThisTurn = false;
		nonGoldenCardPlayedThisTurn = false;
	}

	function computeCardLockOptions() {
		// Turn rule: max 1 normal card per turn; golden is always allowed.
		const allowNormalByTurnRule = !nonGoldenCardPlayedThisTurn;
		return {
			allowGolden: allowGoldenCardsInHand(),
			allowNormal: allowNormalByTurnRule && hasNonGoldenCardsInHand()
		};
	}

	function applyTurnCardLocks() {
		if (cardsPlayedThisTurn > 0) {
			setCardSelectionLock(true, null, computeCardLockOptions());
		} else {
			setCardSelectionLock(false);
		}
	}

	function recomputeTurnCardFlags() {
		resetTurnCardFlags();
		for (const entry of cardPlacementHistory) {
			if (!entry || entry.isBonusPlacement) continue;
			if (entry.wasGolden) goldenCardPlayedThisTurn = true;
			else nonGoldenCardPlayedThisTurn = true;
		}
	}

	function createCardElement(cardData, inlineLabel, options = {}) {
	  const { onSelect } = options;
	  const card = document.createElement('div');
	  card.classList.add('card', 'card-option');
	  card.dataset.cardId = cardData.id;
	  card.dataset.shapeName = cardData.shapeName;
	  card.dataset.shapeCols = String(cardData.matrix[0].length);
	  card.dataset.shapeRows = String(cardData.matrix.length);
	  card.cardData = cardData;
	  card.cardShape = cardData.matrix;
	  card.cardColor = cardData.color;
	const isGoldenCard = !!cardData.isGolden || !!cardData.color?.isGolden;
	const isDeckCopy = !!cardData.isDeckCopy;
	const isLuckyCopy = !!cardData.isLuckyCopy;
	card.dataset.golden = isGoldenCard ? 'true' : 'false';
	card.dataset.deckCopy = isDeckCopy ? 'true' : 'false';
	card.dataset.luckyCopy = isLuckyCopy ? 'true' : 'false';
	if (isGoldenCard) {
		card.classList.add('card-golden');
	}
	if (isDeckCopy) {
		card.classList.add('card-deck-copy');
	}
	if (isLuckyCopy) {
		card.classList.add('card-lucky-copy');
	}
	// Visual markers for pre-level chosen cards
	if (cardData && cardData.isPrelevelChoice) {
		card.classList.add('prelevel-card');
		try {
			card.style.filter = cardData.isUsed ? 'grayscale(60%) brightness(0.6)' : 'brightness(0.85)';
			const badge = document.createElement('span'); badge.className = 'prelevel-badge'; badge.textContent = 'â—';
			badge.style.position = 'absolute'; badge.style.top = '6px'; badge.style.right = '6px'; badge.style.fontSize = '14px'; badge.style.pointerEvents = 'none';
			card.style.position = 'relative';
			card.appendChild(badge);
		} catch (e) {}
	}
	  const pattern = document.createElement('div');
	  pattern.classList.add('card-pattern');
	  card.appendChild(pattern);
	  updateCardPattern(card, cardData.matrix, cardData.color);

	if (inlineLabel) {
		const label = document.createElement('div');
		label.classList.add('card-label');
		const swatch = document.createElement('span');
		swatch.classList.add('card-label-dot');
		// Golden is a modifier; keep the swatch showing the base color.
		swatch.style.background = (cardData.color.code === 'rainbow'
			? 'linear-gradient(135deg, #f06272, #fff25a, #4ed346, #5d90f0, #a35eff)'
			: cardData.color.code);
		const labelText = document.createElement('span');
		labelText.textContent = isGoldenCard
		  ? 'GOUDEN'
		  : cardData.color.name.toUpperCase();
		label.append(swatch, labelText);

		const meta = document.createElement('div');
		meta.classList.add('card-meta');
		meta.textContent = `${cardData.matrix.length}Ã—${cardData.matrix[0].length}`;

		card.append(label, meta);
	  }

	  // Pointer UX:
	  // - Touch: tap selects (no loose block), press/hold or move starts drag.
	  // - Mouse: click selects (no floating block); click+drag starts drag (floating block follows cursor).
	  card.addEventListener('pointerdown', event => {
		const isMobileLayout = isMobileViewport();
		const isTouchDevice = ('ontouchstart' in window || navigator.maxTouchPoints > 0);
		if (event.button !== undefined && event.button !== 0) return;

		// Mouse / non-touch: only start drag after actual movement.
		if (!isTouchDevice) {
			const pointerId = event.pointerId;
			const startX = event.clientX;
			const startY = event.clientY;
			let lastX = startX;
			let lastY = startY;
			let started = false;

			const clear = () => {
				document.removeEventListener('pointermove', onMove, true);
				document.removeEventListener('pointerup', onUp, true);
				document.removeEventListener('pointercancel', onUp, true);
			};

			const startDrag = () => {
				if (started) return;
				started = true;
				if (typeof onSelect === 'function') {
					onSelect(cardData, card);
				} else {
					selectCard(card, card.cardShape, card.cardColor, { clientX: lastX, clientY: lastY, pointerId, forceDrag: true });
				}
				// Prevent the subsequent click from toggling selection unexpectedly.
				suppressCardSelectUntil = Date.now() + 250;
				try { card.setPointerCapture(pointerId); } catch {}
				clear();
			};

			const onMove = ev => {
				if (ev.pointerId !== pointerId) return;
				lastX = ev.clientX;
				lastY = ev.clientY;
				const dx = Math.abs(lastX - startX);
				const dy = Math.abs(lastY - startY);
				if (!started && (dx + dy) > 3) {
					ev.preventDefault();
					startDrag();
				}
			};

			const onUp = ev => {
				if (ev.pointerId !== pointerId) return;
				if (started) {
					// Pointer capture can synthesize a click on the card even if the user released elsewhere.
					// Ensure that click cannot toggle selection/cleanup after an (invalid) release.
					suppressCardSelectUntil = Date.now() + 650;
				}
				clear();
			};

			document.addEventListener('pointermove', onMove, true);
			document.addEventListener('pointerup', onUp, true);
			document.addEventListener('pointercancel', onUp, true);
			return;
		}

		// Touch desktop (e.g. iPad): tap to select, drag to pick up block.
		// Changed from immediate forceDrag to tap-select behavior with drag support.
		if (!isMobileLayout) {
			const pointerId = event.pointerId;
			const startX = event.clientX;
			const startY = event.clientY;
			let lastX = startX;
			let lastY = startY;
			let started = false;
			let timer = null;

			const clear = () => {
				if (timer) {
					clearTimeout(timer);
					timer = null;
				}
				document.removeEventListener('pointermove', onMove, true);
				document.removeEventListener('pointerup', onUp, true);
				document.removeEventListener('pointercancel', onUp, true);
			};

			const startDrag = () => {
				if (started) return;
				started = true;
				// Start drag met forceDrag
				if (typeof onSelect === 'function') {
					onSelect(cardData, card);
				} else {
					selectCard(card, card.cardShape, card.cardColor, { clientX: lastX, clientY: lastY, pointerId, forceDrag: true });
				}
				suppressCardSelectUntil = Date.now() + 400;
				try { card.setPointerCapture(pointerId); } catch {}
				clear();
			};

			const onMove = ev => {
				if (ev.pointerId !== pointerId) return;
				lastX = ev.clientX;
				lastY = ev.clientY;
				const dx = Math.abs(lastX - startX);
				const dy = Math.abs(lastY - startY);
				// Als gebruiker beweegt, start drag
				if (!started && (dx + dy) > 8) {
					ev.preventDefault();
					startDrag();
				}
			};

			const onUp = ev => {
				if (ev.pointerId !== pointerId) return;
				if (started) {
					suppressCardSelectUntil = Date.now() + 650;
				}
				clear();
				// Als niet gedragged, laat de click handler het afhandelen (selectie/toggle)
			};

			document.addEventListener('pointermove', onMove, true);
			document.addEventListener('pointerup', onUp, true);
			document.addEventListener('pointercancel', onUp, true);

			// Long-press start drag (voor gebruikers die lang ingedrukt houden)
			timer = setTimeout(() => {
				if (started) return;
				startDrag();
			}, 200);
			return;
		}

		const pointerId = event.pointerId;
		const startX = event.clientX;
		const startY = event.clientY;
		let lastX = startX;
		let lastY = startY;
		let started = false;
		let timer = null;
		const prevTransform = card.style.transform;
		const prevFilter = card.style.filter;
		const prevWillChange = card.style.willChange;
		const prevTransition = card.style.transition;
		let liftActive = false;

		const applyLiftEffect = (clientY) => {
			// Only lift when moving upward; keep it subtle.
			const up = Math.max(0, (startY - (Number(clientY) || startY)));
			const lift = Math.min(22, up * 0.55);
			const t = lift / 22;
			const brightness = 1 - (t * 0.18); // down to ~0.82
			if (!liftActive) {
				liftActive = true;
				card.style.willChange = 'transform, filter';
				card.style.transition = 'transform 0.06s ease, filter 0.06s ease';
			}
			card.style.transform = `translateY(${-lift}px)`;
			card.style.filter = `brightness(${brightness})`;
		};

		const resetLiftEffect = () => {
			if (!liftActive) return;
			liftActive = false;
			card.style.transform = prevTransform;
			card.style.filter = prevFilter;
			card.style.willChange = prevWillChange;
			card.style.transition = prevTransition;
		};

		const clear = () => {
			if (timer) {
				clearTimeout(timer);
				timer = null;
			}
			resetLiftEffect();
			document.removeEventListener('pointermove', onMove, true);
			document.removeEventListener('pointerup', onUp, true);
			document.removeEventListener('pointercancel', onUp, true);
		};

		const startDrag = () => {
			if (started) return;
			started = true;
			resetLiftEffect();
			if (typeof onSelect === 'function') {
				onSelect(cardData, card);
			} else {
				selectCard(card, card.cardShape, card.cardColor, { clientX: lastX, clientY: lastY, pointerId, forceDrag: true });
			}
			suppressCardSelectUntil = Date.now() + 400;
			try {
				card.setPointerCapture(pointerId);
			} catch {}
			clear();
		};

		const onMove = ev => {
			if (ev.pointerId !== pointerId) return;
			lastX = ev.clientX;
			lastY = ev.clientY;
			const dx = Math.abs(lastX - startX);
			const dy = Math.abs(lastY - startY);
			// Visual: as the user pulls up, lift + darken the card ("picked up" feel).
			if (!started) {
				applyLiftEffect(lastY);
			}
			// If the user starts moving, interpret it as a drag intent.
			if (!started && (dx + dy) > 6) {
				ev.preventDefault();
				startDrag();
			}
		};

		const onUp = ev => {
			if (ev.pointerId !== pointerId) return;
			if (started) {
				suppressCardSelectUntil = Date.now() + 650;
			}
			clear();
		};

		document.addEventListener('pointermove', onMove, true);
		document.addEventListener('pointerup', onUp, true);
		document.addEventListener('pointercancel', onUp, true);

		// Long-press also starts drag (useful when moving less initially).
		timer = setTimeout(() => {
			if (started) return;
			startDrag();
		}, 120);
	  }, true);

	  card.addEventListener('click', event => {
		event.stopPropagation();
		// Allow toggling off the currently selected card even during suppression windows.
		const clickedCardId = card?.dataset?.cardId || null;
		const isToggleOffClick = !!clickedCardId && !!selectedCardId && clickedCardId === selectedCardId;
		if (!isToggleOffClick && Date.now() < suppressCardSelectUntil) return;
		if (typeof onSelect === 'function') {
		  onSelect(cardData, card);
		} else {
		  selectCard(card, card.cardShape, card.cardColor);
		}
		// Only show controls when there is an active selection or a hanging block/bonus.
		const hasActiveContext = !!(selectedCardElement || draggedBlock || activeBonusPlacement);
		if (hasActiveContext) {
			if (rotateButton) rotateButton.disabled = false;
			if (mirrorButton) mirrorButton.disabled = false;
			addCardControlButtons();

			// Re-render on next frame so the draggable measures the correct cell size
			// if a zoom/lift was triggered via autoZoomToColorZone().
			requestAnimationFrame(() => {
				try {
					renderBlock(freeBlock, freeBlock._shape || shape, colorObj);
					({ offsetX, offsetY } = computeShapeCenterOffsets(freeBlock._shape || shape));
					const touchOffsetY2 = 60;
					freeBlock.style.left = `${event.clientX - offsetX}px`;
					freeBlock.style.top = `${event.clientY - offsetY - touchOffsetY2}px`;
				} catch (e) {}
			});
		} else {
			if (rotateButton) rotateButton.disabled = true;
			if (mirrorButton) mirrorButton.disabled = true;
			removeCardControlButtons();
		}
	  });

	  return card;
	}

	function renderCurrentHand() {
	  const container = document.getElementById('card-options');
	  if (!container) {
		console.warn('âš ï¸ card-options container not found');
		return;
	  }
	  
	  if (typeof debugMode !== 'undefined' && debugMode) {
		console.log('ðŸ“‹ renderCurrentHand - currentHand:', currentHand.length, 'cards');
		console.log('ðŸ“‹ Container visible:', container.offsetParent !== null, 'display:', getComputedStyle(container).display);
	  }
	  
	  const inlineButton = isMobileViewport();

	  container.innerHTML = '';
	  selectedShape = null;
	  selectedColor = null;
	  selectedCardId = null;
	  selectedCardElement = null;
	  if (rotateButton) rotateButton.disabled = true;
		cardSelectionLocked = false;

	  // Respect scenario restrictions when set: `window.scenarioAllowedColors` is an
	  // optional array of Dutch color names (e.g. ['groen','blauw']). If present,
	  // only show cards matching those colors or multikleur cards.
	  const allowedColors = Array.isArray(window.scenarioAllowedColors) ? window.scenarioAllowedColors : null;
	  const handToRender = allowedColors ? currentHand.filter(c => c && (allowedColors.includes((c.color && c.color.name) || '') || (c.color && c.color.name) === 'multikleur')) : currentHand;
	  handToRender.forEach((cardData, idx) => {
		if (typeof debugMode !== 'undefined' && debugMode) {
			console.log(`  Card ${idx}:`, cardData.shapeName, cardData.color?.name);
		}
		const cardElement = createCardElement(cardData, inlineButton);
		container.appendChild(cardElement);
	  });
	  
	  if (typeof debugMode !== 'undefined' && debugMode) {
		console.log('ðŸŽ´ Rendered', currentHand.length, 'cards to hand. Container children:', container.children.length);
	  }
	  
	  // Desktop: toon scrollbalk alleen bij 4+ kaarten
	  if (currentHand.length >= 4) {
		container.classList.add('has-scroll');
		const sidebar = document.getElementById('desktop-right');
		if (sidebar) sidebar.classList.add('hand-has-scroll');
	  } else {
		container.classList.remove('has-scroll');
		const sidebar = document.getElementById('desktop-right');
		if (sidebar) sidebar.classList.remove('hand-has-scroll');
	  }

	  placeActionButtons();
	  applyCardSizing();
	  applyMobileHandFitForFiveCards();
	  // Mobile UX: show max ~3 cards and allow horizontal scroll with arrows.
	  try {
		container.scrollLeft = 0;
		initHandScrollControls();
		updateHandScrollControls();
	  } catch {}
	updateDrawButtonState();
	applyTurnCardLocks();
	try { if (typeof monitorScenarioProgress === 'function') monitorScenarioProgress(); } catch(e){}
	}

	function finalizeBonusPlacement(placementResult, coinSnapshotBefore, bonusContext) {
	  if (!bonusContext || !placementResult) return;
	  const { colorKey } = bonusContext;
	  
	  // Handle purchased placement - clear de preview state
	  if (colorKey === 'purchased') {
		clearPurchasedPlacement();
		const coinSnapshot = (coinSnapshotBefore || []).map(state => ({ active: state.active, used: state.used }));
		const actionId = ++actionSequence;
		cardPlacementHistory.push({
			isBonusPlacement: true,
			bonusKey: 'purchased',
			cells: (placementResult.cells || []).filter(Boolean),
			zoneId: placementResult.zoneId,
			coinSnapshotBefore: coinSnapshot,
			bonuses: Array.isArray(placementResult.bonuses) ? placementResult.bonuses.slice() : [],
			sequence: actionId,
			bonusSpent: false
		});
		updateDrawButtonState();
		return;
	  }
	  
	  if (!colorKey || !BONUS_COLOR_CONFIG[colorKey]) return;
	  const coinSnapshot = (coinSnapshotBefore || []).map(state => ({ active: state.active, used: state.used }));
	  const consumed = spendBonusCharge(colorKey);
	  const actionId = ++actionSequence;
	  cardPlacementHistory.push({
		isBonusPlacement: true,
		bonusKey: colorKey,
		cells: (placementResult.cells || []).filter(Boolean),
		zoneId: placementResult.zoneId,
		coinSnapshotBefore: coinSnapshot,
		bonuses: Array.isArray(placementResult.bonuses) ? placementResult.bonuses.slice() : [],
		sequence: actionId,
		bonusSpent: consumed
	  });
	if (consumed) {
		updateBonusInventoryUI();
	}
	  updateDrawButtonState();
	}

	function updateDrawButtonState() {
	  if (!newCardsButton) return;
	  if (drawPile.length === 0 && currentHand.length === 0) {
		// Voltooi ronde - tekst wijzigt naar "Einde beurt"
		newCardsButton.classList.add('complete-round');
		newCardsButton.classList.remove('ready-for-next-turn');
		newCardsButton.disabled = false;
		newCardsButton.setAttribute('data-label', 'Einde beurt');
		newCardsButton.setAttribute('aria-label', 'Einde beurt');
		return;
	  }
	  if (drawPile.length === 0) {
		// Voltooi ronde - tekst wijzigt naar "Einde beurt"
		newCardsButton.classList.add('complete-round');
		newCardsButton.classList.remove('ready-for-next-turn');
		newCardsButton.disabled = cardsPlayedThisTurn === 0;
		newCardsButton.setAttribute('data-label', 'Einde beurt');
		newCardsButton.setAttribute('aria-label', 'Einde beurt');
		return;
	  }
	  // Herstel naar standaard tekst
	  newCardsButton.classList.remove('complete-round');
	  newCardsButton.setAttribute('data-label', 'Volgende hand');
	  newCardsButton.setAttribute('aria-label', 'Volgende hand');

	  // PERFORMANCE:
	  // After a placement (especially golden), `isCardPlayable()` may scan huge zones (multikleur).
	  // Once the player has played at least one card this turn, this button should be enabled anyway.
	  const hasUsableBonuses = getRemainingBonusCharges() > 0;
	  if (cardsPlayedThisTurn > 0) {
		newCardsButton.classList.remove('ready-for-next-turn');
		newCardsButton.disabled = false;
		return;
	  }

	  const hasPlayableCards = currentHand.some(card => card && isCardPlayable(card));
	  const readyForNextTurn = !hasPlayableCards && !hasUsableBonuses;
	  newCardsButton.classList.toggle('ready-for-next-turn', readyForNextTurn);
	  
	  if (readyForNextTurn) {
		newCardsButton.disabled = false;
		return;
	  }

	  const shouldDisable = hasPlayableCards || hasUsableBonuses;
	  newCardsButton.disabled = shouldDisable;
	}

	function drawNextHand() {
	  if (drawPile.length === 0) {
		updateDrawButtonState();
		return;
	  }
	  cardPlacementHistory = [];
	  cardsPlayedThisTurn = 0;
	resetTurnCardFlags();
	  
	  const createUpgradeCopy = (sourceCard, originTag) => {
		if (!sourceCard) return null;
		const color = cloneColor(sourceCard.color);
		return {
			id: nextCardInstanceId(),
			blueprintId: sourceCard.blueprintId,
			shapeName: sourceCard.shapeName,
			matrix: cloneShape(sourceCard.matrix),
			category: sourceCard.category,
			color,
			isGolden: !!(sourceCard.isGolden || sourceCard.color?.isGolden),
			generatedByUpgrade: originTag || null
		};
	  };

	  const BASE_HAND_DRAW = 3;
	  const drawCount = Math.min(BASE_HAND_DRAW, drawPile.length);
	  const newHand = [];
	  for (let i = 0; i < drawCount; i++) {
		newHand.push(drawPile.shift());
	  }

	  // extraHandSize: maak een kopie van een random kaart uit het deck (blijft in deck)
	  if (hasUpgrade('extraHandSize') && drawPile.length > 0) {
		const copyIndex = Math.floor(Math.random() * drawPile.length);
		const copySource = drawPile[copyIndex];
		const extraCopy = createUpgradeCopy(copySource, 'extraHandSize');
		if (extraCopy) {
			extraCopy.isDeckCopy = true; // Markeer als kopie
			newHand.push(extraCopy);
		}
	  }

	  if (hasUpgrade('luckyDraw') && drawPile.length > 0 && Math.random() < LUCKY_DRAW_COPY_CHANCE) {
		const luckyIndex = Math.floor(Math.random() * drawPile.length);
		const luckySource = drawPile[luckyIndex];
		const luckyCopy = createUpgradeCopy(luckySource, 'luckyDraw');
		if (luckyCopy) {
			luckyCopy.isLuckyCopy = true;
			newHand.push(luckyCopy);
		}
	  }
	  currentHand = newHand;
	  turnCount += 1;
	  updateTurnCounterDisplay();
	  renderCurrentHand();
	}

	function consumeCard(cardId) {
	  if (!cardId) return null;
	  const idx = currentHand.findIndex(card => card.id === cardId);
	  if (idx === -1) return null;
	  const [played] = currentHand.splice(idx, 1);
	  // Kopie-kaarten (van extraHandSize of luckyDraw) gaan niet naar discard pile
	  if (!played.isDeckCopy && !played.isLuckyCopy) {
		discardPile.push(played);
	  }
	  selectedCardId = null;
	  selectedCardElement = null;
	  selectedShape = null;
	  selectedColor = null;
	  if (rotateButton) rotateButton.disabled = true;
	  // Don't call renderCurrentHand here - let finalizeCardPlacement do it after updating state
	  return {
		playedCard: played,
		handIndex: idx
	  };
	}

	function discardCurrentHand() {
	  if (currentHand.length === 0) return;
	  // Filter kopie-kaarten uit voordat ze naar discard gaan
	  currentHand.forEach(card => {
		if (!card.isDeckCopy && !card.isLuckyCopy) {
			discardPile.push(card);
		}
	  });
	  currentHand = [];
	  cardPlacementHistory = [];
	cardsPlayedThisTurn = 0;
	resetTurnCardFlags();
	  selectedCardId = null;
	  selectedCardElement = null;
	  selectedShape = null;
	  selectedColor = null;
	  if (rotateButton) rotateButton.disabled = true;
	applyTurnCardLocks();
	}

	function finalizeCardPlacement(placementResult, coinSnapshotBefore) {
	  if (!selectedCardId || !placementResult) return;
	  const consumed = consumeCard(selectedCardId);
	  if (!consumed) return;
	cardsPlayedThisTurn += 1;
	const { playedCard, handIndex } = consumed;
	const actionId = ++actionSequence;
	const cardSnapshot = {
		id: playedCard.id,
		blueprintId: playedCard.blueprintId,
		shapeName: playedCard.shapeName,
		matrix: cloneShape(playedCard.matrix),
		category: playedCard.category,
		color: cloneColor(playedCard.color)
	  };
	const wasGolden = !!(playedCard.isGolden || playedCard.color?.isGolden || cardSnapshot.color?.isGolden);
	if (wasGolden) goldenCardPlayedThisTurn = true;
	else nonGoldenCardPlayedThisTurn = true;
	const coinSnapshot = (coinSnapshotBefore || []).map(state => ({ active: state.active, used: state.used }));
	cardPlacementHistory.push({
		cardRef: playedCard,
		cardState: cardSnapshot,
		handIndex,
		cells: (placementResult.cells || []).filter(Boolean),
		zoneId: placementResult.zoneId,
		coinSnapshotBefore: coinSnapshot,
		bonuses: Array.isArray(placementResult.bonuses) ? placementResult.bonuses.slice() : [],
		turn: turnCount,
		sequence: actionId,
		wasGolden
	});
	// Golden cards are always extra; do not set per-turn locks.
	  // Rebuild the hand after removing the card so availability + button states refresh correctly
	  renderCurrentHand();
	  applyTurnCardLocks();
	}

	function clearBoardPreserveCoins() {
	  const coinSnapshot = getCoinStateSnapshot();
	  document.querySelectorAll('.cell.active').forEach(cell => cell.classList.remove('active'));
	  document.querySelectorAll('.cell.preview-allowed, .cell.preview-denied').forEach(cell => {
		cell.classList.remove('preview-allowed', 'preview-denied');
		cell.style.removeProperty('background');
	  });
	  historyStack.length = 0;
	  resetScoreState();
	  updateScore();
	  if (activeZoomZone) schedulePlaceholderSync(activeZoomZone);
	  restoreCoinState(coinSnapshot);
	}

	const roundModalLayer = document.getElementById('game-modal-layer');
	const roundModalSummary = document.getElementById('round-modal-summary');
	const roundModalTitle = document.getElementById('round-modal-title');
	const roundModalMessage = document.getElementById('round-modal-message');
	const roundModalNext = document.getElementById('round-modal-next');
	const roundModalRestart = document.getElementById('round-modal-restart');
	const shopModalLayer = document.getElementById('shop-modal-layer');
	const shopModalMessage = document.getElementById('shop-modal-message');
	const shopCardOptions = document.getElementById('shop-card-options');
	const shopUpgradeContainer = document.getElementById('shop-upgrade-container');
	const shopBonusContainer = document.getElementById('shop-bonus-container');
	const shopModalSkip = document.getElementById('shop-modal-skip');
	const upgradeModalLayer = document.getElementById('upgrade-modal-layer');
	const upgradeModalClose = document.getElementById('upgrade-modal-close');
	const confirmCompleteLayer = document.getElementById('confirm-complete-layer');
	const confirmCompleteYes = document.getElementById('confirm-complete-yes');
	const confirmCompleteNo = document.getElementById('confirm-complete-no');
	const confirmCompleteDetails = document.getElementById('confirm-complete-details');
	let pendingRoundCompletion = null;

	function getCandidateZonesForColor(colorName) {
		if (!colorName) return [];
		const zones = Array.from(document.querySelectorAll('.zone')).filter(zone => zone.querySelector('.cell') && !zone.classList.contains('red-group'));
		return zones.filter(zone => {
			const zoneColor = zone.dataset.color || (zone.id && zone.id.startsWith('red-grid') ? 'rood' : null);
			if (!zoneColor) return false;
			if (colorName === 'multikleur') return true;
			if (colorName === 'rood') return zoneColor === 'rood';
			return zoneColor === colorName;
		});
	}

	function getUniqueRotations(shape) {
		const rotations = [];
		const seen = new Set();
		let current = cloneShape(shape);
		for (let i = 0; i < 4; i += 1) {
			const key = JSON.stringify(current);
			if (!seen.has(key)) {
				rotations.push(current.map(row => row.slice()));
				seen.add(key);
			}
			current = rotateShape(current);
		}
		return rotations;
	}

	function cardHasPlayablePlacement(card) {
		if (!card || !Array.isArray(card.matrix) || !card.matrix.length) return false;
		const colorName = card.color?.name || null;
		// Golden is a card modifier (frame-only), not a wildcard for placement.
		const zones = getCandidateZonesForColor(colorName);
		if (!zones.length) return false;
		const rotations = getUniqueRotations(card.matrix);
		for (const zone of zones) {
			const metrics = getZoneMetrics(zone);
			if (!metrics || metrics.maxX < metrics.minX || metrics.maxY < metrics.minY) continue;
			for (const shape of rotations) {
				const shapeHeight = shape.length;
				const shapeWidth = shape[0].length;
				const maxStartX = metrics.maxX - shapeWidth + 1;
				const maxStartY = metrics.maxY - shapeHeight + 1;
				if (maxStartX < metrics.minX || maxStartY < metrics.minY) continue;
				for (let baseX = metrics.minX; baseX <= maxStartX; baseX += 1) {
					for (let baseY = metrics.minY; baseY <= maxStartY; baseY += 1) {
						let adjustedX = baseX;
						let adjustedY = baseY;
						if (zone.id === 'yellow-zone') {
							const placement = getYellowPlacement(zone, baseX, baseY, shape, metrics);
							adjustedX = placement.baseX;
							adjustedY = placement.baseY;
						} else if (zone.id === 'blue-zone') {
							adjustedY = getStickyBaseY(zone, baseX, baseY, shape);
						}
						if (canPlace(zone, adjustedX, adjustedY, shape)) {
							return true;
						}
					}
				}
			}
		}
		return false;
	}

	function isCardAllowedByTurnRules(card) {
		// Turn rule: you may place at most 1 normal card per turn.
		// Golden cards are exempt.
		if (!card) return false;
		const isGolden = !!(card.isGolden || card.color?.isGolden);
		if (isGolden) return true;
		return !nonGoldenCardPlayedThisTurn;
	}

	function isCardPlayable(card) {
		if (!card) return false;
		return isCardAllowedByTurnRules(card) && cardHasPlayablePlacement(card);
	}

	function getRemainingBonusCharges() {
		let total = BONUS_ORDER.reduce((sum, key) => sum + (bonusInventory[key] || 0), 0);
		// Include free placements ("Gratis")
		total += Math.max(0, Number(freePlacementsRemaining) || 0);
		// Include purchased placement (single pending purchased block)
		if (window.hasPurchasedPlacement) total += 1;
		return total;
	}

	function getCompletionWarningState() {
		const cards = currentHand.filter(Boolean);
		let playableCards = 0;
		cards.forEach(card => {
			if (isCardPlayable(card)) playableCards += 1;
		});
		const remainingBonuses = getRemainingBonusCharges();
		const hasActiveSelection = !!activeBonusPlacement || !!draggedBlock;
		return { playableCards, totalCards: cards.length, remainingBonuses, hasActiveSelection };
	}

	function buildCompletionWarningDetails(state = getCompletionWarningState()) {
		const parts = [];
		// Alleen waarschuwen voor speelbare kaarten
		if (state.playableCards > 0) {
			const cardLabel = state.playableCards === 1 ? 'speelbare kaart' : 'speelbare kaarten';
			parts.push(`${state.playableCards} ${cardLabel}`);
		}
		if (state.remainingBonuses > 0) {
			const bonusLabel = state.remainingBonuses === 1 ? 'bonus' : 'bonussen';
			parts.push(`${state.remainingBonuses} ${bonusLabel}`);
		}
		if (state.hasActiveSelection && parts.length === 0) {
			parts.push('een bonus of kaart die je net hebt geselecteerd');
		}
		if (parts.length === 0) return '';
		if (parts.length === 1) return `Je hebt nog ${parts[0]}.`;
		return `Je hebt nog ${parts[0]} en ${parts[1]}.`;
	}

	function hideCompleteRoundConfirm() {
		if (confirmCompleteLayer) confirmCompleteLayer.classList.remove('show');
		if (confirmCompleteDetails) {
			confirmCompleteDetails.textContent = '';
			confirmCompleteDetails.style.display = '';
		}
		pendingRoundCompletion = null;
	}

	function showDiscardHandConfirm(callback) {
		// Hergebruik de complete round confirm modal voor discard hand waarschuwing
		pendingRoundCompletion = callback;
		if (!confirmCompleteLayer) {
			if (typeof callback === 'function') callback();
			pendingRoundCompletion = null;
			return;
		}
		if (confirmCompleteDetails) {
			// ONLY warn about playable cards when moving to the next hand.
			// Bonuses should not block/warn here; they matter when ending the round.
			const playableCount = currentHand.filter(card => card && isCardPlayable(card)).length;
			if (playableCount > 0) {
				const cardLabel = playableCount === 1 ? 'speelbare kaart' : 'speelbare kaarten';
				confirmCompleteDetails.textContent = `Je hebt nog ${playableCount} ${cardLabel} die je zou kunnen plaatsen. Weet je zeker dat je naar de volgende hand wilt gaan?`;
			} else {
				confirmCompleteDetails.textContent = 'Weet je zeker dat je naar de volgende hand wilt gaan?';
			}
			confirmCompleteDetails.style.display = '';
		}
		confirmCompleteLayer.classList.add('show');
		if (confirmCompleteYes) confirmCompleteYes.focus();
	}

	function showCompleteRoundConfirm(callback) {
		pendingRoundCompletion = callback;
		if (!confirmCompleteLayer) {
			if (typeof callback === 'function') callback();
			pendingRoundCompletion = null;
			return;
		}
		if (confirmCompleteDetails) {
			const state = getCompletionWarningState();
			const detailText = buildCompletionWarningDetails(state);
			confirmCompleteDetails.textContent = detailText;
			confirmCompleteDetails.style.display = detailText ? '' : 'none';
		}
		confirmCompleteLayer.classList.add('show');
		if (confirmCompleteYes) confirmCompleteYes.focus();
	}

	function shouldWarnBeforeCompletingRound() {
		const { playableCards, remainingBonuses, hasActiveSelection } = getCompletionWarningState();
		return playableCards > 0 || remainingBonuses > 0 || hasActiveSelection;
	}

	function hideAllModals() {
		hideCompleteRoundConfirm();
		[roundModalLayer, shopModalLayer, upgradeModalLayer].forEach(layer => {
			if (layer) layer.classList.remove('show');
		});
	}

	function showRoundModal(success, score, coins, bonusCoins = 0) {
		if (!roundModalLayer) return;
	lastRoundWasSuccess = success;
	// Prefer a loaded custom objective when present
	const loadedCustom = (window && window.loadedCustomObjectiveCompiled) ? window.loadedCustomObjectiveCompiled : null;
	const activeObjective = loadedCustom || getObjectiveById(currentObjectiveId) || getObjectiveForLevel(currentLevel);
	const objectiveLabel = activeObjective ? (activeObjective.short || activeObjective.description) : null;
	// Compute cleared state: custom objective exposes .check(scores), otherwise use existing completed set
	let objectiveCleared = true;
	if (loadedCustom) {
		try { objectiveCleared = !!loadedCustom.check(); } catch (e) { objectiveCleared = false; }
	} else {
		objectiveCleared = activeObjective ? isObjectiveCompleted(activeObjective.id) : true;
	}
	if (roundModalTitle) {
		if (loadedCustom && window.loadedCustomLevelMeta && window.loadedCustomLevelMeta.name) {
			roundModalTitle.textContent = (success ? 'Ronde voltooid' : 'Game Over') + ' â€” ' + window.loadedCustomLevelMeta.name;
		} else {
			roundModalTitle.textContent = success ? 'Ronde voltooid' : 'Game Over';
		}
	}
	  if (success) {
		if (objectiveLabel) {
			roundModalMessage.textContent = `Doel behaald: ${objectiveLabel}. Kies wat je nu wilt doen.`;
		} else {
			roundModalMessage.textContent = 'Je hebt het level gehaald! Maak je keuze hieronder.';
		}
	  } else {
		switch (lastRoundFailureReason) {
			case 'objective':
				roundModalMessage.textContent = objectiveLabel ? `Doel nog niet gehaald: ${objectiveLabel}.` : 'Er is nog een leveldoel dat niet gehaald is.';
				break;
			default:
				roundModalMessage.textContent = 'Niet gehaald... Je deck wordt teruggezet naar de standaard set.';
				break;
		}
	  }
		if (roundModalSummary) {
		let summaryHTML = buildCardSummaryHTML(score, coins, bonusCoins);
		if (activeObjective) {
			const statusLabel = objectiveCleared ? 'Voltooid' : 'Niet voltooid';
			const objDesc = (loadedCustom && loadedCustom.description) ? loadedCustom.description : (activeObjective.short || activeObjective.description);
			summaryHTML += `<div class="modal-summary-line"><strong>Doel</strong><span>${objDesc} - ${statusLabel}</span></div>`;
		}
		roundModalSummary.innerHTML = summaryHTML;
	}
	  if (roundModalNext) {
		roundModalNext.textContent = success ? `Naar level ${currentLevel + 1}` : 'Opnieuw proberen';
		roundModalNext.disabled = false;
	  }
	  if (roundModalRestart) {
		roundModalRestart.textContent = success ? 'Nieuwe run' : 'Reset deck';
	  }
	  roundModalLayer.classList.add('show');
	}

	function updateShopUpgradeUI() {
		if (!shopUpgradeContainer) return;
		shopUpgradeContainer.innerHTML = '';
		shopUpgradeContainer.style.display = '';
		const upgradesSection = shopUpgradeContainer.closest('.shop-upgrades-section');
		
		const coins = getSpendableCoinCount();
		// Filter voor alleen unlocked en niet-gekochte upgrades
		const availableUpgrades = Object.entries(UPGRADES).filter(([id, upgrade]) => {
			return !upgrade.purchased && UNLOCK_PROGRESSION.isUpgradeUnlocked(id, currentLevel, currentWorld);
		});
		
		if (availableUpgrades.length === 0) {
			if (upgradesSection) upgradesSection.classList.add('shop-section--empty');
			const emptyState = document.createElement('p');
			emptyState.classList.add('shop-empty-state');
			emptyState.textContent = 'Geen upgrades beschikbaar. Speel meer levels om nieuwe upgrades te ontgrendelen!';
			shopUpgradeContainer.appendChild(emptyState);
			return;
		}
		
		if (upgradesSection) upgradesSection.classList.remove('shop-section--empty');
		
		availableUpgrades.forEach(([upgradeId, upgrade]) => {
			const upgradeCard = document.createElement('div');
			upgradeCard.classList.add('shop-upgrade-card');
			const effectiveCost = getEffectiveUpgradeCost(upgradeId);
			
			const upgradeHeader = document.createElement('div');
			upgradeHeader.classList.add('shop-upgrade-header');
			upgradeHeader.innerHTML = `<span class="upgrade-icon">${upgrade.icon}</span><span class="upgrade-name">${upgrade.name}</span>`;
			
			const upgradeDesc = document.createElement('p');
			upgradeDesc.classList.add('shop-upgrade-desc');
			upgradeDesc.textContent = upgrade.description;
			
			const upgradeActions = document.createElement('div');
			upgradeActions.classList.add('shop-upgrade-actions');
			
			const buyBtn = document.createElement('button');
			// In debug mode: gratis, anders toon kosten
			if (debugMode) {
				buyBtn.textContent = `Kopen (gratis)`;
				buyBtn.disabled = false;
				buyBtn.title = `Koop ${upgrade.name} (debug mode - gratis)`;
			} else {
				buyBtn.innerHTML = `Kopen (${effectiveCost} ${coinIcon()})`;
				buyBtn.disabled = coins < effectiveCost;
				buyBtn.title = coins < effectiveCost ? 'Onvoldoende munten' : `Koop ${upgrade.name}`;
			}
			buyBtn.addEventListener('click', () => purchaseUpgrade(upgradeId));
			
			upgradeActions.appendChild(buyBtn);
			upgradeCard.append(upgradeHeader, upgradeDesc, upgradeActions);
			shopUpgradeContainer.appendChild(upgradeCard);
		});
	}

function refreshShopCardButtons() {
	if (!shopCardOptions) return;
	const coins = getSpendableCoinCount();
	shopCardOptions.querySelectorAll('.shop-card').forEach(card => {
		const cost = Number(card.dataset.cardCost);
		const btn = card.querySelector('.shop-card-actions button');
		if (!btn || !Number.isFinite(cost)) return;
		btn.disabled = coins < cost;
		btn.title = coins < cost ? 'Onvoldoende munten' : 'Voeg deze kaart toe aan je deck';
	});
}

function updateShopBonusUI() {
	if (!shopBonusContainer) return;
	shopBonusContainer.innerHTML = '';
	const coins = getSpendableCoinCount();
	let populated = false;
	const bonusSection = shopBonusContainer.closest('.shop-bonus-section');
	BONUS_ORDER.forEach(colorKey => {
		const meta = getBonusMeta(colorKey);
		if (!meta) return;
		const upgradeCost = BONUS_UPGRADE_COSTS[colorKey] ?? 6;
		const upgradeOwned = isBonusUpgraded(colorKey);
		const card = document.createElement('div');
		card.classList.add('shop-bonus-card');
		const info = document.createElement('div');
		info.classList.add('shop-bonus-info');
		const swatch = document.createElement('span');
		swatch.classList.add('shop-bonus-swatch');
		swatch.style.background = meta.colorCode;
		const label = document.createElement('span');
		label.textContent = meta.label;
		info.append(swatch, label);
		const actions = document.createElement('div');
		actions.classList.add('shop-bonus-actions');
		if (!upgradeOwned) {
			const upgradeBtn = document.createElement('button');
			upgradeBtn.type = 'button';
			upgradeBtn.classList.add('shop-bonus-upgrade-btn');
			upgradeBtn.innerHTML = debugMode ? `Upgrade (gratis)` : `Upgrade (${upgradeCost} ${coinIcon()})`;
			upgradeBtn.disabled = debugMode ? false : coins < upgradeCost;
			upgradeBtn.title = coins < upgradeCost ? 'Onvoldoende munten' : `Upgrade de ${meta.label.toLowerCase()} bonus permanent`;
			upgradeBtn.addEventListener('click', () => purchaseBonusUpgrade(colorKey));
			actions.appendChild(upgradeBtn);
		} else {
			const status = document.createElement('span');
			status.classList.add('shop-bonus-status');
			status.textContent = 'GeÃ¼pgraded';
			actions.appendChild(status);
		}
		card.append(info, actions);
		shopBonusContainer.appendChild(card);
		populated = true;
	});
	if (!populated) {
		const empty = document.createElement('div');
		empty.classList.add('shop-bonus-card');
		empty.textContent = 'Geen bonussen beschikbaar.';
		empty.style.justifyContent = 'center';
		empty.style.fontWeight = '600';
		shopBonusContainer.appendChild(empty);
	}
	if (bonusSection) {
		bonusSection.classList.toggle('shop-section--empty', !populated);
	}
}
	
function updateShopFreePlaceUI() {
	const freePlaceContainer = document.getElementById('shop-freeplace-container');
	if (!freePlaceContainer) return;
	freePlaceContainer.innerHTML = '';
	
	const coins = getSpendableCoinCount();
	const freePlaceCost = 2;
	
	const card = document.createElement('div');
	card.classList.add('shop-bonus-card');
	card.style.padding = '16px';
	
	const info = document.createElement('div');
	info.style.display = 'flex';
	info.style.flexDirection = 'column';
	info.style.gap = '8px';
	
	const label = document.createElement('span');
	label.innerHTML = `+1 gratis blokplaatsing (${freePlaceCost} ${coinIcon()})`;
	label.style.fontWeight = '600';
	label.style.fontSize = '0.95rem';
	
	const description = document.createElement('span');
	description.textContent = 'Plaats een extra 1x1 blok op elke kleur deze ronde';
	description.style.fontSize = '0.8rem';
	description.style.opacity = '0.7';
	
	if (freePlacementsRemaining > 0) {
		const status = document.createElement('span');
		status.textContent = `âœ“ Je hebt ${freePlacementsRemaining} gratis plaatsing${freePlacementsRemaining === 1 ? '' : 'en'}`;
		status.style.color = '#4CAF50';
		status.style.fontSize = '0.85rem';
		status.style.fontWeight = '600';
		info.append(label, description, status);
	} else {
		info.append(label, description);
	}
	
	const buyBtn = document.createElement('button');
	buyBtn.type = 'button';
	buyBtn.classList.add('shop-bonus-upgrade-btn');
	buyBtn.textContent = `Koop (+1 plaatsing)`;
	buyBtn.disabled = coins < freePlaceCost;
	buyBtn.title = coins < freePlaceCost ? 'Onvoldoende munten' : 'Koop een extra gratis plaatsing';
	buyBtn.addEventListener('click', () => purchaseFreePlacement(freePlaceCost));
	
	card.appendChild(info);
	card.appendChild(buyBtn);
	freePlaceContainer.appendChild(card);
}

function purchaseFreePlacement(cost) {
	const coinsAvailable = getSpendableCoinCount();
	if (coinsAvailable < cost) {
		if (shopModalMessage) shopModalMessage.textContent = 'Onvoldoende munten voor deze aankoop.';
		return;
	}
	if (!spendCoins(cost)) {
		if (shopModalMessage) shopModalMessage.textContent = 'Munten konden niet worden afgeschreven.';
		return;
	}
	
	freePlacementsRemaining += 1;
	updateShopFreePlaceUI();
	updateShopCoinDisplay();
	showObjectiveToast(`ðŸŽ +1 gratis plaatsing gekocht! (${freePlacementsRemaining} totaal)`);
}

function purchaseBonusUpgrade(colorKey) {
		const meta = getBonusMeta(colorKey);
		if (!meta || isBonusUpgraded(colorKey)) return;
		const cost = BONUS_UPGRADE_COSTS[colorKey] ?? 6;
		
		// In debugMode zijn bonus upgrades gratis
		if (!debugMode) {
			const coinsAvailable = getSpendableCoinCount();
			if (coinsAvailable < cost) {
				if (shopModalMessage) shopModalMessage.textContent = 'Onvoldoende munten voor deze upgrade.';
				return;
			}
			if (!spendCoins(cost)) {
				if (shopModalMessage) shopModalMessage.textContent = 'Munten konden niet worden afgeschreven.';
				return;
			}
		}
		
		setBonusUpgraded(colorKey, true);
		updateBonusInventoryUI();
		if (shopModalMessage) shopModalMessage.textContent = `${meta.label} bonus geÃ¼pgraded!`;
		showObjectiveToast(`ðŸŒŸ ${meta.label} bonus verbeterd!`);
		updateShopUpgradeUI();
		updateShopBonusUI();
		refreshShopCardButtons();
	}

function purchaseUpgrade(upgradeId) {
		const upgrade = UPGRADES[upgradeId];
		if (!upgrade || upgrade.purchased) return;
		const effectiveCost = getEffectiveUpgradeCost(upgradeId);
		
		// In debugMode zijn alle upgrades gratis
		if (!debugMode) {
			const coins = getSpendableCoinCount();
			if (coins < effectiveCost) {
				if (shopModalMessage) shopModalMessage.textContent = 'Je hebt niet genoeg munten voor deze upgrade.';
				return;
			}
			
			if (!spendCoins(effectiveCost)) {
				if (shopModalMessage) shopModalMessage.textContent = 'Munten konden niet worden afgeschreven.';
				return;
			}
		}
		
	upgrade.purchased = true;
	
	if (upgrade.onPurchase) {
		upgrade.onPurchase();
	}
	
	if (shopModalMessage) {
		shopModalMessage.textContent = `${upgrade.icon} ${upgrade.name} aangekocht!`;
	}
	updateShopUpgradeUI();
	updateShopBonusUI();
	refreshShopCardButtons();
	showObjectiveToast(`${upgrade.icon} ${upgrade.name} ontgrendeld!`);
}

function openShopModal(callback) {
	  console.log('ðŸ›’ openShopModal called with callback:', typeof callback);
	  pendingShopCallback = callback;
	  if (!shopModalLayer || getSpendableCoinCount() === 0) {
		console.log('ðŸ›’ No shop (no coins or no modal), calling callback immediately');
		if (typeof pendingShopCallback === 'function') pendingShopCallback();
		pendingShopCallback = null;
		return;
	  }
	  if (shopCardOptions) {
		shopCardOptions.innerHTML = '';
		const largeShopUnlocked = (UNLOCK_PROGRESSION && typeof UNLOCK_PROGRESSION.isCategoryUnlocked === 'function')
			? UNLOCK_PROGRESSION.isCategoryUnlocked('large', currentLevel)
			: (currentLevel >= 3);
		
		// SHOP: max 3 kaart-opties.
		// Grotere blokken (large/xl/xxl) vervangen soms een kleinere optie i.p.v. extra bij te komen.
		// Altijd 1 "random" (mystery) kaart + 2 andere aanbiedingen.
		const offers = [];

		// Helper: pick N unieke entries.
		function pickUnique(list, count) {
			const pool = list.slice();
			const out = [];
			while (pool.length && out.length < count) {
				const idx = Math.floor(Math.random() * pool.length);
				out.push(pool.splice(idx, 1)[0]);
			}
			return out;
		}

		// Build tier factories (deterministic cost per tier).
		const tierFactories = {
			mini: () => {
				const miniChoices = (CARD_BLUEPRINTS && Array.isArray(CARD_BLUEPRINTS.mini)) ? CARD_BLUEPRINTS.mini : [];
				const miniPick = miniChoices.length
					? miniChoices[Math.floor(Math.random() * miniChoices.length)]
					: { name: 'Domino verticaal', matrix: [[1],[1]] };
				const entry = { name: miniPick.name, matrix: cloneShape(miniPick.matrix), category: 'mini' };
				return { option: createShopCard(entry), cost: 2, fixed: true };
			},
			standard: () => {
				const standardChoices = (CARD_BLUEPRINTS && Array.isArray(CARD_BLUEPRINTS.standard)) ? CARD_BLUEPRINTS.standard : [];
				const standardPick = standardChoices.length
					? standardChoices[Math.floor(Math.random() * standardChoices.length)]
					: { name: 'O', matrix: [[1,1],[1,1]] };
				const entry = { name: standardPick.name, matrix: cloneShape(standardPick.matrix), category: 'standard' };
				return { option: createShopCard(entry), cost: 4, fixed: true };
			},
			large: () => {
				const largeBlueprints = (CARD_BLUEPRINTS && Array.isArray(CARD_BLUEPRINTS.large)) ? CARD_BLUEPRINTS.large : [];
				const fiveBlockPool = largeBlueprints
					.filter(entry => entry && entry.matrix)
					.map(entry => ({ name: entry.name, matrix: entry.matrix, blocks: countShapeBlocks(entry.matrix) }))
					.filter(entry => entry.blocks === 5);
				const pickedLarge = fiveBlockPool.length
					? fiveBlockPool[Math.floor(Math.random() * fiveBlockPool.length)]
					: { name: 'Plus', matrix: [[0,1,0],[1,1,1],[0,1,0]] };
				const entry = { name: pickedLarge.name, matrix: cloneShape(pickedLarge.matrix), category: 'large' };
				return { option: createShopCard(entry), cost: 6, fixed: true };
			},
			xl: () => {
				const xlPick = XL_6_SHAPES[Math.floor(Math.random() * XL_6_SHAPES.length)];
				const entry = { name: xlPick.name, matrix: cloneShape(xlPick.matrix), category: 'large' };
				return { option: createShopCard(entry), cost: 8, fixed: true };
			},
			xxl: () => {
				const xxlPick = EXTRA_LARGE_7_SHAPES[Math.floor(Math.random() * EXTRA_LARGE_7_SHAPES.length)];
				const entry = { name: xxlPick.name, matrix: cloneShape(xxlPick.matrix), category: 'large' };
				return { option: createShopCard(entry), cost: 10, fixed: true };
			}
		};

		// Which size tiers are available right now?
		const availableSizeKeys = ['mini', 'standard'];
		if (largeShopUnlocked) availableSizeKeys.push('large');
		if (hasUpgrade('xlBlocks') && Array.isArray(XL_6_SHAPES) && XL_6_SHAPES.length) availableSizeKeys.push('xl');
		if (hasUpgrade('extraLargeBlocks') && Array.isArray(EXTRA_LARGE_7_SHAPES) && EXTRA_LARGE_7_SHAPES.length) availableSizeKeys.push('xxl');

		// Specials are allowed but should not explode the amount of options.
		const availableSpecialFactories = [];
		if (hasUpgrade('goldenCards')) {
			availableSpecialFactories.push(() => {
				const goldenCard = createGoldenShopCard();
				goldenCard.isGoldenShopCard = true;
				return { option: goldenCard, cost: calculateCardCost(goldenCard), fixed: false };
			});
		}
		if (hasUpgrade('betterCards')) {
			availableSpecialFactories.push(() => {
				const premiumCard = createPremiumShopCard();
				premiumCard.isPremiumShopCard = true;
				return { option: premiumCard, cost: calculateCardCost(premiumCard), fixed: false };
			});
		}

		// Choose 2 offers (at least 1 size tier). Early game stays mini+standard.
		let picked = [];
		if (!largeShopUnlocked && availableSpecialFactories.length === 0) {
			picked = ['mini', 'standard'];
		} else {
			const firstSize = pickUnique(availableSizeKeys, 1)[0] || 'standard';
			picked.push(firstSize);
			// Second slot: either another size, or sometimes a special.
			const allowSpecial = availableSpecialFactories.length > 0 && Math.random() < 0.35;
			if (allowSpecial) {
				const specialFactory = pickUnique(availableSpecialFactories, 1)[0];
				if (specialFactory) {
					offers.push(specialFactory());
				}
			} else {
				const remainingSizes = availableSizeKeys.filter(k => k !== firstSize);
				picked.push(pickUnique(remainingSizes, 1)[0] || firstSize);
			}
		}

		// Add size tier offers.
		picked.forEach(key => {
			const factory = tierFactories[key];
			if (!factory) return;
			offers.push(factory());
		});

		// Always add the random (mystery) card as the 3rd option.
		const randomCard = createShopCard(null, true);
		randomCard.isRandomShopCard = true;
		offers.push({ option: randomCard, cost: 6, fixed: false, isRandom: true });

		// Defensive: ensure max 3.
		const finalOffers = offers.slice(0, 3);
		const coins = getSpendableCoinCount();
		finalOffers.forEach((offer, index) => {
		  const option = offer.option;
		  const cost = offer.cost;
		  const isRandom = !!offer.isRandom;
		  const isFixed = !!offer.fixed;
		  
		  const wrapper = document.createElement('div');
		  wrapper.classList.add('shop-card');
		  wrapper.dataset.cardCost = String(cost);
		  if (isRandom) wrapper.classList.add('shop-card-random');
		  if (isFixed) wrapper.classList.add('shop-card-fixed');

		  const header = document.createElement('div');
		  header.classList.add('shop-card-header');
		  
		  // Voor random kaarten geen titel tonen om geheim te houden.
		  // Voor niet-random: verberg de tetris-bloknaam (alleen kleur badge tonen).
		  if (!isRandom) {
			const colorBadge = document.createElement('span');
			colorBadge.classList.add('card-meta');
			const isGoldenCard = !!(option?.isGolden || option?.color?.isGolden);
			colorBadge.textContent = isGoldenCard ? 'GOUDEN' : option.color.name.toUpperCase();
			header.append(colorBadge);
		  }

		  const price = document.createElement('div');
		  price.classList.add('shop-card-price');
		  if (isRandom) {
			price.innerHTML = `âœ¨ Random: ${cost} ${coinIcon()}`;
		  } else {
			price.innerHTML = `Kosten: ${cost} ${coinIcon()}`;
		  }

		  const preview = document.createElement('div');
		  preview.classList.add('shop-card-preview');
		  
		  // Mystery card voor random slot
		  if (isRandom) {
			const mysteryContainer = document.createElement('div');
			mysteryContainer.classList.add('mystery-card-container');
			
			const mysteryInner = document.createElement('div');
			mysteryInner.classList.add('mystery-card-inner');
			mysteryInner.dataset.cardIndex = String(index);
			
			const mysteryFront = document.createElement('div');
			mysteryFront.classList.add('mystery-card-front');
			const questionMark = document.createElement('div');
			questionMark.classList.add('question-mark');
			questionMark.textContent = '?';
			mysteryFront.appendChild(questionMark);
			
			const mysteryBack = document.createElement('div');
			mysteryBack.classList.add('mystery-card-back');
			const previewCard = createCardElement(option, true, { onSelect: () => {} });
			previewCard.classList.add('shop-preview-card');
			previewCard.style.cursor = 'default';
			previewCard.style.pointerEvents = 'none';
			const { cardSize } = getCardSizing();
			const isMobileView = window.innerWidth <= MOBILE_BREAKPOINT;
			if (isMobileView) {
			  previewCard.style.width = '118px';
			  previewCard.style.minHeight = '178px';
			} else {
			  previewCard.style.width = `${cardSize}px`;
			  previewCard.style.minHeight = `${cardSize}px`;
			}
			mysteryBack.appendChild(previewCard);
			
			mysteryInner.append(mysteryFront, mysteryBack);
			mysteryContainer.appendChild(mysteryInner);
			preview.appendChild(mysteryContainer);
		  } else {
			// Normale kaart preview
			const previewCard = createCardElement(option, true, { onSelect: () => {} });
			previewCard.classList.add('shop-preview-card');
			previewCard.style.cursor = 'default';
			previewCard.style.pointerEvents = 'none';
			const { cardSize } = getCardSizing();
			const isMobileView = window.innerWidth <= MOBILE_BREAKPOINT;
			if (isMobileView) {
			  previewCard.style.width = '118px';
			  previewCard.style.minHeight = '178px';
			} else {
			  previewCard.style.width = `${cardSize}px`;
			  previewCard.style.minHeight = `${cardSize}px`;
			}
			preview.appendChild(previewCard);
		  }

		  const actions = document.createElement('div');
		  actions.classList.add('shop-card-actions');
		  const buyBtn = document.createElement('button');
		  buyBtn.textContent = 'Kopen';
		  buyBtn.disabled = coins < cost;
		  buyBtn.title = coins < cost ? 'Onvoldoende munten' : 'Voeg deze kaart toe aan je deck';
		  buyBtn.addEventListener('click', event => {
			 event.stopPropagation();
			 handleShopPurchase(option, cost, index);
		  });
		  actions.appendChild(buyBtn);

		  wrapper.append(header, price, preview, actions);
		  shopCardOptions.appendChild(wrapper);
		});
		applyCardSizing();
		refreshShopCardButtons();
	  }
	  if (shopModalMessage) {
		const coins = getSpendableCoinCount();
		const showUpgradesInMsg = currentLevel >= 5;
		
		let message = '';
		if (coins === 0) {
			message = 'Je hebt nog geen munten verzameld deze ronde.';
		} else if (showUpgradesInMsg) {
			message = `Je hebt ${coins} munt${coins === 1 ? '' : 'en'} om te besteden aan kaarten of upgrades.`;
		} else {
			message = `Je hebt ${coins} munt${coins === 1 ? '' : 'en'} om te besteden aan kaarten.`;
		}
		shopModalMessage.textContent = message;
	  }
	  updateShopCoinDisplay();
	  
	  // Toon/verberg upgrades en bonussen op basis van level
	  const showUpgrades = currentLevel >= 5; // Upgrades altijd zichtbaar vanaf level 5
	  const upgradesSection = document.querySelector('.shop-upgrades-section');
	  const bonusSection = document.querySelector('.shop-bonus-section');
	  const freePlaceSection = document.querySelector('.shop-freeplace-section');
	  const lowerGrid = document.querySelector('.shop-lower-grid');
	  
	  // VERBERG bonus sectie in normale shop (alleen beschikbaar via bonus shop button)
	  if (bonusSection) {
		bonusSection.style.display = 'none';
	  }
	  
	  // VERBERG freeplace sectie - dit is nu beschikbaar via de knop bij de munten
	  if (freePlaceSection) {
		freePlaceSection.style.display = 'none';
	  }
	  
	  if (showUpgrades) {
		if (upgradesSection) upgradesSection.style.display = '';
		if (lowerGrid) lowerGrid.style.display = '';
		updateShopUpgradeUI();
	  } else {
		if (upgradesSection) upgradesSection.style.display = 'none';
		if (lowerGrid) lowerGrid.style.display = 'none';
	  }
	  
	  shopModalLayer.classList.add('show');
	}

	function handleShopPurchase(option, cost, cardIndex) {
	  if (!shopModalLayer) return;
	  const coinsAvailable = getSpendableCoinCount();
	  if (coinsAvailable < cost) {
		if (shopModalMessage) shopModalMessage.textContent = 'Onvoldoende munten voor deze kaart.';
		return;
	  }
	  if (!spendCoins(cost)) {
		if (shopModalMessage) shopModalMessage.textContent = 'Munten konden niet worden afgeschreven.';
		return;
	  }
	  
	  updateShopUpgradeUI();
	  updateShopBonusUI();
	  refreshShopCardButtons();
	  
	  // Check of dit een mystery/random card is
	  if (option && option.isRandomShopCard) {
		const mysteryInner = document.querySelector(`.mystery-card-inner[data-card-index="${cardIndex}"]`);
		if (mysteryInner) {
		  // Disable alle knoppen tijdens animatie
		  const allBuyButtons = shopCardOptions.querySelectorAll('button');
		  allBuyButtons.forEach(btn => btn.disabled = true);
		  
		  // Trigger flip animatie
		  mysteryInner.classList.add('flipped');
		  
		  // Wacht 1.5 seconden voordat we de kaart toevoegen
		  setTimeout(() => {
			ownedDeckBlueprints.push({
			  blueprintId: option.blueprintId,
			  shapeName: option.shapeName,
			  matrix: cloneShape(option.matrix),
			  category: option.category,
			  color: cloneColor(option.color)
			});
			
			// Shop blijft open - markeer mystery kaart als gekocht
			if (shopModalMessage) shopModalMessage.textContent = 'Mystery kaart gekocht! Koop meer of klik "Sla over".';
			const shopCards = shopCardOptions.querySelectorAll('.shop-card');
			if (shopCards[cardIndex]) {
			  shopCards[cardIndex].style.opacity = '0.5';
			  shopCards[cardIndex].style.pointerEvents = 'none';
			  const btn = shopCards[cardIndex].querySelector('button');
			  if (btn) {
				btn.disabled = true;
				btn.textContent = 'Gekocht!';
			  }
			}
			
			// Re-enable andere buttons
			const allBuyButtons = shopCardOptions.querySelectorAll('button');
			allBuyButtons.forEach(btn => {
			  if (!btn.closest('.shop-card').style.pointerEvents) {
				btn.disabled = false;
			  }
			});
			
			refreshShopCardButtons();
		  }, 1500);
		  return;
		}
	  }
	  
	  // Normale kaart aankoop
	  ownedDeckBlueprints.push({
		blueprintId: option.blueprintId,
		shapeName: option.shapeName,
		matrix: cloneShape(option.matrix),
		category: option.category,
		color: cloneColor(option.color)
	  });
	  
	  // Shop blijft open - verwijder de gekochte kaart en toon bericht
	  if (shopModalMessage) shopModalMessage.textContent = 'Kaart gekocht! Koop meer of klik "Sla over" om te sluiten.';
	  
	  // Verwijder de gekochte kaart visueel
	  const shopCards = shopCardOptions.querySelectorAll('.shop-card');
	  if (shopCards[cardIndex]) {
		shopCards[cardIndex].style.opacity = '0.5';
		shopCards[cardIndex].style.pointerEvents = 'none';
		const btn = shopCards[cardIndex].querySelector('button');
		if (btn) {
		  btn.disabled = true;
		  btn.textContent = 'Gekocht!';
		}
	  }
	  
	  // Update buttons maar sluit shop NIET
	  updateShopUpgradeUI();
	  updateShopBonusUI();
	  refreshShopCardButtons();
	}

	function skipShop() {
	  console.log('ðŸ›’ skipShop called, pendingShopCallback:', typeof pendingShopCallback);
	  
	  // Herstel normale shop layout
	  const shopModalTitle = document.getElementById('shop-modal-title');
	  const shopCardOptions = document.getElementById('shop-card-options');
	  const upgradesSection = document.querySelector('.shop-upgrades-section');
	  
	  if (shopModalTitle) shopModalTitle.textContent = 'Kaarten & Upgrades';
	  if (shopCardOptions) {
		const cardsSection = shopCardOptions.closest('.shop-cards-section');
		if (cardsSection) cardsSection.style.display = '';
	  }
	  if (upgradesSection) upgradesSection.style.display = '';
	  
	  if (shopModalLayer) shopModalLayer.classList.remove('show');
	  if (typeof pendingShopCallback === 'function') pendingShopCallback();
	  pendingShopCallback = null;
	}

	function rebuildGameBoards() {
	  closeZoom();
	  resetScoreState();
	  historyStack.length = 0;
	  
	  // Bepaal in welke world we zitten
	  const { world, subLevel } = getWorldAndSubLevel(currentLevel);
	  currentWorld = world;
	  document.body.classList.toggle('world-2', world === 2);
	  document.body.classList.toggle('world-1', world === 1);
	  document.body.classList.toggle('world-3', world === 3);
	  
	  // World 1: disable scrolling in green zone
	  const greenZone = document.getElementById('green-zone');
	  if (greenZone) {
		if (world === 1) {
		  greenZone.classList.add('no-scroll');
		} else {
		  greenZone.classList.remove('no-scroll');
		}
	  }
	  
	  if (world === 1) {
		rebuildGameBoards_World1();
	  } else if (world === 2) {
		rebuildGameBoards_World2();
	  } else if (world === 3) {
		rebuildGameBoards_World3();
	  } else {
		// Fallback naar World 3 voor toekomstige worlds
		rebuildGameBoards_World3();
	  }
	}

	// WORLD 1: Originele grid layout (levels 1-10)
	function rebuildGameBoards_World1() {
	  
	  const yellowColumnHeights = [6, 6, 8, 8, 10, 10, 12, 12, 14, 14];
	  const yellowCols = yellowColumnHeights.length;
	  const yellowRows = Math.max(...yellowColumnHeights);
	  const yellowRowPattern = [];
	  const yellowRowOffsets = [];
	  for (let r = 0; r < yellowRows; r++) {
		let activeCount = 0;
		for (let c = 0; c < yellowCols; c++) {
		  const topRow = yellowRows - yellowColumnHeights[c];
		  if (r >= topRow) activeCount++;
		}
		yellowRowPattern.push(activeCount);
		yellowRowOffsets.push(Math.max(0, yellowCols - activeCount));
	  }
	  // Punten per kolom: 8 voor eerste, dan 12, 16, 24, 32, 40... (exponentieel stijgend)
	  const yellowPointsArray = [8, 12, 16, 24, 32, 40, 48, 56, 64, 72];
	  const yellowColumnPoints = yellowColumnHeights.map((height, idx) => yellowPointsArray[idx] || (24 + (idx - 3) * 8));
	  
	  window.yellowGridConfig = {
		rows: yellowRows,
		cols: yellowCols,
		rowLengths: yellowRowPattern.slice(),
		rowOffsets: yellowRowOffsets.slice(),
		pointsByColumn: yellowColumnPoints.slice(),
		columnHeights: yellowColumnHeights.slice(),
		pointsByRow: [],
		pointsByWidth: {},
		pointsPerRow: 0,
		pointsPerColumn: 0
	  };
	  
	  const blueRowPattern = [2, 2, 3, 3, 3, 2, 2, 3, 3, 2, 2, 3, 3, 3, 2, 2, 3, 3, 2, 2, 3, 3, 2, 3, 3];
	  const blueRowOffsets = [1, 1, 1, 0, 0, 1, 2, 2, 2, 3, 2, 2, 1, 1, 1, 0, 0, 0, 1, 2, 2, 2, 3, 2, 1];
	  const blueRows = blueRowPattern.length;
	  const blueCols = Math.max(...blueRowOffsets.map((offset, idx) => offset + (blueRowPattern[idx] || 0)), 3);

	  // Alleen traps genereren vanaf level 5, met scaling naar level 10
	  const shouldGenerateTraps = currentLevel >= 5;
	  const hasBlackHoleUpgrade = hasUpgrade('blackHoleAccess');
	  // Trap chance schaalt van 0.05 (level 5) naar 0.09 (level 10+)
	  const baseTrapChance = shouldGenerateTraps ? (currentLevel >= 10 ? 0.09 : 0.05) : 0;
	  const trapChance = baseTrapChance;
	  const maxTraps = shouldGenerateTraps ? (currentLevel >= 10 ? 8 : 5) : 0;
	  const blackHoleChance = hasBlackHoleUpgrade ? BLACK_HOLE_DEFAULT_CHANCE : 0;
	  
	  // Als black hole upgrade is gekocht: maximaal 1 black hole per level
	  const blackHoleOnlyChance = hasBlackHoleUpgrade && !shouldGenerateTraps ? 0.10 : 0;
	  const blackHoleOnlyMaxTraps = hasBlackHoleUpgrade && !shouldGenerateTraps ? 1 : 0;

	  const boardConfigs = [
		() => createGrid('yellow-grid', yellowRows, yellowCols, { goldCells: true, symbols: true, minSymbols: 8, maxSymbols: 12, coinChance: 0.2, maxCoins: 15, rowLengths: yellowRowPattern, rowOffsets: yellowRowOffsets, boldColumns: [0], pointsPerColumn: yellowColumnPoints, trapChance: trapChance || blackHoleOnlyChance, maxTraps: maxTraps || blackHoleOnlyMaxTraps, blackHoleChance: hasBlackHoleUpgrade ? 1.0 : 0 }),
		() => createGrid('purple-grid', 9, 9, { symbols: true, goldCells: true, minSymbols: 6, maxSymbols: 8, coinChance: 0.03, maxCoins: 4, randomBoldCount: 8, avoidAdjacentBold: true, trapChance: (shouldGenerateTraps ? 0.08 : 0) || blackHoleOnlyChance, maxTraps: shouldGenerateTraps ? 7 : 0, blackHoleChance: hasBlackHoleUpgrade && shouldGenerateTraps ? 0.3 : 0 }),
		() => createGrid('blue-grid', blueRows, blueCols, { boldBottom: true, goldCells: true, symbols: true, minSymbols: 10, maxSymbols: 12, coinChance: 0.05, maxCoins: 6, rowLengths: blueRowPattern, rowOffsets: blueRowOffsets, trapChance: (shouldGenerateTraps ? 0.04 : 0), maxTraps: shouldGenerateTraps ? 4 : 0, blackHoleChance: 0 }),
		() => generateRoots('green-grid', 15, 15, 40, 0.25, 0.06, 12, 16, 4, false, (shouldGenerateTraps ? 0.07 : 0), shouldGenerateTraps ? 5 : 0, 0),
		() => generateRoots('red-grid1', 4, 4, 10, 0.3, 0.04, 2, 4, 2, true, 0.00, 0, 0),
		() => generateRoots('red-grid2', 4, 5, 10, 0.3, 0.04, 2, 4, 2, true, 0.00, 0, 0),
		() => generateRoots('red-grid3', 5, 5, 12, 0.3, 0.06, 3, 5, 2, true, 0.00, 0, 0),
		() => generateRoots('red-grid4', 5, 5, 12, 0.3, 0.06, 3, 5, 2, true, 0.00, 0, 0)
	  ];
	  boardConfigs.forEach(fn => fn());
	  updateScore();
	  
	  // Reset zone groottes naar originele World 1 waardes
	  resetZoneSizesForWorld1();
	}
	
	// Reset zone groottes naar originele World 1 CSS waardes
	function resetZoneSizesForWorld1() {
	  const yellowZone = document.getElementById('yellow-zone');
	  const purpleZone = document.getElementById('purple-zone');
	  const blueZone = document.getElementById('blue-zone');
	  const greenZone = document.getElementById('green-zone');
	  const blueGrid = document.getElementById('blue-grid');
	  
	  if (yellowZone) {
		yellowZone.style.height = '450px';
		yellowZone.style.minWidth = '300px';
		yellowZone.style.width = '';
	  }
	  
	  if (purpleZone) {
		purpleZone.style.height = '310px';
		purpleZone.style.width = '';
	  }
	  
	  if (blueZone) {
		blueZone.style.width = '180px';
		blueZone.style.height = '791px';
		blueZone.style.maxHeight = '';
		blueZone.style.overflowX = '';
		blueZone.style.overflowY = '';
		blueZone.style.minWidth = '';
	  }
	  if (blueGrid) {
		blueGrid.style.transform = '';
		blueGrid.style.justifyContent = '';
		blueGrid.style.marginLeft = '';
		blueGrid.style.marginRight = '';
	  }
	  
	  if (greenZone) {
		greenZone.style.width = '';
		greenZone.style.height = '';
		greenZone.style.maxHeight = '';
		greenZone.style.overflowY = '';
		greenZone.style.overflowX = '';
	  }
	}


	// WORLD 2: Nieuwe complexe grids (levels 11-20)
	function rebuildGameBoards_World2() {
	  const { subLevel } = getWorldAndSubLevel(currentLevel);
	  
	  // Trap/black hole configuratie
	  const shouldGenerateTraps = currentLevel >= 15; // World 2 start met traps vanaf sublevel 5
	  const hasBlackHoleUpgrade = hasUpgrade('blackHoleAccess');
	  const trapChance = shouldGenerateTraps ? 0.12 : 0.05;
	  const maxTraps = shouldGenerateTraps ? 12 : 3;
	  const blackHoleChance = hasBlackHoleUpgrade ? BLACK_HOLE_DEFAULT_CHANCE : 0;
	  
	  // GEEL: Verschillende vormen (diamant, ster, spiraal, etc) in plaats van lijnen
	  // Grotere grids met speciale patronen die je moet voltooien
	  const yellowShapes = [
		// Diamant patroon - GROTER en langwerpiger
		{ pattern: [3, 4, 6, 8, 10, 11, 10, 8, 6, 4, 3], offsets: [5, 4, 3, 2, 1, 0, 1, 2, 3, 4, 5], boldCells: [[0,0], [5,5], [10,10], [0,10], [5,0]] },
		// Spiraal - Vierkant 11x11 (1 rij korter voor vierkant vorm)
		{ pattern: [11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11], offsets: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], boldCells: [[0,0], [0,10], [10,0], [10,10], [5,5]] },
		// Kruis - GROTER en langwerpiger
		{ pattern: [3, 3, 3, 3, 3, 10, 3, 3, 3, 3, 3], offsets: [3, 3, 3, 3, 3, 0, 3, 3, 3, 3, 3], boldCells: [[0,0], [0,2], [5,0], [5,9], [10,0], [10,2]] }
	  ];
	  // WORLD 2 request: keep the yellow board shape consistent across sublevels.
	  // Use the rectangular "spiral" layout (index 1) instead of rotating to the cross/plus.
	  const yellowShape = yellowShapes[1];
	  const yellowRows = yellowShape.pattern.length;
	  const yellowCols = Math.max(...yellowShape.pattern) + Math.max(...yellowShape.offsets);
	  // Punten per kolom: 8 voor eerste, dan 12, 16, 24, 32, 40... (exponentieel stijgend)
	  const yellowPointsArray = [8, 12, 16, 24, 32, 40, 48, 56, 64, 72];
	  const yellowColumnPoints = yellowShape.pattern.map((width, idx) => yellowPointsArray[idx] || (24 + (idx - 3) * 8));
	  
	  window.yellowGridConfig = {
		rows: yellowRows,
		cols: yellowCols,
		rowLengths: yellowShape.pattern.slice(),
		rowOffsets: yellowShape.offsets.slice(),
		pointsByColumn: yellowColumnPoints.slice(),
		columnHeights: yellowShape.pattern.map((_, i) => i),
		pointsByRow: [],
		pointsByWidth: {},
		pointsPerRow: 0,
		pointsPerColumn: 0,
		// WORLD 2: Yellow is scored by diagonals (not columns)
		scoreMode: 'diagonal',
		diagonalAxis: 'xMinusY',
		diagonalPointsPerCell: 2,
		minDiagonalLength: 4
	  };
	  
	  // BLAUW: Lange continue rivier (60+ rijen) die kronkelt en soms breed wordt
	  // Blauw grid: Continue rivier die altijd doorloopt, met extra tak tijdens split
	  const blueRowPattern = [];
	  const blueRowOffsets = [];
	  const blueSplitData = []; // Voor tracking split info
	  const blueGapCells = new Set(); // Cells die void moeten zijn (gap tussen main en split)
	  
	  let currentOffset = 4;
	  let currentWidth = 3;
	  let prevOffset = currentOffset;
	  let prevWidth = currentWidth;
	  
	  // Split tracking
	  let inSplit = false;
	  let splitRowsLeft = 0;
	  let splitOffset = 0;
	  let splitWidth = 3;
	  let prevSplitOffset = 0;
	  let prevSplitWidth = 3;
	  
	  for (let i = 0; i < 60; i++) {
		// Variatie in breedte van hoofdrivier
		if (i % 12 === 7) {
		  currentWidth = 4 + Math.floor(Math.random() * 2); // 4-5 breed
		} else {
		  currentWidth = 2 + Math.floor(Math.random() * 3); // 2-4 breed
		}
		
		// ALTIJD overlap checken voor hoofdrivier (ook tijdens split!)
		if (i > 0) {
		  const minOffset = prevOffset - currentWidth + 1; // Minimaal 1 cell overlap
		  const maxOffset = prevOffset + prevWidth - 1;
		  
		  // Kleine kronkeling
		  let newOffset = currentOffset;
		  if (Math.random() > 0.5) {
			newOffset += (Math.random() > 0.5 ? 1 : -1);
		  }
		  
		  // Beperk binnen overlap range
		  newOffset = Math.max(minOffset, Math.min(maxOffset, newOffset));
		  newOffset = Math.max(0, Math.min(10, newOffset));
		  currentOffset = newOffset;
		}
		
		// Voeg hoofdrivier toe (ALTIJD)
		blueRowPattern.push(currentWidth);
		blueRowOffsets.push(currentOffset);
		
		// Onthoud voor volgende iteratie
		prevOffset = currentOffset;
		prevWidth = currentWidth;
		
		// Check of we split moeten starten
		if (!inSplit && i === 20) {
		  inSplit = true;
		  splitRowsLeft = 20; // Langer: 20 rijen ipv 12
		  splitWidth = 3;
		  // Split tak start direct aansluitend aan hoofdrivier
		  splitOffset = currentOffset + currentWidth - 1; // 1 cell overlap voor connectie
		  prevSplitOffset = splitOffset;
		  prevSplitWidth = splitWidth;
		  console.log(`ðŸŒŠ Split start at row ${i}: main at ${currentOffset}-${currentOffset+currentWidth-1}, split at ${splitOffset}-${splitOffset+splitWidth-1}`);
		}
		
		// Als we in split zijn, COMBINEER main en split in Ã©Ã©n row MAAR markeer gap als void
		if (inSplit) {
		  // Zorg dat er minimaal 1 lege cell tussen main en split is (behalve bij start/eind)
		  const isStartRow = splitRowsLeft === 20;
		  const mergeRows = 8;
		  const isEndingPhase = splitRowsLeft <= mergeRows; // Laatste rijen: samenvoegen tot 1 tak
		  
		  // Split tak heeft overlap met zijn eigen vorige rij (during merge we relax a bit so it can actually re-join)
		  if (splitRowsLeft < 20 && !isStartRow) { // Niet de eerste rij
			const relax = isEndingPhase ? 2 : 0;
			const minSplitOffset = prevSplitOffset - splitWidth + 1 - relax; // overlap range (relaxed near merge)
			const maxSplitOffset = prevSplitOffset + prevSplitWidth - 1 + relax;
			
			// Kleine variatie
			let newSplitOffset = splitOffset;
			if (!isEndingPhase && Math.random() > 0.5) {
			  newSplitOffset += (Math.random() > 0.5 ? 1 : -1);
			}
			
			// EERST: beperk binnen overlap range van eigen vorige rij
			splitOffset = Math.max(minSplitOffset, Math.min(maxSplitOffset, newSplitOffset));
		  }
		  
		  // Positioneer split relatief aan main
		  const mainStart = currentOffset;
		  const mainEnd = currentOffset + currentWidth;
		  
		  if (isStartRow) {
			// Bij start: direct aansluitend (overlap voor connectie)
			splitOffset = mainEnd - 1; // 1 cell overlap
		  } else if (isEndingPhase) {
			// Laatste rijen: forceer samenvoegen tot 1 door overlap/adjacency te maken.
			const desiredSplitOffset = mainEnd - 1; // overlap 1 cell with main
			const relax = 2;
			const minSplitOffset = prevSplitOffset - splitWidth + 1 - relax;
			const maxSplitOffset = prevSplitOffset + prevSplitWidth - 1 + relax;
			splitOffset = Math.max(minSplitOffset, Math.min(maxSplitOffset, desiredSplitOffset));
		  } else {
			// Tijdens split: houd minimaal 1 lege cell tussen main en split
			// Maar: zorg dat split overlap houdt met ZIJN eigen vorige rij
			const splitStart = splitOffset;
			const minGap = splitRowsLeft <= (mergeRows + 2) ? 0 : 1; // vlak voor merge: laat gap verdwijnen
			
			// Als split te dichtbij main komt, schuif naar rechts (als dat binnen overlap range blijft)
			if (splitStart < mainEnd + minGap) {
			  const desiredSplitOffset = mainEnd + minGap;
			  // Check of dit binnen overlap range van vorige split rij valt
			  const minSplitOffset = prevSplitOffset - splitWidth + 1;
			  const maxSplitOffset = prevSplitOffset + prevSplitWidth - 1;
			  
			  if (desiredSplitOffset >= minSplitOffset && desiredSplitOffset <= maxSplitOffset) {
				splitOffset = desiredSplitOffset;
			  }
			  // Anders: behoud huidige offset (heeft overlap met vorige split rij)
			}
		  }
		  
		  // COMBINEER main en split in Ã©Ã©n row inclusief de gap
		  const combinedStart = Math.min(currentOffset, splitOffset);
		  const combinedEnd = Math.max(currentOffset + currentWidth, splitOffset + splitWidth);
		  const combinedWidth = combinedEnd - combinedStart;
		  
		  // Markeer gap cells als void (tussen main en split) - ALLEEN als er een gap is
		  const actualMainEnd = currentOffset + currentWidth;
		  const actualSplitStart = splitOffset;
		  if (actualMainEnd < actualSplitStart) {
			for (let gapCol = actualMainEnd; gapCol < actualSplitStart; gapCol++) {
			  blueGapCells.add(`${gapCol},${i}`); // Sla op als "col,row"
			}
		  }
		  
		  // Update de laatste toegevoegde row (die we net hebben toegevoegd)
		  blueRowPattern[blueRowPattern.length - 1] = combinedWidth;
		  blueRowOffsets[blueRowOffsets.length - 1] = combinedStart;
		  
		  console.log(`ðŸ”— Row ${i}: Combined width=${combinedWidth}, offset=${combinedStart} [main: ${currentOffset}-${actualMainEnd-1}, ${actualMainEnd < actualSplitStart ? `GAP: ${actualMainEnd}-${actualSplitStart-1}, ` : ''}split: ${splitOffset}-${splitOffset+splitWidth-1}] ${isEndingPhase ? '(ending phase)' : ''}`);
		  
		  prevSplitOffset = splitOffset;
		  prevSplitWidth = splitWidth;
		  
		  splitRowsLeft--;
		  if (splitRowsLeft <= 0) {
			inSplit = false;
			console.log(`ðŸŒŠ Split ends at row ${i}, main river continues normally`);
		  }
		}
	  }
	  
	  const blueRows = 60;
	  const blueCols = 18; // Smaller: genoeg voor main + split + gap
	  
	  console.log(`ðŸŒŠ Blue grid: ${blueRows} rows, ${blueCols} cols, ${blueSplitData.length} split cells prepared`);
	  
	  // PAARS (World 2): bigger grid (+1 row/col) with fixed corner bold cells
	  const purpleSize = 13;
	  window.purpleGridConfig = {
		world2: true,
		outerRingBonusPerBold: 20
	  };
	  
	  // GROEN: Veel groter (20x20) met langere wortels en meer vertakkingen
	  // Punten verdubbelen naarmate je verder van startcells bent
	  const greenSize = 20;
	  const greenMaxGrowth = 60 + subLevel * 5; // Langere wortels
	  const greenBoldChance = 0.35; // Meer bold cells
	  
	  // ROOD: 4 grids met verschillende groottes - smaller maar hoger voor betere ruimtebenutting
	  // Connectie bonus: als je beide vult krijg je extra punten
	  // Alleen grids gebruiken die in de HTML bestaan (red-grid1 t/m red-grid4)
	  const redConfigs = [
		{ id: 'red-grid1', width: 5, height: 4, growth: 14, bonus: true },  // World 2 tweak: wider (+2), shorter (-2)
		{ id: 'red-grid2', width: 6, height: 4, growth: 16, bonus: true },  // World 2 tweak: wider (+2), shorter (-2)
		{ id: 'red-grid3', width: 6, height: 5, growth: 18, bonus: false }, // World 2 tweak: wider (+2), shorter (-2)
		{ id: 'red-grid4', width: 6, height: 5, growth: 20, bonus: false }  // World 2 tweak: wider (+2), shorter (-2)
	  ].filter(cfg => document.getElementById(cfg.id)); // Filter alleen bestaande grids
	  
	  // Genereer alle grids
	  const boardConfigs = [
		// Geel: Shape-based met bold cells op specifieke posities - MINDER coins/symbolen (50% reduction voor World 2)
		() => {
		  createGrid('yellow-grid', yellowRows, yellowCols, {
			goldCells: true,
			symbols: true,
			minSymbols: 5,
			maxSymbols: 7,
			coinChance: 0.07,
			maxCoins: 8,
			rowLengths: yellowShape.pattern,
			rowOffsets: yellowShape.offsets,
			boldColumns: [], // Geen kolom-based bolds
			pointsPerColumn: yellowColumnPoints,
			diagonalShading: true,
			diagonalLegend: true,
			trapChance: trapChance,
			maxTraps: maxTraps,
			blackHoleChance: blackHoleChance
		  });
		  // Voeg handmatig bold cells toe op specifieke posities
		  const yellowZone = document.getElementById('yellow-zone');
		  if (yellowZone && yellowShape.boldCells) {
			const cleanupYellowStartCell = (cell) => {
				if (!cell) return;
				// Remove any bonuses/symbols/traps that were assigned before this cell became a start/bold cell.
				cell.classList.remove('gold-cell');
				cell.querySelectorAll('.symbol').forEach(s => s.remove());
				if (cell.classList.contains('trap-cell')) {
					cell.classList.remove('trap-cell');
					delete cell.dataset.trap;
					delete cell.dataset.trapType;
					delete cell.dataset.trapTriggered;
					delete cell.dataset.trapInstanceId;
					cell.querySelectorAll('.trap-symbol').forEach(s => s.remove());
				}
			};
			yellowShape.boldCells.forEach(([row, col]) => {
			  const cell = getCell(yellowZone, col, row);
			  if (!cell) return;
			  if (!cell.classList.contains('bold-cell')) cell.classList.add('bold-cell');
			  cleanupYellowStartCell(cell);
			});
			// Safety net: ensure NO bold/start cell in yellow contains symbols/coins.
			yellowZone.querySelectorAll('.cell.bold-cell').forEach(cleanupYellowStartCell);
		  }
		},
		
		// Paars: World 2 rules (fixed corner bolds + outer ring shading) - 50% reduction coins/symbols
		() => createGrid('purple-grid', purpleSize, purpleSize, {
		  symbols: true,
		  goldCells: true,
		  minSymbols: 8,
		  maxSymbols: 11,
		  coinChance: 0.04,
		  maxCoins: 6,
		  // Keep the World 2 fixed corner bolds, but also keep the normal connector bolds in the middle (like World 1).
		  randomBoldCount: 10,
		  avoidAdjacentBold: true,
		  // World 2 request: random bold cells must NOT appear in the outer 2 rings.
		  randomBoldMinEdgeDistance: 2,
		  fixedBoldCells: [[0,0], [0, purpleSize - 1], [purpleSize - 1, 0], [purpleSize - 1, purpleSize - 1]],
		  outerRingShade: true,
		  trapChance: trapChance,
		  maxTraps: Math.floor(maxTraps * 1.2),
		  blackHoleChance: blackHoleChance * 0.5
		}),
		
		// Blauw: Lang kronkelig pad met split tak - 50% reduction coins/symbols voor World 2
		() => {
		  createGrid('blue-grid', blueRows, blueCols, {
			boldBottom: true,
			goldCells: true,
			symbols: true,
			minSymbols: 15,
			maxSymbols: 22,
			coinChance: 0.09,
			maxCoins: 16,
			rowLengths: blueRowPattern,
			rowOffsets: blueRowOffsets,
			voidCells: blueGapCells, // Gap cells tussen main en split
			trimLeft: true,
			trimRight: true,
			trapChance: trapChance * 0.8,
			maxTraps: Math.floor(maxTraps * 0.8),
			blackHoleChance: 0
		  });
		  // UX: start the blue view at the bottom once after rebuild.
		  const blueZone = document.getElementById('blue-zone');
		  if (blueZone) blueZone.dataset.needsInitialScrollBottom = 'true';
		  console.log(`ðŸŒŠ Blue grid created with split pattern (${blueGapCells.size} gap cells)`);
		},
		
		// Groen: Complexe wortelstructuur met meer vertakkingen (smaller maar hoger)
		// World 2: 50% minder symbols en coins dan normaal
		() => {
		  const greenSize = 28; // World 2: wider so horizontal scrolling is meaningful
		  const greenRows = 34; // Slightly shorter/less tall than before
		  const greenMaxGrowth = 220; // Growth budget for the mega-root + 4 arms
		  const greenBoldChance = 0.25;
		  const greenSplitChance = 0.35; // Hogere splitChance voor meer vertakkingen
		  window.greenGridConfig = {
			world2: true,
			minEndPoints: 8,
			minEndCellPoints: 14,
			maxEndCellPoints: 30
		  };
		  // NOTE: generateRoots signature is (.., branchCount, splitChance, coinChance, minSymbols, maxSymbols, maxCoins, ...)
		  // Previously, splitChance and coinChance were accidentally swapped, causing huge coin/bonus density.
		  // World 2 request: noticeably fewer bonuses on green.
		  const greenCoinChance = 0.02;
		  return generateRoots('green-grid', greenRows, greenSize, greenMaxGrowth, greenSplitChance, greenCoinChance, 4, 6, 2, false, trapChance, Math.floor(maxTraps * 0.9), blackHoleChance * 0.3);
		},
		
		// Rood: 4 grids met verschillende groottes (smaller maar hoger)
		// World 2: 50% minder symbols en coins
		...redConfigs.map(cfg => () => {
		  // 50% reduction: minSymbols 3->2, maxSymbols 6->3, maxCoins 3->2
		  const grid = generateRoots(cfg.id, cfg.height, cfg.width, cfg.growth, 0.35, 0.03, 2, 3, 2, true, 0, 0, 0);
		  // Markeer bonus grids visueel
		  if (cfg.bonus) {
			const zone = document.getElementById(cfg.id.replace('-grid', '-zone'));
			if (zone) zone.dataset.bonusGrid = 'true';
		  }
		  return grid;
		})
	  ];
	  
	  boardConfigs.forEach(fn => fn());
	  updateScore();
	  
	  // Pas zone groottes aan op basis van gegenereerde grids
	  adjustZoneSizesForWorld2();
	  
	  // Log voor debugging
	  console.log('ðŸŒ World 2 grids generated for level', currentLevel, 'sublevel', subLevel);
	}
	
	// WORLD 3: Ultimate challenge - Mix van World 1 en 2 met extra moeilijkheid (levels 21-30)
	function rebuildGameBoards_World3() {
	  const { subLevel } = getWorldAndSubLevel(currentLevel);
	  
	  // World 3: Meer traps en hogere moeilijkheid
	  const hasBlackHoleUpgrade = hasUpgrade('blackHoleAccess');
	  const trapChance = 0.15 + (subLevel * 0.01); // 15-25% trap chance
	  const maxTraps = 15 + subLevel; // 15-25 max traps
	  const blackHoleChance = hasBlackHoleUpgrade ? BLACK_HOLE_DEFAULT_CHANCE * 1.5 : 0;
	  
	  // GEEL: Mega diamant patroon - combinatie van World 1 kolommen + World 2 vormen
	  // Grotere vorm met diagonale scoring
	  const yellowShape = {
		pattern: [4, 6, 8, 10, 12, 14, 14, 12, 10, 8, 6, 4],
		offsets: [5, 4, 3, 2, 1, 0, 0, 1, 2, 3, 4, 5],
		boldCells: [[0,1], [0,2], [5,0], [5,13], [6,0], [6,13], [11,1], [11,2], [3,6], [3,7], [8,6], [8,7]]
	  };
	  const yellowRows = yellowShape.pattern.length;
	  const yellowCols = Math.max(...yellowShape.pattern) + Math.max(...yellowShape.offsets);
	  
	  // World 3: Hogere punten per kolom/diagonaal
	  const yellowPointsArray = [10, 15, 20, 28, 36, 44, 52, 60, 68, 76, 84, 92, 100];
	  const yellowColumnPoints = yellowShape.pattern.map((width, idx) => yellowPointsArray[idx] || (44 + (idx - 5) * 8));
	  
	  window.yellowGridConfig = {
		rows: yellowRows,
		cols: yellowCols,
		rowLengths: yellowShape.pattern.slice(),
		rowOffsets: yellowShape.offsets.slice(),
		pointsByColumn: yellowColumnPoints.slice(),
		columnHeights: yellowShape.pattern.map((_, i) => i),
		pointsByRow: [],
		pointsByWidth: {},
		pointsPerRow: 0,
		pointsPerColumn: 0,
		// World 3: Hybride scoring - zowel kolommen als diagonalen
		scoreMode: 'diagonal',
		diagonalAxis: 'xMinusY',
		diagonalPointsPerCell: 3, // Hogere punten per cel
		minDiagonalLength: 3, // Kortere diagonalen tellen ook
		world3BonusMultiplier: 1.5 // Extra bonus voor voltooide vormen
	  };
	  
	  // BLAUW: Ultra lange rivier met meerdere splits (80 rijen!)
	  const blueRowPattern = [];
	  const blueRowOffsets = [];
	  const blueGapCells = new Set();
	  
	  let currentOffset = 6;
	  let currentWidth = 3;
	  let prevOffset = currentOffset;
	  let prevWidth = currentWidth;
	  
	  // Split tracking - World 3: 2 splits!
	  let inSplit = false;
	  let splitRowsLeft = 0;
	  let splitOffset = 0;
	  let splitWidth = 3;
	  let prevSplitOffset = 0;
	  let prevSplitWidth = 3;
	  let splitCount = 0; // Track how many splits we've done
	  
	  for (let i = 0; i < 80; i++) {
		// Variatie in breedte
		if (i % 10 === 5) {
		  currentWidth = 4 + Math.floor(Math.random() * 3); // 4-6 breed
		} else {
		  currentWidth = 2 + Math.floor(Math.random() * 3); // 2-4 breed
		}
		
		// Overlap check voor hoofdrivier
		if (i > 0) {
		  const minOffset = prevOffset - currentWidth + 1;
		  const maxOffset = prevOffset + prevWidth - 1;
		  
		  let newOffset = currentOffset;
		  if (Math.random() > 0.4) {
			newOffset += (Math.random() > 0.5 ? 1 : -1);
		  }
		  
		  newOffset = Math.max(minOffset, Math.min(maxOffset, newOffset));
		  newOffset = Math.max(0, Math.min(12, newOffset));
		  currentOffset = newOffset;
		}
		
		blueRowPattern.push(currentWidth);
		blueRowOffsets.push(currentOffset);
		
		prevOffset = currentOffset;
		prevWidth = currentWidth;
		
		// World 3: Twee splits - op rij 20 en rij 50
		if (!inSplit && (i === 20 || i === 50) && splitCount < 2) {
		  inSplit = true;
		  splitRowsLeft = i === 20 ? 18 : 15; // Langere eerste split
		  splitWidth = 3;
		  splitOffset = currentOffset + currentWidth - 1;
		  prevSplitOffset = splitOffset;
		  prevSplitWidth = splitWidth;
		  splitCount++;
		}
		
		// Split logica (vergelijkbaar met World 2)
		if (inSplit) {
		  const isStartRow = (i === 20 || i === 50);
		  const mergeRows = 6;
		  const isEndingPhase = splitRowsLeft <= mergeRows;
		  
		  if (splitRowsLeft < 18 && !isStartRow) {
			const relax = isEndingPhase ? 2 : 0;
			const minSplitOffset = prevSplitOffset - splitWidth + 1 - relax;
			const maxSplitOffset = prevSplitOffset + prevSplitWidth - 1 + relax;
			
			let newSplitOffset = splitOffset;
			if (!isEndingPhase && Math.random() > 0.5) {
			  newSplitOffset += (Math.random() > 0.5 ? 1 : -1);
			}
			
			splitOffset = Math.max(minSplitOffset, Math.min(maxSplitOffset, newSplitOffset));
		  }
		  
		  const mainStart = currentOffset;
		  const mainEnd = currentOffset + currentWidth;
		  
		  if (isStartRow) {
			splitOffset = mainEnd - 1;
		  } else if (isEndingPhase) {
			const desiredSplitOffset = mainEnd - 1;
			const relax = 2;
			const minSplitOffset = prevSplitOffset - splitWidth + 1 - relax;
			const maxSplitOffset = prevSplitOffset + prevSplitWidth - 1 + relax;
			splitOffset = Math.max(minSplitOffset, Math.min(maxSplitOffset, desiredSplitOffset));
		  } else {
			const minGap = splitRowsLeft <= (mergeRows + 2) ? 0 : 1;
			const splitStart = splitOffset;
			
			if (splitStart < mainEnd + minGap) {
			  const desiredSplitOffset = mainEnd + minGap;
			  const minSplitOffset = prevSplitOffset - splitWidth + 1;
			  const maxSplitOffset = prevSplitOffset + prevSplitWidth - 1;
			  
			  if (desiredSplitOffset >= minSplitOffset && desiredSplitOffset <= maxSplitOffset) {
				splitOffset = desiredSplitOffset;
			  }
			}
		  }
		  
		  const combinedStart = Math.min(currentOffset, splitOffset);
		  const combinedEnd = Math.max(currentOffset + currentWidth, splitOffset + splitWidth);
		  const combinedWidth = combinedEnd - combinedStart;
		  
		  const actualMainEnd = currentOffset + currentWidth;
		  const actualSplitStart = splitOffset;
		  if (actualMainEnd < actualSplitStart) {
			for (let gapCol = actualMainEnd; gapCol < actualSplitStart; gapCol++) {
			  blueGapCells.add(`${gapCol},${i}`);
			}
		  }
		  
		  blueRowPattern[blueRowPattern.length - 1] = combinedWidth;
		  blueRowOffsets[blueRowOffsets.length - 1] = combinedStart;
		  
		  prevSplitOffset = splitOffset;
		  prevSplitWidth = splitWidth;
		  
		  splitRowsLeft--;
		  if (splitRowsLeft <= 0) {
			inSplit = false;
		  }
		}
	  }
	  
	  const blueRows = 80;
	  const blueCols = 22;
	  
	  // PAARS: Mega grid (14x14) met extra bold cells in het midden
	  const purpleSize = 14;
	  window.purpleGridConfig = {
		world3: true,
		outerRingBonusPerBold: 25, // Hogere bonus dan World 2
		innerRingBonus: true, // Nieuwe mechanic: bonus voor inner ring ook
		innerRingBonusPerBold: 15
	  };
	  
	  // GROEN: Ultra groot (36x36) met maximale vertakkingen
	  const greenRows = 40;
	  const greenCols = 36;
	  const greenMaxGrowth = 300 + subLevel * 15;
	  window.greenGridConfig = {
		world3: true,
		minEndPoints: 12,
		minEndCellPoints: 12,
		maxEndCellPoints: 40,
		branchBonusMultiplier: 2
	  };
	  
	  // ROOD: Alle 6 grids actief met hogere moeilijkheid
	  const redConfigs = [
		{ id: 'red-grid1', width: 6, height: 5, growth: 20 },
		{ id: 'red-grid2', width: 7, height: 5, growth: 22 },
		{ id: 'red-grid3', width: 7, height: 6, growth: 25 },
		{ id: 'red-grid4', width: 7, height: 6, growth: 28 },
		{ id: 'red-grid5', width: 8, height: 6, growth: 30 },
		{ id: 'red-grid6', width: 8, height: 7, growth: 32 }
	  ].filter(cfg => document.getElementById(cfg.id));
	  
	  // Genereer alle grids
	  const boardConfigs = [
		// Geel: Mega diamant met veel bold cells
		() => {
		  createGrid('yellow-grid', yellowRows, yellowCols, {
			goldCells: true,
			symbols: true,
			minSymbols: 8,
			maxSymbols: 14,
			coinChance: 0.08,
			maxCoins: 10,
			rowLengths: yellowShape.pattern,
			rowOffsets: yellowShape.offsets,
			boldColumns: [],
			pointsPerColumn: yellowColumnPoints,
			diagonalShading: true,
			diagonalLegend: true,
			trapChance: trapChance,
			maxTraps: maxTraps,
			blackHoleChance: blackHoleChance
		  });
		  const yellowZone = document.getElementById('yellow-zone');
		  if (yellowZone && yellowShape.boldCells) {
			yellowShape.boldCells.forEach(([row, col]) => {
			  const cell = getCell(yellowZone, col, row);
			  if (cell && !cell.classList.contains('bold-cell')) {
				cell.classList.add('bold-cell');
			  }
			});
		  }
		},
		
		// Paars: Mega grid met binnen- en buitenring bonussen
		() => createGrid('purple-grid', purpleSize, purpleSize, {
		  symbols: true,
		  goldCells: true,
		  minSymbols: 16,
		  maxSymbols: 24,
		  coinChance: 0.06,
		  maxCoins: 12,
		  randomBoldCount: 14,
		  avoidAdjacentBold: true,
		  fixedBoldCells: [[0,0], [0, purpleSize - 1], [purpleSize - 1, 0], [purpleSize - 1, purpleSize - 1], 
						   [0, Math.floor(purpleSize/2)], [purpleSize - 1, Math.floor(purpleSize/2)],
						   [Math.floor(purpleSize/2), 0], [Math.floor(purpleSize/2), purpleSize - 1]],
		  outerRingShade: true,
		  trapChance: trapChance * 1.2,
		  maxTraps: Math.floor(maxTraps * 1.3),
		  blackHoleChance: blackHoleChance * 0.6
		}),
		
		// Blauw: Ultra lange rivier met 2 splits
		() => {
		  createGrid('blue-grid', blueRows, blueCols, {
			boldBottom: true,
			goldCells: true,
			symbols: true,
			minSymbols: 35,
			maxSymbols: 50,
			coinChance: 0.18,
			maxCoins: 35,
			rowLengths: blueRowPattern,
			rowOffsets: blueRowOffsets,
			voidCells: blueGapCells,
			trapChance: trapChance * 0.9,
			maxTraps: Math.floor(maxTraps * 0.9),
			blackHoleChance: 0
		  });
		},
		
		// Groen: Ultra groot met maximale vertakkingen
		() => {
		  const greenSplitChance = 0.45;
		  return generateRoots('green-grid', greenRows, greenCols, greenMaxGrowth, greenSplitChance, 0.08, 16, 28, 8, false, trapChance, Math.floor(maxTraps * 1.1), blackHoleChance * 0.4);
		},
		
		// Rood: Alle 6 grids
		...redConfigs.map(cfg => () => {
		  return generateRoots(cfg.id, cfg.height, cfg.width, cfg.growth, 0.4, 0.08, 4, 8, 4, true, trapChance * 0.5, Math.floor(maxTraps * 0.3), 0);
		})
	  ];
	  
	  boardConfigs.forEach(fn => fn());
	  updateScore();
	  
	  // Gebruik World 2 zone sizing (werkt ook voor World 3)
	  adjustZoneSizesForWorld2();
	  
	  console.log('ðŸ”¥ World 3 grids generated for level', currentLevel, 'sublevel', subLevel);
	}
	
	// Pas zone groottes dynamisch aan voor World 2 grids
	function enableZoneDragScroll(zoneEl, opts = {}) {
		if (!zoneEl) return;
		if (zoneEl.dataset.dragScrollEnabled === 'true') return;
		zoneEl.dataset.dragScrollEnabled = 'true';
		const ignoreSelectors = opts.ignoreSelectors || '.card,.card-option,#controls,#bottom-bar';
		const threshold = typeof opts.threshold === 'number' ? opts.threshold : 6;
		let activePointerId = null;
		let startX = 0;
		let startY = 0;
		let startScrollLeft = 0;
		let startScrollTop = 0;
		let moved = false;

		zoneEl.addEventListener('pointerdown', (e) => {
			if (e.button !== undefined && e.button !== 0) return; // left button only
			// Don't hijack pointer drags while placing a block.
			if (typeof draggedBlock !== 'undefined' && draggedBlock) return;
			if (typeof draggedShape !== 'undefined' && draggedShape) return;
			if (typeof activeBonusPlacement !== 'undefined' && activeBonusPlacement) return;
			if (ignoreSelectors && e.target.closest(ignoreSelectors)) return;
			activePointerId = e.pointerId;
			moved = false;
			startX = e.clientX;
			startY = e.clientY;
			startScrollLeft = zoneEl.scrollLeft;
			startScrollTop = zoneEl.scrollTop;
			zoneEl.dataset.dragScrolling = 'false';
			zoneEl.classList.add('drag-scroll-active');
			try { zoneEl.setPointerCapture(activePointerId); } catch (_) {}
		});

		zoneEl.addEventListener('pointermove', (e) => {
			if (activePointerId === null || e.pointerId !== activePointerId) return;
			const dx = e.clientX - startX;
			const dy = e.clientY - startY;
			if (!moved && (Math.abs(dx) > threshold || Math.abs(dy) > threshold)) {
				moved = true;
				zoneEl.dataset.dragScrolling = 'true';
			}
			if (!moved) return;
			e.preventDefault();
			zoneEl.scrollLeft = startScrollLeft - dx;
			zoneEl.scrollTop = startScrollTop - dy;
		}, { passive: false });

		const endDrag = () => {
			if (activePointerId === null) return;
			activePointerId = null;
			zoneEl.classList.remove('drag-scroll-active');
			// Keep the "dragScrolling" flag briefly so pointerup on a cell can detect it.
			if (zoneEl.dataset.dragScrolling === 'true') {
				setTimeout(() => { zoneEl.dataset.dragScrolling = 'false'; }, 0);
			}
		};
		zoneEl.addEventListener('pointerup', endDrag);
		zoneEl.addEventListener('pointercancel', endDrag);
	}

	function adjustZoneSizesForWorld2() {
	  // Gebruik de echte --cell-size CSS variabele voor consistente sizing tussen werelden
	  const computedCellSize = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--cell-size')) || 26;
	  const cellSize = Math.max(18, Math.min(30, computedCellSize)); // Clamp between 18 and 30
	  const worldInfo = (typeof getWorldAndSubLevel === 'function') ? getWorldAndSubLevel(currentLevel) : null;
	  const isWorld2 = !!(worldInfo && worldInfo.world === 2);
	  const isPortrait = window.innerHeight > window.innerWidth;
	  const isShortHeight = window.innerHeight <= 925;
	  const isDesktopPortraitLayout = document.body.classList.contains('desktop-portrait')
			&& !document.body.classList.contains('mobile-sidebar-layout')
			&& !document.body.classList.contains('touch-portrait');
	  // Purple needs extra vertical chrome so it never clips (header/padding/outline).
	  const purpleChromePx = isDesktopPortraitLayout ? 40 : 30;
	  const tallZoneMaxVh = isPortrait ? '52vh' : (isShortHeight ? '65vh' : '85vh');
	  // Green should be visibly shorter so the rest of the UI fits, but still scrollable.
	  // User request: make it ~40px shorter.
	  const greenZoneMaxVh = isPortrait ? 'calc(40vh - 40px)' : (isShortHeight ? 'calc(50vh - 40px)' : 'calc(52vh - 40px)');
	  const tallZoneMaxPx = isPortrait ? 600 : (isShortHeight ? 800 : 1200);
	  
	  // Geel zone - iets korter
	  const yellowGrid = document.getElementById('yellow-grid');
	  const yellowZone = document.getElementById('yellow-zone');
	  if (yellowGrid && yellowZone) {
		const yellowRows = parseInt(yellowGrid.dataset.rows) || 10;
		const yellowCols = parseInt(yellowGrid.dataset.cols) || 10;
		yellowZone.style.width = `${yellowCols * cellSize + 40}px`;
		// Keep enough headroom so the top/bottom spacing remains even.
		yellowZone.style.height = `${yellowRows * cellSize + 70}px`;
	  }
	  
	  // Paars zone - aangepast voor 10x10 grid (2 rijen smaller)
	  const purpleGrid = document.getElementById('purple-grid');
	  const purpleZone = document.getElementById('purple-zone');
	  if (purpleGrid && purpleZone) {
		const purpleSize = parseInt(purpleGrid.dataset.rows) || 10;
		// Tighter chrome around the generated purple grid - gebruik minder padding.
		purpleZone.style.width = `${purpleSize * cellSize + 30}px`;
		purpleZone.style.height = `${purpleSize * cellSize + purpleChromePx}px`;
	  }

	  // WORLD 2 UX: make yellow zone the same width as purple.
	  try {
		const worldInfo = typeof getWorldAndSubLevel === 'function' ? getWorldAndSubLevel(currentLevel) : null;
		if (worldInfo && worldInfo.world === 2 && yellowZone && purpleZone) {
			const targetWidth = purpleZone.style.width || `${purpleZone.offsetWidth}px`;
			if (targetWidth) {
				yellowZone.style.width = targetWidth;
				yellowZone.style.minWidth = targetWidth;
			}
		}
	  } catch (_) {}
	  
	  // Blauw zone - aangepast voor smaller splits, minder min-width
	  const blueGrid = document.getElementById('blue-grid');
	  const blueZone = document.getElementById('blue-zone');
	  if (blueGrid && blueZone) {
		const blueRows = parseInt(blueGrid.dataset.rows) || 60;
		const blueCols = parseInt(blueGrid.dataset.cols) || 18;
		// WORLD 2 UX (user request): fixed max width + allow horizontal scrolling.
		const isNarrow = window.innerWidth <= 650;
		const maxWidthPx = isNarrow ? 165 : 260;
		// If the generated river is narrower, shrink to content so there is no unnecessary horizontal scrolling.
		const contentWidthPx = blueCols * cellSize;
		const targetWidthPx = Math.min(maxWidthPx, Math.max(1, contentWidthPx));
		blueZone.style.width = `${targetWidthPx}px`;
		blueZone.style.minWidth = `${targetWidthPx}px`;
		blueZone.style.maxWidth = `${targetWidthPx}px`;
		
		// WORLD 2 UX: Blauw zone hoogte = geel + paars + gap ertussen
		let blueHeight;
		if (yellowGrid && purpleGrid) {
		  // Bereken hoogtes direct in plaats van offsetHeight (die kan 0 zijn bij eerste render)
		  const yellowRows = parseInt(yellowGrid.dataset.rows) || 10;
		  const purpleRows = parseInt(purpleGrid.dataset.rows) || 10;
		  const yellowHeight = yellowRows * cellSize + 70; // Zelfde als yellowZone.style.height berekening
			const purpleHeight = purpleRows * cellSize + purpleChromePx; // Zelfde als purpleZone.style.height berekening
		  const gapBetweenZones = 10; // Gap tussen geel en paars zones
		  blueHeight = yellowHeight + purpleHeight + gapBetweenZones;
		} else {
		  blueHeight = Math.min(blueRows * cellSize, tallZoneMaxPx);
		}
		blueZone.style.height = `${blueHeight}px`;
		// Verwijder maxHeight beperking zodat blauw echt even lang kan zijn als geel+paars
		blueZone.style.maxHeight = 'none';
		blueZone.style.overflowY = 'auto';
		blueZone.style.overflowX = 'auto';
		// Remove margins so the view starts exactly at the left edge.
		blueGrid.style.margin = '0px';
		blueGrid.style.justifyContent = 'start';
		blueGrid.style.transform = '';
		// World 2: unzoomed blue should start bottom-centered (bold start cells),
		// and later keep the user's last unzoomed scroll position.
		restoreOrAnchorZoneScroll(blueZone, (z) => resetBlueZoomScroll(z));
		enableZoneDragScroll(blueZone, { ignoreSelectors: '#controls,#bottom-bar,#card-choice-zone,.card,.card-option' });
		console.log(`30a Blue zone: width=${maxWidthPx}px, scroll enabled, maxHeight=${tallZoneMaxVh}`);
	  }
	  
	  // Groen zone
	  const greenGrid = document.getElementById('green-grid');
	  const greenZone = document.getElementById('green-zone');
	  if (greenGrid && greenZone) {
		// Always keep green scrollable when content exceeds the viewport.
		greenZone.style.overflowY = 'auto';
		greenZone.style.overflowX = 'auto';
		// Clear potentially stale inline sizing; we re-apply below when needed.
		greenZone.style.removeProperty('width');
		greenZone.style.removeProperty('height');
		greenZone.style.removeProperty('min-height');
		greenZone.style.removeProperty('max-height');
		enableZoneDragScroll(greenZone, { ignoreSelectors: '#controls,#bottom-bar,#card-choice-zone,.card,.card-option' });
		console.log('ðŸ’š Green zone: scroll enabled');
	  }
	  
	  // Rood zones - VEEL meer height voor uitstekende cells
	  ['red-grid1', 'red-grid2', 'red-grid3', 'red-grid4'].forEach(gridId => {
		const redGrid = document.getElementById(gridId);
		if (redGrid) {
		  const zoneId = gridId.replace('-grid', '-zone');
		  const redZone = document.getElementById(zoneId);
		  if (redZone) {
			const redRows = parseInt(redGrid.dataset.rows) || 6;
			const redCols = parseInt(redGrid.dataset.cols) || 6;
			// Auto height met ruime minimum - geen fixed heights meer
			redZone.style.width = `${redCols * cellSize + 40}px`;
			redZone.style.height = 'auto';
			redZone.style.minHeight = `${redRows * cellSize + 150}px`; // Nog meer buffer
			redZone.style.overflow = 'visible'; // Laat uitstekende cells zien
			console.log(`ðŸ”´ Red zone ${zoneId}: ${redCols}x${redRows} cells, auto height with min ${redRows * cellSize + 150}px`);
		  }
		}
	  });

	  requestAnimationFrame(() => {
		// World 2 request: green zone must be a SQUARE: height == width (unzoomed).
		try {
			if (isWorld2 && greenZone && !document.body.classList.contains('zoomed-in')) {
				// Use the UNTRANSFORMED layout width as source of truth.
				// If an ancestor is transform-scaled, getBoundingClientRect() returns the scaled width,
				// and setting height to that value would be scaled again (ending up too short).
				let target = Math.round(greenZone.offsetWidth || 0);
				if (!(target > 0)) {
					target = Math.round(greenZone.getBoundingClientRect().width);
				}
				if (!(target > 0)) {
					// Fallback to the desktop sizing formula.
					target = Math.round((13 * cellSize) + 80);
				}
				greenZone.style.height = `${target}px`;
				greenZone.style.minHeight = `${target}px`;
				greenZone.style.maxHeight = `${target}px`;
			}
		} catch (_) {}

		// World 2 unzoomed: ALWAYS center on green start cell (reset scroll memory on layout changes).
		// User wants start-cell in middle when unzoomed, regardless of previous scroll.
		if (greenZone && !document.body.classList.contains('zoomed-in')) {
			// Force anchor (ignore saved scroll) by calling resetGreenZoomScroll directly
			resetGreenZoomScroll(greenZone);
		}
	  });
	}


	function startLevel(level) {
	  console.log('ðŸŽ® startLevel called with level:', level);
	  currentLevel = level;
	  // Clear any previously loaded custom board metadata when starting a normal level
	  try { window.loadedCustomLevelMeta = null; window.loadedCustomObjectiveCompiled = null; window.loadedCustomLevelMetaCompleted = false; } catch(e){}
	  lastRoundFailureReason = null;
		
	  // Rebuild shape pool zodat nieuwe card categorieÃ«n beschikbaar zijn
	  shapePool = buildShapePool();
		
	  // Reset alle score- en zone-tracking state voor het nieuwe level EERST
	  // (incl. per-zone caches zoals scoredYellowColumns/Segments, blue scored rows, etc.)
	  resetScoreState();
	  freePlacementsRemaining = 0;
	  
	  // Reset ALLE score UI elementen naar 0 VOORDAT objectives worden gecontroleerd
	  document.querySelectorAll('#scoreboard .score').forEach(el => {
		el.textContent = '0';
	  });
	  const totalScoreEl = document.getElementById('total-score');
	  if (totalScoreEl) totalScoreEl.textContent = '0';
	  
	  // Reset latestScoreSnapshot zodat objectives op 0 berekend worden
	  latestScoreSnapshot = { yellow: 0, red: 0, green: 0, purple: 0, blue: 0, bonus: 0, total: 0 };
	  
	  // Dan objectives resetten (zodat renderObjectivePanel de juiste scores ziet)
	  resetObjectives();
	  
	  // NOTE: Do NOT call updateScore() here. The board from the previous level/run is
	  // still mounted until rebuildGameBoards() runs. Calling updateScore() now would
	  // repopulate latestScoreSnapshot with old scores and incorrectly affect objectives.
	  
	  // Apply coinMaster upgrade if active: grant immediate coins visually
	  if (hasUpgrade('coinMaster')) {
		const bonusAmount = UPGRADES.coinMaster.bonusCoins || 2;
		for (let i = 0; i < bonusAmount; i++) addCoin();
	  }
		
		setCurrentObjectiveForLevel(level);
	  turnCount = 0;
	  selectedCardId = null;
	  selectedCardElement = null;
	  selectedShape = null;
	  selectedColor = null;
	  if (rotateButton) rotateButton.disabled = true;
	  rebuildGameBoards();
	  // World 2: place a single bonus-upgrade shop event on the board.
	  placeBonusUpgradeFieldEvent_World2();
	  
	  // Plaats portals als de upgrade actief is
	  if (portalsActive) {
		placePortalsForLevel();
	  }
	  
	  // Removed placeUpgradeShop and placeMegaBonus - shop now always accessible from level 5
	  
	  // Bonus upgrade shop is no longer opened via a button.
	  const bonusShopBtn = document.getElementById('bonus-shop-btn');
	  if (bonusShopBtn) bonusShopBtn.style.display = 'none';
	  
	  cardPlacementHistory = [];
	  cardsPlayedThisTurn = 0;
	  actionSequence = 0;
	  resetTurnCardFlags();
	  
	  console.log('ðŸƒ Building deck from', ownedDeckBlueprints.length, 'blueprints');
	  
	  // Bij laden van een save: gebruik de opgeslagen deck state indien beschikbaar
	  if (isLoadingGame && savedDeckState) {
		drawPile = savedDeckState.drawPile || [];
		// Apply scenario filter so restricted colors are not present in the draw pile.
		if (Array.isArray(window.scenarioAllowedColors)) {
			const allowed = window.scenarioAllowedColors;
			drawPile = (drawPile || []).filter(c => c && (allowed.includes((c.color && c.color.name) || '') || (c.color && c.color.name) === 'multikleur'));
		}
		discardPile = savedDeckState.discardPile || [];
		currentHand = savedDeckState.currentHand || [];
		turnCount = savedDeckState.turnCount || 0;
		console.log('ðŸŽ´ Restored deck from save:', drawPile.length, 'in draw,', currentHand.length, 'in hand,', discardPile.length, 'in discard');
	  } else {
		// Nieuwe start: maak fresh deck
		drawPile = shuffleArray(ownedDeckBlueprints.map(bp => instantiateBlueprint(bp)));
		// If scenario restricts colors, remove disallowed cards from the draw pile
		// so they are never drawn during this run.
		if (Array.isArray(window.scenarioAllowedColors)) {
			const allowed = window.scenarioAllowedColors;
			drawPile = drawPile.filter(c => c && (allowed.includes((c.color && c.color.name) || '') || (c.color && c.color.name) === 'multikleur'));
		}
		discardPile = [];
		currentHand = [];
		turnCount = 0;
		console.log('ðŸŽ´ Fresh deck created:', drawPile.length, 'cards in draw pile');
	  }
	  
	  console.log('ðŸŽ´ First card:', drawPile[0]?.shapeName, drawPile[0]?.color?.name);
	  
	  updateDeckPreview();
	  updateTurnCounterDisplay();
	  
	  // Als we een restore hebben gedaan, render de bestaande hand
	  // Anders, trek nieuwe kaarten
	  if (isLoadingGame && savedDeckState && currentHand.length > 0) {
		renderCurrentHand();
		console.log('ðŸŽ´ Restored hand rendered');
	  } else {
		renderCurrentHand();
		drawNextHand();
		console.log('ðŸŽ´ After drawNextHand - currentHand:', currentHand.length, 'cards');
		console.log('ðŸŽ´ After drawNextHand - drawPile:', drawPile.length, 'cards remaining');
	  }
	  
	  updateDeckPreview();
	  
	  // Auto-save na het starten van een level (behalve tijdens laden)
	  if (!isLoadingGame) {
		saveGameState();
	  }
	}

	function resetDeckToStandard() {
	  ownedDeckBlueprints = buildStandardDeckBlueprint();
	}

	// ========== SAVE/LOAD SYSTEM ==========
	function saveGameState() {
	  try {
		const gameState = {
		  version: '1.0',
		  timestamp: Date.now(),
		  currentLevel: currentLevel,
		  currentWorld: currentWorld,
		  // totalTurns/currentStreak removed (unused UI)
		  
		  // Coins
		  coins: Array.from(document.querySelectorAll('#collected-coins .coin')).map(coin => ({
			active: coin.classList.contains('active'),
			used: coin.classList.contains('used')
		  })),
		  
		  // Upgrades
		  upgrades: Object.keys(UPGRADES).reduce((acc, key) => {
			acc[key] = UPGRADES[key].purchased || false;
			return acc;
		  }, {}),
		  
		  // Bonuses
		  bonusInventory: { ...bonusInventory },
		  bonusMasteryState: { ...bonusMasteryState },
		  
		  // Objectives
		  currentObjectiveId: currentObjectiveId,
		  completedObjectives: [...completedObjectives],
		  completedObjectiveIds: Array.from(completedObjectiveIds || []),
		  
		  // Deck
		  ownedDeckBlueprints: ownedDeckBlueprints.map(bp => ({
			blueprintId: bp.blueprintId,
			shapeName: bp.shapeName,
			matrix: bp.matrix,
			category: bp.category,
			color: bp.color ? { name: bp.color.name, code: bp.color.code, isGolden: bp.color.isGolden } : null,
			isGolden: bp.isGolden || false
		  })),
		  
		  // Current game state (drawPile, discardPile, currentHand)
		  drawPile: drawPile.map(card => ({
			id: card.id,
			blueprintId: card.blueprintId,
			shapeName: card.shapeName,
			matrix: card.matrix,
			category: card.category,
			color: card.color ? { name: card.color.name, code: card.color.code, isGolden: card.color.isGolden } : null,
			isGolden: card.isGolden || false
		  })),
		  discardPile: discardPile.map(card => ({
			id: card.id,
			blueprintId: card.blueprintId,
			shapeName: card.shapeName,
			matrix: card.matrix,
			category: card.category,
			color: card.color ? { name: card.color.name, code: card.color.code, isGolden: card.color.isGolden } : null,
			isGolden: card.isGolden || false
		  })),
		  currentHand: currentHand.map(card => ({
			id: card.id,
			blueprintId: card.blueprintId,
			shapeName: card.shapeName,
			matrix: card.matrix,
			category: card.category,
			color: card.color ? { name: card.color.name, code: card.color.code, isGolden: card.color.isGolden } : null,
			isGolden: card.isGolden || false
		  })),
		  cardsPlayedThisTurn: cardsPlayedThisTurn,
		  turnCount: turnCount,
		  
		  // Portals
		  portalsActive: portalsActive || false
		};

		// Include a sanitized snapshot of the current board DOM (without active/placed cells)
		try {
			if (typeof getEditorBoardHtml === 'function') {
				const raw = getEditorBoardHtml();
				if (raw) gameState.boardHtml = (typeof sanitizeBoardHtml === 'function') ? sanitizeBoardHtml(raw) : raw;
			} else if (document.getElementById('board')) {
				const raw = document.getElementById('board').outerHTML;
				if (raw) gameState.boardHtml = (typeof sanitizeBoardHtml === 'function') ? sanitizeBoardHtml(raw) : raw;
			}
		} catch (e) {}
		
		localStorage.setItem('locusGameSave', JSON.stringify(gameState));
		console.log('âœ… Game saved successfully at level', currentLevel);
		console.log('ðŸ’¾ Full save data:', JSON.stringify(gameState, null, 2));
		return true;
	  } catch (error) {
		console.error('âŒ Failed to save game:', error);
		return false;
	  }
	}

// Sanitize a board HTML snapshot so it never contains runtime-placed cells or inline styles.
// IMPORTANT: Preserve inline styles for grids using absolute positioning (green/red).
function sanitizeBoardHtml(html) {
	try {
		const tmp = document.createElement('div');
		tmp.innerHTML = html || '';
		tmp.querySelectorAll('.cell').forEach(cell => {
			// Preserve symbols/bonus visuals; only clear runtime-filled state
			try { cell.classList.remove('active', 'edge-cell'); } catch (e) {}
			// Check if this cell uses absolute positioning (green/red zones)
			// These rely on inline left/top for placement - do NOT remove their styles
			// Red subgrids (red-grid1, red-grid2, etc.) have cells directly inside, no .grid child
			const grid = cell.closest('.grid');
			const zone = cell.closest('.zone');
			const isGreenGrid = (grid && grid.id === 'green-grid') || (zone && zone.dataset && zone.dataset.color === 'groen');
			const isRedGrid = (zone && zone.id && zone.id.startsWith('red-grid')) ||
				(zone && zone.dataset && zone.dataset.color === 'rood') ||
				(zone && zone.classList && zone.classList.contains('red-group'));
			const usesAbsolutePositioning = isGreenGrid || isRedGrid || (cell.style && cell.style.position === 'absolute');
			// Only remove inline styles for CSS Grid-based zones, not absolute-positioned ones
			if (!usesAbsolutePositioning) {
				try { cell.removeAttribute('style'); } catch (e) {}
			}
		});
		// Also remove any floating info popovers in zones
		tmp.querySelectorAll('.zone-info-btn, .zone-info-popover, .zone-handle, .grid-resizer, .zone-delete').forEach(n => n.remove());
		return tmp.innerHTML;
	} catch (e) {
		return html;
	}
}

	function loadGameState() {
	  try {
		const saved = localStorage.getItem('locusGameSave');
		if (!saved) {
		  console.log('ðŸ“‚ No save data found');
		  return false;
		}
		
		const gameState = JSON.parse(saved);
		if (!gameState) {
		  console.error('âŒ Failed to parse save data');
		  return false;
		}
		
		if (gameState.version !== '1.0') {
		  console.warn('âš ï¸ Save version mismatch:', gameState.version);
		  return false;
		}
		
		console.log('ðŸ“‚ Loading saved game from level', gameState.currentLevel);
		console.log('ðŸ“‚ Full loaded data:', JSON.stringify(gameState, null, 2));
		
		// Restore level & world
		currentLevel = gameState.currentLevel || 1;
		currentWorld = gameState.currentWorld || 1;
		console.log('ðŸ“‚ Set currentLevel to:', currentLevel);
		turnCount = gameState.turnCount || 0;
		
		// Restore upgrades
		if (gameState.upgrades) {
		  Object.keys(gameState.upgrades).forEach(key => {
			if (UPGRADES[key]) {
			  UPGRADES[key].purchased = gameState.upgrades[key];
			  return;
			}
			// Back-compat: compactCards was renamed/merged into miniPack34.
			if (key === 'compactCards' && UPGRADES.miniPack34) {
			  UPGRADES.miniPack34.purchased = gameState.upgrades[key];
			}
		  });
		}
		
		// Restore bonuses
		if (gameState.bonusInventory) {
		  Object.keys(gameState.bonusInventory).forEach(key => {
			bonusInventory[key] = gameState.bonusInventory[key];
		  });
		}
		if (gameState.bonusMasteryState) {
		  Object.keys(gameState.bonusMasteryState).forEach(key => {
			bonusMasteryState[key] = gameState.bonusMasteryState[key];
		  });
		}
		
		// Restore objectives
		currentObjectiveId = gameState.currentObjectiveId || null;
		completedObjectives.length = 0;
		if (gameState.completedObjectives) {
		  gameState.completedObjectives.forEach(obj => completedObjectives.push(obj));
		}
		completedObjectiveIds.clear();
		if (gameState.completedObjectiveIds) {
		  gameState.completedObjectiveIds.forEach(id => completedObjectiveIds.add(id));
		}
		
		// Restore deck
		if (gameState.ownedDeckBlueprints && gameState.ownedDeckBlueprints.length > 0) {
		  ownedDeckBlueprints = gameState.ownedDeckBlueprints.map(bp => {
			const colorObj = bp.color ? 
			  (bp.color.isGolden ? 
				{ name: bp.color.name, code: bp.color.code, isGolden: true } : 
				colors.find(c => c.name === bp.color.name) || bp.color
			  ) : null;
			
			// Valideer dat matrix bestaat
			if (!bp.matrix || !Array.isArray(bp.matrix)) {
			  console.error('Invalid matrix in blueprint:', bp);
			  return null;
			}
			
			return {
			  blueprintId: bp.blueprintId || nextBlueprintId(),
			  shapeName: bp.shapeName || 'unknown',
			  matrix: bp.matrix,
			  category: bp.category || 'standard',
			  color: colorObj,
			  isGolden: bp.isGolden || false
			};
		  }).filter(bp => bp !== null);
		  
		  // Als er geen valide blueprints zijn, reset naar standard
		  if (ownedDeckBlueprints.length === 0) {
			console.warn('No valid blueprints loaded, resetting to standard deck');
			resetDeckToStandard();
		  }
		} else {
		  resetDeckToStandard();
		}
		
		// Restore portals
		portalsActive = gameState.portalsActive || false;
		
		// Restore coins
		if (gameState.coins) {
		  initialiseCoins(gameState.coins.length);
		} else {
		  initialiseCoins();
		}
		resetCoins();
		if (gameState.coins) {
		  const coinElements = Array.from(document.querySelectorAll('#collected-coins .coin'));
		  gameState.coins.forEach((coinData, index) => {
			if (coinElements[index]) {
			  if (coinData.active) coinElements[index].classList.add('active');
			  if (coinData.used) coinElements[index].classList.add('used');
			}
		  });
		  updateCoinCounter();
		}
		
		// Helper functie om card instance te herstellen
		function restoreCardInstance(cardData) {
		  const colorObj = cardData.color ? 
			(cardData.color.isGolden ? 
			  { name: cardData.color.name, code: cardData.color.code, isGolden: true } : 
			  colors.find(c => c.name === cardData.color.name) || cardData.color
			) : null;
		  
		  return {
			id: cardData.id || nextCardInstanceId(),
			blueprintId: cardData.blueprintId,
			shapeName: cardData.shapeName,
			matrix: cardData.matrix,
			category: cardData.category || 'standard',
			color: colorObj,
			isGolden: cardData.isGolden || false
		  };
		}
		
		// Prepareer saved deck state voor gebruik in startLevel
		savedDeckState = {
		  drawPile: gameState.drawPile ? gameState.drawPile.map(restoreCardInstance) : [],
		  discardPile: gameState.discardPile ? gameState.discardPile.map(restoreCardInstance) : [],
		  currentHand: gameState.currentHand ? gameState.currentHand.map(restoreCardInstance) : [],
		  turnCount: gameState.turnCount || 0
		};
		
		// Als alle kaarten in discard zitten (einde van een ronde), herstel ze naar draw pile
		if (savedDeckState.drawPile.length === 0 && savedDeckState.currentHand.length === 0 && savedDeckState.discardPile.length > 0) {
		  console.log('ðŸ“¦ All cards in discard, moving to draw pile for fresh start');
		  savedDeckState.drawPile = shuffleArray(savedDeckState.discardPile);
		  savedDeckState.discardPile = [];
		}
		
		console.log('ðŸ“¦ Prepared saved deck state:', savedDeckState.drawPile.length, 'draw,', savedDeckState.currentHand.length, 'hand,', savedDeckState.discardPile.length, 'discard');
		
		// Start the loaded level (zal savedDeckState gebruiken)
		isLoadingGame = true;
		startLevel(currentLevel);
		// If the save includes a board snapshot, apply it (sanitized) so structure is restored
		try {
			if (gameState.boardHtml) {
				const htmlToApply = (typeof sanitizeBoardHtml === 'function') ? sanitizeBoardHtml(gameState.boardHtml) : gameState.boardHtml;
				applyBoardHtmlToGame(htmlToApply);
			}
		} catch (e) { console.error('Failed to apply saved board snapshot after startLevel', e); }
		isLoadingGame = false;
		savedDeckState = null; // Clear na gebruik
		
		updateBonusInventoryUI();
		
		console.log('âœ… Game loaded successfully!');
		return true;
	  } catch (error) {
		console.error('âŒ Failed to load game:', error);
		return false;
	  }
	}

	function clearSaveData() {
	  try {
		localStorage.removeItem('locusGameSave');
		console.log('ðŸ—‘ï¸ Save data cleared');
		return true;
	  } catch (error) {
		console.error('âŒ Failed to clear save data:', error);
		return false;
	  }
	}

	function startNewRun() {
	  hideAllModals();
	  
	  // Reset alle upgrades
	  Object.keys(UPGRADES).forEach(key => {
		UPGRADES[key].purchased = false;
	  });
	  
	  // Reset portals
	  portalsActive = false;
	  clearPortals();
	  
	  // Reset bonussen
	  BONUS_ORDER.forEach(colorKey => {
		bonusInventory[colorKey] = 0;
		bonusMasteryState[colorKey] = false;
	  });
	  updateBonusInventoryUI();
	  resetDeckToStandard();
	  resetCoins();
	  addCoin();
	  
	  // Reset alle scores naar 0
	  document.querySelectorAll('#scoreboard .score').forEach(el => {
		el.textContent = '0';
	  });
	  const totalScoreEl = document.getElementById('total-score');
	  if (totalScoreEl) totalScoreEl.textContent = '0';
	  
	  // Reset blue zone scored rows tracking
	  window['blue-grid-scoredRows'] = new Map();
	  window['blue-grid-scoredTargets'] = new Map();
	  window['blue-grid-rowPlacements'] = new Map();
	  window['blue-grid-placementScorings'] = new Map();
	  try { window._locusEditorApplied = false; } catch (e) {}
	  // Clear per-grid editor-applied markers
	  try {
		document.querySelectorAll('.grid').forEach(g => {
			try { if (g && g.dataset && g.dataset.editorApplied) delete g.dataset.editorApplied; } catch (e) {}
		});
	  } catch (e) {}
	  
	  // Reset coinsAwardedFromScore
	  if (typeof coinsAwardedFromScore !== 'undefined') coinsAwardedFromScore = 0;
	  
	  startLevel(1);
	}

	function completeRound() {
	  if (currentHand.length !== 0 || drawPile.length !== 0) {
		return;
	  }
		const score = Number(document.getElementById('total-score')?.textContent || '0') || 0;
		const coinsBeforeBonus = getSpendableCoinCount();
		grantRoundScoreCoins(score);
		const coinsAfterBonus = getSpendableCoinCount();
		const bonusCoins = Math.max(0, coinsAfterBonus - coinsBeforeBonus);
		const coins = coinsAfterBonus;
		const objectiveCleared = isCurrentObjectiveCompleted();
		const success = objectiveCleared;
		lastRoundFailureReason = success ? null : 'objective';
		showRoundModal(success, score, coins, bonusCoins);
	}

	function finalizeRoundCompletion() {
		let handWasDiscarded = false;
		if (currentHand.length > 0) {
			const objectiveComplete = isCurrentObjectiveCompleted();
			if (cardsPlayedThisTurn === 0 && !objectiveComplete) return;
			discardCurrentHand();
			handWasDiscarded = true;
		}
		cardsPlayedThisTurn = 0;
		if (!handWasDiscarded) {
			renderCurrentHand();
		}
		completeRound();
	}

	let selectedShape = null;
	let selectedColor = null;
	let floatingPreviewActive = false;
	let suppressCardSelectUntil = 0;
	let desktopHoverDragActive = false;
	let suppressDesktopDropUntil = 0;

	function cancelDesktopHoverDragKeepSelection({ showPreview = false } = {}) {
		if (!desktopHoverDragActive) return;
		const overlay = document.getElementById('drag-overlay');
		try { draggedBlock?.remove(); } catch {}
		draggedBlock = null;
		draggedShape = null;
		draggedColor = null;
		lastZone = null;
		lastBaseX = lastBaseY = null;
		desktopHoverDragActive = false;
		suppressDesktopDropUntil = 0;
		endPointerDragTracking();
		if (overlay) overlay.style.display = 'none';
		document.body.classList.remove('dragging');
		document.body.style.cursor = '';
		document.documentElement.style.cursor = '';
		stopGlobalDragVisuals();
		removeCardControlButtons();
		if (showPreview && selectedShape && selectedColor) {
			showFloatingPreview(selectedShape, selectedColor);
		}
	}

	function startDesktopHoverDragFromSelection(cardEl, shape, color) {
		if (!cardEl || !shape || !color) return;
		// Desktop mouse UX: click-to-pickup (no on-card option buttons, no floating preview)
		hideFloatingPreview();
		removeCardControlButtons();
		// If a drag block exists, remove it without clearing selection.
		if (draggedBlock) {
			const overlay = document.getElementById('drag-overlay');
			try { draggedBlock.remove(); } catch {}
			draggedBlock = null;
			draggedShape = null;
			draggedColor = null;
			lastZone = null;
			lastBaseX = lastBaseY = null;
			endPointerDragTracking();
			if (overlay) overlay.style.display = 'none';
			document.body.classList.remove('dragging');
			document.body.style.cursor = '';
			document.documentElement.style.cursor = '';
			stopGlobalDragVisuals();
		}

		const rect = cardEl.getBoundingClientRect();
		const startX = rect.left + (rect.width / 2);
		const startY = rect.top + (rect.height / 2);
		const centerOffsets = computeShapeCenterOffsets(shape);

		const block = makeDraggable(shape, color);
		offsetX = centerOffsets.offsetX;
		offsetY = centerOffsets.offsetY;
		block.style.left = `${startX - offsetX}px`;
		block.style.top = `${startY - offsetY}px`;

		draggedBlock = block;
		draggedShape = block._shape || shape;
		draggedColor = color;
		lastZone = null;
		lastBaseX = lastBaseY = null;

		desktopHoverDragActive = true;
		suppressDesktopDropUntil = Date.now() + 250;

		const overlay = document.getElementById('drag-overlay');
		if (overlay && !overlay.contains(block)) {
			overlay.appendChild(block);
			overlay.style.display = 'block';
		}
		beginPointerDrag({ clientX: startX, clientY: startY, pointerId: null });
		startGlobalDragVisuals();
	}

	function selectCard(card, shape, color, options = {}) {
		if (!card) return;
		if (card.classList.contains('selection-disabled') && card !== selectedCardElement) return;
		const forceDrag = !!options.forceDrag;
		const isMobileLayout = isMobileViewport();
		const isTouchDevice = ('ontouchstart' in window || navigator.maxTouchPoints > 0);
		// Touch UX: alleen een draggable block spawnen als forceDrag true is (bij slepen/long-press).
		// Een normale tap moet alleen selecteren en floating preview + control buttons tonen.
		const shouldSpawnBlock = forceDrag;
		const isSameCard = (selectedCardElement === card) || (!!selectedCardId && !!card?.dataset?.cardId && selectedCardId === card.dataset.cardId);
		if (isSameCard && !forceDrag) {
			cancelDesktopHoverDragKeepSelection({ showPreview: false });
			// Clear any selected styling (DOM can be re-rendered, so be defensive).
			document.querySelectorAll('.card-option.selected').forEach(el => el.classList.remove('selected'));
			selectedCardId = null;
			selectedCardElement = null;
			selectedShape = null;
			selectedColor = null;
			if (rotateButton) rotateButton.disabled = true;
			if (mirrorButton) mirrorButton.disabled = true;
			if (draggedBlock) cleanupDragState({ clearBonus: false });
			hideFloatingPreview();
			removeCardControlButtons();
			// UX: deselecting a card should also exit zoomed-in view.
			closeZoom();
			applyTurnCardLocks();
			// Voorkom dat een snelle tweede klik direct weer selecteert
			suppressCardSelectUntil = Date.now() + 500;
			return;
		}
		// For any other selection, respect suppression windows.
		if (Date.now() < suppressCardSelectUntil) return;
		// If we are starting a drag from the currently selected card, remove the old drag
		// block without clearing the card selection.
		if (isSameCard && forceDrag && draggedBlock) {
			const overlay = document.getElementById('drag-overlay');
			try { draggedBlock.remove(); } catch {}
			draggedBlock = null;
			draggedShape = null;
			draggedColor = null;
			lastZone = null;
			lastBaseX = lastBaseY = null;
			endPointerDragTracking();
			if (overlay) overlay.style.display = 'none';
			document.body.classList.remove('dragging');
			document.body.style.cursor = '';
			document.documentElement.style.cursor = '';
			stopGlobalDragVisuals();
			removeCardControlButtons();
		}
		if (draggedBlock) cleanupDragState({ clearBonus: false });
		document.querySelectorAll('.card-option').forEach(c => c.classList.remove('selected'));
		removeCardControlButtons();
		card.classList.add('selected');
		const cardData = card.cardData;
		const currentShape = cardData?.matrix || card.cardShape || shape;
		const currentColor = cardData?.color || card.cardColor || color;
		selectedCardId = card.dataset.cardId || null;
		selectedCardElement = card;
		selectedShape = currentShape;
		selectedColor = currentColor;
		if (rotateButton) rotateButton.disabled = false;
		if (mirrorButton) mirrorButton.disabled = false;
		// Keep cards switchable; only apply turn-based locks (golden vs normal) + playability.
		applyTurnCardLocks();

		// Desktop mouse UX: click-to-pickup (hover follow) without option buttons.
		// Touch UX: selection doesn't spawn a loose draggable copy; touch uses drag or floating preview.
		if (!shouldSpawnBlock) {
			if (isMobileLayout) {
				autoZoomToColorZone(currentColor);
				// Mobile: toon floating preview + control buttons
				showFloatingPreview(currentShape, currentColor);
				addCardControlButtons();
			} else if (isTouchDevice) {
				// Large-screen touch devices (iPad): floating preview + control buttons voor draaien/spiegelen
				showFloatingPreview(currentShape, currentColor);
				addCardControlButtons();
			} else {
				startDesktopHoverDragFromSelection(card, currentShape, currentColor);
			}
			// Keep UI consistent: ensure controls can be used right after selecting.
			if (rotateButton) rotateButton.disabled = false;
			if (mirrorButton) mirrorButton.disabled = false;
			return;
		}

	// Auto-zoom naar de juiste zone op basis van kleur (altijd op mobiel)
	if (isMobileLayout) {
		autoZoomToColorZone(currentColor);
	}

	// Maak het blok direct draggable vanaf de kaart positie
	const block = makeDraggable(currentShape, currentColor);
	const rect = card.getBoundingClientRect();
	const shapeWidth = currentShape?.[0]?.length || 1;
	const shapeHeight = currentShape?.length || 1;
	const hasPointerPos = Number.isFinite(options.clientX) && Number.isFinite(options.clientY);
	const centerOffsets = computeShapeCenterOffsets(currentShape);

	if (forceDrag && hasPointerPos) {
		// Force-drag: start at pointer position (mouse or touch long-press).
		offsetX = centerOffsets.offsetX;
		offsetY = centerOffsets.offsetY;
		const touchOffsetY = isTouchDevice ? 60 : 0;
		block.style.left = `${options.clientX - offsetX}px`;
		block.style.top = `${options.clientY - offsetY - touchOffsetY}px`;
		const overlay = document.getElementById('drag-overlay');
		if (overlay && !overlay.contains(block)) {
			overlay.appendChild(block);
			overlay.style.display = 'block';
		}
	} else if (isMobileLayout) {
		offsetX = centerOffsets.offsetX;
		offsetY = centerOffsets.offsetY;
		const touchOffsetY = isTouchDevice ? 60 : 0;
		let startX = rect.left + (rect.width / 2);
		let startY = rect.top + (rect.height / 2);
		if (hasPointerPos) {
			startX = options.clientX;
			startY = options.clientY;
		}
		block.style.left = `${startX - offsetX}px`;
		block.style.top = `${startY - offsetY - touchOffsetY}px`;
		// Show the draggable immediately on touch (no need to lift finger first).
		if (isTouchDevice) {
			const overlay = document.getElementById('drag-overlay');
			if (overlay && !overlay.contains(block)) {
				overlay.appendChild(block);
				overlay.style.display = 'block';
			}
		}
	} else {
		block.style.left = `${rect.left}px`;
		block.style.top = `${rect.top}px`;
		offsetX = 0;
		offsetY = 0;
	}

	draggedBlock = block;
	draggedShape = block._shape || selectedShape;
	draggedColor = selectedColor;
	lastZone = null;
	lastBaseX = lastBaseY = null;
	if (forceDrag) {
		beginPointerDrag({
			clientX: hasPointerPos ? options.clientX : (rect.left + rect.width / 2),
			clientY: hasPointerPos ? options.clientY : (rect.top + rect.height / 2),
			pointerId: options.pointerId || null
		});
		startGlobalDragVisuals();
	}

	// Voor touch devices op mobiel: toon direct transform buttons bij het blok
	if (isTouchDevice && isCoarsePointer()) {
		addCardControlButtons();
	}
}

// EN:
// - FIX: When a dragged block is active, it can sit on top of the card UI and
//   â€œeatâ€ the click, so clicking the same selected card won't toggle/cancel.
//   This capture-phase handler peeks *under* the dragged block and cancels
//   if the user clicked the currently selected card.
document.addEventListener('pointerdown', ev => {
	if (!draggedBlock) return;
	if (ev.button !== 0) return;

	// Prefer desktop/mouse behavior; on touch devices users already have a cancel button.
	const isTouchDevice = ('ontouchstart' in window || navigator.maxTouchPoints > 0);
	if (isTouchDevice) return;

	const x = ev.clientX;
	const y = ev.clientY;

	const prevPointerEvents = draggedBlock.style.pointerEvents;
	draggedBlock.style.pointerEvents = 'none';
	const underlying = document.elementFromPoint(x, y);
	draggedBlock.style.pointerEvents = prevPointerEvents || '';

	const clickedCard = underlying ? underlying.closest('.card-option') : null;
	if (!clickedCard) return;

	// Clicking a card should always clear the sticky block.
	// If it's the currently selected card, toggle it off (deselect).
	if (selectedCardElement && clickedCard === selectedCardElement) {
		ev.preventDefault();
		ev.stopPropagation();
		cleanupDragState({ clearBonus: false, hidePreview: true });
		selectCard(clickedCard);
		return;
	}

	// Other card: clear the block but allow the click to continue so the new card selects.
	cleanupDragState({ clearBonus: false, hidePreview: true });
}, true);
	function addCardControlButtons() {
		const isMobileLayout = window.innerWidth <= MOBILE_BREAKPOINT;
		const isTouchDevice = ('ontouchstart' in window || navigator.maxTouchPoints > 0);
		// Desktop mouse UX: no on-card option buttons.
		if (!isMobileLayout && !isTouchDevice) return;
		if (desktopHoverDragActive) return;
		// Skip control buttons for purchased placement (1x1 block doesn't need rotate/mirror)
		if (activeBonusPlacement && activeBonusPlacement.purchasedPlacement) return;

		// If this is a bonus draggable (or we have an activeBonusPlacement), do not show mirror button
		const isBonusDrag = !!( (draggedBlock && draggedBlock.classList && draggedBlock.classList.contains('bonus-draggable')) || (activeBonusPlacement && activeBonusPlacement.colorKey) );
		
		// Check of buttons al bestaan
		let rotateBtn = document.querySelector('.card-control-rotate');
		let mirrorBtn = document.querySelector('.card-control-mirror');
		let cancelBtn = document.querySelector('.card-control-cancel');
		
		if (!rotateBtn) {
			// Maak rotate button
			rotateBtn = document.createElement('button');
			rotateBtn.className = 'card-control-btn card-control-rotate';
			rotateBtn.innerHTML = 'â†»';
			rotateBtn.title = 'Draai blok';
			rotateBtn.setAttribute('aria-label', 'Draai blok');
			
			const handleRotate = (e) => {
				e.preventDefault();
				e.stopPropagation();
				e.stopImmediatePropagation();
				rotateSelectedCard();
			};
			
			rotateBtn.addEventListener('click', handleRotate);
			rotateBtn.addEventListener('touchend', handleRotate);
			rotateBtn.addEventListener('mousedown', (e) => {
				e.preventDefault();
				e.stopPropagation();
				e.stopImmediatePropagation();
			});
			rotateBtn.addEventListener('touchstart', (e) => {
				e.preventDefault();
				e.stopPropagation();
				e.stopImmediatePropagation();
			});
			rotateBtn.addEventListener('pointerdown', (e) => {
				e.preventDefault();
				e.stopPropagation();
				e.stopImmediatePropagation();
			});
			document.body.appendChild(rotateBtn);
		}
		
		if (!mirrorBtn) {
			// Maak mirror button
			mirrorBtn = document.createElement('button');
			mirrorBtn.className = 'card-control-btn card-control-mirror';
			mirrorBtn.innerHTML = 'â‡„';
			mirrorBtn.title = 'Spiegel blok';
			mirrorBtn.setAttribute('aria-label', 'Spiegel blok');
			
			const handleMirror = (e) => {
				e.preventDefault();
				e.stopPropagation();
				e.stopImmediatePropagation();
				mirrorSelectedCard();
			};
			
			mirrorBtn.addEventListener('click', handleMirror);
			mirrorBtn.addEventListener('touchend', handleMirror);
			mirrorBtn.addEventListener('mousedown', (e) => {
				e.preventDefault();
				e.stopPropagation();
				e.stopImmediatePropagation();
			});
			mirrorBtn.addEventListener('touchstart', (e) => {
				e.preventDefault();
				e.stopPropagation();
				e.stopImmediatePropagation();
			});
			mirrorBtn.addEventListener('pointerdown', (e) => {
				e.preventDefault();
				e.stopPropagation();
				e.stopImmediatePropagation();
			});
			document.body.appendChild(mirrorBtn);
		}
		
		if (!cancelBtn) {
			// Maak cancel button
			cancelBtn = document.createElement('button');
			cancelBtn.className = 'card-control-btn card-control-cancel';
			cancelBtn.innerHTML = 'Ã—';
			cancelBtn.title = 'Annuleer selectie';
			cancelBtn.setAttribute('aria-label', 'Annuleer selectie');
			
			const handleCancel = (e) => {
				e.preventDefault();
				e.stopPropagation();
				e.stopImmediatePropagation();
				// Verwijder het gedraaide tetris blok
				if (draggedBlock) {
					try { draggedBlock.remove(); } catch {}
					draggedBlock = null;
					draggedShape = null;
					draggedColor = null;
				}
				if (activeBonusPlacement) {
					cancelActiveBonusPlacement({ hidePreview: true });
				} else if (selectedCardElement) {
					selectCard(selectedCardElement); // Toggle off
				}
				hideFloatingPreview();
				closeZoom();
				removeCardControlButtons();
			};
			
			cancelBtn.addEventListener('click', handleCancel);
			cancelBtn.addEventListener('touchend', handleCancel);
			cancelBtn.addEventListener('mousedown', (e) => {
				e.preventDefault();
				e.stopPropagation();
				e.stopImmediatePropagation();
			});
			cancelBtn.addEventListener('touchstart', (e) => {
				e.preventDefault();
				e.stopPropagation();
				e.stopImmediatePropagation();
			});
			cancelBtn.addEventListener('pointerdown', (e) => {
				e.preventDefault();
				e.stopPropagation();
				e.stopImmediatePropagation();
			});
			document.body.appendChild(cancelBtn);
		}
		
				// Maak buttons zichtbaar. For touch-initiated bonus drags we may delay
				// the mirror button until release (activeBonusPlacement.delayedControls).
				rotateBtn.classList.add('visible');
				cancelBtn.classList.add('visible');
				const isDelayingMirror = !!(activeBonusPlacement && activeBonusPlacement.delayedControls && isTouchDevice);
				if (!isDelayingMirror && !isBonusDrag) {
					mirrorBtn.classList.add('visible');
					mirrorBtn.disabled = false;
					try { delete mirrorBtn.dataset.delayed; } catch (e) { mirrorBtn.dataset.delayed = ''; }
				} else {
					// Keep mirror hidden and disabled until later
					mirrorBtn.classList.remove('visible');
					mirrorBtn.disabled = true;
					mirrorBtn.dataset.delayed = 'true';
				}

		// Position buttons for touch devices:
		if (isTouchDevice) {
			// Helper to clamp horizontal positions within viewport
			const clampX = (x, w=44) => Math.max(8, Math.min((window.innerWidth - (w + 8)), Math.round(x)));
			const clampY = (y, h=44) => Math.max(8, Math.min((window.innerHeight - (h + 8)), Math.round(y)));
			const applyDynamicPos = (btn) => {
				if (!btn) return;
				btn.classList.add('dynamic-pos');
				btn.style.right = 'auto';
				btn.style.marginLeft = '0px';
			};
			const clearDynamicPos = (btn) => {
				if (!btn) return;
				btn.classList.remove('dynamic-pos');
				btn.style.removeProperty('right');
				btn.style.removeProperty('margin-left');
			};
			if (draggedBlock) {
				// Place controls directly under the dragged block (centered)
				try {
					const rect = draggedBlock.getBoundingClientRect();
					const centerX = rect.left + (rect.width / 2);
					// Prefer below the block; if too close to bottom, move above.
					let y = rect.bottom + 8;
					if (y + 44 + 8 > window.innerHeight) y = rect.top - 8 - 44;
					y = clampY(y);
					// Determine which buttons are visible
					const visibleBtns = [];
					if (cancelBtn) visibleBtns.push(cancelBtn);
					if (rotateBtn) visibleBtns.push(rotateBtn);
					// mirrorBtn may be hidden/disabled for bonus drags
					if (mirrorBtn && mirrorBtn.classList.contains('visible') && !mirrorBtn.dataset.delayed) visibleBtns.push(mirrorBtn);
					// Clear dynamic positioning for hidden buttons
					[rotateBtn, mirrorBtn, cancelBtn].forEach(btn => {
						if (!btn) return;
						if (visibleBtns.includes(btn)) applyDynamicPos(btn);
						else clearDynamicPos(btn);
					});
					const count = visibleBtns.length || 1;
					// spacing adapts to viewport but stays reasonable
					const spacing = Math.max(56, Math.min(96, Math.round(window.innerWidth * 0.12)));
					const startX = centerX - spacing * (count - 1) / 2;
					for (let i = 0; i < count; i++) {
						const btn = visibleBtns[i];
						if (!btn) continue;
						btn.style.left = clampX(startX + i * spacing) + 'px';
						btn.style.top = y + 'px';
						btn.style.bottom = 'auto';
					}
				} catch (e) {}
			} else {
				// Desktop touch: anchor controls to bottom center for both portrait and landscape
				const centerX = Math.round(window.innerWidth / 2);
				const bottomVal = 'calc(var(--bottom-bar-height) + 10px)';
				// Determine visible buttons for bottom layout
				const visibleBtns = [];
				if (cancelBtn) visibleBtns.push(cancelBtn);
				if (rotateBtn) visibleBtns.push(rotateBtn);
				if (mirrorBtn && mirrorBtn.classList.contains('visible') && !mirrorBtn.dataset.delayed) visibleBtns.push(mirrorBtn);
				[rotateBtn, mirrorBtn, cancelBtn].forEach(btn => {
					if (!btn) return;
					if (visibleBtns.includes(btn)) applyDynamicPos(btn);
					else clearDynamicPos(btn);
				});
				const count = visibleBtns.length || 1;
				const spacing = Math.max(56, Math.min(96, Math.round(window.innerWidth * 0.12)));
				const startX = centerX - spacing * (count - 1) / 2;
				for (let i = 0; i < count; i++) {
					const btn = visibleBtns[i];
					if (!btn) continue;
					btn.style.left = clampX(startX + i * spacing) + 'px';
					btn.style.bottom = bottomVal;
					btn.style.top = 'auto';
				}
			}
		}
	}

	function removeCardControlButtons() {
		// Verberg alle card control buttons
			const buttons = document.querySelectorAll('.card-control-btn');
			buttons.forEach(btn => {
				btn.classList.remove('visible');
				btn.classList.remove('dynamic-pos');
				// Clear any inline positioning applied for touch mode so CSS can take over again.
				btn.style.removeProperty('left');
				btn.style.removeProperty('top');
				btn.style.removeProperty('bottom');
				btn.style.removeProperty('right');
				btn.style.removeProperty('margin-left');
			});
	}

	function rotateSelectedCard() {
	  if (activeBonusPlacement) {
		// Roteer de shape in activeBonusPlacement
		const currentShape = selectedShape || draggedShape;
		if (!currentShape) return;
		const newShape = rotateShape(currentShape);
		selectedShape = newShape;
		activeBonusPlacement.shape = cloneShape(newShape);
		if (draggedBlock) {
			// Preserve visual center so the bonus block rotates in-place and never disappears.
			const nextShape = cloneShape(newShape);
			draggedShape = nextShape;
			draggedBlock._shape = nextShape;
			try {
				const beforeRect = draggedBlock.getBoundingClientRect();
				const centerX = beforeRect.left + beforeRect.width / 2;
				const centerY = beforeRect.top + beforeRect.height / 2;
				renderBlock(draggedBlock, nextShape, draggedColor || selectedColor);
				const afterRect = draggedBlock.getBoundingClientRect();
				if (Number.isFinite(centerX) && Number.isFinite(centerY) && afterRect.width > 0 && afterRect.height > 0) {
					draggedBlock.style.left = `${centerX - afterRect.width / 2}px`;
					draggedBlock.style.top = `${centerY - afterRect.height / 2}px`;
				}
			} catch (e) {
				renderBlock(draggedBlock, nextShape, draggedColor || selectedColor);
			}
			try {
				const overlay = document.getElementById('drag-overlay');
				if (overlay) {
					if (!overlay.contains(draggedBlock)) overlay.appendChild(draggedBlock);
					overlay.style.display = 'block';
				}
			} catch (e) {}
			draggedBlock.style.opacity = '1';
			draggedBlock.style.visibility = '';
			if (!draggedBlock.style.position) draggedBlock.style.position = 'fixed';
			draggedBlock.style.zIndex = draggedBlock.style.zIndex || '10000';
			try { addCardControlButtons(); } catch (e) {}
		} else if (draggedShape) {
			draggedShape = cloneShape(newShape);
		}
		if (floatingPreviewActive) updateFloatingPreview(newShape, draggedColor || selectedColor);
		if (lastZone) {
		  clearPreview(lastZone);
		  lastBaseX = null;
		  lastBaseY = null;
		}
		return;
	  }
	  if (!selectedShape || !selectedColor) return;
	  const selectedCard = selectedCardElement || document.querySelector('.card-option.selected');
	  if (!selectedCard) return;
	  const newShape = rotateShape(selectedShape);
	  selectedShape = newShape;
	  const cardData = selectedCard.cardData;
	  if (cardData) cardData.matrix = newShape;
	  selectedCard.cardShape = newShape;
	  const cardColor = cardData?.color || selectedCard.cardColor || selectedColor;
	  selectedCard.cardColor = cardColor;
	  updateCardPattern(selectedCard, newShape, cardColor);
	  applyCardSizing();
	  
	  // Update floating preview direct met nieuwe shape
	  if (floatingPreviewActive) {
		updateFloatingPreview(selectedShape, selectedColor);
	  }
	  
	// If a draggable block exists (e.g. sticky preview), always keep it in sync.
	// Preserve the visual center so the block doesn't jump or disappear on touch.
	// Do NOT rely on object identity between color objects.
	if (draggedBlock) {
		try {
			const beforeRect = draggedBlock.getBoundingClientRect();
			const centerX = beforeRect.left + beforeRect.width / 2;
			const centerY = beforeRect.top + beforeRect.height / 2;
			const nextShape = cloneShape(newShape);
			draggedShape = nextShape;
			draggedBlock._shape = nextShape;
			renderBlock(draggedBlock, nextShape, draggedColor || selectedColor);
			// After re-render, reposition so the center remains under the finger
			const afterRect = draggedBlock.getBoundingClientRect();
			if (Number.isFinite(centerX) && Number.isFinite(centerY) && afterRect.width > 0 && afterRect.height > 0) {
				draggedBlock.style.left = `${centerX - afterRect.width / 2}px`;
				draggedBlock.style.top = `${centerY - afterRect.height / 2}px`;
			}
			draggedBlock.style.opacity = '1';
			draggedBlock.style.visibility = '';
			if (!draggedBlock.style.position) draggedBlock.style.position = 'fixed';
			draggedBlock.style.zIndex = draggedBlock.style.zIndex || '10000';
		} catch (e) {
			const nextShape = cloneShape(newShape);
			draggedShape = nextShape;
			draggedBlock._shape = nextShape;
			renderBlock(draggedBlock, nextShape, draggedColor || selectedColor);
		}
		// Recompute center offsets so placement/drag uses the transformed shape correctly.
		({ offsetX, offsetY } = computeShapeCenterOffsets(draggedShape));
		if (lastZone) {
			clearPreview(lastZone);
			lastBaseX = null;
			lastBaseY = null;
		}
	}
	}

	function mirrorSelectedCard() {
		// If controls were deliberately delayed for a touch-initiated bonus drag,
		// ignore mirror actions until the controls are revealed on release.
		if (activeBonusPlacement && activeBonusPlacement.delayedControls) return;

		if (activeBonusPlacement) {
		// Spiegel de shape in activeBonusPlacement
		const currentShape = selectedShape || draggedShape;
		if (!currentShape) return;
		const newShape = mirrorShape(currentShape);
		selectedShape = newShape;
		activeBonusPlacement.shape = cloneShape(newShape);
		if (draggedBlock) {
			const nextShape = cloneShape(newShape);
			draggedShape = nextShape;
			draggedBlock._shape = nextShape;
			try { liftToBody(draggedBlock); } catch (e) {}
			renderBlock(draggedBlock, nextShape, draggedColor || selectedColor);
		} else if (draggedShape) {
			draggedShape = cloneShape(newShape);
		}
		if (floatingPreviewActive) updateFloatingPreview(newShape, draggedColor || selectedColor);
		if (lastZone) {
		  clearPreview(lastZone);
		  lastBaseX = null;
		  lastBaseY = null;
		}
		return;
	  }
	  if (!selectedShape || !selectedColor) return;
	  const selectedCard = selectedCardElement || document.querySelector('.card-option.selected');
	  if (!selectedCard) return;
	  const newShape = mirrorShape(selectedShape);
	  selectedShape = newShape;
	  const cardData = selectedCard.cardData;
	  if (cardData) cardData.matrix = newShape;
	  selectedCard.cardShape = newShape;
	  const cardColor = cardData?.color || selectedCard.cardColor || selectedColor;
	  selectedCard.cardColor = cardColor;
	  updateCardPattern(selectedCard, newShape, cardColor);
	  applyCardSizing();
	  
	  // Update floating preview direct met nieuwe shape
	  if (floatingPreviewActive) {
		updateFloatingPreview(selectedShape, selectedColor);
	  }
	  
	  if (draggedBlock) {
			// Preserve visual center so block doesn't jump or disappear on touch
			try {
				const beforeRect = draggedBlock.getBoundingClientRect();
				const centerX = beforeRect.left + beforeRect.width / 2;
				const centerY = beforeRect.top + beforeRect.height / 2;
				const nextShape = cloneShape(newShape);
				draggedShape = nextShape;
				draggedBlock._shape = nextShape;
				try { liftToBody(draggedBlock); } catch (e) {}
				renderBlock(draggedBlock, nextShape, draggedColor || selectedColor);
				// After re-render, reposition so the center remains under the finger
				const afterRect = draggedBlock.getBoundingClientRect();
				if (Number.isFinite(centerX) && Number.isFinite(centerY) && afterRect.width > 0 && afterRect.height > 0) {
					draggedBlock.style.left = `${centerX - afterRect.width / 2}px`;
					draggedBlock.style.top = `${centerY - afterRect.height / 2}px`;
				}
				draggedBlock.style.opacity = '1';
				draggedBlock.style.visibility = '';
				if (!draggedBlock.style.position) draggedBlock.style.position = 'fixed';
				draggedBlock.style.zIndex = draggedBlock.style.zIndex || '10000';
			} catch (e) {
				const nextShape = cloneShape(newShape);
				draggedShape = nextShape;
				draggedBlock._shape = nextShape;
				renderBlock(draggedBlock, nextShape, draggedColor || selectedColor);
			}
		({ offsetX, offsetY } = computeShapeCenterOffsets(nextShape));
		if (lastZone) {
			clearPreview(lastZone);
			lastBaseX = null;
			lastBaseY = null;
		}
	  }
}

// Helper functie om beide shape manipulation buttons te enablen/disablen
function setShapeButtonsEnabled(enabled) {
  if (rotateButton) rotateButton.disabled = !enabled;
  if (mirrorButton) mirrorButton.disabled = !enabled;
}

// ========================================
// FLOATING PREVIEW VOOR TOUCH DEVICES
// ========================================

function showFloatingPreview(shape, color, options = {}) {
		const preview = document.getElementById('floating-preview');
		if (!preview) return;

		const isNarrowMobile = window.innerWidth <= 650;
		const isBonusPreview = !!(activeBonusPlacement || options.useDefaultPosition);
		// Phone UX: the floating preview box is redundant (card already shows the shape) and
		// looks bad when it can't align perfectly with the card. Keep it only for bonus placement.
		if (isNarrowMobile && !isBonusPreview) {
			hideFloatingPreview();
			return;
		}

		floatingPreviewActive = true;
		updateFloatingPreview(shape, color);
		preview.style.display = 'flex';

		// Hide mirror control for bonus previews (we don't allow mirroring bonus blocks)
		try {
			const mirrorBtnEl = document.getElementById('floating-preview-mirror');
			if (mirrorBtnEl) {
				if (isBonusPreview) {
					mirrorBtnEl.style.display = 'none';
				} else {
					mirrorBtnEl.style.display = '';
				}
			}
		} catch (e) {}

		const shouldPinAboveBottomBar = (window.innerWidth <= 650) || document.body.classList.contains('zoomed-in');
		const baseTransform = (isBonusPreview || shouldPinAboveBottomBar) ? 'translate(-50%, 0)' : 'none';
		const targetScale = isBonusPreview ? 0.55 : 1;
		const startScale = isBonusPreview ? 0.48 : 0.85;
		preview.dataset.baseTransform = baseTransform;

		const rootStyle = getComputedStyle(document.documentElement);
		const bottomBarHeight = parseFloat(rootStyle.getPropertyValue('--bottom-bar-height'));
		const fallbackBottomBarHeight = parseFloat(rootStyle.getPropertyValue('--bottom-height'));
		const effectiveBottomBarHeight = Number.isFinite(bottomBarHeight)
			? bottomBarHeight
			: (Number.isFinite(fallbackBottomBarHeight) ? fallbackBottomBarHeight : 150);

		// Positioneer preview: boven de bottom bar (mobiel/zoom), anders op kaart positie (tenzij bonus placement)
		if (shouldPinAboveBottomBar) {
			// Zet de preview net boven de bottom bar zodat rotate/mirror/cancel niet over de zoomed zone vallen.
			preview.style.top = 'auto';
			preview.style.left = '50%';
			preview.style.right = 'auto';
			const viewportH = Math.round((window.visualViewport && window.visualViewport.height) ? window.visualViewport.height : window.innerHeight);
			const extraDrop = (viewportH <= 650) ? 26 : 6;
			preview.style.bottom = `${Math.round(effectiveBottomBarHeight - extraDrop)}px`;
		} else if (isBonusPreview) {
			// Bonus: klein en onderin, gecentreerd
			preview.style.top = 'auto';
			preview.style.left = '50%';
			preview.style.bottom = '22px';
			preview.style.right = 'auto';
		} else if (selectedCardElement) {
			// Kaart selectie: positioneer op de kaart
			const cardRect = selectedCardElement.getBoundingClientRect();
			preview.style.left = `${cardRect.left + (cardRect.width / 2) - 69}px`; // 69 = halve breedte preview
			preview.style.top = `${cardRect.top + (cardRect.height / 2) - 90}px`; // 90 = halve hoogte preview
			preview.style.bottom = 'auto';
			preview.style.right = 'auto';
		}

		preview.style.transform = `${baseTransform} scale(${startScale})`;
		preview.style.opacity = '0.9';

		// Animeer in
		setTimeout(() => {
			preview.style.transform = `${baseTransform} scale(${targetScale})`;
			preview.style.opacity = '1';
		}, 10);
	}

	function hideFloatingPreview() {
		const preview = document.getElementById('floating-preview');
		if (!preview) return;

		floatingPreviewActive = false;
		preview.style.display = 'none';
		const baseTransform = preview.dataset.baseTransform || 'none';
		preview.style.transform = `${baseTransform} scale(0.8)`;
		preview.style.opacity = '0';
	}

	function updateFloatingPreview(shape, color) {
		const patternContainer = document.getElementById('floating-preview-pattern');
		if (!patternContainer) return;

		// Clear oude pattern
		patternContainer.innerHTML = '';

		// Bereken cell size: als we gezoomd zijn of dit een bonus-preview is,
		// meet de werkelijke celgrootte uit de actieve zoomzone en gebruik die
		// zodat de preview overeenkomt met wat de gebruiker ziet op het bord.
		const rows = shape.length;
		const cols = shape[0].length;
		let cellSize = 0;
		let gapPx = 2;
		try {
			if (document.body.classList.contains('zoomed-in') && typeof activeZoomZone !== 'undefined' && activeZoomZone) {
				cellSize = Math.round(getActualCellSize(activeZoomZone));
				const metrics = getBoardCellMetrics();
				gapPx = metrics.gap || 2;
			}
		} catch (e) {
			cellSize = 0;
		}

		// Fallback: keep the old small container-based sizing when not zoomed
		if (!cellSize || !Number.isFinite(cellSize) || cellSize <= 8) {
			const maxDim = Math.max(rows, cols);
			const containerSize = 76; // 100px - 24px padding
			cellSize = Math.max(8, Math.floor(containerSize / maxDim) - 2);
			gapPx = 2;
		}

		// Maak grid voor het pattern
		const grid = document.createElement('div');
		grid.style.display = 'grid';
		grid.style.gap = `${gapPx}px`;
		grid.style.gridTemplateColumns = `repeat(${cols}, ${cellSize}px)`;
		grid.style.gridTemplateRows = `repeat(${rows}, ${cellSize}px)`;

		// Haal color code op (kan object of string zijn)
		const colorCode = (typeof color === 'object' && color.code) ? color.code : color;

		// Render cellen
		shape.forEach((row, y) => {
			row.forEach((val, x) => {
				const cell = document.createElement('div');
				cell.style.width = `${cellSize}px`;
				cell.style.height = `${cellSize}px`;
				cell.style.borderRadius = '3px';
				
				if (val === 1) {
					cell.style.background = colorCode;
					cell.style.border = '1px solid rgba(0,0,0,0.2)';
					cell.style.boxShadow = '0 1px 3px rgba(0,0,0,0.2)';
				} else {
					cell.style.background = 'transparent';
				}
				
				grid.appendChild(cell);
			});
		});

		patternContainer.appendChild(grid);
	}

	// ========================================
	// ZOOM-LENS VOOR PLAATSING PREVIEW
	// ========================================
	
	function showZoomLens(x, y, zone, baseX, baseY, shape, color, isValid) {
		const lens = document.getElementById('placement-zoom-lens');
		if (!lens) return;
		
		// Bepaal welk grid we moeten tonen
		let targetZone = zone;
		
		// Als er een actieve zoom zone is, gebruik die (tenzij het een rood subgrid is)
		if (activeZoomZone) {
			if (activeZoomZone.id === 'red-zone') {
				// Als we in de red-zone zitten, gebruik het specifieke subgrid
				if (zone && zone.dataset && zone.dataset.subgrid) {
					targetZone = zone; // Gebruik het specifieke rood subgrid
				} else {
					targetZone = activeZoomZone; // Fallback naar parent
				}
			} else {
				// Voor andere zones: gebruik de actieve gezoomde zone
				targetZone = activeZoomZone;
			}
		}
		// Als geen activeZoomZone: gewoon het huidige zone gebruiken
		
		// Positioneer lens links van touch punt (zodat vinger niet in de weg zit)
		const lensWidth = 160;
		const lensHeight = 160;
		const offset = 20; // Extra marge
		
		// Probeer eerst links van de vinger
		let lensX = x - lensWidth - offset;
		let lensY = y - (lensHeight / 2); // Verticaal gecentreerd op touch punt
		
		// Als niet genoeg ruimte links, probeer rechts
		if (lensX < 10) {
			lensX = x + offset;
		}
		
		// Als nog steeds niet past, force links met minimum marge
		if (lensX + lensWidth > window.innerWidth - 10) {
			lensX = Math.max(10, x - lensWidth - offset);
		}

		// Voorkom dat lens verticaal buiten scherm gaat
		lensY = Math.max(10, Math.min(window.innerHeight - lensHeight - 10, lensY));

		lens.style.left = `${lensX}px`;
		lens.style.top = `${lensY}px`;
		lens.style.display = 'block';
		lens.style.opacity = '1';

		// Render de zoom inhoud met de juiste zone
		updateZoomLensContent(targetZone, baseX, baseY, shape, color, isValid);
	}

	function hideZoomLens() {
		const lens = document.getElementById('placement-zoom-lens');
		if (!lens) return;
		lens.style.display = 'none';
		lens.style.opacity = '0';
	}

	function updateZoomLensContent(zone, baseX, baseY, shape, color, isValid) {
		const content = document.getElementById('zoom-lens-content');
		if (!content) return;

		content.innerHTML = '';

		// Vind het grid element
		let targetGrid = zone;
		if (zone.dataset && zone.dataset.subgrid) {
			// Dit is een rood subgrid
			targetGrid = zone;
		} else if (zone.classList.contains('grid')) {
			targetGrid = zone;
		} else {
			// Zoek .grid binnen de zone
			const gridChild = zone.querySelector('.grid');
			if (gridChild) targetGrid = gridChild;
		}

		// Bereken het gebied dat we moeten tonen (shape gebied + kleine marge)
		const shapeRows = shape.length;
		const shapeCols = shape[0].length;
		const margin = 1;
		
		const viewStartX = Math.max(0, baseX - margin);
		const viewStartY = Math.max(0, baseY - margin);
		const viewEndX = baseX + shapeCols + margin;
		const viewEndY = baseY + shapeRows + margin;

		// Get een sample cell om de grootte te bepalen
		const sampleCell = targetGrid.querySelector('.cell:not(.void-cell)');
		if (!sampleCell) {
			content.innerHTML = '<div style="padding: 20px; text-align: center; color: #999; font-size: 11px;">Wachten...</div>';
			return;
		}
		
		const cellRect = sampleCell.getBoundingClientRect();
		const cellSize = cellRect.width;

		// Maak een nieuwe container voor de lens inhoud
		const lensContainer = document.createElement('div');
		lensContainer.style.position = 'relative';
		lensContainer.style.width = `${(viewEndX - viewStartX) * cellSize}px`;
		lensContainer.style.height = `${(viewEndY - viewStartY) * cellSize}px`;
		lensContainer.style.margin = 'auto';
		
		// Get alle cellen in het target grid
		const allCells = targetGrid.querySelectorAll('.cell');
		const colorCode = (typeof color === 'object' && color.code) ? color.code : color;
		const colorName = (typeof color === 'object' && color.name) ? color.name : 'unknown';
		
		let visibleCount = 0;
		
		allCells.forEach(cell => {
			const cellX = parseInt(cell.dataset.x, 10);
			const cellY = parseInt(cell.dataset.y, 10);
			
			// Skip cellen buiten ons view gebied of void cells
			if (isNaN(cellX) || isNaN(cellY) ||
			    cellX < viewStartX || cellX >= viewEndX ||
			    cellY < viewStartY || cellY >= viewEndY ||
			    cell.classList.contains('void-cell')) {
				return;
			}
			
			visibleCount++;
			
			// Clone de cel voor in de lens
			const cellClone = cell.cloneNode(true);
			cellClone.style.position = 'absolute';
			cellClone.style.left = `${(cellX - viewStartX) * cellSize}px`;
			cellClone.style.top = `${(cellY - viewStartY) * cellSize}px`;
			cellClone.style.width = `${cellSize}px`;
			cellClone.style.height = `${cellSize}px`;
			cellClone.style.boxSizing = 'border-box';
			
			// Check of deze cel deel uitmaakt van de te plaatsen shape
			const shapeRelX = cellX - baseX;
			const shapeRelY = cellY - baseY;
			const isInShape = shapeRelY >= 0 && shapeRelY < shapeRows &&
			                  shapeRelX >= 0 && shapeRelX < shapeCols &&
			                  shape[shapeRelY][shapeRelX] === 1;

			if (isInShape) {
				// Voeg preview overlay toe - dit is de tetris block preview
				const overlay = document.createElement('div');
				overlay.style.position = 'absolute';
				overlay.style.inset = '3px'; // Kleine marge binnen de cel
				overlay.style.pointerEvents = 'none';
				overlay.style.zIndex = '10';
				overlay.style.borderRadius = '3px';
				
				if (isValid) {
					// Groene rand voor geldige plaatsing
					if (colorName === 'multikleur') {
						overlay.style.background = 'linear-gradient(135deg, rgba(240,98,114,0.8), rgba(255,242,90,0.8), rgba(78,211,70,0.8), rgba(93,144,240,0.8), rgba(163,94,255,0.8))';
					} else {
						overlay.style.backgroundColor = colorCode;
						overlay.style.opacity = '0.7';
					}
					overlay.style.border = '3px solid #4CAF50';
					overlay.style.boxShadow = '0 0 8px rgba(76, 175, 80, 1), inset 0 0 6px rgba(255,255,255,0.5)';
				} else {
					// Rode rand voor ongeldige plaatsing
					overlay.style.backgroundColor = '#ff5252';
					overlay.style.opacity = '0.65';
					overlay.style.border = '3px solid #f44336';
					overlay.style.boxShadow = '0 0 8px rgba(244, 67, 54, 1)';
				}
				
				cellClone.appendChild(overlay);
			}
			
			lensContainer.appendChild(cellClone);
		});

		if (visibleCount === 0) {
			content.innerHTML = '<div style="padding: 20px; text-align: center; color: #999; font-size: 11px;">Geen cellen</div>';
			return;
		}

		// Wrapper voor centreren en overflow
		const wrapper = document.createElement('div');
		wrapper.style.width = '100%';
		wrapper.style.height = '100%';
		wrapper.style.display = 'flex';
		wrapper.style.alignItems = 'center';
		wrapper.style.justifyContent = 'center';
		wrapper.style.overflow = 'hidden';
		wrapper.style.borderRadius = '12px';
		wrapper.appendChild(lensContainer);

		content.appendChild(wrapper);
	}

	// Touch handlers voor floating preview
	(function initFloatingPreviewHandlers() {
		/*
			EN:
			- WHY: â€œFloating previewâ€ is a touch-friendly mini-panel that lets the user rotate/mirror/cancel,
			  and also initiate a drag by grabbing the preview itself.
			- DUPLICATE: rotate/mirror/cancel exists in multiple UI paths (keyboard, wheel, buttons).
			- STATE: interacts with `selectedShape/Color`, `draggedBlock/Shape/Color`, `floatingPreviewActive`.
		*/
		const preview = document.getElementById('floating-preview');
		const rotateBtn = document.getElementById('floating-preview-rotate');
		const mirrorBtn = document.getElementById('floating-preview-mirror');
		const cancelBtn = document.getElementById('floating-preview-cancel');

		if (!preview || !rotateBtn || !mirrorBtn || !cancelBtn) return;

		// Rotate button
		rotateBtn.addEventListener('click', (e) => {
			e.stopPropagation();
			rotateSelectedCard();
		});

		// Mirror button
		mirrorBtn.addEventListener('click', (e) => {
			e.stopPropagation();
			mirrorSelectedCard();
		});

		// Cancel button
		cancelBtn.addEventListener('click', (e) => {
			e.stopPropagation();
			if (activeBonusPlacement) {
				cancelActiveBonusPlacement({ hidePreview: true });
			} else if (selectedCardElement) {
				selectCard(selectedCardElement); // Toggle off (dit verbergt preview al)
			}
			hideFloatingPreview(); // Verberg altijd bij cancel button
			removeCardControlButtons(); // Verberg control buttons
			closeZoom();
		});

		// Drag vanaf preview
		let dragStarted = false;
		let startX, startY;

		preview.addEventListener('pointerdown', (e) => {
			/*
				EN:
				- WHY: Start a drag by grabbing the floating preview panel.
				- STATE: creates the same draggable block as normal card drag.
				- NOTE: Uses pointer capture so the drag continues even if finger leaves the element.
			*/
			// Negeer als we een button raken
			if (e.target.closest('button')) return;

			e.preventDefault();
			dragStarted = true;
			startX = e.clientX;
			startY = e.clientY;

			preview.classList.add('dragging');
			preview.setPointerCapture(e.pointerId);

			// Start drag: maak draggable block
			if (selectedShape && selectedColor && !draggedBlock) {
				const block = makeDraggable(selectedShape, selectedColor);
				const rect = preview.getBoundingClientRect();
				block.style.left = `${rect.left}px`;
				block.style.top = `${rect.top}px`;

				draggedBlock = block;
				draggedShape = block._shape || selectedShape;
				draggedColor = selectedColor;
				beginPointerDrag({ clientX: e.clientX, clientY: e.clientY, pointerId: e.pointerId });
				startGlobalDragVisuals();

				// Set offset zodat blok net boven vinger verschijnt
				({ offsetX, offsetY } = computeShapeCenterOffsets(draggedShape));
				offsetY += 40; // +40px zodat blok boven vinger verschijnt
			}
		});

		preview.addEventListener('pointermove', (e) => {
			/*
				EN:
				- WHY: Instead of duplicating the entire drag logic here, we synthesize a `pointermove`
				  and dispatch it on `document`, so the main drag handler runs.
				- DUPLICATE/OVERRIDE RISK: This depends on the document-level pointermove handler being present
				  and on event ordering. If multiple document pointermove handlers exist, behavior can change.
			*/
			if (!dragStarted) return;

			const deltaX = Math.abs(e.clientX - startX);
			const deltaY = Math.abs(e.clientY - startY);

			// Als we genoeg bewogen hebben, behandel als drag
			if (deltaX > 5 || deltaY > 5) {
				// Trigger het normale drag systeem
				const moveEvent = new PointerEvent('pointermove', {
					clientX: e.clientX,
					clientY: e.clientY,
					bubbles: true
				});
				document.dispatchEvent(moveEvent);
			}
		});

		preview.addEventListener('pointerup', (e) => {
			if (!dragStarted) return;

			dragStarted = false;
			preview.classList.remove('dragging');
			
			const deltaX = Math.abs(e.clientX - startX);
			const deltaY = Math.abs(e.clientY - startY);

			// Als we nauwelijks bewogen, behandel als tap
			if (deltaX < 5 && deltaY < 5) {
				// Optioneel: highlight preview of doe niets
			}
		});

		preview.addEventListener('pointercancel', () => {
			dragStarted = false;
			preview.classList.remove('dragging');
		});
	})();

	// ========================================
	// TAP-TO-PLACE VOOR TOUCH DEVICES
	// ========================================
	document.addEventListener('click', (e) => {
		/*
			EN:
			- WHY: On touch devices, allow â€œtap a cell to place the selected cardâ€ instead of dragging.
			- STATE: requires `floatingPreviewActive` + `selectedShape` + `selectedColor`.
			- OVERRIDE/DUPLICATE RISK: This is a global document click handler and can conflict with:
			  - zoom close click handler
			  - menu close click handler
			  - per-cell click toggles (e.g. debug mode)
			  Use `stopPropagation()` carefully.
		*/
		// Alleen actief als we een kaart geselecteerd hebben EN floating preview zichtbaar is
		if (!floatingPreviewActive || !selectedShape || !selectedColor) return;
		
		// Check of we op een cell klikken
		const cell = e.target.closest('.cell');
		if (!cell || cell.classList.contains('void-cell') || cell.dataset.disabled === 'true') return;

		// Check of we in een zone zijn
		const zone = cell.closest('.zone');
		if (!zone || zone.classList.contains('zone-placeholder')) return;

		// Negeer clicks op buttons, controls, etc
		if (e.target.closest('button') || e.target.closest('#card-choice-zone') || 
			e.target.closest('#controls') || e.target.closest('#floating-preview')) return;

		// Stop event zodat toggleCell niet triggert
		e.preventDefault();
		e.stopPropagation();

		// Probeer te plaatsen
		const baseX = parseInt(cell.dataset.x, 10) || 0;
		const baseY = parseInt(cell.dataset.y, 10) || 0;

		// Check of plaatsing valid is
		if (canPlace(zone, selectedShape, baseX, baseY)) {
			// Plaats het blok
			placeShapeOnGrid(zone, selectedShape, baseX, baseY, selectedColor);
			
			// Clean up - bonus placement heeft speciale cleanup
			if (activeBonusPlacement) {
				cancelActiveBonusPlacement({ updateInventory: true });
			} else {
				if (selectedCardElement) {
					selectedCardElement.classList.remove('selected');
				}
			}
			
			selectedCardId = null;
			selectedCardElement = null;
			selectedShape = null;
			selectedColor = null;
			hideFloatingPreview();
			removeCardControlButtons();
			
			// Voer na-plaatsing logica uit
			if (rotateButton) rotateButton.disabled = true;
			if (mirrorButton) mirrorButton.disabled = true;
			updateTurnState();
		} else {
			// Visual feedback dat plaatsing invalid is
			// Preview uitgeschakeld
			// showPreview(zone, selectedShape, baseX, baseY, false);
			// setTimeout(() => clearPreview(zone), 300;
		}
	}, true); // Use capture phase zodat we voor andere handlers triggeren

	// ========================================
	// ZONE INFO POPOVERS ("i" linksboven)
	// ========================================
	(() => {
		const getCurrentWorld = () => {
			try {
				if (typeof getWorldAndSubLevel === 'function') {
					return Number(getWorldAndSubLevel(currentLevel)?.world || 1) || 1;
				}
				return Number(currentWorld || 1) || 1;
			} catch {
				return 1;
			}
		};

		const WORLD_INFO = {
			1: {
				paars: '<strong>Paars</strong>: Maak clusters van aaneengesloten paarse cellen. (8 punten per connectie van dikgedrukte cellen)',
				geel: '<strong>Geel</strong>: Je scoort als je een volledige kolom vult. (start vanaf dikgedrukte cellen)',
				groen: '<strong>Groen</strong>: Activeer eindcellen om punten te verdienen. (start vanaf dikgedrukte cel)',
				rood: '<strong>Rood</strong>: Elk klein rood grid dat volledig gevuld is levert punten op. (2 punten per cel)',
				blauw: '<strong>Blauw</strong>: Per rij waarin minstens Ã©Ã©n vetgedrukte cel actief is scoor je oplopende punten. (eerste rij lager, elke volgende rij hoger).'
			},
			2: {
				paars: '<strong>Paars</strong>: Maak clusters van aaneengesloten paarse cellen. Verbindingen met vetgedrukte cellen scoren extra: buitenring (20 per verbinding) en binnenste vetgedrukte cellen (8 per verbinding).',
				geel: '<strong>Geel</strong>: Je scoort als je een diagonale lijn vult. (start vanaf dikgedrukte cellen)',
				groen: '<strong>Groen</strong>: Activeer eindcellen. Eindcellen verder van de start leveren doorgaans meer punten op.',
				rood: '<strong>Rood</strong>: Elk klein rood grid dat volledig gevuld is levert punten op. (2 punten per cel)',
				blauw: '<strong>Blauw</strong>: Per rij waarin minstens Ã©Ã©n vetgedrukte cel actief is scoor je oplopende punten. (eerste rij lager, elke volgende rij hoger).'
			}
		};

		const getZoneKey = (zoneEl) => {
			if (!zoneEl) return null;
			if (zoneEl.id === 'purple-zone') return 'paars';
			if (zoneEl.id === 'yellow-zone') return 'geel';
			if (zoneEl.id === 'green-zone') return 'groen';
			if (zoneEl.id === 'red-zone') return 'rood';
			if (zoneEl.id === 'blue-zone') return 'blauw';
			return zoneEl.dataset.color || null;
		};

		const closeAll = () => {
			document.querySelectorAll('.zone[data-info-open="true"]').forEach(zone => {
				zone.dataset.infoOpen = 'false';
				const btn = zone.querySelector('.zone-info-btn');
				const pop = zone.querySelector('.zone-info-popover');
				if (btn) btn.setAttribute('aria-expanded', 'false');
				if (pop) pop.setAttribute('aria-hidden', 'true');
			});
		};

		const openZoneInfo = (zone, btn) => {
			if (!zone || !btn) return;
			const key = getZoneKey(zone);
			const world = getCurrentWorld();
			const pop = zone.querySelector('.zone-info-popover');
			const html = WORLD_INFO[world]?.[key] || WORLD_INFO[1]?.[key] || '';
			if (pop) {
				pop.innerHTML = html;
				pop.setAttribute('aria-hidden', 'false');
			}
			zone.dataset.infoOpen = 'true';
			btn.setAttribute('aria-expanded', 'true');
		};

		const maybeCloseZoneInfo = (zone, relatedTarget) => {
			if (!zone) return;
			if (relatedTarget && (relatedTarget.closest('.zone-info-popover') || relatedTarget.closest('.zone') === zone)) return;
			zone.dataset.infoOpen = 'false';
			const btn = zone.querySelector('.zone-info-btn');
			const pop = zone.querySelector('.zone-info-popover');
			if (btn) btn.setAttribute('aria-expanded', 'false');
			if (pop) pop.setAttribute('aria-hidden', 'true');
		};

		document.addEventListener('mouseover', (event) => {
			const btn = event.target.closest('.zone-info-btn');
			if (!btn) return;
			const zone = btn.closest('.zone');
			if (!zone) return;
			closeAll();
			openZoneInfo(zone, btn);
		}, true);

		document.addEventListener('mouseout', (event) => {
			const btn = event.target.closest('.zone-info-btn');
			if (!btn) return;
			const zone = btn.closest('.zone');
			if (!zone) return;
			maybeCloseZoneInfo(zone, event.relatedTarget);
		}, true);

		// If the pointer entered the popover and then leaves it (or leaves the zone entirely),
		// the button won't receive mouseout again. Close based on leaving the whole zone.
		document.addEventListener('mouseout', (event) => {
			const zone = event.target.closest('.zone');
			if (!zone) return;
			if (zone.dataset.infoOpen !== 'true') return;
			const toEl = event.relatedTarget;
			if (toEl && (toEl.closest('.zone') === zone || toEl.closest('.zone-info-popover'))) return;
			maybeCloseZoneInfo(zone, toEl);
		}, true);

		document.addEventListener('focusin', (event) => {
			const btn = event.target.closest('.zone-info-btn');
			if (!btn) return;
			const zone = btn.closest('.zone');
			if (!zone) return;
			closeAll();
			openZoneInfo(zone, btn);
		}, true);

		document.addEventListener('focusout', (event) => {
			const btn = event.target.closest('.zone-info-btn');
			if (!btn) return;
			const zone = btn.closest('.zone');
			if (!zone) return;
			maybeCloseZoneInfo(zone, event.relatedTarget);
		}, true);

		document.addEventListener('pointerdown', (event) => {
			if (event.target.closest('.zone') || event.target.closest('.zone-info-popover')) return;
			closeAll();
		}, true);

		document.addEventListener('keydown', (event) => {
			if (event.key === 'Escape') closeAll();
		}, true);
	})();

	rotateButton = document.getElementById('rotate-card-btn');
	if (rotateButton) {
	  rotateButton.addEventListener('click', event => {
		event.stopPropagation();
		rotateSelectedCard();
	  });
	  rotateButton.disabled = true;
	}

	mirrorButton = document.getElementById('mirror-card-btn');
	if (mirrorButton) {
	  mirrorButton.addEventListener('click', event => {
		event.stopPropagation();
		mirrorSelectedCard();
	  });
	  mirrorButton.disabled = true;
	}

	const bonusShopBtn = document.getElementById('bonus-shop-btn');
	if (bonusShopBtn) {
	  bonusShopBtn.style.display = 'none';
	}

	if (deckPreviewEl) {
	  deckPreviewEl.addEventListener('click', event => {
		event.preventDefault();
		event.stopPropagation();
		openDeckModal();
	  });
	  deckPreviewEl.addEventListener('keydown', event => {
		if (event.key === 'Enter' || event.key === ' ') {
		  event.preventDefault();
		  openDeckModal();
		}
	  });
	}

	if (deckModalClose) {
	  deckModalClose.addEventListener('click', event => {
		event.preventDefault();
		closeDeckModal();
	  });
	}

	if (deckModalLayer) {
	  deckModalLayer.addEventListener('click', event => {
		if (event.target === deckModalLayer) {
		  closeDeckModal();
		}
	  });
	}

	if (blackHoleClaimBtn) {
	  blackHoleClaimBtn.addEventListener('click', event => {
		event.preventDefault();
		claimBlackHoleReward();
	  });
	}

	if (blackHoleForfeitBtn) {
	  blackHoleForfeitBtn.addEventListener('click', event => {
		event.preventDefault();
		forfeitBlackHoleChallenge();
	  });
	}

	if (blackHoleModalLayer) {
	  blackHoleModalLayer.addEventListener('click', event => {
		if (event.target === blackHoleModalLayer) {
		  forfeitBlackHoleChallenge();
		}
	  });
	}

	const newCardsButton = document.getElementById('new-cards-btn');
	if (newCardsButton) {
	  newCardsButton.addEventListener('click', event => {
		event.stopPropagation();
		if (drawPile.length === 0) {
		  // End of round: warn about playable cards AND remaining bonuses.
		  if (shouldWarnBeforeCompletingRound()) {
			showCompleteRoundConfirm(finalizeRoundCompletion);
		  } else {
			finalizeRoundCompletion();
		  }
		  return;
		}
		if (currentHand.length > 0) {
		  // Next hand: ONLY warn about playable cards (no bonus-only warnings).
		  const hasPlayableCards = currentHand.some(card => card && isCardPlayable(card));
		  if (hasPlayableCards) {
			showDiscardHandConfirm(() => {
			  discardCurrentHand();
			  drawNextHand();
			  updateDeckPreview();
			});
			return;
		  }
		  discardCurrentHand();
		}
		drawNextHand();
		updateDeckPreview();
	  });
	}

	const debugToggleBtn = document.getElementById('debug-mode-toggle');
	const newGameBtn = document.getElementById('new-game-btn');
	const persistedDebug = localStorage.getItem('debugModeEnabled') === 'true';
	setDebugMode(persistedDebug);
	if (debugToggleBtn) {
		debugToggleBtn.addEventListener('click', event => {
			event.preventDefault();
			toggleDebugMode();
		});
	}
	
	// Nieuw Spel button en modal handlers
	const confirmNewGameLayer = document.getElementById('confirm-new-game-layer');
	const confirmNewGameYes = document.getElementById('confirm-new-game-yes');
	const confirmNewGameNo = document.getElementById('confirm-new-game-no');
	
	function showNewGameConfirm() {
		if (confirmNewGameLayer) {
			confirmNewGameLayer.classList.add('show');
		}
	}
	
	function hideNewGameConfirm() {
		if (confirmNewGameLayer) {
			confirmNewGameLayer.classList.remove('show');
		}
	}
	
	if (newGameBtn) {
		newGameBtn.addEventListener('click', event => {
			event.preventDefault();
			showNewGameConfirm();
		});
	}
	
	if (confirmNewGameYes) {
		confirmNewGameYes.addEventListener('click', () => {
			hideNewGameConfirm();
			clearSaveData();
			startNewRun();
		});
	}
	
	if (confirmNewGameNo) {
		confirmNewGameNo.addEventListener('click', () => {
			hideNewGameConfirm();
		});
	}
	
	if (confirmNewGameLayer) {
		confirmNewGameLayer.addEventListener('click', event => {
			if (event.target === confirmNewGameLayer) {
				hideNewGameConfirm();
			}
		});
	}

	// Print instellingen + printvriendelijke output (geen screenshot)
	const printBtn = document.getElementById('print-btn');
	const printSettingsLayer = document.getElementById('print-settings-layer');
	const printSettingsClose = document.getElementById('print-settings-close');
	const printSettingsCancel = document.getElementById('print-settings-cancel');
	const printSettingsPrint = document.getElementById('print-settings-print');
	const printSettingsPreview = document.getElementById('print-settings-preview');
	const printOptLight = document.getElementById('print-opt-light');
	const printOptNoBonuses = document.getElementById('print-opt-no-bonuses');
	const editorBtn = document.getElementById('menu-editor-btn');

	function showPrintSettings() {
		if (!printSettingsLayer) return;
		printSettingsLayer.classList.add('show');
		printSettingsLayer.setAttribute('aria-hidden', 'false');
	}
	function hidePrintSettings() {
		if (!printSettingsLayer) return;
		printSettingsLayer.classList.remove('show');
		printSettingsLayer.setAttribute('aria-hidden', 'true');
	}
	function getPrintSettings() {
		const selected = document.querySelector('input[name="print-board-source"]:checked');
		const source = selected ? String(selected.value) : 'current';
		return {
			source,
			lightMode: !!(printOptLight && printOptLight.checked),
			noBonuses: !!(printOptNoBonuses && printOptNoBonuses.checked)
		};
	}

	function stripBoardForLowInk(rootEl) {
		if (!rootEl) return;
		rootEl.querySelectorAll('.zone-info-btn,.zone-info-popover,h2').forEach(el => el.remove());
		rootEl.querySelectorAll('.symbol,.trap-symbol,.coin-icon,.coin').forEach(el => el.remove());
		// Remove classes that imply heavy fills; print CSS will further normalize.
		rootEl.querySelectorAll('.cell.gold-cell').forEach(el => el.classList.remove('gold-cell'));
		rootEl.querySelectorAll('.cell.trap-cell').forEach(el => el.classList.remove('trap-cell'));
	}

	function buildPrintBoardFromCurrent(noBonuses) {
		const board = document.getElementById('board');
		if (!board) return '';
		const columns = Array.from(board.children).filter(el => el && el.classList && el.classList.contains('column'));
		const playColumns = columns.slice(0, 3);
		const wrapper = document.createElement('div');
		wrapper.className = 'board';
		playColumns.forEach(col => wrapper.appendChild(col.cloneNode(true)));
		if (noBonuses) stripBoardForLowInk(wrapper);
		return wrapper.outerHTML;
	}

	// External editor bridge (separate page): send a snapshot of the current playfield.
	const LOCUS_EDITOR_STORAGE_KEY = 'locusEditorBoardHtml';
	function getEditorBoardHtml() {
		// Editor wants the full playfield; do not strip bonuses/symbols here.
		try {
			return buildPrintBoardFromCurrent(false);
		} catch (e) {
			const board = document.getElementById('board');
			return board ? board.outerHTML : '';
		}
	}

	// Apply a board HTML snapshot into the current game DOM by replacing known grids.
	function applyBoardHtmlToGame(boardHtml) {
		if (!boardHtml) return;
		try {
			const temp = document.createElement('div');
			temp.innerHTML = boardHtml;
			// helper: ensure absolute-positioned root grids have a real layout box
			function ensureAbsoluteContainerSizing(containerEl, srcEl) {
				if (!containerEl) return;
				// Determine the zone ID for this container
				const zone = containerEl.closest('.zone');
				const zoneId = containerEl.id || (zone ? zone.id : '') || '';
				
				// Root grids (green/red) must render with absolute-positioned children.
				// Editor exports may omit inline `position/left/top`, so we reconstruct them from data-x/y or data-c/r.
				function ensureAbsoluteCells(targetEl) {
					if (!targetEl) return;
					const cells = Array.from(targetEl.querySelectorAll('.cell'));
					// Determine columns from dataset or by counting cells in each row
					let fallbackCols = (() => {
						const n = parseInt(String(targetEl.dataset && targetEl.dataset.cols || ''), 10);
						return Number.isFinite(n) && n > 0 ? n : 0;
					})();
					// If no cols in dataset, try to infer from cell count and rows, or use sqrt heuristic
					if (!fallbackCols && cells.length > 0) {
						const rowsAttr = parseInt(String(targetEl.dataset && targetEl.dataset.rows || ''), 10);
						if (Number.isFinite(rowsAttr) && rowsAttr > 0) {
							fallbackCols = Math.ceil(cells.length / rowsAttr);
						} else {
							// Use sqrt heuristic for square-ish grids
							fallbackCols = Math.ceil(Math.sqrt(cells.length));
						}
					}
					cells.forEach((cell, idx) => {
						try {
							if (!cell || !cell.style) return;
							// Ensure absolute positioning
							if (!cell.style.position || cell.style.position === 'relative') {
								cell.style.position = 'absolute';
							}
							let x = Number(cell.dataset.x ?? cell.dataset.c);
							let y = Number(cell.dataset.y ?? cell.dataset.r);
							// Fallback: derive coordinates from DOM order if needed (only if missing)
							if (!Number.isFinite(x) || !Number.isFinite(y)) {
								if (fallbackCols > 0) {
									x = Number.isFinite(x) ? x : (idx % fallbackCols);
									y = Number.isFinite(y) ? y : Math.floor(idx / fallbackCols);
									// Store derived coordinates in dataset for later use
									cell.dataset.x = String(x);
									cell.dataset.y = String(y);
								}
							}
							// Ensure zoneId is set for game logic
							if (zoneId && !cell.dataset.zoneId) {
								cell.dataset.zoneId = zoneId;
							}
							// Only set left/top if they are missing (preserve existing positions)
							if (!cell.style.left && Number.isFinite(x)) {
								cell.style.left = `calc(${x} * var(--cell-size))`;
							}
							if (!cell.style.top && Number.isFinite(y)) {
								cell.style.top = `calc(${y} * var(--cell-size))`;
							}
						} catch (e) {}
					});
				}
				const readInt = (v) => {
					const n = parseInt(String(v || ''), 10);
					return Number.isFinite(n) && n > 0 ? n : 0;
				};
				let cols = readInt((containerEl.dataset && containerEl.dataset.cols) || (srcEl && srcEl.dataset && srcEl.dataset.cols));
				let rows = readInt((containerEl.dataset && containerEl.dataset.rows) || (srcEl && srcEl.dataset && srcEl.dataset.rows));
				if (!cols || !rows) {
					const cells = Array.from(containerEl.querySelectorAll('.cell:not(.void-cell)'));
					let maxX = -Infinity;
					let maxY = -Infinity;
					cells.forEach(c => {
						const x = Number(c.dataset.x ?? c.dataset.c);
						const y = Number(c.dataset.y ?? c.dataset.r);
						if (Number.isFinite(x)) maxX = Math.max(maxX, x);
						if (Number.isFinite(y)) maxY = Math.max(maxY, y);
					});
					if (!cols && Number.isFinite(maxX) && maxX >= 0) cols = maxX + 1;
					if (!rows && Number.isFinite(maxY) && maxY >= 0) rows = maxY + 1;
					if (containerEl.dataset) {
						if (cols) containerEl.dataset.cols = String(cols);
						if (rows) containerEl.dataset.rows = String(rows);
					}
				}
				// These root grids rely on absolute-positioned children; without a width/height the zone can look empty
				try { containerEl.style.position = 'relative'; } catch (e) {}
				if (cols) {
					try { containerEl.style.width = `calc(${cols} * var(--cell-size))`; } catch (e) {}
				}
				if (rows) {
					try { containerEl.style.height = `calc(${rows} * var(--cell-size))`; } catch (e) {}
				}
				// Root grids are not CSS-grid laid out; keep them as a normal block box
				try { containerEl.style.display = 'block'; } catch (e) {}
				// And ensure the children are truly placed absolutely (prevents the â€œcells under each otherâ€ symptom)
				ensureAbsoluteCells(containerEl);
			}
			// helper: remove editor-only chrome from a node
			function stripEditorChrome(node) {
				if (!node) return;
				node.querySelectorAll('.zone-handle, .grid-resizer, .zone-delete').forEach(n => n.remove());
				node.querySelectorAll('[draggable]').forEach(n => n.removeAttribute('draggable'));
			}
			// helper: copy grid content from source grid into destination grid (cleaning editor chrome)
			function copyGridContent(srcGrid, destGrid) {
				if (!srcGrid || !destGrid) return;
				stripEditorChrome(srcGrid);
				// Clone children to avoid carrying over event listeners or references
				destGrid.innerHTML = '';
				// Be robust: some older editor exports may wrap cells in extra nodes.
				const directCells = Array.from(srcGrid.querySelectorAll(':scope > .cell'));
				const cellsToCopy = directCells.length ? directCells : Array.from(srcGrid.querySelectorAll('.cell'));
				if (cellsToCopy.length) {
					cellsToCopy.forEach(ch => destGrid.appendChild(ch.cloneNode(true)));
				} else {
					Array.from(srcGrid.children || []).forEach(ch => destGrid.appendChild(ch.cloneNode(true)));
				}
				// Ensure any runtime-filled state (active) is cleared so the game starts with an empty board
				// IMPORTANT: Do NOT remove inline styles for grids using absolute positioning (green/red).
				// Those grids rely on inline left/top for cell placement.
				// Red subgrids (red-grid1, red-grid2, etc.) don't have a .grid child - cells are directly inside.
				const isGreenGrid = destGrid.id === 'green-grid' || destGrid.closest('.zone[data-color="groen"]');
				const isRedGrid = destGrid.id && destGrid.id.startsWith('red-grid') || destGrid.closest('.zone[data-color="rood"]') || destGrid.closest('.red-group') || (destGrid.dataset && destGrid.dataset.color === 'rood');
				const usesAbsolutePositioning = isGreenGrid || isRedGrid;
				
				// Determine the zone ID for this grid
				const zone = destGrid.closest('.zone');
				const zoneId = destGrid.id || (zone ? zone.id : '') || '';
				
				destGrid.querySelectorAll('.cell').forEach(cell => {
					try { cell.classList.remove('active', 'edge-cell'); } catch (e) {}
					if (!usesAbsolutePositioning) {
						try { cell.removeAttribute('style'); } catch (e) {}
					}
				});
				// copy dataset rows/cols
				if (srcGrid.dataset && srcGrid.dataset.rows) destGrid.dataset.rows = srcGrid.dataset.rows;
				if (srcGrid.dataset && srcGrid.dataset.cols) destGrid.dataset.cols = srcGrid.dataset.cols;
				// ensure grid template columns/rows match dataset or cell count (only for CSS Grid zones, not absolute-positioned ones)
				if (!usesAbsolutePositioning) {
					const cols = parseInt(destGrid.dataset.cols || '', 10) || (destGrid.querySelectorAll(':scope > .cell').length ? Math.max(1, Math.round(Math.sqrt(destGrid.querySelectorAll(':scope > .cell').length))) : 0);
					if (cols) destGrid.style.gridTemplateColumns = `repeat(${cols}, var(--cell-size))`;
					destGrid.style.gridAutoRows = 'var(--cell-size)';
					
					// CRITICAL: Ensure all cells have data-x, data-y, and data-zone-id for game logic
					const allCells = Array.from(destGrid.querySelectorAll(':scope > .cell'));
					allCells.forEach((cell, idx) => {
						const x = idx % cols;
						const y = Math.floor(idx / cols);
						cell.dataset.x = String(x);
						cell.dataset.y = String(y);
						if (zoneId) cell.dataset.zoneId = zoneId;
					});
				} else {
					// For green/red grids: derive cols/rows from cell count if not set
					const cellCount = destGrid.querySelectorAll(':scope > .cell').length;
					if (!destGrid.dataset.cols && cellCount > 0) {
						const inferred = Math.ceil(Math.sqrt(cellCount));
						destGrid.dataset.cols = String(inferred);
						destGrid.dataset.rows = String(Math.ceil(cellCount / inferred));
					}
					ensureAbsoluteContainerSizing(destGrid, srcGrid);
				}
			}
			// Map zones by color so editor IDs don't need to match game IDs
			const colors = ['paars','geel','groen','blauw'];
			colors.forEach(color => {
				const srcZone = temp.querySelector(`.zone[data-color="${color}"]`) || temp.querySelector(`#${color}-zone`);
				const destZone = document.querySelector(`.zone[data-color="${color}"]`);
				if (!destZone) return;
				if (!srcZone) {
					// Editor removed this zone â€” hide it in the game view
					destZone.style.display = 'none';
					destZone.innerHTML = '';
					return;
				} else {
					destZone.style.display = '';
				}
				const srcGrid = srcZone.querySelector(':scope > .grid') || srcZone.querySelector('.grid');
				const destGrid = destZone.querySelector(':scope > .grid') || destZone.querySelector('.grid');
				copyGridContent(srcGrid, destGrid);
				// Diagnostics: help spot missing grids/cells during editor -> game import
				try {
					const srcCount = srcGrid ? srcGrid.querySelectorAll('.cell').length : 0;
					const dstCount = destGrid ? destGrid.querySelectorAll('.cell').length : 0;
					if (String(color).toLowerCase() === 'groen' || String(color).toLowerCase() === 'blauw') {
						console.log(`ðŸ“¦ import ${color}: srcCells=${srcCount} destCells=${dstCount} srcGrid=${!!srcGrid} destGrid=${!!destGrid}`);
					}
				} catch (e) {}

				// Special handling for green zone: synchronize end-cell / start markers from the editor
				// NOTE: The game uses .bold-cell as the start marker in green, NOT .start-cell.
				// Support older boards where cells may be direct children of the zone (no .grid wrapper)
				if (String(color).toLowerCase() === 'groen') {
					try {
						// Remove any lingering start-cell markers in destination (game doesn't use them)
						const destContainerForStartRemove = destGrid || destZone;
						if (destContainerForStartRemove) destContainerForStartRemove.querySelectorAll('.cell.start-cell').forEach(n => n.classList.remove('start-cell'));

						// Collect source and destination cells robustly whether wrapped in .grid or direct children
						const srcCells = Array.from((srcGrid ? srcGrid : srcZone).querySelectorAll(':scope > .cell'));
						const destCells = Array.from((destGrid ? destGrid : destZone).querySelectorAll(':scope > .cell'));

						// Build a map of dest cells by coordinates for robust matching
						const destCellMap = new Map();
						destCells.forEach(dcell => {
							const r = dcell.dataset.r || dcell.dataset.y;
							const c = dcell.dataset.c || dcell.dataset.x;
							if (r !== undefined && c !== undefined) {
								destCellMap.set(`${r},${c}`, dcell);
							}
						});

						srcCells.forEach((scell) => {
							const r = scell.dataset.r || scell.dataset.y;
							const c = scell.dataset.c || scell.dataset.x;
							const dcell = destCellMap.get(`${r},${c}`);
							if (!dcell) return;
							const shouldBeEnd = scell.classList.contains('end-cell');
							const shouldBeStart = scell.classList.contains('start-cell') || scell.classList.contains('bold-cell');
							// Preserve end-cell state
							if (shouldBeEnd) dcell.classList.add('end-cell');
							else dcell.classList.remove('end-cell');
							// Ensure start markers in the editor become bold-cells in the game
							if (shouldBeStart && !dcell.classList.contains('bold-cell')) dcell.classList.add('bold-cell');
						});
					} catch (e) { /* ignore */ }
				}

				// Special handling for blue zone: preserve editor-placed bold-cells as start positions
				// Only use bottom-row fallback if NO bold-cells exist from the source
				if (String(color).toLowerCase() === 'blauw') {
					try {
						const srcContainer = srcGrid || srcZone;
						const destContainer = destGrid || destZone;
						if (destContainer) {
							// Check if source had any bold-cells (editor-placed start positions)
							const srcHasBoldCells = srcContainer && srcContainer.querySelectorAll('.cell.bold-cell').length > 0;
							const destHasBoldCells = destContainer.querySelectorAll('.cell.bold-cell').length > 0;
							
							// Backfill coordinate attributes if an older export used r/c instead of x/y
							destContainer.querySelectorAll('.cell').forEach(c => {
								if ((c.dataset.x == null || c.dataset.x === '') && c.dataset.c != null) c.dataset.x = String(c.dataset.c);
								if ((c.dataset.y == null || c.dataset.y === '') && c.dataset.r != null) c.dataset.y = String(c.dataset.r);
							});
							
							// Only apply bottom-row fallback if there are NO existing bold-cells
							if (!srcHasBoldCells && !destHasBoldCells) {
								const destCells = Array.from(destContainer.querySelectorAll(':scope > .cell:not(.void-cell)'));
								if (destCells.length) {
									let maxY = -Infinity;
									destCells.forEach(c => {
										const y = Number(c.dataset.y || c.dataset.r || c.dataset.y);
										if (Number.isFinite(y) && y > maxY) maxY = y;
									});
									if (maxY !== -Infinity) {
										destCells.filter(c => Number(c.dataset.y || c.dataset.r || c.dataset.y) === maxY)
											.forEach(c => { if (!c.classList.contains('bold-cell')) c.classList.add('bold-cell'); });
									}
								}
							}
						}
					} catch (e) { /* ignore */ }
				}
			});
			// Post-import: if the editor snapshot had explicit bold-cells for blue,
			// enforce that the game uses exactly those positions (avoid bottom-row fallback).
			try {
				const srcBlue = temp.querySelector('.zone[data-color="blauw"]') || temp.querySelector('#blauw-zone');
				const destBlue = document.querySelector('.zone[data-color="blauw"]');
				if (srcBlue && destBlue) {
					const srcBold = Array.from(srcBlue.querySelectorAll(':scope > .grid > .cell.bold-cell, :scope > .cell.bold-cell, .cell.bold-cell'));
					if (srcBold.length > 0) {
						// Clear existing bold markers in destination
						destBlue.querySelectorAll('.cell.bold-cell').forEach(n => n.classList.remove('bold-cell'));
						// Map dest cells by r,c or y,x for robust matching
						const destCells = Array.from(destBlue.querySelectorAll(':scope > .grid > .cell, :scope > .cell'));
						const destMap = new Map();
						destCells.forEach(d => {
							const r = d.dataset.r || d.dataset.y;
							const c = d.dataset.c || d.dataset.x;
							if (r !== undefined && c !== undefined) destMap.set(`${r},${c}`, d);
						});
						srcBold.forEach(s => {
							const r = s.dataset.r || s.dataset.y;
							const c = s.dataset.c || s.dataset.x;
							const match = destMap.get(`${r},${c}`);
							if (match) match.classList.add('bold-cell');
						});
					}
				}
			} catch (e) { /* ignore */ }
			// Handle red-group (may contain multiple sub-zones)
			// NOTE: Red subgrids use absolute positioning (like green), cells are directly in the zone (no .grid child)
			const srcRed = temp.querySelector('.zone.red-group') || temp.querySelector('.zone[data-color="rood"]');
			const destRed = document.querySelector('.zone.red-group') || document.querySelector('.zone[data-color="rood"]');
			if (!destRed) {
				// nothing to do
			} else if (!srcRed) {
				// Editor removed red-group entirely â€” hide it
				destRed.style.display = 'none';
				destRed.innerHTML = '';
			} else {
				const srcSubs = Array.from(srcRed.querySelectorAll(':scope > .zone'));
				let destSubs = Array.from(destRed.querySelectorAll(':scope > .zone'));
				// Create missing destination sub-zones if necessary
				if (destSubs.length < srcSubs.length) {
					srcSubs.slice(destSubs.length).forEach((srcSub, i) => {
						const newSub = document.createElement('div');
						newSub.className = 'zone';
						newSub.dataset.color = 'rood';
						newSub.id = srcSub.id || `red-grid${destSubs.length + i + 1}`;
						destRed.appendChild(newSub);
					});
					destSubs = Array.from(destRed.querySelectorAll(':scope > .zone'));
				}
				srcSubs.forEach((srcSub, idx) => {
					const destSub = destSubs[idx] || destSubs[destSubs.length - 1];
					if (!destSub) return;
					// Red subgrids: cells are directly in the zone, not in a .grid child
					// Check if there's a .grid child or if cells are direct children
					const srcGrid = srcSub.querySelector(':scope > .grid');
					const destGrid = destSub.querySelector(':scope > .grid');
					if (srcGrid && destGrid) {
						// Standard case with .grid child on both sides
						copyGridContent(srcGrid, destGrid);
							ensureAbsoluteContainerSizing(destGrid, srcGrid);
					} else if (srcGrid && !destGrid) {
						// Source has .grid wrapper but destination expects cells directly in the zone
						stripEditorChrome(srcSub);
						// Remove existing direct cells in dest
						destSub.querySelectorAll(':scope > .cell').forEach(c => c.remove());
						// Clone from srcGrid into destSub (direct children)
							const srcCells = Array.from(srcGrid.querySelectorAll(':scope > .cell'));
							const srcCellsToCopy = srcCells.length ? srcCells : Array.from(srcGrid.querySelectorAll('.cell'));
							srcCellsToCopy.forEach(srcCell => {
							const clone = srcCell.cloneNode(true);
							try { clone.classList.remove('active', 'edge-cell'); } catch (e) {}
							destSub.appendChild(clone);
						});
						// Copy dataset from srcGrid or srcSub if present
						if (srcGrid.dataset && srcGrid.dataset.rows) destSub.dataset.rows = srcGrid.dataset.rows;
						if (srcGrid.dataset && srcGrid.dataset.cols) destSub.dataset.cols = srcGrid.dataset.cols;
						if (srcSub.dataset && srcSub.dataset.rows) destSub.dataset.rows = srcSub.dataset.rows;
						if (srcSub.dataset && srcSub.dataset.cols) destSub.dataset.cols = srcSub.dataset.cols;
							ensureAbsoluteContainerSizing(destSub, srcGrid);
					} else if (!srcGrid && destGrid) {
						// Source has direct cells in the zone but destination expects a .grid child
						stripEditorChrome(srcSub);
						// Clear destination grid and append cloned cells into its .grid
						destGrid.innerHTML = '';
							const srcCells = Array.from(srcSub.querySelectorAll(':scope > .cell'));
							const srcCellsToCopy = srcCells.length ? srcCells : Array.from(srcSub.querySelectorAll('.cell'));
							srcCellsToCopy.forEach(srcCell => {
							const clone = srcCell.cloneNode(true);
							try { clone.classList.remove('active', 'edge-cell'); } catch (e) {}
							destGrid.appendChild(clone);
						});
						// Copy dataset into destGrid
						if (srcSub.dataset && srcSub.dataset.rows) destGrid.dataset.rows = srcSub.dataset.rows;
						if (srcSub.dataset && srcSub.dataset.cols) destGrid.dataset.cols = srcSub.dataset.cols;
							ensureAbsoluteContainerSizing(destGrid, srcSub);
					} else {
						// Neither side has a .grid wrapper: both expect direct children in the zone
						stripEditorChrome(srcSub);
						destSub.querySelectorAll(':scope > .cell').forEach(c => c.remove());
							const srcCells = Array.from(srcSub.querySelectorAll(':scope > .cell'));
							const srcCellsToCopy = srcCells.length ? srcCells : Array.from(srcSub.querySelectorAll('.cell'));
							srcCellsToCopy.forEach(srcCell => {
							const clone = srcCell.cloneNode(true);
							try { clone.classList.remove('active', 'edge-cell'); } catch (e) {}
							destSub.appendChild(clone);
						});
						if (srcSub.dataset.rows) destSub.dataset.rows = srcSub.dataset.rows;
						if (srcSub.dataset.cols) destSub.dataset.cols = srcSub.dataset.cols;
							ensureAbsoluteContainerSizing(destSub, srcSub);
					}
				});
					// Diagnostics for red import
					try {
						const dstSubCount = Array.from(destRed.querySelectorAll(':scope > .zone')).map(z => z.querySelectorAll('.cell').length);
						console.log('ðŸ“¦ import rood: subgrid cell counts', dstSubCount);
					} catch (e) {}
			}

			// Ensure any portal cells in the destination are considered start positions by marking them bold
			try {
				const allPortalDest = document.querySelectorAll('.portal-cell');
				allPortalDest.forEach(pc => { if (!pc.classList.contains('bold-cell')) pc.classList.add('bold-cell'); });
			} catch (e) { /* ignore */ }
			// Initialize trap state for imported boards so black-hole and other traps work
			try {
				// Find candidate trap cells: explicit dataset, editor trap class, or trap-symbol present
				const allCells = Array.from(document.querySelectorAll('.cell'));
				const importedTraps = allCells.filter(cell => {
					if (!cell) return false;
					if (cell.dataset && cell.dataset.trap === 'true') return true;
					if (cell.classList && cell.classList.contains('trap-cell')) return true;
					if (cell.querySelector && cell.querySelector('.trap-symbol')) return true;
					return false;
				});
				importedTraps.forEach(cell => {
					try {
						// Ensure the dataset.trap flag exists
						if (!cell.dataset) cell.dataset = {};
						if (!cell.dataset.trap || String(cell.dataset.trap) !== 'true') cell.dataset.trap = 'true';
						// Prefer explicit trapType if present, else infer from symbol/class
						if (!cell.dataset.trapType) {
							const hasBH = !!cell.querySelector('.trap-symbol.trap-symbol--black-hole');
							const hasPit = !!cell.querySelector('.trap-symbol') && !hasBH;
							if (hasBH) cell.dataset.trapType = 'blackHole';
							else if (hasPit) cell.dataset.trapType = 'pit';
						}
						const zoneId = cell.dataset.zoneId || cell.closest('.grid')?.id || '';
						// Register or release trap depending on active state
						ensureTrapState(cell, zoneId, { silent: true });
					} catch (e) { /* ignore per-cell errors */ }
				});
				// Refresh trap UI summary
				try { if (typeof renderTrapSummary === 'function') renderTrapSummary(); } catch (e) {}
			} catch (e) { /* ignore */ }
			// Final cleanup: remove any lingering editor chrome from DOM
			document.querySelectorAll('.zone-handle, .grid-resizer, .zone-delete').forEach(n => n.remove());
			// Recompute scores and UI
			if (typeof resetScoreState === 'function') resetScoreState();
			if (typeof updateScore === 'function') updateScore();
			if (typeof updateDeckPreview === 'function') updateDeckPreview();
			if (typeof renderCurrentHand === 'function') renderCurrentHand();
			// Mark that a board was applied from the external editor so runtime logic
			// can opt-in to editor-specific behaviors (e.g. blue startcells anywhere).
			try { window._locusEditorApplied = true; } catch (e) {}
			try {
				// Mark every grid element so validation can detect editor-applied boards
				document.querySelectorAll('.grid').forEach(g => {
					try { if (g && g.dataset) g.dataset.editorApplied = 'true'; } catch (e) {}
				});
			} catch (e) {}
		} catch (e) {
			console.error('applyBoardHtmlToGame failed', e);
		}
	}

	// Set the visible level title and objective in the UI when loading a custom board
	function setLoadedLevelMeta(name, objective) {
		try {
			// Persist loaded custom level metadata and compile objective once
			window.loadedCustomLevelMeta = { name: name ? String(name) : '', objective: objective == null ? '' : String(objective).trim() };
			window.loadedCustomObjectiveCompiled = null;
			window.loadedCustomLevelMetaCompleted = false;
			if (window.loadedCustomLevelMeta.objective) {
				try { window.loadedCustomObjectiveCompiled = parseObjectiveTextToObjective(window.loadedCustomLevelMeta.objective); } catch (e) { window.loadedCustomObjectiveCompiled = null; }
			}
			// Prevent built-in objectives interfering
			currentObjectiveId = null;
			const titleEl = document.querySelector('#objective-zone h2');
			const currentEl = document.getElementById('objective-current');
			if (titleEl) titleEl.textContent = window.loadedCustomLevelMeta.name || titleEl.textContent;
			let obj = window.loadedCustomLevelMeta.objective || '';
			if (!obj) obj = 'Haal 100 punten';
			if (currentEl) currentEl.innerHTML = `<strong>Doel:</strong> ${obj}`;
		} catch (e) { /* ignore */ }
	}

// --- Scenario helpers for World 4 prototypes (4.1, 4.2) ---
function buildScenarioBoardHtml(scenarioId) {
	// Build a minimal board DOM for the scenario and return outerHTML.
	const board = document.createElement('div');
	board.className = 'board';

	// Column placeholders to match main layout so applyBoardHtmlToGame maps zones correctly
	const col1 = document.createElement('div'); col1.className = 'column';
	const col2 = document.createElement('div'); col2.className = 'column';
	const col3 = document.createElement('div'); col3.className = 'column';
	const col4 = document.createElement('div'); col4.className = 'column';

	// For 4.1: rectangular green + wide blue
	if (scenarioId === '4.1') {
		// Green zone (placed in column 2) â€” larger, slightly irregular field
		const gz = document.createElement('div'); gz.className = 'zone'; gz.dataset.color = 'groen'; gz.id = 'green-zone';
		const gg = document.createElement('div'); gg.className = 'grid'; gg.id = 'green-grid'; gg.dataset.rows = '10'; gg.dataset.cols = '10';
		for (let y=0;y<10;y++) for (let x=0;x<10;x++) { const c = document.createElement('div'); c.className='cell'; c.dataset.x=String(x); c.dataset.y=String(y);
			// carve a few void pockets for visual interest
			if ((x===0 || x===9) && (y<2 || y>7)) c.classList.add('void-cell');
			if ((y===0 || y===9) && (x<2 || x>7)) c.classList.add('void-cell');
			gg.appendChild(c); }
		gz.appendChild(gg);
		col2.appendChild(gz);

		// Blue zone (column 3) wide rectangle with varied bands
		const bz = document.createElement('div'); bz.className = 'zone'; bz.dataset.color = 'blauw'; bz.id = 'blue-zone';
		const bg = document.createElement('div'); bg.className = 'grid'; bg.id = 'blue-grid'; bg.dataset.rows = '10'; bg.dataset.cols = '22';
		for (let y=0;y<10;y++) for (let x=0;x<22;x++) { const c = document.createElement('div'); c.className='cell'; c.dataset.x=String(x); c.dataset.y=String(y);
			// create narrow banding: some rows are slightly obstructed for challenge
			if ((y===2 || y===7) && (x%5===0)) c.classList.add('void-cell');
			bg.appendChild(c); }
		bz.appendChild(bg);
		col3.appendChild(bz);

		// Keep other columns empty (applyBoardHtmlToGame will hide missing zones)
	}

	// For 4.2: creative shapes + subgoal hints (some void cells + a portal/key)
	if (scenarioId === '4.2') {
		// Green: larger organic island (11x11) with void pockets and start-cells
		const gz = document.createElement('div'); gz.className = 'zone'; gz.dataset.color = 'groen'; gz.id = 'green-zone';
		const gg = document.createElement('div'); gg.className = 'grid'; gg.id = 'green-grid'; gg.dataset.rows = '11'; gg.dataset.cols = '11';
		for (let y=0;y<11;y++) for (let x=0;x<11;x++) {
			const c = document.createElement('div'); c.className='cell'; c.dataset.x=String(x); c.dataset.y=String(y);
			// create organic voids
			if ((Math.abs(x-5)+Math.abs(y-5))>7) c.classList.add('void-cell');
			// bold anchors to guide subgoal placement
			if ((x===5 && (y===2 || y===8)) || ((x===2||x===8) && y===5)) c.classList.add('bold-cell');
			gg.appendChild(c);
		}
		gz.appendChild(gg);
		col2.appendChild(gz);

		// Blue: long winding strip with portal/key and a few locked cells
		const bz = document.createElement('div'); bz.className = 'zone'; bz.dataset.color = 'blauw'; bz.id = 'blue-zone';
		const bg = document.createElement('div'); bg.className = 'grid'; bg.id = 'blue-grid'; bg.dataset.rows = '7'; bg.dataset.cols = '24';
		for (let y=0;y<7;y++) for (let x=0;x<24;x++) {
			const c = document.createElement('div'); c.className='cell'; c.dataset.x=String(x); c.dataset.y=String(y);
			// make a small pocket for the portal
			if (x===3 && y===3) { c.classList.add('portal-cell'); const s=document.createElement('span'); s.className='portal-symbol'; s.textContent='ðŸ—ï¸'; c.appendChild(s); }
			// occasional voids to create placement rhythm
			if ((x%7===0) && (y===1 || y===5)) c.classList.add('void-cell');
			bg.appendChild(c);
		}
		bz.appendChild(bg);
		col3.appendChild(bz);
	}

	board.appendChild(col1); board.appendChild(col2); board.appendChild(col3); board.appendChild(col4);
	return board.outerHTML;
}

function showPreLevelChoice(onPick) {
	// Small modal offering 3 multikleur card choices (instantiated from shapePool).
	try {
		const overlayId = 'prelevel-choice-overlay';
		let overlay = document.getElementById(overlayId);
		if (!overlay) {
			overlay = document.createElement('div'); overlay.id = overlayId; overlay.className = 'highscore-modal-overlay';
			overlay.innerHTML = `<div class="highscore-modal"><h2>Kies Ã©Ã©n bonuskaart</h2><div id="prelevel-choices" style="display:flex;gap:8px;flex-wrap:wrap;margin:8px 0"></div><div style="margin-top:8px"><button class="modal-btn" id="prelevel-skip">Sla over</button></div></div>`;
			document.body.appendChild(overlay);
		}
		overlay.classList.add('show');
		const container = document.getElementById('prelevel-choices'); container.innerHTML='';
		// Create 3 options
		const rainbowColor = { name: 'multikleur', code: 'rainbow' };
		for (let i=0;i<3;i++) {
			const shapeEntry = shapePool[(Math.abs(i + Math.floor(Math.random()*shapePool.length)) % shapePool.length)];
			const bp = createCardBlueprint(shapeEntry, rainbowColor);
			const card = instantiateBlueprint(bp);
			const el = createCardElement(card, true, { onSelect: () => {} });
			el.style.cursor='pointer';
			el.addEventListener('click', ()=>{
				overlay.classList.remove('show');
				try { onPick(card); } catch(e){}
			});
			container.appendChild(el);
		}
		document.getElementById('prelevel-skip').onclick = ()=>{ overlay.classList.remove('show'); try{ onPick(null); }catch(e){} };
	} catch (e) { console.error(e); try{ onPick(null); }catch(e){} }
}

function loadScenario(id, meta) {
	const boardHtml = buildScenarioBoardHtml(id);
	applyBoardHtmlToGame(boardHtml);
	setLoadedLevelMeta(meta.name, meta.desc || '');
	// Restrict visible cards to the scenario colors (Dutch names)
	window.scenarioAllowedColors = meta.allowedColors || null;
	// Reset relevant game state so the scenario always starts with the scenario's
	// own deck/coins/scores rather than the player's current in-progress session.
	try {
		if (typeof resetScoreState === 'function') resetScoreState();
		if (typeof resetCoins === 'function') resetCoins();
	} catch (e) {}

	// Helper: resolve a start-deck entry (blueprint, blueprintId or already-instantiated)
	const resolveToInstance = (spec) => {
		try {
			if (!spec) return null;
			// Already an instantiated card
			if (spec.id && spec.blueprintId) return spec;
			// Full blueprint object
			if (spec.matrix || spec.shapeName) return instantiateBlueprint(spec);
			// String assumed to be a blueprintId; find in ownedBlueprints
			if (typeof spec === 'string') {
				const bp = ownedDeckBlueprints.find(b => (b && (b.blueprintId === spec || b.shapeName === spec)));
				if (bp) return instantiateBlueprint(bp);
			}
		} catch (e) { console.error('resolveToInstance failed', e); }
		return null;
	};

	// Start-deck: prefer explicit meta.startDeck (array of specs). If absent,
	// create a fresh deck composed from owned blueprints but filter by allowed colors.
	if (Array.isArray(meta && meta.startDeck) && meta.startDeck.length) {
		drawPile = shuffleArray((meta.startDeck.map(resolveToInstance).filter(Boolean)));
		discardPile = [];
		currentHand = [];
		turnCount = 0;
	} else {
		// Build fresh draw pile but respect scenarioAllowedColors
		drawPile = shuffleArray(ownedDeckBlueprints.map(bp => instantiateBlueprint(bp)));
		if (Array.isArray(window.scenarioAllowedColors)) {
			const allowed = window.scenarioAllowedColors;
			drawPile = drawPile.filter(c => c && (allowed.includes((c.color && c.color.name) || '') || (c.color && c.color.name) === 'multikleur'));
		}
		discardPile = [];
		currentHand = [];
		turnCount = 0;
	}

	// If meta provides explicit startHand, populate it (instances or specs).
	if (Array.isArray(meta && meta.startHand) && meta.startHand.length) {
		currentHand = meta.startHand.map(resolveToInstance).filter(Boolean);
	}

	// If meta provides startCoins (number), apply to the coin UI
	if (typeof meta?.startCoins === 'number') {
		try {
			const desired = Math.max(0, Math.floor(meta.startCoins));
			const container = document.getElementById('collected-coins');
			if (container) {
				// Ensure there are enough coin elements
				const existing = container.children.length;
				for (let i = existing; i < desired; i++) container.appendChild(createCoinElement(i));
				// Reset all
				container.querySelectorAll('.coin').forEach(el => el.classList.remove('active','used'));
				// Activate the first `desired` coins
				Array.from(container.querySelectorAll('.coin')).slice(0, desired).forEach(el => el.classList.add('active'));
				updateCoinCounter();
			}
		} catch (e) { console.error('Failed to apply startCoins', e); }
	}

	// Offer the pre-level multikleur choice and, if picked, insert it into the current hand
	showPreLevelChoice((pickedCard) => {
		if (pickedCard) {
			// mark and insert the chosen instantiated card into the hand immediately
			pickedCard.isPrelevelChoice = true;
			pickedCard.isUsed = false;
			// ensure identical blueprint isn't in the draw pile (remove exact matches)
			try { drawPile = (drawPile || []).filter(c => c && c.blueprintId !== pickedCard.blueprintId); } catch(e) {}
			currentHand.unshift(pickedCard);
			renderCurrentHand();
		} else {
			renderCurrentHand();
		}
		// keep deck UI aware: render preview and hand
		try { if (typeof updateDeckPreview === 'function') updateDeckPreview(); } catch(e){}
	});
}

// --- Subgoal checks for scenarios ---
function checkGreenHas4x4Square() {
	try {
		const g = document.getElementById('green-grid');
		if (!g) return false;
		const rows = Number(g.dataset.rows) || Math.ceil(Math.sqrt(g.querySelectorAll('.cell').length));
		const cols = Number(g.dataset.cols) || Math.ceil(Math.sqrt(g.querySelectorAll('.cell').length));
		for (let ry = 0; ry <= rows - 4; ry++) {
			for (let cx = 0; cx <= cols - 4; cx++) {
				let ok = true;
				for (let y = 0; y < 4 && ok; y++) {
					for (let x = 0; x < 4; x++) {
						const sel = g.querySelector(`.cell[data-x="${cx + x}"][data-y="${ry + y}"]`);
						if (!sel || sel.classList.contains('void-cell') || !sel.classList.contains('active')) { ok = false; break; }
					}
				}
				if (ok) return true;
			}
		}
	} catch (e) { console.error(e); }
	return false;
}

function checkBluePortalActive() {
	try {
		const b = document.getElementById('blue-grid');
		if (!b) return false;
		const portal = b.querySelector('.portal-cell');
		return !!(portal && portal.classList.contains('active'));
	} catch (e) { return false; }
}

// If loading scenario 4.2, register its subgoals (first shown only)
(function attachScenarioHooks(){
	const origLoad = window.loadScenario || null;
	window.loadScenario = function(id, meta) {
		if (typeof origLoad === 'function') origLoad(id, meta);
		try {
			// Register subgoals per scenario. Provide robust checks.
			if (id === '4.1' || (meta && meta.scenarioId === '4.1')) {
				const subgoals = [
					{ title: 'Groen 5Ã—5', text: 'Maak een 5Ã—5 volledig actief blok in groen.', check: () => checkGridHasFilledSquare('green-grid', 5) },
					{ title: 'Blauw kolom', text: 'Activeer een volledige kolom van 8 cellen in blauw.', check: () => checkGridHasFullColumn('blue-grid', 8) }
				];
				setScenarioSubgoals(subgoals);
			}
			if (id === '4.2' || (meta && meta.scenarioId === '4.2')) {
				const subgoals = [
					{ title: '4Ã—4 Vorm', text: 'Maak een 4Ã—4 volledig actief blok in groen.', check: () => checkGridHasFilledSquare('green-grid', 4) },
					{ title: 'Sleutel activeren', text: 'Activeer de portal/sleutel in blauw.', check: () => checkBluePortalActive() }
				];
				setScenarioSubgoals(subgoals);
			}
		} catch (e) { console.error(e); }
	};
})();

// Helper checks for scenarios
function checkGridHasFilledSquare(gridId, n) {
	try {
		const g = document.getElementById(gridId);
		if (!g) return false;
		const rows = Number(g.dataset.rows) || Math.ceil(Math.sqrt(g.querySelectorAll('.cell').length));
		const cols = Number(g.dataset.cols) || Math.ceil(Math.sqrt(g.querySelectorAll('.cell').length));
		for (let ry = 0; ry <= rows - n; ry++) {
			for (let cx = 0; cx <= cols - n; cx++) {
				let ok = true;
				for (let y = 0; y < n && ok; y++) {
					for (let x = 0; x < n; x++) {
						const sel = g.querySelector(`.cell[data-x="${cx + x}"][data-y="${ry + y}"]`);
						if (!sel || sel.classList.contains('void-cell') || !sel.classList.contains('active')) { ok = false; break; }
					}
				}
				if (ok) return true;
			}
		}
	} catch (e) { console.error(e); }
	return false;
}

function checkGridHasFullColumn(gridId, minHeight) {
	try {
		const g = document.getElementById(gridId);
		if (!g) return false;
		const rows = Number(g.dataset.rows) || Math.ceil(Math.sqrt(g.querySelectorAll('.cell').length));
		const cols = Number(g.dataset.cols) || Math.ceil(Math.sqrt(g.querySelectorAll('.cell').length));
		for (let cx = 0; cx < cols; cx++) {
			let activeCount = 0;
			for (let y = 0; y < rows; y++) {
				const sel = g.querySelector(`.cell[data-x="${cx}"][data-y="${y}"]`);
				if (!sel || sel.classList.contains('void-cell')) { activeCount = 0; break; }
				if (sel.classList.contains('active')) activeCount++; else { activeCount = 0; break; }
			}
			if (activeCount >= minHeight) return true;
		}
	} catch (e) { console.error(e); }
	return false;
}

// Scenario subgoal management
window.scenarioSubgoals = null;
window.currentScenarioSubgoalIndex = -1;
function setScenarioSubgoals(subgoals) {
	window.scenarioSubgoals = Array.isArray(subgoals) ? subgoals : null;
	window.currentScenarioSubgoalIndex = subgoals && subgoals.length ? 0 : -1;
	showCurrentScenarioSubgoal();
}

function showCurrentScenarioSubgoal() {
	try {
		const idx = Number(window.currentScenarioSubgoalIndex || 0);
		if (!window.scenarioSubgoals || idx < 0 || idx >= window.scenarioSubgoals.length) return;
		const sub = window.scenarioSubgoals[idx];
		// Display in objective zone briefly
		const titleEl = document.querySelector('#objective-zone h2');
		const currentEl = document.getElementById('objective-current');
		if (titleEl) titleEl.textContent = sub.title || titleEl.textContent;
		if (currentEl) currentEl.innerHTML = `<strong>Subdoel ${idx+1}:</strong> ${sub.text}`;
	} catch (e) {}
}

function monitorScenarioProgress() {
	try {
		if (!window.scenarioSubgoals || window.currentScenarioSubgoalIndex == null) return;
		const idx = Number(window.currentScenarioSubgoalIndex || 0);
		if (idx < 0 || idx >= window.scenarioSubgoals.length) return;
		const sub = window.scenarioSubgoals[idx];
		if (!sub || typeof sub.check !== 'function') return;
		const ok = !!sub.check();
		if (ok) {
			// show exclamation toast & visual
			showObjectiveToast(`â— ${sub.text} voltooid!`);
			// darken and remove prelevel card from draw if present
			try {
				const pre = currentHand.find(c => c && c.isPrelevelChoice && !c.isUsed);
				if (pre) {
					pre.isUsed = true;
					// remove any exact blueprint matches from drawPile
					drawPile = (drawPile || []).filter(c => c && c.blueprintId !== pre.blueprintId);
				}
				renderCurrentHand();
			} catch (e) {}
			// advance
			window.currentScenarioSubgoalIndex += 1;
			if (window.currentScenarioSubgoalIndex >= window.scenarioSubgoals.length) {
				// all done
				setLoadedLevelMeta(window.loadedCustomLevelMeta?.name || 'Scenario voltooid', 'Alle subdoelen voltooid!');
				window.scenarioSubgoals = null; window.currentScenarioSubgoalIndex = -1;
			} else {
				showCurrentScenarioSubgoal();
			}
		}
	} catch (e) { console.error(e); }
}

	function openEditorWindow() {
		const boardHtml = getEditorBoardHtml();
		try { localStorage.setItem(LOCUS_EDITOR_STORAGE_KEY, boardHtml); } catch (e) {}
		// Open as a separate page (clean separation).
		const w = window.open('editor.html', '_blank');
		if (!w) {
			alert('Popup geblokkeerd. Sta popups toe om de editor te openen.');
			return;
		}
		// Best effort: send immediately (editor also requests on load).
		try {
			w.postMessage({ type: 'LOCUS_EDITOR_BOARD', boardHtml }, '*');
		} catch (e) {}
	}
	window.addEventListener('message', (event) => {
		// Only respond to the opener/child channel we use.
		const data = event && event.data ? event.data : {};
		if (!data) return;
		if (data.type === 'LOCUS_EDITOR_REQUEST_BOARD') {
			const boardHtml = getEditorBoardHtml();
			try { localStorage.setItem(LOCUS_EDITOR_STORAGE_KEY, boardHtml); } catch (e) {}
			try { event.source && event.source.postMessage({ type: 'LOCUS_EDITOR_BOARD', boardHtml }, '*'); } catch (e) {}
			return;
		}
		// Accept boards sent from the external editor window
		if (data.type === 'LOCUS_EDITOR_BOARD' && typeof data.boardHtml === 'string') {
			try {
				applyBoardHtmlToGame(data.boardHtml);
				// If the editor provided name/objective, persist that metadata in the UI
				if (data.name || data.objective) {
					setLoadedLevelMeta(data.name || '', data.objective || '');
					try { if (typeof resetScoreState === 'function') resetScoreState(); } catch(e){}
					if (typeof updateScore === 'function') setTimeout(()=> updateScore(), 120);
				}
				if (typeof setStatus === 'function') setStatus('Speelveld geladen vanuit editor.');
			} catch (e) { console.error(e); }
			return;
		}
	});

	function mulberry32(seed) {
		let a = seed >>> 0;
		return function() {
			a |= 0;
			a = (a + 0x6D2B79F5) | 0;
			let t = Math.imul(a ^ (a >>> 15), 1 | a);
			t = (t + Math.imul(t ^ (t >>> 7), 61 | t)) ^ t;
			return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
		};
	}

	function buildGeneratedPrintBoard(world, noBonuses) {
		const includeBonuses = !noBonuses;
		const prefix = `print-${world}-${Date.now().toString(36)}-${Math.random().toString(16).slice(2)}`;
		const staging = document.createElement('div');
		staging.style.position = 'fixed';
		staging.style.left = '-99999px';
		staging.style.top = '-99999px';
		staging.style.width = '1px';
		staging.style.height = '1px';
		staging.style.overflow = 'hidden';
		document.body.appendChild(staging);

		const makeZone = (id, color, child) => {
			const z = document.createElement('div');
			z.className = 'zone';
			z.id = id;
			z.dataset.color = color;
			if (child) z.appendChild(child);
			return z;
		};
		const makeGrid = (id) => {
			const g = document.createElement('div');
			g.className = 'grid';
			g.id = id;
			return g;
		};

		const boardEl = document.createElement('div');
		boardEl.className = 'board';
		const col1 = document.createElement('div');
		col1.className = 'column';
		const col2 = document.createElement('div');
		col2.className = 'column';
		const col3 = document.createElement('div');
		col3.className = 'column';

		const purpleGridId = `${prefix}-purple-grid`;
		const yellowGridId = `${prefix}-yellow-grid`;
		const greenGridId = `${prefix}-green-grid`;
		const blueGridId = `${prefix}-blue-grid`;
		const redZoneId = `${prefix}-red-zone`;
		const red1Id = `${prefix}-red-grid1`;
		const red2Id = `${prefix}-red-grid2`;
		const red3Id = `${prefix}-red-grid3`;
		const red4Id = `${prefix}-red-grid4`;

		const purpleZone = makeZone(`${prefix}-purple-zone`, 'paars', makeGrid(purpleGridId));
		const yellowZone = makeZone(`${prefix}-yellow-zone`, 'geel', makeGrid(yellowGridId));
		const greenZone = makeZone(`${prefix}-green-zone`, 'groen', makeGrid(greenGridId));
		const blueZone = makeZone(`${prefix}-blue-zone`, 'blauw', makeGrid(blueGridId));
		const redZone = document.createElement('div');
		redZone.className = 'zone red-group';
		redZone.id = redZoneId;
		redZone.dataset.color = 'rood';
		const red1 = document.createElement('div'); red1.className = 'zone'; red1.id = red1Id; red1.dataset.color = 'rood';
		const red2 = document.createElement('div'); red2.className = 'zone'; red2.id = red2Id; red2.dataset.color = 'rood';
		const red3 = document.createElement('div'); red3.className = 'zone'; red3.id = red3Id; red3.dataset.color = 'rood';
		const red4 = document.createElement('div'); red4.className = 'zone'; red4.id = red4Id; red4.dataset.color = 'rood';
		redZone.append(red1, red2, red3, red4);

		col1.append(purpleZone, yellowZone);
		col2.append(greenZone, redZone);
		col3.append(blueZone);
		boardEl.append(col1, col2, col3);
		staging.appendChild(boardEl);

		// Seed randomness so print generation is stable-ish.
		const origRandom = Math.random;
		try {
			Math.random = mulberry32(0xC0FFEE + (world === 'world2' ? 2 : 1));
		} catch (_) {}

		try {
			if (world === 'world1') {
				// Yellow (World 1): irregular columns -> rowLengths/offsets
				const yellowColumnHeights = [6, 6, 8, 8, 10, 10, 12, 12, 14, 14];
				const yellowCols = yellowColumnHeights.length;
				const yellowRows = Math.max(...yellowColumnHeights);
				const yellowRowPattern = [];
				const yellowRowOffsets = [];
				for (let r = 0; r < yellowRows; r++) {
					let activeCount = 0;
					for (let c = 0; c < yellowCols; c++) {
						const topRow = yellowRows - yellowColumnHeights[c];
						if (r >= topRow) activeCount++;
					}
					yellowRowPattern.push(activeCount);
					yellowRowOffsets.push(Math.max(0, yellowCols - activeCount));
				}
				createGrid(yellowGridId, yellowRows, yellowCols, {
					symbols: includeBonuses,
					goldCells: includeBonuses,
					minSymbols: includeBonuses ? 8 : 0,
					maxSymbols: includeBonuses ? 12 : 0,
					coinChance: includeBonuses ? 0.2 : 0,
					maxCoins: includeBonuses ? 15 : 0,
					rowLengths: yellowRowPattern,
					rowOffsets: yellowRowOffsets,
					boldColumns: [0],
					trapChance: 0,
					maxTraps: 0,
					blackHoleChance: 0
				});
				createGrid(purpleGridId, 9, 9, {
					symbols: includeBonuses,
					goldCells: includeBonuses,
					minSymbols: includeBonuses ? 6 : 0,
					maxSymbols: includeBonuses ? 8 : 0,
					coinChance: includeBonuses ? 0.03 : 0,
					maxCoins: includeBonuses ? 4 : 0,
					randomBoldCount: 8,
					avoidAdjacentBold: true,
					trapChance: 0,
					maxTraps: 0,
					blackHoleChance: 0
				});
				const blueRowPattern = [2, 2, 3, 3, 3, 2, 2, 3, 3, 2, 2, 3, 3, 3, 2, 2, 3, 3, 2, 2, 3, 3, 2, 3, 3];
				const blueRowOffsets = [1, 1, 1, 0, 0, 1, 2, 2, 2, 3, 2, 2, 1, 1, 1, 0, 0, 0, 1, 2, 2, 2, 3, 2, 1];
				const blueRows = blueRowPattern.length;
				const blueCols = Math.max(...blueRowOffsets.map((o, idx) => o + (blueRowPattern[idx] || 0)), 3);
				createGrid(blueGridId, blueRows, blueCols, {
					boldBottom: true,
					symbols: includeBonuses,
					goldCells: includeBonuses,
					minSymbols: includeBonuses ? 10 : 0,
					maxSymbols: includeBonuses ? 12 : 0,
					coinChance: includeBonuses ? 0.05 : 0,
					maxCoins: includeBonuses ? 6 : 0,
					rowLengths: blueRowPattern,
					rowOffsets: blueRowOffsets,
					trapChance: 0,
					maxTraps: 0,
					blackHoleChance: 0
				});
				generateRoots(greenGridId, 15, 15, 40, 0.25, includeBonuses ? 0.06 : 0, includeBonuses ? 12 : 0, includeBonuses ? 16 : 0, includeBonuses ? 4 : 0, false, 0, 0, 0);
				generateRoots(red1Id, 4, 4, 10, 0.3, includeBonuses ? 0.04 : 0, includeBonuses ? 2 : 0, includeBonuses ? 4 : 0, includeBonuses ? 2 : 0, true, 0, 0, 0);
				generateRoots(red2Id, 4, 5, 10, 0.3, includeBonuses ? 0.04 : 0, includeBonuses ? 2 : 0, includeBonuses ? 4 : 0, includeBonuses ? 2 : 0, true, 0, 0, 0);
				generateRoots(red3Id, 5, 5, 12, 0.3, includeBonuses ? 0.06 : 0, includeBonuses ? 3 : 0, includeBonuses ? 5 : 0, includeBonuses ? 2 : 0, true, 0, 0, 0);
				generateRoots(red4Id, 5, 5, 12, 0.3, includeBonuses ? 0.06 : 0, includeBonuses ? 3 : 0, includeBonuses ? 5 : 0, includeBonuses ? 2 : 0, true, 0, 0, 0);
			} else {
				// World 2 (print): deterministic shapes that keep proportions.
				createGrid(yellowGridId, 11, 11, {
					symbols: includeBonuses,
					goldCells: includeBonuses,
					minSymbols: includeBonuses ? 5 : 0,
					maxSymbols: includeBonuses ? 7 : 0,
					coinChance: includeBonuses ? 0.07 : 0,
					maxCoins: includeBonuses ? 8 : 0,
					trapChance: 0,
					maxTraps: 0,
					blackHoleChance: 0
				});
				createGrid(purpleGridId, 13, 13, {
					symbols: includeBonuses,
					goldCells: includeBonuses,
					minSymbols: includeBonuses ? 8 : 0,
					maxSymbols: includeBonuses ? 11 : 0,
					coinChance: includeBonuses ? 0.04 : 0,
					maxCoins: includeBonuses ? 6 : 0,
					fixedBoldCells: [[0,0],[0,12],[12,0],[12,12]],
					randomBoldCount: 10,
					avoidAdjacentBold: true,
					randomBoldMinEdgeDistance: 2,
					outerRingShade: includeBonuses,
					trapChance: 0,
					maxTraps: 0,
					blackHoleChance: 0
				});
				const blueRows = 60;
				const blueCols = 18;
				const blueRowPattern = [];
				const blueRowOffsets = [];
				for (let i = 0; i < blueRows; i++) {
					const baseW = (i % 12 === 7) ? 5 : ((i % 5 === 0) ? 4 : 3);
					const w = Math.max(2, Math.min(5, baseW));
					const raw = 4 + Math.round(2 * Math.sin(i / 6));
					const maxOffset = Math.max(0, blueCols - w);
					const off = Math.max(0, Math.min(maxOffset, raw));
					blueRowPattern.push(w);
					blueRowOffsets.push(off);
				}
				createGrid(blueGridId, blueRows, blueCols, {
					boldBottom: true,
					symbols: includeBonuses,
					goldCells: includeBonuses,
					minSymbols: includeBonuses ? 15 : 0,
					maxSymbols: includeBonuses ? 22 : 0,
					coinChance: includeBonuses ? 0.09 : 0,
					maxCoins: includeBonuses ? 16 : 0,
					rowLengths: blueRowPattern,
					rowOffsets: blueRowOffsets,
					trimLeft: true,
					trimRight: true,
					trapChance: 0,
					maxTraps: 0,
					blackHoleChance: 0
				});
				generateRoots(greenGridId, 34, 28, 220, 0.35, includeBonuses ? 0.02 : 0, includeBonuses ? 4 : 0, includeBonuses ? 6 : 0, includeBonuses ? 2 : 0, false, 0, 0, 0);
				generateRoots(red1Id, 4, 5, 14, 0.35, includeBonuses ? 0.03 : 0, includeBonuses ? 2 : 0, includeBonuses ? 3 : 0, includeBonuses ? 2 : 0, true, 0, 0, 0);
				generateRoots(red2Id, 4, 6, 16, 0.35, includeBonuses ? 0.03 : 0, includeBonuses ? 2 : 0, includeBonuses ? 3 : 0, includeBonuses ? 2 : 0, true, 0, 0, 0);
				generateRoots(red3Id, 5, 6, 18, 0.35, includeBonuses ? 0.03 : 0, includeBonuses ? 2 : 0, includeBonuses ? 3 : 0, includeBonuses ? 2 : 0, true, 0, 0, 0);
				generateRoots(red4Id, 5, 6, 20, 0.35, includeBonuses ? 0.03 : 0, includeBonuses ? 2 : 0, includeBonuses ? 3 : 0, includeBonuses ? 2 : 0, true, 0, 0, 0);
			}
		} finally {
			try { Math.random = origRandom; } catch (_) {}
		}

		// For World 2 prints, mark the green-zone start cell so the print preview can center on it.
		if (world === 'world2') {
			try {
				const greenRoot = staging.querySelector('#' + greenGridId + ' .root-cell');
				if (greenRoot) greenRoot.classList.add('print-focus');
			} catch (e) {}
		}

		if (noBonuses) stripBoardForLowInk(boardEl);
		const html = boardEl.outerHTML;
		try { staging.remove(); } catch { try { staging.parentNode && staging.parentNode.removeChild(staging); } catch {} }
		return html;
	}

	function openPrintWindow(boardHtml, opts) {
		const w = window.open('', '_blank');
		if (!w) {
			alert('Popup geblokkeerd. Sta popups toe om te printen.');
			return;
		}
		const lightMode = !!opts.lightMode;
		const noBonuses = !!opts.noBonuses;
		const css = `
.@page { size: A4 landscape; margin: 8mm; }
html, body { height: 100%; }
body { margin: 0; padding: 0; background: ${lightMode ? 'white' : '#111'}; color: ${lightMode ? '#111' : '#eee'}; font-family: Arial, sans-serif; }
#print-hide-icons .zone-info-btn, #print-hide-icons .zone-delete, #print-hide-icons .trash-btn,
.zone-info-btn, .zone-delete, .trash-btn { display: none !important; }
#print-root { width: fit-content; }
.board { display: flex; gap: 14px; align-items: center; transform-origin: top left; }
.column { display: flex; flex-direction: column; gap: 14px; align-items: center; }
.zone { background: transparent; padding: 10px; border-radius: 10px; box-shadow: none; border: 1px solid ${lightMode ? '#b9b9b9' : '#666'}; overflow: visible; max-height: none; }
.zone.red-group { border-radius: 10px; align-self: flex-start; }
.zone[data-color="geel"] { background: ${lightMode ? (noBonuses ? '#fffdf4' : '#fff6cf') : 'transparent'}; }
.zone[data-color="paars"] { background: ${lightMode ? (noBonuses ? '#fdf9ff' : '#f1e7ff') : 'transparent'}; }
.zone[data-color="groen"] { background: ${lightMode ? (noBonuses ? '#f6fff6' : '#e1f7e1') : 'transparent'}; }
.zone[data-color="blauw"] { background: ${lightMode ? (noBonuses ? '#f6fbff' : '#dff1ff') : 'transparent'}; }
.zone[data-color="rood"] { background: ${lightMode ? (noBonuses ? '#fff7f7' : '#ffe3e3') : 'transparent'}; }
.zone.red-group { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; padding: 10px; }
.zone.red-group > .zone { padding: 6px; }
	.grid { display: grid; gap: var(--board-grid-gap,2px); overflow: visible; max-height: none; grid-auto-columns: var(--cell-size); grid-auto-rows: var(--cell-size); }
	.cell { display: block; width: var(--cell-size); height: var(--cell-size); min-width: var(--cell-size); min-height: var(--cell-size); padding: 0; margin: 0; box-sizing: border-box; border: 1px solid ${lightMode ? '#b7b7b7' : '#777'}; background: ${lightMode ? 'rgba(255,255,255,0.92)' : '#1a1a1a'}; border-radius: 4px; }
	.cell.bold-cell { border-style: solid; border-width: 2px; border-color: ${lightMode ? '#2d2d2d' : '#ddd'}; }
	.cell.bold-cell.active { box-shadow: none; }
.cell.void-cell { border-color: transparent !important; background: transparent !important; }
.cell.active { background: ${lightMode ? '#f0f0f0' : '#2a2a2a'}; }
	.root-cell { border-radius: 4px; }
/* Zone-specific cell tinting (keeps the board recognizable, but very light). */
.zone[data-color="geel"] .cell { background: ${lightMode ? (noBonuses ? '#fffef8' : '#fffbe3') : 'transparent'}; }

.zone[data-color="geel"] .cell.active { background: ${lightMode ? (noBonuses ? '#f6f2d8' : '#efe29c') : 'transparent'}; }

		.zone[data-color="groen"] .cell { background: ${lightMode ? (noBonuses ? '#fbfffb' : '#eef9ee') : 'transparent'}; }
		.zone[data-color="groen"] .cell.active { background: ${lightMode ? (noBonuses ? '#e7f1e7' : '#bfe3bf') : 'transparent'}; }

		.zone[data-color="blauw"] .cell { background: ${lightMode ? (noBonuses ? '#fbfdff' : '#ecf6ff') : 'transparent'}; }
		.zone[data-color="blauw"] .cell.active { background: ${lightMode ? (noBonuses ? '#e5eef7' : '#b7d6f2') : 'transparent'}; }

		.zone[data-color="rood"] .cell { background: ${lightMode ? (noBonuses ? '#fffafb' : '#fff0f0') : 'transparent'}; }
		.zone[data-color="rood"] .cell.active { background: ${lightMode ? (noBonuses ? '#f6e4e4' : '#eeb3b3') : 'transparent'}; }

		/* Normalise all zone cells to the same base appearance so green/red match other grids. */
		.zone .cell { border-radius: 4px; border: 1px solid ${lightMode ? '#b7b7b7' : '#777'}; background: ${lightMode ? 'rgba(255,255,255,0.92)' : '#1a1a1a'}; }
		.zone .cell.active { background: ${lightMode ? '#f0f0f0' : '#2a2a2a'}; }

		/* Keep start/end/bold cells readable without heavy ink. */
		.cell.bold-cell.active { filter: ${lightMode ? 'none' : 'none'}; }
		${noBonuses ? '' : '.cell.gold-cell{outline:1px solid ' + (lightMode ? '#a98c2a' : '#c9a94a') + ';}'}
		${noBonuses ? '.symbol,.trap-symbol,.coin{display:none !important;}' : ''}
		`;

		// Collect existing page styles (all <style> and linked stylesheets) so print window matches game styling exactly.
		const existingStyles = Array.from(document.querySelectorAll('style, link[rel="stylesheet"]')).map(el => el.outerHTML).join('\n');

		// Determine actual cell size from the current board so printed board keeps on-screen proportions.
		const actualCellSize = (typeof getActualCellSize === 'function') ? getActualCellSize() : (parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--cell-size')) || 26);

		// Build head: include original stylesheets and a minimal set of print-only overrides.
		let htmlClass = (document.documentElement && document.documentElement.className) ? document.documentElement.className : '';
		// Respect the print lightMode option: if true, remove dark-mode; if false, ensure dark-mode present.
		if (typeof opts !== 'undefined' && opts) {
			if (opts.lightMode) {
				htmlClass = htmlClass.replace(/\bdark-mode\b/g, '').trim();
			} else {
				if (!/\bdark-mode\b/.test(htmlClass)) htmlClass = (htmlClass + ' dark-mode').trim();
			}
		}
		const printOverrides = `
/* Minimal print overrides: hide UI elements, keep original colors and sizing */
@page { size: A4 landscape; margin: 8mm; }
body { background: transparent !important; }
#dark-mode-toggle,
.blur-overlay,
#drag-overlay,
#floating-preview,
#placement-zoom-lens,
#mobile-objective-banner,
#bottom-bar,
#card-choice-zone,
#bonus-zone,
#scoreboard,
#objective-zone,
#original-coins-zone,
#gold-zone,
#collected-coins,
#buy-placement-container,
#controls,
#round-modal-layer,
#shop-modal-layer,
#upgrade-modal-layer,
#deck-modal-layer,
#golden-unlock-layer,
#blackhole-modal-layer,
.objective-toast,
.zone-nav-arrow,
.zone-info-btn,
.zone-info-popover { display: none !important; }

/* Clip content to the zone bounds so grids do not overflow outside their zone */
.zone { overflow: hidden !important; max-height: none !important; }

/* Grids should scroll inside their zones if needed; default to auto so clipped content is accessible in preview (but not visually overflowing). */
.grid { display: grid !important; gap: var(--board-grid-gap,2px) !important; overflow: auto !important; max-height: none !important; box-sizing: border-box; }

/* Green zone: center the inner grid so the start cell (print-focus) appears centered. */
.zone[data-color="groen"] .grid,
#green-zone .grid { align-content: center !important; justify-content: center !important; height: 100% !important; }

/* Blue zone: anchor content to the bottom so the grid appears to grow upwards. */
.zone[data-color="blauw"] .grid,
#blue-zone .grid { align-content: end !important; justify-content: center !important; height: 100% !important; }

/* Red zone: keep standard clipping behavior but allow its internal grids to center. */
.zone[data-color="rood"] .grid,
#red-zone .grid { align-content: center !important; justify-content: center !important; }

/* Hide native scrollbars in print preview */
* { scrollbar-width: none; -ms-overflow-style: none; }
*::-webkit-scrollbar { display: none; }
`;

		const headContent = existingStyles + '\n' + '<style>' + printOverrides + '</style>';

		const doc = `<!doctype html><html lang="nl" class="${htmlClass}"><head><meta charset="utf-8"><title>Print</title>${headContent}</head>\n<body>\n<div id="print-root">${boardHtml}</div>\n
<script>
(function(){
	function fit(){
		var b = document.querySelector('.board');
		if(!b) return;
		b.style.transform = '';
		b.style.transformOrigin = 'top left';
		var rect = b.getBoundingClientRect();
		var margin = 16;
		var scale = Math.min((window.innerWidth - margin) / rect.width, (window.innerHeight - margin) / rect.height, 1);

		// Try to center the start/root cell in the viewport when present.
		var root = b.querySelector('.print-focus') || b.querySelector('.root-cell') || b.querySelector('.cell.root') || b.querySelector('.cell.start');
		if (root) {
			var rootRect = root.getBoundingClientRect();
			var relX = (rootRect.left - rect.left) + (rootRect.width/2);
			var relY = (rootRect.top - rect.top) + (rootRect.height/2);
			var centerX = window.innerWidth / 2;
			var centerY = window.innerHeight / 2;
			// After scaling, the root center will be at rel*scale. Compute translation so it's at viewport center.
			var tx = centerX - (relX * scale);
			var ty = centerY - (relY * scale);
			// Apply scale first, then translate (translate values are in device pixels after scaling).
			b.style.transform = 'scale(' + scale.toFixed(4) + ') translate(' + tx.toFixed(2) + 'px,' + ty.toFixed(2) + 'px)';
		} else {
			b.style.transform = 'scale(' + scale.toFixed(4) + ')';
		}
	}
	var __autoPrint = ${opts && typeof opts.autoPrint !== 'undefined' ? (opts.autoPrint ? 'true' : 'false') : 'true'};
	window.addEventListener('load', function(){ fit(); if(__autoPrint) setTimeout(function(){ window.print(); }, 200); });
	window.addEventListener('resize', fit);
})();
</scr` + `ipt>
</body></html>`;
		w.document.open();
		w.document.write(doc);
		w.document.close();
	}

	function performPrintFromSettings() {
		const opts = getPrintSettings();
		let boardHtml = '';
		if (opts.source === 'world1') {
			boardHtml = buildGeneratedPrintBoard('world1', opts.noBonuses);
		} else if (opts.source === 'world2') {
			boardHtml = buildGeneratedPrintBoard('world2', opts.noBonuses);
		} else {
			boardHtml = buildPrintBoardFromCurrent(opts.noBonuses);
		}
		openPrintWindow(boardHtml, opts);
	}

	function performPreviewFromSettings() {
		const opts = getPrintSettings();
		let boardHtml = '';
		if (opts.source === 'world1') {
			boardHtml = buildGeneratedPrintBoard('world1', opts.noBonuses);
		} else if (opts.source === 'world2') {
			boardHtml = buildGeneratedPrintBoard('world2', opts.noBonuses);
		} else {
			boardHtml = buildPrintBoardFromCurrent(opts.noBonuses);
		}
		// Open print window but do not auto-invoke window.print()
		openPrintWindow(boardHtml, Object.assign({}, opts, { autoPrint: false }));
	}

	if (printBtn) {
		printBtn.addEventListener('click', (e) => {
			e.preventDefault();
			showPrintSettings();
		});
	}
	if (printSettingsClose) {
		printSettingsClose.addEventListener('click', (e) => {
			e.preventDefault();
			hidePrintSettings();
		});
	}
	if (printSettingsCancel) {
		printSettingsCancel.addEventListener('click', (e) => {
			e.preventDefault();
			hidePrintSettings();
		});
	}
	if (printSettingsPrint) {
		printSettingsPrint.addEventListener('click', (e) => {
			e.preventDefault();
			hidePrintSettings();
			performPrintFromSettings();
		});
	}
	if (printSettingsPreview) {
		printSettingsPreview.addEventListener('click', (e) => {
			e.preventDefault();
			hidePrintSettings();
			performPreviewFromSettings();
		});
	}
	if (editorBtn) {
		editorBtn.addEventListener('click', (e) => {
			e.preventDefault();
			// Close the hamburger menu if open.
			try {
				const menuToggle = document.getElementById('menu-toggle');
				const controls = document.getElementById('controls');
				if (menuToggle) menuToggle.classList.remove('active');
				if (controls) controls.classList.remove('open');
			} catch (err) {}
			openEditorWindow();
		});
	}
	if (printSettingsLayer) {
		printSettingsLayer.addEventListener('click', (e) => {
			if (e.target === printSettingsLayer) hidePrintSettings();
		});
	}
	
	if (confirmCompleteYes) {
	  confirmCompleteYes.addEventListener('click', () => {
		const callback = pendingRoundCompletion;
		hideCompleteRoundConfirm();
		if (typeof callback === 'function') {
			callback();
		} else if (newCardsButton) {
			newCardsButton.focus();
		}
	  });
	}
	if (confirmCompleteNo) {
	  confirmCompleteNo.addEventListener('click', () => {
		hideCompleteRoundConfirm();
		if (newCardsButton) newCardsButton.focus();
	  });
	}
	if (confirmCompleteLayer) {
		confirmCompleteLayer.addEventListener('click', event => {
		  if (event.target === confirmCompleteLayer) {
			hideCompleteRoundConfirm();
			if (newCardsButton) newCardsButton.focus();
		  }
		});
	}
	document.addEventListener('keydown', event => {
		if (event.key !== 'Escape') return;
		if (confirmNewGameLayer && confirmNewGameLayer.classList.contains('show')) {
			hideNewGameConfirm();
			return;
		}
		if (confirmCompleteLayer && confirmCompleteLayer.classList.contains('show')) {
			hideCompleteRoundConfirm();
			if (newCardsButton) newCardsButton.focus();
			return;
		}
		if (blackHoleModalLayer && blackHoleModalLayer.classList.contains('show')) {
			forfeitBlackHoleChallenge();
			return;
		}
		if (deckModalLayer && deckModalLayer.classList.contains('show')) {
			closeDeckModal();
		}
	});
	window.addEventListener('resize', () => {
		renderTrapSummary();
	});
	if (roundModalNext) {
	  const handleRoundNext = () => {
		console.log('ðŸŽ¯ Round modal Next clicked, lastRoundWasSuccess:', lastRoundWasSuccess);
		hideAllModals();
		if (lastRoundWasSuccess) {
		  const upcomingLevel = currentLevel + 1;
		  console.log('ðŸŽ¯ Going to level:', upcomingLevel);
		  
		  // BELANGRIJK: Reset ALLE scores EN objectives VOORDAT we currentLevel updaten
		  // Dit voorkomt dat de nieuwe level objective wordt gecontroleerd met oude scores
		  resetScoreState();
		  resetObjectives();
		  document.querySelectorAll('#scoreboard .score').forEach(el => {
			el.textContent = '0';
		  });
		  const totalScoreEl = document.getElementById('total-score');
		  if (totalScoreEl) totalScoreEl.textContent = '0';
		  latestScoreSnapshot = { yellow: 0, red: 0, green: 0, purple: 0, blue: 0, bonus: 0, total: 0 };
		  
		  // NU pas currentLevel updaten
		  currentLevel = upcomingLevel;
		  
		  // Save direct na level completion
		  saveGameState();
		  
		  // Check voor nieuwe unlocks
		  const levelUnlocks = UNLOCK_PROGRESSION.getLevelUnlocks(upcomingLevel, currentWorld);
		  // One-time announcement: traps become relevant after completing level 4.
		  let announceTraps = false;
		  try {
			const trapsIntroKey = 'locus_traps_intro_shown_v1';
			announceTraps = (Number(upcomingLevel) === 5 && !localStorage.getItem(trapsIntroKey));
			if (announceTraps) localStorage.setItem(trapsIntroKey, 'true');
		  } catch {
			announceTraps = (Number(upcomingLevel) === 5);
		  }
		  if (announceTraps) {
			levelUnlocks.features = Array.isArray(levelUnlocks.features) ? levelUnlocks.features : [];
			levelUnlocks.features.push({
				id: 'trapsIntro',
				icon: 'âš ï¸',
				name: 'Traps actief',
				description: 'Let op valkuilen en zwarte gaten.'
			});
		  }
		  const hasUnlocks = levelUnlocks.cardCategories.length > 0 || levelUnlocks.upgrades.length > 0 || (levelUnlocks.features && levelUnlocks.features.length > 0);
		  console.log('ðŸŽ¯ Has unlocks:', hasUnlocks);
		  
		  if (hasUnlocks) {
			// Toon unlock modal met callback naar shop
			showUnlockModal(levelUnlocks, () => {
				console.log('ðŸŽ‰ Unlock modal callback, opening shop');
				openShopModal(() => startLevel(currentLevel));
			});
		  } else {
			// Geen unlocks, ga direct naar shop
			openShopModal(() => startLevel(currentLevel));
		  }
		} else {
		  startNewRun();
		}
	  };
	  roundModalNext.addEventListener('click', handleRoundNext);
	  roundModalNext.addEventListener('touchend', (e) => {
		e.preventDefault();
		handleRoundNext();
	  });
	}
	if (roundModalRestart) {
	  const handleRestart = () => {
		hideAllModals();
		startNewRun();
	  };
	  roundModalRestart.addEventListener('click', handleRestart);
	  roundModalRestart.addEventListener('touchend', (e) => {
		e.preventDefault();
		handleRestart();
	  });
	}
	if (shopModalSkip) {
	  const handleSkipShop = () => skipShop();
	  shopModalSkip.addEventListener('click', handleSkipShop);
	  shopModalSkip.addEventListener('touchend', (e) => {
		e.preventDefault();
		handleSkipShop();
	  });
	}
	
	// Shop modal kruisje handler
	const shopModalClose = document.getElementById('shop-modal-close');
	if (shopModalClose) {
	  const handleCloseShop = () => skipShop();
	  shopModalClose.addEventListener('click', handleCloseShop);
	  shopModalClose.addEventListener('touchend', (e) => {
		e.preventDefault();
		handleCloseShop();
	  });
	}
	
	// Unlock Modal handler - met touch support voor mobiel
	const unlockModalContinue = document.getElementById('unlock-modal-continue');
	if (unlockModalContinue) {
		const handleUnlockContinue = () => {
			console.log('ðŸŽ‰ Unlock continue button pressed');
			hideUnlockModal();
		};
		unlockModalContinue.addEventListener('click', handleUnlockContinue);
		unlockModalContinue.addEventListener('touchend', (e) => {
			e.preventDefault(); // Voorkom dubbele trigger
			handleUnlockContinue();
		});
	}
	
	if (upgradeModalClose) {
	  upgradeModalClose.addEventListener('click', () => {
		upgradeModalLayer?.classList.remove('show');
	  });
	}

	// Rules Modal handlers
	const rulesModalLayer = document.getElementById('rules-modal-layer');
	const rulesModalClose = document.getElementById('rules-modal-close');
	
	window.showRulesModal = function() {
		if (rulesModalLayer) {
			rulesModalLayer.classList.add('show');
		}
	};

	if (rulesModalClose) {
		rulesModalClose.addEventListener('click', () => {
			rulesModalLayer?.classList.remove('show');
		});
	}
	
	if (rulesModalLayer) {
		rulesModalLayer.addEventListener('click', (e) => {
			if (e.target === rulesModalLayer) {
				rulesModalLayer.classList.remove('show');
			}
		});
	}

	const bonusZoneEl = document.getElementById('bonus-zone');
	if (bonusZoneEl) {
	  bonusZoneEl.addEventListener('pointerdown', onBonusPointerDown);
	  bonusZoneEl.addEventListener('click', event => {
		const badge = event.target.closest('.bonus-badge');
		if (badge) event.preventDefault();
	  });
	}
	updateBonusInventoryUI();
	// startNewRun() is verplaatst naar de game initialization functie
	initialiseCoins();
	addCoin();
	
	// Initialiseer de +1 blokplaatsing knop en preview
	const buyPlacementBtn = document.getElementById('buy-placement-btn');
	const purchasedBlockPreview = document.getElementById('purchased-block-preview');
	if (buyPlacementBtn) {
	  buyPlacementBtn.addEventListener('click', (e) => {
		e.stopPropagation();
		onBuyPlacementClick();
	  });
	  buyPlacementBtn.addEventListener('pointerdown', (e) => {
		e.stopPropagation();
	  });
	  buyPlacementBtn.addEventListener('pointerup', (e) => {
		e.stopPropagation();
	  });
	  updateBuyPlacementButton();
	}
	if (purchasedBlockPreview) {
	  // Gebruik pointerdown voor zowel mouse als touch
	  purchasedBlockPreview.addEventListener('pointerdown', (e) => {
		e.stopPropagation();
		e.preventDefault(); // Voorkom touch scroll
		// Capture pointer voor touch devices
		if (e.pointerId !== undefined) {
			try {
				purchasedBlockPreview.setPointerCapture(e.pointerId);
			} catch (err) { /* ignore */ }
		}
		onPurchasedBlockPreviewClick(e);
	  });
	  purchasedBlockPreview.addEventListener('click', (e) => {
		e.stopPropagation();
	  });
	  // Touch events als fallback
	  purchasedBlockPreview.addEventListener('touchstart', (e) => {
		// Niet blokkeren als pointerdown al afgehandeld is
		if (e.defaultPrevented) return;
		e.stopPropagation();
		const touch = e.touches[0];
		if (touch) {
			onPurchasedBlockPreviewClick({
				clientX: touch.clientX,
				clientY: touch.clientY,
				pointerId: touch.identifier
			});
		}
	  }, { passive: false });
	}

  // expose some helpers for debugging
	window.createGrid = createGrid;
	window.generateRoots = generateRoots;
	// Wrap updateScore so scenario monitor runs after each score recalculation
	try {
		window._origUpdateScore = updateScore;
		window.updateScore = function(cell) {
			try { window._origUpdateScore(cell); } catch(e) { try { window._origUpdateScore(cell); } catch(e){} }
			try { if (typeof monitorScenarioProgress === 'function') monitorScenarioProgress(); } catch(e){}
		};
	} catch (e) {
		window.updateScore = updateScore;
	}
  
  
	function hideEmptyZones() {
	const zones = document.querySelectorAll('#original-coins-zone, #original-score-zone, #original-objective-zone, #original-card-zone, #original-controls-zone, #original-bonus-zone');
	  zones.forEach(zone => {
		if (zone.children.length === 0) {
		  zone.style.display = 'none';
		} else {
		  zone.style.display = '';
		}
	  });
	}
 
	function getCardSizing() {
		const isMobile = window.innerWidth <= MOBILE_BREAKPOINT;
		// If we're in a zoomed-in mobile view, prefer measuring the actual
		// rendered cell size from the active zoom zone so card previews use
		// the same cell size as the board.
		try {
			if (document.body.classList.contains('zoomed-in') && typeof activeZoomZone !== 'undefined' && activeZoomZone) {
				const measured = Math.round(getActualCellSize(activeZoomZone));
				return {
					cardSize: isMobile ? 140 : 110,
					cellSize: Number.isFinite(measured) && measured > 6 ? measured : (isMobile ? 14 : 20)
				};
			}
		} catch (e) {}
		return {
			cardSize: isMobile ? 140 : 110,
			cellSize: isMobile ? 14 : 20
		};
	}

	function applyCardSizing() {
	const { cellSize: fallbackCellSize } = getCardSizing();
	document.querySelectorAll('#card-choice-zone .card-option, .shop-card .card-option, #deck-modal-content .card-option').forEach(card => {
		const cols = parseInt(card.dataset.shapeCols || '0', 10);
		const rows = parseInt(card.dataset.shapeRows || '0', 10);
		const pattern = card.querySelector('.card-pattern');
		const cells = pattern ? pattern.querySelectorAll('.card-cell') : card.querySelectorAll('.card-cell');
		const cssCellSizeRaw = (getComputedStyle(card).getPropertyValue('--preview-cell') || '').trim();
		const cssCellSize = parseFloat(cssCellSizeRaw);
		const cellSize = Number.isFinite(cssCellSize) && cssCellSize > 0 ? cssCellSize : fallbackCellSize;
		if (pattern && cols) pattern.style.gridTemplateColumns = `repeat(${cols}, ${cellSize}px)`;
		if (pattern && rows) pattern.style.gridTemplateRows = `repeat(${rows}, ${cellSize}px)`;
		cells.forEach(cell => {
		  cell.style.width = `${cellSize}px`;
		  cell.style.height = `${cellSize}px`;
		});
	  });
	}

	function applyMobileHandFitForFiveCards() {
		const bottomBar = document.getElementById('bottom-bar');
		if (!bottomBar) return;
		const isMobile = window.innerWidth <= MOBILE_BREAKPOINT;
		if (!isMobile) {
			bottomBar.style.removeProperty('--hand-card-width');
			return;
		}
		const cardControls = document.getElementById('card-controls');
		const cardOptions = document.getElementById('card-options');
		const actionButtons = document.getElementById('card-action-buttons');
		if (!cardControls || !cardOptions || !actionButtons) return;

		const cards = cardOptions.querySelectorAll('.card-option');
		const cardCount = cards.length;
		if (cardCount < 1) {
			bottomBar.style.removeProperty('--hand-card-width');
			return;
		}

		const rootStyles = getComputedStyle(document.documentElement);
		const cardGap = parseFloat(rootStyles.getPropertyValue('--hand-card-gap')) || 6;
		const controlsGapRaw = getComputedStyle(cardControls).gap || '0px';
		const controlsGap = parseFloat(String(controlsGapRaw).split(' ')[0]) || 0;
		const optionsStyles = getComputedStyle(cardOptions);
		const paddingLeft = parseFloat(optionsStyles.paddingLeft) || 0;
		const paddingRight = parseFloat(optionsStyles.paddingRight) || 0;
		const available = cardControls.clientWidth
			- actionButtons.offsetWidth
			- controlsGap
			- paddingLeft
			- paddingRight;
		if (!(available > 0)) return;

		const targetWidth = Math.floor((available - (cardGap * Math.max(0, cardCount - 1))) / cardCount);
		// Clamp so cards remain tappable on narrow screens.
		const clamped = Math.max(56, Math.min(targetWidth, 132));
		bottomBar.style.setProperty('--hand-card-width', `${clamped}px`);
	}

	function scaleBoardForDesktop() {
		const board = document.getElementById('board');
		if (!board) return;
		const boardContainer = board.parentElement;
		const desktopBottom = document.getElementById('desktop-bottom');
		const desktopWrapper = document.getElementById('desktop-wrapper');
		const isDesktop = window.innerWidth > MOBILE_BREAKPOINT;
		const isMobileSidebar = document.body.classList.contains('mobile-sidebar-layout');
		if (!isDesktop || isMobileSidebar) {
			if (desktopWrapper) {
				desktopWrapper.style.removeProperty('transform');
				desktopWrapper.style.removeProperty('transform-origin');
			}
			board.style.removeProperty('transform');
			board.style.removeProperty('transform-origin');
			if (boardContainer && boardContainer.id === 'desktop-grids') {
				boardContainer.style.removeProperty('justify-content');
			}
			if (desktopBottom) {
				desktopBottom.style.removeProperty('margin-top');
			}
			document.body.classList.remove('board-scaled');
			return;
		}

		if (!desktopWrapper) {
			board.style.removeProperty('transform');
			board.style.removeProperty('transform-origin');
			document.body.classList.remove('board-scaled');
			return;
		}

		// reset inline transforms before measuring
		desktopWrapper.style.removeProperty('transform');
		desktopWrapper.style.removeProperty('transform-origin');

		// Always clear board-only scaling first; we may apply wrapper-level scaling.
		board.style.removeProperty('transform');
		board.style.removeProperty('transform-origin');

		const isPortrait = document.body.classList.contains('desktop-portrait');
		const isLandscape = document.body.classList.contains('desktop-landscape');

		// Desktop-landscape: scale the entire desktop wrapper so board + side UI fit together.
		if (isLandscape) {
			if (boardContainer && boardContainer.id === 'desktop-grids') {
				boardContainer.style.removeProperty('justify-content');
			}
			if (desktopBottom) {
				desktopBottom.style.removeProperty('margin-top');
			}
			document.body.classList.remove('board-scaled');

			// The body has padding: 10px on each side.
			// Be conservative: transformed content + shadows can otherwise get clipped at the viewport edges.
			const viewportW = document.documentElement ? document.documentElement.clientWidth : window.innerWidth;
			const viewportH = document.documentElement ? document.documentElement.clientHeight : window.innerHeight;
			// Margin to avoid edge clipping from shadows/rounding.
			// Keep this modest so the left/right panels don't get unnecessarily cramped.
			const safeMargin = 24;
			const availableWidth = Math.max(viewportW - safeMargin, 280);
			const availableHeight = Math.max(viewportH - safeMargin, 240);
			const contentWidth = desktopWrapper.scrollWidth;
			const contentHeight = desktopWrapper.scrollHeight;
			if (!(contentWidth > 0 && contentHeight > 0)) return;

			const scale = Math.min(availableWidth / contentWidth, availableHeight / contentHeight, 1);
			if (scale < 0.999) {
				// Anchor to the left so narrow screens don't waste space on the left,
				// but center it when there is spare horizontal room after scaling.
				desktopWrapper.style.transformOrigin = 'top left';
				const scaledWidth = contentWidth * scale;
				const offsetX = Math.max(0, (viewportW - scaledWidth) / 2);
				desktopWrapper.style.transform = `translateX(${offsetX.toFixed(1)}px) scale(${scale.toFixed(4)})`;
			} else {
				desktopWrapper.style.removeProperty('transform');
				desktopWrapper.style.removeProperty('transform-origin');
			}
			return;
		}
		
		// Calculate sidebar widths for landscape mode
		let rightSidebarWidth = 0;
		if (isLandscape) {
			const wrapper = document.getElementById('desktop-wrapper');
			const rightSidebar = wrapper ? wrapper.querySelector('.desktop-right-column, #right-sidebar, [class*="right"]') : null;
			if (rightSidebar) {
				rightSidebarWidth = rightSidebar.offsetWidth || 200;
			} else {
				// Estimate sidebar width based on viewport
				rightSidebarWidth = Math.min(220, window.innerWidth * 0.18);
			}
		}
		
		// Portrait mode: leave more room for bottom bar
		// Landscape mode: account for right sidebar
		// Short height (<=925px): need extra room for compact bottom bar
		const isShortHeight = window.innerHeight <= 925;
		const bottomReserve = isPortrait ? (isShortHeight ? 150 : 160) : 80;
		const horizontalPadding = isPortrait ? 40 : 60;
		const sidebarReserve = isLandscape ? (rightSidebarWidth + 40) : 0; // sidebar + gap
		
		const availableWidth = Math.max(window.innerWidth - horizontalPadding - sidebarReserve, 280);
		const availableHeight = Math.max(window.innerHeight - horizontalPadding - bottomReserve, 200);
		const boardWidth = board.scrollWidth;
		const boardHeight = board.scrollHeight;
		if (!boardWidth || !boardHeight) return;

		// For constrained viewports (925-1650px), be more aggressive with scaling
		const isConstrainedLandscape = isLandscape && window.innerWidth < 1650;
		const maxScale = isConstrainedLandscape ? 0.95 : 1;
		
		const scale = Math.min(availableWidth / boardWidth, availableHeight / boardHeight, maxScale);
		const containerWidth = (boardContainer && boardContainer.clientWidth) ? boardContainer.clientWidth : (window.innerWidth - sidebarReserve);
		const scaledBoardWidth = boardWidth * scale;
		const scaledBoardHeight = boardHeight * scale;
		const offsetX = Math.max((containerWidth - scaledBoardWidth) / 2, 0);

		if (scale < 0.999) {
			// When we scale with CSS transforms, layout width stays unscaled.
			// If the parent is centered flex, this can push the board off to the left.
			// Fix by left-aligning layout and translating the scaled board back to center.
			if (boardContainer && boardContainer.id === 'desktop-grids') {
				boardContainer.style.justifyContent = 'flex-start';
			}
			// Desktop-portrait: compensate for transform-scale whitespace by pulling the bottom UI up.
			// This avoids clipping the board (transform doesn't affect layout height).
			if (isPortrait && desktopBottom) {
				const gap = Math.max(0, Math.round(boardHeight - scaledBoardHeight));
				desktopBottom.style.marginTop = gap ? `-${gap}px` : '';
			} else if (desktopBottom) {
				desktopBottom.style.removeProperty('margin-top');
			}
			board.style.transform = `translateX(${offsetX.toFixed(1)}px) scale(${scale})`;
			board.style.transformOrigin = 'top left';
			document.body.classList.add('board-scaled');
		} else {
			board.style.removeProperty('transform');
			board.style.removeProperty('transform-origin');
			if (boardContainer && boardContainer.id === 'desktop-grids') {
				boardContainer.style.removeProperty('justify-content');
			}
			if (desktopBottom) {
				desktopBottom.style.removeProperty('margin-top');
			}
			document.body.classList.remove('board-scaled');
		}
	}

	function scaleBoardForMobile() {
		const board = document.getElementById('board');
		if (!board) return;
		const isMobile = window.innerWidth <= MOBILE_BREAKPOINT;
		if (!isMobile) {
			document.documentElement.style.removeProperty('--board-scale');
			document.body.classList.remove('board-mobile-scaled');
			return;
		}

		// Reset any inline desktop transform if we just crossed breakpoints.
		board.style.removeProperty('transform');
		board.style.removeProperty('transform-origin');
		document.body.classList.remove('board-scaled');

		const rootStyles = getComputedStyle(document.documentElement);
		const isClassicMode = document.body.classList.contains('classic-mode');
		const bottomBar = document.getElementById('bottom-bar');
		const bottomBarMeasured = (!isClassicMode && bottomBar) ? bottomBar.getBoundingClientRect().height : 0;
		const bottomBarCss = isClassicMode ? 0 : (parseFloat(rootStyles.getPropertyValue('--bottom-bar-height')) || 0);
		const bottomBarHeight = Math.max(bottomBarMeasured || 0, bottomBarCss || 0);
		const mobileObjective = document.getElementById('mobile-objective-banner');
		const objectiveHeight = mobileObjective ? mobileObjective.getBoundingClientRect().height : 0;

		// Provide some breathing room so we never render past the edges.
		const horizontalPadding = 16;
		const verticalPadding = 24;
		const availableWidth = Math.max(window.innerWidth - horizontalPadding, 280);
		const availableHeight = Math.max(window.innerHeight - bottomBarHeight - objectiveHeight - verticalPadding, 280);

		const boardWidth = board.scrollWidth;
		const boardHeight = board.scrollHeight;
		if (!boardWidth || !boardHeight) return;

		let scale = Math.min(availableWidth / boardWidth, availableHeight / boardHeight, 1);
		scale = Math.max(0.25, Math.min(scale, 1));
		document.documentElement.style.setProperty('--board-scale', scale.toFixed(3));
		document.body.classList.add('board-mobile-scaled');
	}

	function moveGameElements() {
	  const width = window.innerWidth;
	  const height = window.innerHeight;
	  const isMobile = width <= MOBILE_BREAKPOINT;
	  
	  // Bepaal portrait/landscape primair op basis van afmetingen (iPad/Safari matchMedia kan misrapporteren).
	  const ORIENTATION_EPS = 24; // px tolerance to avoid flapping near-square viewports
	  const effectiveLandscape = (width - height) > ORIENTATION_EPS;
	  const effectivePortrait = (height - width) > ORIENTATION_EPS;
	  // Fallback if near-square
	  const isPortrait = effectivePortrait || (!effectiveLandscape && height >= width);
	  
	  // Touch device check - belangrijk voor onderscheid desktop vs tablet/telefoon
	  // isCoarsePointer() checkt voor touch-primaire devices
	  const isTouchDevice = isCoarsePointer();
	  const isLargeTouchScreen = isTouchDevice && Math.min(width, height) >= 700;
	  
	  // Desktop breakpoints - voor wanneer bottom layout beter is
	  const DESKTOP_NARROW_BREAKPOINT = 800; // Was 925, nu smaller voor meer sidebar gebruik
	  const DESKTOP_SHORT_HEIGHT_BREAKPOINT = 500; // Was 925, nu korter - sidebars werken ook bij korte hoogte
	  
	  // BELANGRIJK: Verschil maken tussen:
	  // 1. Desktop/laptop (muis) â†’ gebruikt normale desktop layout (sidebars of bottom)
	  // 2. Tablet/telefoon (touch) in landscape â†’ gebruikt compacte mobile sidebar layout
	  
	  // Mobile sidebar layout is ALLEEN voor kleine touch screens (phones/small tablets) in landscape.
	  // Grote tablets (iPad) gebruiken de normale desktop layout.
	  const useMobileSidebarLayout = isTouchDevice && !isLargeTouchScreen && effectiveLandscape && 
	                                  width > 500 && height >= 350;
	  
	  const useDesktopLayout = !isMobile && !useMobileSidebarLayout;
	  // Desktop sidebar layout: landscape met voldoende breedte
	  const useDesktopLandscape = useDesktopLayout && effectiveLandscape && width > DESKTOP_NARROW_BREAKPOINT;
	  // Bottom layout: portrait of te smal
	  const isNarrowDesktop = useDesktopLayout && width <= DESKTOP_NARROW_BREAKPOINT;
	  const isShortDesktop = useDesktopLayout && height <= DESKTOP_SHORT_HEIGHT_BREAKPOINT;
	  
	  // Touch device in portrait mode
	  const isTouchPortrait = isTouchDevice && !useMobileSidebarLayout && !effectiveLandscape;
	  
	  // Desktop bottom layout: alleen in portrait of als echt te smal
	  // NIET meer gebaseerd op short height - sidebars werken goed met scroll
	  const useDesktopPortrait = useDesktopLayout && (isPortrait || isNarrowDesktop);
	  
	  // Add body classes for CSS targeting
	  document.body.classList.toggle('mobile-sidebar-layout', useMobileSidebarLayout);
	  document.body.classList.toggle('touch-portrait', isTouchPortrait);
	  document.body.classList.remove('mobile-landscape'); // deprecated class
	  
	  // Desktop classes - ook voor grote tablets (iPad) zodat portrait/landscape correct werkt
	  if (useDesktopLayout) {
		  document.body.classList.toggle('desktop-portrait', useDesktopPortrait);
		  document.body.classList.toggle('desktop-landscape', useDesktopLandscape && !useDesktopPortrait);
	  } else {
		  document.body.classList.remove('desktop-portrait', 'desktop-landscape');
	  }

		  const coins = document.getElementById('gold-zone');
		  const score = document.getElementById('scoreboard');
		  const objective = document.getElementById('objective-zone');
		  const bonus = document.getElementById('bonus-zone');
		  const cards = document.getElementById('card-choice-zone');
		  const controls = document.getElementById('controls');
		  const board = document.getElementById('board');

			  const bottomBarScore = document.getElementById('bottom-bar-score');
			  const bottomBarRight = document.getElementById('bottom-bar-cards');
			  const bottomBarBonus = document.getElementById('bottom-bar-bonus');
			  const bottomBarCoins = document.getElementById('bottom-bar-coins');
			  const bottomBarScoreCoins = document.getElementById('bottom-bar-score-coins');
		  const mobileObjective = document.getElementById('mobile-objective-banner');
		  
		  // Mobile Sidebar containers
		  const mlWrapper = document.getElementById('mobile-landscape-wrapper');
		  const mlLeft = document.getElementById('ml-sidebar-left');
		  const mlCenter = document.getElementById('ml-board-center');
		  const mlRight = document.getElementById('ml-sidebar-right');
		  const mlObjectiveTop = document.getElementById('ml-objective-top');

	const origCoins = document.getElementById('original-coins-zone');
	const origScore = document.getElementById('original-score-zone');
	const origObjective = document.getElementById('original-objective-zone');
	const origBonus = document.getElementById('original-bonus-zone');
	  const origCards = document.getElementById('original-card-zone');
	  const origControls = document.getElementById('original-controls-zone');

			// === MOBILE LANDSCAPE SIDEBAR LAYOUT ===
			// Dit geldt ALLEEN voor touch devices (tablets/telefoons) in landscape mode
			// Desktop/laptop behoudt normale layout
			if (useMobileSidebarLayout) {
				// Zorg dat de sidebar wrapper elementen bestaan
				if (!mlWrapper || !mlLeft || !mlCenter || !mlRight) {
					console.warn('Mobile landscape wrapper elements not found, cannot use sidebar layout');
				} else {
				// Remove desktop wrapper if exists
				const desktopWrapper = document.getElementById('desktop-wrapper');
				if (desktopWrapper) {
					const parent = desktopWrapper.parentNode;
					while (desktopWrapper.firstChild) {
						parent.insertBefore(desktopWrapper.firstChild, desktopWrapper);
					}
					desktopWrapper.remove();
				}
				
				// Show wrapper
				mlWrapper.style.display = 'flex';
				
				// Move elements to sidebars
				if (score && !mlLeft.contains(score)) mlLeft.appendChild(score);
				if (coins && !mlLeft.contains(coins)) mlLeft.appendChild(coins);
				
				// Move objective to top of center column
				if (objective && mlObjectiveTop && !mlObjectiveTop.contains(objective)) {
					mlObjectiveTop.appendChild(objective);
					mlObjectiveTop.style.display = 'flex';
				}
				
				if (board && !mlCenter.contains(board)) mlCenter.appendChild(board);
				if (cards && !mlRight.contains(cards)) mlRight.appendChild(cards);
				if (bonus && !mlRight.contains(bonus)) mlRight.appendChild(bonus);
				
				// Scale board to fit center
				requestAnimationFrame(() => {
					if (!board || !mlCenter) return;
					const objectiveH = mlObjectiveTop ? mlObjectiveTop.offsetHeight : 0;
					const availW = mlCenter.clientWidth - 6;
					const availH = mlCenter.clientHeight - objectiveH - 10;
					const boardW = board.scrollWidth;
					const boardH = board.scrollHeight;
					if (boardW > 0 && boardH > 0) {
						const scale = Math.min(availW / boardW, availH / boardH, 1);
						board.style.transform = `scale(${Math.max(0.25, scale).toFixed(3)})`;
						board.style.transformOrigin = 'top center';
					}
				});
				
				placeActionButtons();
				applyCardSizing();
				hideEmptyZones();
				return;
				}
			}
			
			// Hide mobile sidebar wrapper when not in that mode
			if (mlWrapper) mlWrapper.style.display = 'none';
			if (mlObjectiveTop) mlObjectiveTop.style.display = 'none';

				if (isMobile) {
				const isClassicMode = document.body.classList.contains('classic-mode');
				// Remove desktop wrapper if exists
				const desktopWrapper = document.getElementById('desktop-wrapper');
				if (desktopWrapper) {
					const parent = desktopWrapper.parentNode;
					while (desktopWrapper.firstChild) {
						parent.insertBefore(desktopWrapper.firstChild, desktopWrapper);
					}
					desktopWrapper.remove();
				}
				
					// Move elements to bottom bar sections
					if (score && bottomBarScore && !bottomBarScore.contains(score)) bottomBarScore.appendChild(score);
					if (objective && mobileObjective && !mobileObjective.contains(objective)) mobileObjective.appendChild(objective);
					if (cards && bottomBarRight && !bottomBarRight.contains(cards)) bottomBarRight.appendChild(cards);

					// Mobile footer: row above scoreboard = bonus inventory + coin total + buy button.
					// In classic mode, the bottom bar is hidden: keep coins outside the bottom bar.
					if (bonus && bottomBarBonus && !bottomBarBonus.contains(bonus) && !isClassicMode) bottomBarBonus.appendChild(bonus);
					if (coins && bottomBarBonus && !bottomBarBonus.contains(coins) && !isClassicMode) bottomBarBonus.appendChild(coins);
					if (coins && board && !board.contains(coins) && isClassicMode) board.appendChild(coins);
					const buyPlacementContainer = document.getElementById('buy-placement-container');
					if (buyPlacementContainer && coins && !coins.contains(buyPlacementContainer)) {
						coins.appendChild(buyPlacementContainer);
					}

				if (controls && controls.parentNode !== document.body) document.body.appendChild(controls);
				placeActionButtons();
				applyCardSizing();
			} else {
			closeZoom();

				// Ensure the buy button lives inside the coin zone again on desktop.
				const buyPlacementContainer = document.getElementById('buy-placement-container');
				if (buyPlacementContainer && coins && !coins.contains(buyPlacementContainer)) {
					coins.appendChild(buyPlacementContainer);
				}
		
		// Toggle body class for portrait bottom layout (keep both flags consistent)
		document.body.classList.toggle('desktop-portrait', useDesktopPortrait);
		document.body.classList.toggle('desktop-landscape', useDesktopLandscape && !useDesktopPortrait);
		
		// Create desktop wrapper if not exists
		let desktopWrapper = document.getElementById('desktop-wrapper');
		if (!desktopWrapper) {
			desktopWrapper = document.createElement('div');
			desktopWrapper.id = 'desktop-wrapper';
			
			// Create containers
			const desktopMenu = document.createElement('div');
			desktopMenu.id = 'desktop-menu';
			
			const desktopObjective = document.createElement('div');
			desktopObjective.id = 'desktop-objective';
			
			const desktopLeft = document.createElement('div');
			desktopLeft.id = 'desktop-left';
			
			const desktopGrids = document.createElement('div');
			desktopGrids.id = 'desktop-grids';
			
			const desktopRight = document.createElement('div');
			desktopRight.id = 'desktop-right';
			
			const desktopBottom = document.createElement('div');
			desktopBottom.id = 'desktop-bottom';
			
			// Create bottom section columns for portrait mode
			const bottomLeft = document.createElement('div');
			bottomLeft.id = 'desktop-bottom-left';
			const bottomCenter = document.createElement('div');
			bottomCenter.id = 'desktop-bottom-center';
			const bottomButtons = document.createElement('div');
			bottomButtons.id = 'desktop-bottom-buttons';
			const bottomRight = document.createElement('div');
			bottomRight.id = 'desktop-bottom-right';
			
			desktopBottom.appendChild(bottomLeft);
			desktopBottom.appendChild(bottomCenter);
			desktopBottom.appendChild(bottomButtons);
			desktopBottom.appendChild(bottomRight);
			
			desktopWrapper.appendChild(desktopMenu);
			desktopWrapper.appendChild(desktopObjective);
			desktopWrapper.appendChild(desktopLeft);
			desktopWrapper.appendChild(desktopGrids);
			desktopWrapper.appendChild(desktopRight);
			desktopWrapper.appendChild(desktopBottom);					// Insert wrapper before board
					if (board) {
						board.parentNode.insertBefore(desktopWrapper, board);
					}
					
					// Desktop menu toggle is handled by the single #menu-toggle overlay.
				}
				
				// Move elements to desktop positions
				const desktopMenu = document.getElementById('desktop-menu');
				const desktopObjective = document.getElementById('desktop-objective');
				const desktopLeft = document.getElementById('desktop-left');
				const desktopGrids = document.getElementById('desktop-grids');
				const desktopRight = document.getElementById('desktop-right');
				const desktopBottom = document.getElementById('desktop-bottom');
				const bottomLeft = document.getElementById('desktop-bottom-left');
				const bottomCenter = document.getElementById('desktop-bottom-center');
				const bottomButtons = document.getElementById('desktop-bottom-buttons');
				const bottomRight = document.getElementById('desktop-bottom-right');
				
				if (controls && desktopMenu && !desktopMenu.contains(controls)) {
					desktopMenu.appendChild(controls);
				}
				// Remove legacy duplicated desktop toggle if it exists from older versions.
				const legacyDesktopToggle = document.getElementById('desktop-menu-toggle');
				if (legacyDesktopToggle) legacyDesktopToggle.remove();
				if (objective && desktopObjective && !desktopObjective.contains(objective)) {
					desktopObjective.appendChild(objective);
				}
				if (board && desktopGrids && !desktopGrids.contains(board)) {
					desktopGrids.appendChild(board);
				}
				
				if (useDesktopPortrait) {
					// Portrait mode: gebruik bottom layout
					if (score && bottomLeft && !bottomLeft.contains(score)) {
						bottomLeft.appendChild(score);
					}
					if (cards && bottomCenter && !bottomCenter.contains(cards)) {
						bottomCenter.appendChild(cards);
					}
					
					// Move action buttons below cards in portrait mode
					// On touch devices (iPad portrait), buttons should be BELOW cards, not in separate column
					const actionButtons = document.getElementById('card-action-buttons');
					if (actionButtons) {
						// Remove from current parent first
						if (actionButtons.parentNode) {
							actionButtons.parentNode.removeChild(actionButtons);
						}
						// On touch device: add buttons BELOW cards (inside bottomCenter)
						// On non-touch: use separate button zone (bottomButtons)
						if (isTouchDevice && bottomCenter) {
							bottomCenter.appendChild(actionButtons);
						} else if (bottomButtons) {
							bottomButtons.appendChild(actionButtons);
						}
					}
					
					if (bonus && bottomRight && !bottomRight.contains(bonus)) {
						bottomRight.appendChild(bonus);
					}
					// Coins (counter + buy button) under the cards in portrait bottom layout.
					if (coins && bottomCenter && !bottomCenter.contains(coins)) {
						bottomCenter.appendChild(coins);
					}
				} else {
					// Landscape mode: gebruik sidebar layout
					if (score && desktopLeft && !desktopLeft.contains(score)) {
						desktopLeft.appendChild(score);
					}
					if (coins && desktopLeft && !desktopLeft.contains(coins)) {
						desktopLeft.appendChild(coins);
					}
					if (cards && desktopRight && !desktopRight.contains(cards)) {
						desktopRight.appendChild(cards);
					}
					
					// In landscape mode, buttons go to separate zone below cards
					const actionButtons = document.getElementById('card-action-buttons');
					if (actionButtons) {
						// Remove from current parent first
						if (actionButtons.parentNode) {
							actionButtons.parentNode.removeChild(actionButtons);
						}
						// Add directly to desktopRight
						if (desktopRight) {
							desktopRight.appendChild(actionButtons);
						}
					}
					
					if (bonus && desktopRight && !desktopRight.contains(bonus)) {
						desktopRight.appendChild(bonus);
					}
				}
							placeActionButtons();
				applyCardSizing();
			}
	  
	  // Verberg lege zones
	  hideEmptyZones();
			  scaleBoardForDesktop();
			  scaleBoardForMobile();
		  renderTrapSummary();
		  autoCenterScrollableZones();
		  
	}

	function scrollChildIntoView(container, child, opts = {}) {
	  if (!container || !child) return;
	  const alignX = opts.alignX || 'center';
	  const alignY = opts.alignY || 'center';
	  const paddingY = Number.isFinite(opts.paddingY) ? opts.paddingY : 16;
	  const containerRect = container.getBoundingClientRect();
	  const childRect = child.getBoundingClientRect();
	  const currentLeft = container.scrollLeft;
	  const currentTop = container.scrollTop;
	  const deltaLeft = childRect.left - containerRect.left;
	  const deltaTop = childRect.top - containerRect.top;
	  let targetLeft = currentLeft;
	  let targetTop = currentTop;
	  if (alignX === 'center') {
		targetLeft = currentLeft + deltaLeft - (containerRect.width / 2 - childRect.width / 2);
	  }
	  if (alignY === 'center') {
		targetTop = currentTop + deltaTop - (containerRect.height / 2 - childRect.height / 2);
	  } else if (alignY === 'bottom') {
		targetTop = currentTop + deltaTop - (containerRect.height - childRect.height - paddingY);
	  }
	  container.scrollLeft = Math.max(0, targetLeft);
	  container.scrollTop = Math.max(0, targetTop);
	}

	function autoCenterScrollableZones() {
	  // Only auto-center when the user hasn't scrolled yet (prevents fighting the player).
	  const greenZone = document.getElementById('green-zone');
	  if (greenZone && greenZone.scrollTop <= 2 && greenZone.scrollLeft <= 2) {
		const greenStart = document.querySelector('#green-grid .cell.root-cell')
		  || document.querySelector('#green-grid .cell.end-cell')
		  || document.querySelector('#green-grid .cell.active');
		if (greenStart) scrollChildIntoView(greenZone, greenStart, { alignX: 'center', alignY: 'center' });
	  }

	  const blueZone = document.getElementById('blue-zone');
	  if (blueZone && blueZone.scrollTop <= 2) {
		const boldCells = Array.from(document.querySelectorAll('#blue-grid .cell.bold-cell'));
		if (boldCells.length) {
			const maxY = Math.max(...boldCells.map(cell => Number(cell.dataset.y) || 0));
			const bottomCells = boldCells.filter(cell => (Number(cell.dataset.y) || 0) === maxY);
			bottomCells.sort((a, b) => (Number(a.dataset.x) || 0) - (Number(b.dataset.x) || 0));
			const target = bottomCells[Math.floor(bottomCells.length / 2)] || boldCells[0];
			scrollChildIntoView(blueZone, target, { alignX: 'center', alignY: 'bottom', paddingY: 18 });
		} else {
			blueZone.scrollTop = blueZone.scrollHeight;
			blueZone.scrollLeft = Math.max(0, (blueZone.scrollWidth - blueZone.clientWidth) / 2);
		}
	  }
	}

	// Initial run
	moveGameElements();
	
	// Laad opgeslagen spel of start nieuw spel (na alle initialisaties)
	// Check EERST of er een save is voordat we iets doen
	(function initializeGame() {
		console.log('ðŸ” Initializing game...');
		const hasSave = localStorage.getItem('locusGameSave');
		console.log('ðŸ’¾ Save found:', !!hasSave);
		// By default do NOT auto-restore save on page reload to avoid surprising persistent decks.
		// Set AUTO_LOAD_SAVED_GAME = true to restore previous behavior.
		const AUTO_LOAD_SAVED_GAME = true;
		if (hasSave && AUTO_LOAD_SAVED_GAME) {
			if (loadGameState()) {
				console.log('âœ… Successfully loaded saved game');
				requestAnimationFrame(() => requestAnimationFrame(autoCenterScrollableZones));
				return;
			} else {
				console.warn('âš ï¸ Failed to load save, starting new game');
			}
		} else {
			console.log('ðŸŽ® Starting new game (auto-restore disabled)');
		}
		
		// Als we hier komen: geen save of laden mislukt
		startNewRun();
		requestAnimationFrame(() => requestAnimationFrame(autoCenterScrollableZones));
	})();

	// Run again on resize
	window.addEventListener('resize', () => {
		moveGameElements();
		// Herbereken zone groottes voor World 2/3 bij resize
		const worldInfo = typeof getWorldAndSubLevel === 'function' ? getWorldAndSubLevel(currentLevel) : null;
		if (worldInfo && (worldInfo.world === 2 || worldInfo.world === 3)) {
			adjustZoneSizesForWorld2();
		}
	});
	
	// Extra listener voor orientation change op mobiel/tablet
	window.addEventListener('orientationchange', () => {
		// Wacht kort tot de nieuwe dimensies beschikbaar zijn
		setTimeout(() => {
			moveGameElements();
			const worldInfo = typeof getWorldAndSubLevel === 'function' ? getWorldAndSubLevel(currentLevel) : null;
			if (worldInfo && (worldInfo.world === 2 || worldInfo.world === 3)) {
				adjustZoneSizesForWorld2();
			}
		}, 100);
	});

	// Menu toggle handled earlier (removed duplicate handler)
	
	// ========================================
	// HIGH SCORE SYSTEM (ADDED)
	// ========================================
	
	function getHighScore() {
		return Number(localStorage.getItem('locusHighScore') || '0');
	}

	function updateHighScore(currentScore) {
		const oldHigh = getHighScore();
		if (currentScore > oldHigh) {
			localStorage.setItem('locusHighScore', String(currentScore));
			showHighScorePopup(currentScore);
		}
	}

	function showHighScorePopup(score) {
		// Remove existing
		document.querySelectorAll('.highscore-toast').forEach(el => el.remove());
		
		const popup = document.createElement('div');
		popup.className = 'highscore-toast';
		popup.innerHTML = `
			<span class="highscore-toast__icon">ðŸ†</span>
			<div>
				<div>Nieuw record!</div>
				<div class="highscore-toast__score">${score}</div>
			</div>
		`;
		document.body.appendChild(popup);
		
		// Auto remove
		setTimeout(() => {
			popup.style.transition = 'opacity 0.5s ease, transform 0.5s ease';
			popup.style.opacity = '0';
			popup.style.transform = 'translate(-50%, -20px) scale(0.9)';
			setTimeout(() => popup.remove(), 500);
		}, 3000);
	}

	function showHighScoreModal() {
		// Create modal if not exists
		let overlay = document.getElementById('highscore-modal-layer');
		if (!overlay) {
			overlay = document.createElement('div');
			overlay.id = 'highscore-modal-layer';
			overlay.className = 'highscore-modal-overlay';
			overlay.innerHTML = `
				<div class="highscore-modal">
					<h2>ðŸ† High Score</h2>
					<div class="highscore-value" id="modal-highscore-value">0</div>
					<button class="highscore-close-btn" onclick="closeHighScoreModal()">Sluiten</button>
				</div>
			`;
			document.body.appendChild(overlay);
			
			// Close on click outside
			overlay.addEventListener('click', (e) => {
				if (e.target === overlay) closeHighScoreModal();
			});
		}
		
		// Update value
		document.getElementById('modal-highscore-value').textContent = getHighScore();
		
		// Show
		overlay.classList.add('show');
		
		// Close menu if open
		const controls = document.getElementById('controls');
		const menuToggle = document.getElementById('menu-toggle');
		if (controls) controls.classList.remove('open');
		if (menuToggle) menuToggle.classList.remove('active');
	}

	function closeHighScoreModal() {
		const overlay = document.getElementById('highscore-modal-layer');
		if (overlay) overlay.classList.remove('show');
	}

	function showSavedLevelsModal() {
		let overlay = document.getElementById('saved-levels-modal');
		if (!overlay) {
			overlay = document.createElement('div');
			overlay.id = 'saved-levels-modal';
			overlay.className = 'highscore-modal-overlay';
			overlay.innerHTML = `
				<div class="highscore-modal">
					<h2>Opgeslagen levels</h2>
					<div id="saved-levels-list" style="max-height:420px; overflow:auto; padding-right:8px;"></div>
					<div style="margin-top:12px;"><button class="modal-btn" onclick="closeSavedLevelsModal()">Sluit</button></div>
				</div>
			`;
			document.body.appendChild(overlay);
			overlay.addEventListener('click', (e) => { if (e.target === overlay) closeSavedLevelsModal(); });
		}
		// populate list
		const list = document.getElementById('saved-levels-list');
		list.innerHTML = '';

		// Append example scenarios for quick testing (World 4 prototypes)
		const examplesHeader = document.createElement('div');
		examplesHeader.style.marginBottom = '8px';
		examplesHeader.innerHTML = '<div class="saved-title">Voorbeeld-scenario\'s (World 4)</div>';
		list.appendChild(examplesHeader);

		const examples = [
		  { id: 'world4-4.1', name: 'Wereld 4.1 - Groen + Blauw', desc: 'Rechthoekige groen + brede blauwe zone. Special: sleutel/portal + subdoelen.', allowedColors: ['groen','blauw'], scenarioId: '4.1' },
		  { id: 'world4-4.2', name: 'Wereld 4.2 - Vormen & Shop', desc: 'Creatieve vormen in groen, lange blauwe strip met portal/key; 4x4 subdoelen en shop-stub.', allowedColors: ['groen','blauw'], scenarioId: '4.2' }
		];
		examples.forEach(ex => {
		  const item = document.createElement('div');
		  item.style.display = 'flex'; item.style.gap = '8px'; item.style.alignItems = 'center'; item.style.marginBottom = '8px';
		  const label = document.createElement('div'); label.style.flex = '1';
		  const titleText = document.createElement('div'); titleText.textContent = ex.name; titleText.style.fontWeight = '600'; titleText.className = 'saved-title';
		  const objText = document.createElement('div'); objText.className = 'saved-obj-text'; objText.textContent = ex.desc;
		  label.appendChild(titleText); label.appendChild(objText);
		  const loadBtn = document.createElement('button'); loadBtn.textContent = 'Laad in spel'; loadBtn.className = 'modal-btn primary';
		  loadBtn.addEventListener('click', ()=>{ loadScenario(ex.scenarioId, ex); closeSavedLevelsModal(); });
		  item.appendChild(label); item.appendChild(loadBtn);
		  list.appendChild(item);
		});
		let saved = {};
		try {
			const raw = localStorage.getItem('locusSavedBoards');
			if (raw) {
				try {
					saved = JSON.parse(raw || '{}');
				} catch (err) {
					console.error('Failed to parse locusSavedBoards JSON:', err, 'raw length:', raw.length);
					console.error('Raw locusSavedBoards starts with:', String(raw).slice(0, 200));
					saved = {};
				}
			} else saved = {};
		} catch (e) { console.error('Error reading locusSavedBoards from localStorage', e); saved = {}; }
		// Also check for an existing backup of the current game session
		let backup = null;
		try { backup = JSON.parse(localStorage.getItem('locusGameSaveBackup') || 'null'); } catch (e) { backup = null; }
		const names = Object.keys(saved).sort((a,b)=>(saved[b].ts||0)-(saved[a].ts||0));
		if (!names.length && !backup) {
			list.textContent = 'Geen opgeslagen levels.';
		} else {
			names.forEach(n => {
				const item = document.createElement('div');
				item.style.display = 'flex'; item.style.gap = '8px'; item.style.alignItems = 'center'; item.style.marginBottom = '8px';
				const label = document.createElement('div'); label.style.flex = '1';
				const titleText = document.createElement('div'); titleText.textContent = n; titleText.style.fontWeight = '600'; titleText.className = 'saved-title';
				const objText = document.createElement('div'); objText.className = 'saved-obj-text';
				objText.textContent = saved[n].objective ? saved[n].objective : 'Geen doel (standaard: Haal 100 punten)';
				label.appendChild(titleText); label.appendChild(objText);
				const openEditorBtn = document.createElement('button'); openEditorBtn.textContent = 'Open in Editor'; openEditorBtn.className = 'modal-btn';
				openEditorBtn.addEventListener('click', ()=>{
					try { localStorage.setItem('locusEditorBoardHtml', saved[n].html); } catch (e) {}
					const w = window.open('editor.html', '_blank');
					if (w) try { w.postMessage({ type:'LOCUS_EDITOR_BOARD', boardHtml: saved[n].html, name: saved[n].name || n, objective: saved[n].objective || null }, '*'); } catch (e) {}
				});
				const loadBtn = document.createElement('button'); loadBtn.textContent = 'Laad in spel'; loadBtn.className = 'modal-btn primary';
				const delBtn = document.createElement('button');
				delBtn.className = 'trash-btn modal-btn';
				delBtn.title = 'Verwijder opgeslagen level';
				delBtn.setAttribute('aria-label', `Verwijder ${n}`);
				delBtn.innerHTML = '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" aria-hidden="true"><path d="M3 6h18" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/><path d="M8 6v14a2 2 0 0 0 2 2h4a2 2 0 0 0 2-2V6" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/><path d="M10 11v6" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/><path d="M14 11v6" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/><path d="M9 6V4a1 1 0 0 1 1-1h4a1 1 0 0 1 1 1v2" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>';
				delBtn.style.padding = '6px';
				delBtn.style.border = '0';
				delBtn.style.background = 'transparent';
				delBtn.style.cursor = 'pointer';
				delBtn.style.color = 'inherit';
				delBtn.addEventListener('click', ()=>{
					if (!confirm(`Verwijder "${n}"?`)) return;
					try {
						try {
							const sb = JSON.parse(localStorage.getItem('locusSavedBoards')||'{}');
							delete sb[n];
							try {
								localStorage.setItem('locusSavedBoards', JSON.stringify(sb));
							} catch (le) {
								console.error('Failed to write locusSavedBoards during delete:', le, 'size:', JSON.stringify(sb).length);
								alert('Kon opgeslagen levels niet bijwerken (localStorage fout). Zie console voor details.');
							}
						} catch (pe) { console.error('Failed to parse locusSavedBoards when deleting:', pe); }
						// remove item from DOM
						if (item && item.parentNode) item.parentNode.removeChild(item);
					} catch (e) { console.error(e); }
				});
				loadBtn.addEventListener('click', ()=>{
					// Backup current game state + board before loading â€” ensure latest game state (coins/deck) is saved
					try {
						if (typeof saveGameState === 'function') {
							try { saveGameState(); } catch (e) { /* ignore save errors */ }
						}
						const currentGameSave = localStorage.getItem('locusGameSave') || null;
						const currentBoardHtmlRaw = (typeof getEditorBoardHtml === 'function') ? getEditorBoardHtml() : (document.getElementById('board') ? document.getElementById('board').outerHTML : null);
						const currentBoardHtml = (typeof sanitizeBoardHtml === 'function' && currentBoardHtmlRaw) ? sanitizeBoardHtml(currentBoardHtmlRaw) : currentBoardHtmlRaw;
						const backupObj = { ts: Date.now(), level: currentLevel || null, gameSave: currentGameSave, boardHtml: currentBoardHtml };
						localStorage.setItem('locusGameSaveBackup', JSON.stringify(backupObj));
						// Also add/overwrite a single autosave entry to saved boards for easy access (include gameSave)
						try {
							try {
								const sb = JSON.parse(localStorage.getItem('locusSavedBoards')||'{}');
								const autosaveKey = 'Autosave: laatste bewerking';
								sb[autosaveKey] = { html: backupObj.boardHtml, gameSave: backupObj.gameSave, name: autosaveKey, ts: backupObj.ts };
								try {
									localStorage.setItem('locusSavedBoards', JSON.stringify(sb));
								} catch (le) {
									console.error('Failed to write locusSavedBoards for autosave:', le, 'size:', JSON.stringify(sb).length);
								}
							} catch (pe) { console.error('Failed to parse locusSavedBoards for autosave:', pe); }
						} catch (e) {}
					} catch (e) {}
					// Now apply the selected board into the current page and set title/objective
					applyBoardHtmlToGame(saved[n].html);
					setLoadedLevelMeta(saved[n].name || n, saved[n].objective || null);
					try { if (typeof resetScoreState === 'function') resetScoreState(); } catch(e){}
					if (typeof updateScore === 'function') setTimeout(()=> updateScore(), 120);
					setTimeout(()=>{ if (typeof setStatus === 'function') setStatus('Speelveld geladen. Gebruik "Herstel vorige" om terug te keren.'); }, 50);
				});
				item.appendChild(label); item.appendChild(openEditorBtn); item.appendChild(loadBtn); item.appendChild(delBtn);
				list.appendChild(item);
			});
			// If a backup exists, show a restore option at the end
				if (backup) {
				const restoreItem = document.createElement('div');
				restoreItem.style.display = 'flex'; restoreItem.style.gap = '8px'; restoreItem.style.alignItems = 'center'; restoreItem.style.marginTop = '12px';
				const lbl = document.createElement('div'); lbl.style.flex = '1'; lbl.textContent = `Herstel vorige sessie (level ${backup.level || '?'})`; lbl.className = 'saved-title';
				const restoreBtn = document.createElement('button'); restoreBtn.textContent = 'Herstel vorige'; restoreBtn.className = 'modal-btn';
				restoreBtn.addEventListener('click', ()=>{
					try {
						// restore saved game into localStorage
						if (backup.gameSave) localStorage.setItem('locusGameSave', backup.gameSave);
						// First restore gameplay state
						if (typeof loadGameState === 'function') {
							loadGameState();
						}
						// Then restore the exact board DOM snapshot
						if (backup.boardHtml) {
							setTimeout(()=>{
								applyBoardHtmlToGame(backup.boardHtml);
								try { if (typeof resetScoreState === 'function') resetScoreState(); } catch(e){}
								if (typeof updateScore === 'function') setTimeout(()=> updateScore(), 120);
							}, 80);
						}
						setTimeout(()=>{ if (typeof setStatus === 'function') setStatus('Vorige sessie hersteld.'); }, 200);
					} catch (e) { console.error(e); }
				});
				restoreItem.appendChild(lbl); restoreItem.appendChild(restoreBtn);
				list.appendChild(restoreItem);
			}
		}
		overlay.classList.add('show');
		// close menu
		const controls = document.getElementById('controls');
		const menuToggle = document.getElementById('menu-toggle');
		if (controls) controls.classList.remove('open');
		if (menuToggle) menuToggle.classList.remove('active');
	}

	function closeSavedLevelsModal() {
		const overlay = document.getElementById('saved-levels-modal');
		if (overlay) overlay.classList.remove('show');
	}
	
  </script>
  <style>
	/* FINAL CONSOLIDATED MOBILE LAYOUT (CLEANUP & FIXES) */
	@media (max-width: 650px) {
		:root {
			--preview-gap: 2px;
		}
		
		/* 1. UNIFORM ZONE WIDTHS & CENTERING */
		/* Yellow + Purple keep equal width; Red + Green are slightly wider to allow the 2Ã—2 red layout. */
		#yellow-zone, #purple-zone, #green-zone,
		#yellow-zone--placeholder, #purple-zone--placeholder,
		#green-zone--placeholder {
			/* Wider to accommodate inner grid margins/padding on mobile */
			width: calc(13 * var(--cell-size) + 40px) !important;
			min-width: calc(13 * var(--cell-size) + 40px) !important;
			max-width: calc(13 * var(--cell-size) + 40px) !important;
			margin: 0 !important;
			padding: 6px !important;
			box-sizing: border-box !important;
			display: flex !important;
			flex-direction: column !important;
			align-items: center !important;
			justify-content: center !important;
		}

		/* Red + Green: slightly wider so red can stay 2Ã—2 and green can match the column width. */
		#red-zone, #green-zone,
		#red-zone--placeholder, #green-zone--placeholder {
			width: calc(15 * var(--cell-size) + 60px) !important;
			min-width: calc(15 * var(--cell-size) + 60px) !important;
			max-width: calc(15 * var(--cell-size) + 60px) !important;
		}

		/* Mobile: keep gaps consistent across zones (zoomed AND unzoomed). */
		.grid { gap: var(--board-grid-gap, 2px) !important; }

		/* Mobile unzoomed: cap blue height so it's not an extremely tall strip; keep it scrollable. */
		body:not(.zoomed-in) #blue-zone,
		body:not(.zoomed-in) #blue-zone--placeholder {
			height: 400px !important;
			max-height: 400px !important;
			overflow: auto !important;
		}

		/* Red MUST remain a 2Ã—2 grid (the rule above sets widths only). */
		#red-zone.red-group,
		#red-zone--placeholder.red-group {
			display: grid !important;
			grid-template-columns: repeat(2, max-content) !important;
			justify-content: center !important;
			gap: 18px !important;
			align-content: start !important;
		}
		#red-zone.red-group > .zone,
		#red-zone--placeholder.red-group > .zone {
			padding: 0 !important;
			box-sizing: border-box !important;
		}

		/* When the board is scaled down to fit the screen, keep spacing consistent. */
		body.board-scaled .grid { gap: var(--board-grid-gap, 2px) !important; }
		body.board-scaled .cell { border-radius: 7px !important; }

		/* Mobile: uniform gap between zones in columns, more gap between columns */
		.board {
			gap: 8px !important; /* gap between columns */
		}
		.column {
			gap: 6px !important; /* uniform gap between zones */
		}
		.zone {
			margin: 0 !important;
			padding: 6px !important;
		}

		/* 2. SYMMETRICAL HEIGHTS */
		/* Blue = 750px reference. Gap = 6px between zones. */
		/* Column 1: Yellow + gap(6) + Purple = 750 â†’ Yellow = 372, Purple = 372 */
		#yellow-zone, #yellow-zone--placeholder {
			min-height: 372px !important;
			height: 372px !important;
		}
		#purple-zone, #purple-zone--placeholder {
			min-height: 372px !important;
			height: 372px !important;
		}
		/* Column 2: Green + gap(6) + Red = 750 â†’ Green = 410, Red = 334 */
		#green-zone, #green-zone--placeholder {
			min-height: 410px !important;
			height: 410px !important;
		}
		#red-zone, #red-zone--placeholder {
			min-height: 334px !important;
			height: 334px !important;
		}

		/* 3. BLUE ZONE: reference height for column symmetry */
		/* Blue = 750px. Column 1: 372+6+372=750. Column 2: 410+6+334=750. */
		#blue-zone, #blue-zone--placeholder {
			min-height: 750px !important;
			height: 750px !important;
			width: 160px !important;
			margin: 0 !important;
			padding: 6px !important;
		}

		/* 4. CARD & HAND ADJUSTMENTS */
		/* Force Cards to be slightly larger for visibility */
		:root {
			--hand-card-width: 58px !important;
			--hand-card-height: 85px !important;
		}

		#bottom-bar #card-choice-zone .card-option {
			width: 58px !important;
			min-width: 58px !important;
			max-width: 58px !important;
			min-height: 85px !important;
			padding: 4px !important;
			/* Key: keep JS preview sizing and CSS in sync */
			--preview-cell: 14px;
			--card-cell-size: 14px;
		}
		
		/* Adjust card pattern gap */
		#bottom-bar #card-choice-zone .card-option .card-pattern {
			/* Actual gap is set dynamically in updateCardPattern(..) */
			display: grid !important;
		}
		
		/* Hamburger Menu: Slightly larger */
		#menu-toggle {
			width: 40px !important;
			height: 40px !important;
			padding: 8px !important;
		}
		#menu-toggle span {
			width: 18px !important;
		}
	}

	/* Zoomed In Uniformity (non-mobile): Force all zoomed zones to be the same size.
	   IMPORTANT: mobile zoom sizing/placement is handled by the dedicated @media (max-width: 650px) block above.
	*/
	@media (min-width: 651px) {
		body.zoomed-in .zone.zoom-focus {
			width: 90vw !important;
			height: 65vh !important;
			max-width: none !important;
			max-height: none !important;
			min-width: 0 !important;
			min-height: 0 !important;
			overflow: auto !important;
			position: fixed !important;
			top: 50% !important;
			left: 50% !important;
			transform: translate(-50%, -50%) !important;
			z-index: 1000 !important;
			margin: 0 !important;
		}
	}

	/* 4. Desktop Landscape Fixes */
	@media (min-width: 900px) {
		#green-zone, #blue-zone {
			flex-shrink: 0; /* Prevent shrinking */
			min-width: calc(13 * var(--cell-size)) !important;
		}
		#blue-zone {
			min-height: 600px; /* Ensure it stays long */
		}
		.board {
			justify-content: center;
			gap: 20px; /* More space between columns */
		}
	}

  </style>
</html>
