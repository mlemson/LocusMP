<!DOCTYPE html>
<html lang="nl">
<head>
	<meta charset="utf-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
	<meta title="LOCUS Digitaal">
	<script>
		/*
			EN:
			- WHY: Apply the saved theme class as early as possible to avoid a flash of the wrong theme.
			- STATE: Reads `localStorage.theme` (and legacy `localStorage.darkMode`). Writes `dark-mode` on <html>.
			- OVERRIDE: The later DOMContentLoaded theme handler (applyTheme) is still the source of truth.
		*/
		(function preloadThemeClass() {
			try {
				var storedTheme = localStorage.getItem('theme');
				if (!storedTheme) {
					var legacy = localStorage.getItem('darkMode');
					if (legacy === 'true') storedTheme = 'dark';
					else if (legacy === 'false') storedTheme = 'light';
				}
				// Default: dark mode on (unless user explicitly chose light before).
				if (!storedTheme) storedTheme = 'dark';
				if (storedTheme === 'dark') {
					document.documentElement.classList.add('dark-mode');
				}
			} catch (e) {
				// Ignore storage errors (private mode / blocked storage).
			}
		})();
	</script>
		<style>
			/*
				EN: Comment tags used throughout this file:
				- WHY: reason the code exists / design intent
				- STATE: what global state / DOM state is read or written
				- OVERRIDE: this block can be overwritten later (order-dependent)
				- DUPLICATE: a similar rule/handler exists elsewhere (risk of divergence)
				- LEGACY: kept for backwards compatibility / older UI paths
				
				Note: This is a single-file app with large CSS + JS blocks; ordering matters.
			*/

			/* === Shared defaults (desktop look from 22-10 + mobile HUD from 23-10-3) === */
			html {
				min-height: 100%;
				background: #f6f8fb;
				overflow-y: hidden;
				overflow-x: hidden;
				overscroll-behavior: contain;
				/* Prevent browser back-navigation on horizontal swipe (iOS Safari, Chrome) */
				overscroll-behavior-x: none;
			}

			body {
				margin: 0;
				position: relative;
				padding: 10px;
				min-height: 100%;
				width: 100%;
				background: #f6f8fb;
				/*
					IMPORTANT (mobile/iOS): never put emoji fonts before system UI fonts.
					Otherwise digits can render in Apple Color Emoji, which looks "weird".
					Keep emoji fonts at the end so emoji still work when needed.
				*/
				font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", "Helvetica Neue", Arial, sans-serif, "Segoe UI Emoji", "Apple Color Emoji", "Noto Color Emoji";
				font-size: 16px;
				/*
					EN:
					- STATE: sets the page base typography + background.
					- LEGACY/BUG-PRONE: `gap`, `grid-template-columns`, `justify-content`, `align-items`
					  have no effect unless `display: grid` or `display: flex` is set on body.
					  If layout is controlled elsewhere (e.g. a `.layout` wrapper), these may be leftovers.
				*/
					gap: 10px;
				grid-template-columns: auto;
				justify-content: center;
				align-items: start;
				color: #222;
				transition: background-color 0.3s, color 0.3s;
			}

		:root {
			/* Base measurements */
			/* Fixed across all grids; the board itself is scaled to fit the screen. */
			--cell-size: 26px;
			--board-grid-gap: 2px;
			--preview-gap: 2px;
			--gap: 10px;
			--radius: 10px;
			--bottom-height: 70px;
			--side-panel-width: 120px;
			--card-size: 150px;

			/* Bottom bar sizing */
			--bottom-bar-gap: 0px;
			--bottom-bar-bottom-offset: 0px;
			--card-hand-lift: 12px;

			/* Z-index scale */
			--z-bottom: 450;      /* bottom bar */
			--z-controls: 1000;   /* controls panel */
			--z-menu: 1100;       /* menu / hamburger (must stay above other UI) */
			--z-ui: 250;          /* generic UI buttons */
			--z-blur: 400;        /* blur backdrop */
			--z-zoom: 500;        /* focused/zoomed zone */
			--z-drag: 600;        /* drag overlay (highest for dragged items) */
			--z-score: 700;       /* transient score / sparkle popups */
			--z-draggable: 600;   /* draggable block default */

			/* Colors - Light mode */
			--main-bg-light: #f6f8fb;
			--panel-bg-light: #ffffff;
			--score-bg-light: rgba(255,255,255,0.9);
			--card-bg-light: #ffffff;
			--coin-color: #ffd700;
			--coin-border: #b8860b;

			/* Colors - Dark mode */
			--main-bg-dark: #1a1a1a;
			--panel-bg-dark: #2d2d2d;
			--score-bg-dark: rgba(45,45,45,0.9);
			--card-bg-dark: #2d2d2d;
		}

		* {
			box-sizing: border-box;
		}

		#drag-overlay {
			position: fixed;
			top: 0;
			left: 0;
			width: 100vw;
			height: 100vh;
			pointer-events: none;
			cursor: none;
			z-index: var(--z-drag);
		}

	/* Floating preview voor touch-vriendelijke kaart plaatsing */
	#floating-preview {
		position: fixed;
		/* Positie wordt dynamisch ingesteld via JS */
		width: 138px;
		min-height: 180px;
		padding: 16px;
		display: none;
		flex-direction: column;
		align-items: center;
		justify-content: center;
		gap: 12px;
		border-radius: 16px;
		background: linear-gradient(165deg, #ffffff 0%, #eef2ff 45%, #dfe4ff 100%);
		border: 2px solid #4a90e2;
		box-shadow: 0 18px 26px rgba(10,12,20,0.3);
		z-index: calc(var(--z-zoom) + 50);
		touch-action: none;
		cursor: grab;
		transition: transform 0.2s ease, box-shadow 0.2s ease, opacity 0.2s ease;
		transform: scale(0.8);
		opacity: 0;
		overflow: visible;
	}		#floating-preview.dragging {
			cursor: grabbing;
			transform: scale(1.1);
			box-shadow: 0 12px 32px rgba(0,0,0,0.4);
		}

	body.dark-mode #floating-preview {
		background: linear-gradient(165deg, #2d2d2d 0%, #1f2233 45%, #1a1d2e 100%);
		border-color: #5a9fd4;
	}	#floating-preview-pattern {
		width: 100%;
		flex: 1;
		display: flex;
		align-items: center;
		justify-content: center;
		pointer-events: none;
		position: relative;
		z-index: 1;
	}		#floating-preview-rotate {
			position: absolute;
			top: 6px;
			right: 6px;
			width: 36px;
			height: 36px;
			background: #4a90e2;
			border: 2px solid white;
			border-radius: 50%;
			display: flex;
			align-items: center;
			justify-content: center;
			font-size: 18px;
			color: white;
			cursor: pointer;
			touch-action: none;
			box-shadow: 0 4px 12px rgba(0,0,0,0.3);
			z-index: 1;
			user-select: none;
		}

		#floating-preview-rotate:active {
			transform: scale(0.95);
		}

		body.dark-mode #floating-preview-rotate {
			background: #5a9fd4;
			border-color: #1e2128;
		}

		#floating-preview-mirror {
			position: absolute;
			bottom: 6px;
			right: 6px;
			width: 36px;
			height: 36px;
			background: #9b59b6;
			border: 2px solid white;
			border-radius: 50%;
			display: flex;
			align-items: center;
			justify-content: center;
			font-size: 18px;
			color: white;
			cursor: pointer;
			touch-action: none;
			box-shadow: 0 4px 12px rgba(0,0,0,0.3);
			z-index: 1;
			user-select: none;
		}

		#floating-preview-mirror:active {
			transform: scale(0.95);
		}

		body.dark-mode #floating-preview-mirror {
			background: #8e44ad;
			border-color: #1e2128;
		}

		#floating-preview-cancel {
			position: absolute;
			top: 6px;
			left: 6px;
			width: 36px;
			height: 36px;
			background: #e74c3c;
			border: 2px solid white;
			border-radius: 50%;
			display: flex;
			align-items: center;
			justify-content: center;
			font-size: 20px;
			color: white;
			cursor: pointer;
			touch-action: none;
			box-shadow: 0 4px 12px rgba(0,0,0,0.3);
			z-index: calc(var(--z-zoom) + 51);
			user-select: none;
		}

		#floating-preview-cancel:active {
			transform: scale(0.95);
		}

		body.dark-mode #floating-preview-cancel {
			background: #c0392b;
			border-color: #1e2128;
		}

		/* Zoom-lens voor plaatsing preview */
		#placement-zoom-lens {
			position: fixed;
			width: 160px;
			height: 160px;
			background: rgba(255, 255, 255, 0.98);
			border: 3px solid #4a90e2;
			border-radius: 16px;
			box-shadow: 0 12px 32px rgba(0,0,0,0.5), 0 0 0 2px rgba(74, 144, 226, 0.3);
			z-index: calc(var(--z-zoom) + 1);
			pointer-events: none;
			transition: opacity 0.15s ease;
		}

		body.dark-mode #placement-zoom-lens {
			background: rgba(30, 33, 40, 0.98);
			border-color: #5a9fd4;
			box-shadow: 0 12px 32px rgba(0,0,0,0.7), 0 0 0 2px rgba(90, 159, 212, 0.3);
		}

		#zoom-lens-content {
			width: 100%;
			height: 100%;
			display: flex;
			align-items: center;
			justify-content: center;
			padding: 8px;
			overflow: hidden;
		}

		#zoom-lens-content .zoom-grid {
			display: grid;
			gap: var(--board-grid-gap, 2px);
			transform: scale(1.5);
			transform-origin: center;
		}

		#zoom-lens-content .zoom-cell {
			border-radius: 2px;
			border: 1px solid rgba(0,0,0,0.15);
		}

		body.dark-mode #zoom-lens-content .zoom-cell {
			border-color: rgba(255,255,255,0.2);
		}

		#zoom-lens-content .zoom-cell.filled {
			box-shadow: 0 2px 4px rgba(0,0,0,0.2);
		}

		#zoom-lens-content .zoom-cell.preview {
			opacity: 0.7;
			border: 2px solid rgba(74, 144, 226, 0.8);
		}

		#zoom-lens-content .zoom-cell.preview.valid {
			border-color: rgba(76, 175, 80, 0.9);
			box-shadow: 0 0 8px rgba(76, 175, 80, 0.4);
		}

		#zoom-lens-content .zoom-cell.preview.invalid {
			border-color: rgba(244, 67, 54, 0.9);
			box-shadow: 0 0 8px rgba(244, 67, 54, 0.4);
		}


		body .blur-overlay {
			pointer-events: none;
		}

		/* ============================================
		   DARK MODE - BASIS STYLING
		   ============================================
		*/
		body.dark-mode {
			background: #1b1d22;
			color: #e5e5e5;
		}

		.board {
			display: flex;
			gap: 12px; /* ruimte tussen kolommen */
			margin: 0 auto;
			touch-action: manipulation;
			position: relative;
			z-index: 1;
			transition: transform 0.25s ease;
		}

		body.board-scaled {
			overflow-y: auto;
		}

		body.board-scaled .board {
			transform-origin: top center;
		}

	.column {
		display: flex;
		flex-direction: column;
		gap: 12px; /* ruimte tussen vakken in dezelfde kolom */
		flex: 1; /* kolommen gelijk breed op mobiel */
	}
	.zone {
		/* Geen background hier - wordt per zone ingesteld */
		position: relative;
		border-radius: 10px;
		border: 1px solid #e3e6ea;
		box-shadow: 0 2px 6px rgba(0,0,0,0.12);
		box-sizing: border-box;
		padding: 10px;
		margin: 10px;
		touch-action: manipulation;
		transition: transform 0.3s ease;
		z-index: 1;
	}

	body.debug-mode .zone .cell:not(.void-cell) {
		cursor: pointer;
	}

	.red-group {
		display: flex;
		flex-wrap: wrap;
		gap: 8px;
		justify-content: center;
	}

	.red-group.zoom-focus {
		width: auto;
		min-height: 400px; /* Minimum height, niet fixed */
		height: auto; /* Laat content de height bepalen */
	}


	body.dark-mode .zone {
		border: 1px solid #2d2f36;
		box-shadow: 0 4px 10px rgba(0,0,0,0.5);
	}		.zone-placeholder {
			pointer-events: none;
			position: relative;
		}

		.blur-overlay {
			display: none;
			position: fixed;
			inset: 0;
			background: rgba(0, 0, 0, 0.4);
			backdrop-filter: blur(4px);
			-webkit-backdrop-filter: blur(4px);
			z-index: var(--z-blur);
		}

		body.zoomed-in .blur-overlay {
			display: block;
		}

		.zone.zoom-focus {
			position: fixed;
			top: 22%;
			left: 50%;
			transform: translate(-50%, -50%) scale(1.25);
			z-index: var(--z-zoom);
			box-shadow: 0 0 30px rgba(0, 0, 0, 0.5);
			margin: 2px;
			padding: 3px;
			border-radius: 6px;
		}

		/* Mobile (incl. larger phones): use the same zoom sizing as the compact (<550px) layout. */
		@media (max-width: 900px) {
			.zone.zoom-focus {
				position: fixed;
				top: 25%;
				left: 50%;
				transform: translate(-50%, -50%) scale(0.95);
				z-index: var(--z-zoom);
				box-shadow: 0 0 30px rgba(0, 0, 0, 0.5);
				margin: 2px;
				padding: 3px;
				border-radius: 6px;
			}

			/* Red zone: keep proportions in zoom, like compact mobile. */
			#red-zone.zoom-focus {
				flex-wrap: wrap !important;
				flex-direction: row !important;
				width: auto !important;
				min-width: 380px !important;
				height: auto !important;
				max-width: 90vw;
			}
		}

		@media (max-width: 650px) {
			body.zoomed-in #yellow-zone.zoom-focus,
			body.zoomed-in #blue-zone.zoom-focus {
				top: calc(22% + 50px);
			}
		}

		/* Phone landscape (short height): scale board down so everything fits.
		   Keep this limited to coarse pointers to avoid shrinking desktop windows. */
		@media (max-height: 600px) and (orientation: landscape) and (pointer: coarse) {
			:root {
				--cell-size: 26px;
			}
		}

		/* ===== MOBILE SIDEBAR LAYOUT =====
		   Used for both mobile landscape AND mobile portrait on phones.
		   Board center, options in slim sidebars. */
		body.mobile-sidebar-layout {
			overflow: hidden !important;
			max-height: 100vh;
			max-height: 100svh;
		}

		body.mobile-sidebar-layout,
		body.mobile-sidebar-layout html {
			overflow: hidden !important;
		}

		/* Hamburger menu in mobile sidebar layout */
		body.mobile-sidebar-layout #menu-toggle {
			position: fixed !important;
			top: 4px;
			left: 4px;
			z-index: 1100;
			width: 36px;
			height: 36px;
			display: flex !important;
		}

		body.mobile-sidebar-layout #controls {
			position: fixed;
			top: 44px;
			left: 4px;
			z-index: 1099;
			max-height: calc(100vh - 50px);
			max-height: calc(100svh - 50px);
			overflow-y: auto;
		}

		body.mobile-sidebar-layout #bottom-bar {
			display: none !important;
		}

		body.mobile-sidebar-layout #mobile-objective-banner {
			display: none !important;
		}

		/* Safety net: if the sidebar class ever lingers, never apply it in portrait. */
		@media (max-width: 650px) and (orientation: portrait) {
			body.mobile-sidebar-layout {
				overflow: auto !important;
				max-height: none;
			}
			body.mobile-sidebar-layout html {
				overflow: auto !important;
			}
			body.mobile-sidebar-layout #mobile-landscape-wrapper {
				display: none !important;
			}
			body.mobile-sidebar-layout #bottom-bar {
				display: flex !important;
			}
			body.mobile-sidebar-layout #mobile-objective-banner {
				display: flex !important;
			}
		}

		/* Mobile landscape sidebar zoom mode */
		body.mobile-sidebar-layout.zoomed-in .zone.zoom-focus {
			position: fixed;
			top: 50%;
			left: 50%;
			transform: translate(-50%, -50%) scale(0.85);
			z-index: var(--z-zoom);
			box-shadow: 0 0 30px rgba(0, 0, 0, 0.5);
			margin: 0;
			padding: 6px;
			border-radius: 8px;
			max-width: 90vw;
			max-height: 85vh;
			max-height: 85svh;
			overflow: auto;
		}

		body.mobile-sidebar-layout.zoomed-in #red-zone.zoom-focus {
			display: grid !important;
			grid-template-columns: repeat(2, max-content) !important;
			width: auto;
			max-width: 95vw;
		}

		body.mobile-sidebar-layout.zoomed-in .zone-nav-arrow {
			display: flex;
		}

		body.mobile-sidebar-layout #mobile-landscape-wrapper {
			display: flex !important;
			flex-direction: row;
			align-items: stretch;
			justify-content: center;
			width: 100vw;
			height: 100vh;
			height: 100svh;
			gap: 2px;
			padding: 2px;
			padding-left: 44px; /* Room for hamburger */
			box-sizing: border-box;
			overflow: hidden;
		}

		body.mobile-sidebar-layout #ml-sidebar-left,
		body.mobile-sidebar-layout #ml-sidebar-right {
			display: flex !important;
			flex-direction: column;
			gap: 2px;
			flex: 0 0 auto;
			width: 58px;
			min-width: 50px;
			max-width: 70px;
			overflow-y: auto;
			overflow-x: hidden;
			scrollbar-width: none;
		}

		/* Landscape: slightly wider sidebars */
		@media (orientation: landscape) {
			body.mobile-sidebar-layout #ml-sidebar-left,
			body.mobile-sidebar-layout #ml-sidebar-right {
				width: 72px;
				min-width: 65px;
				max-width: 90px;
				gap: 3px;
			}
			
			body.mobile-sidebar-layout #mobile-landscape-wrapper {
				gap: 4px;
				padding: 4px;
			}
		}

		body.mobile-sidebar-layout #ml-sidebar-left::-webkit-scrollbar,
		body.mobile-sidebar-layout #ml-sidebar-right::-webkit-scrollbar {
			display: none;
		}

		body.mobile-sidebar-layout #ml-board-center {
			/* Don't expand to fill all remaining width: keep sidebars close to the board
			   (fixes "options too far to the sides" on phone landscape). */
			flex: 0 1 auto;
			display: flex;
			flex-direction: column;
			justify-content: flex-start;
			align-items: center;
			min-width: 0;
			overflow: hidden;
			gap: 2px;
		}

		/* Small-ish desktop landscape: slightly smaller cells so zones fit cleanly. */
		@media (min-width: 651px) and (orientation: landscape) and (max-height: 760px) {
			body.desktop-landscape {
				--cell-size: 26px;
			}
		}

		/* Mid-size desktop landscape (e.g. ~950px wide / ~925px tall):
		   reduce cell size so symbols don't look oversized and the board fits better. */
		@media (min-width: 801px) and (max-width: 1100px) and (orientation: landscape) and (max-height: 980px) {
			body.desktop-landscape {
				--cell-size: 26px;
			}
		}

		/* Compact objective banner in sidebar layout */
		body.mobile-sidebar-layout #ml-objective-top {
			display: flex !important;
			width: 100%;
			padding: 2px 6px;
			background: rgba(255, 251, 234, 0.95);
			border-radius: 6px;
			font-size: 0.65rem;
			text-align: center;
			justify-content: center;
			align-items: center;
			flex-shrink: 0;
		}

		body.dark-mode.mobile-sidebar-layout #ml-objective-top {
			background: rgba(34, 37, 43, 0.95);
			color: #e5e5e5;
		}

		body.mobile-sidebar-layout #ml-objective-top #objective-zone {
			min-height: auto;
			padding: 2px 8px;
			font-size: 0.6rem;
		}

		body.mobile-sidebar-layout #ml-objective-top #objective-zone h2 {
			display: none;
		}

		body.mobile-sidebar-layout #ml-board-center #board {
			transform-origin: top center;
		}

		/* Mobile sidebar styling */
		body.mobile-sidebar-layout #ml-sidebar-left #scoreboard,
		body.mobile-sidebar-layout #ml-sidebar-left #gold-zone,
		body.mobile-sidebar-layout #ml-sidebar-right #bonus-zone {
			padding: 3px 4px;
			font-size: 0.6rem;
		}

		body.mobile-sidebar-layout #ml-sidebar-left #scoreboard h2,
		body.mobile-sidebar-layout #ml-sidebar-left #gold-zone h2,
		body.mobile-sidebar-layout #ml-sidebar-right #bonus-zone h2 {
			display: none;
		}

		/* Gold zone in left sidebar */
		body.mobile-sidebar-layout #ml-sidebar-left #gold-zone {
			display: flex !important;
			flex-direction: column;
			align-items: center;
			gap: 2px;
			padding: 4px;
			background: rgba(255, 215, 0, 0.15);
			border-radius: 6px;
		}

		body.mobile-sidebar-layout #ml-sidebar-left #gold-zone::after {
			content: 'ðŸª™ ' attr(data-coin-text);
			display: block;
			font-size: 0.6rem;
			font-weight: 700;
		}

		body.mobile-sidebar-layout #ml-sidebar-left #gold-zone .buy-placement-btn {
			padding: 3px 5px;
			font-size: 0.45rem;
			display: block !important;
		}

		body.mobile-sidebar-layout #ml-sidebar-left #gold-zone #collected-coins {
			display: none !important;
		}

		@media (orientation: landscape) {
			body.mobile-sidebar-layout #ml-sidebar-left #gold-zone::after {
				font-size: 0.6rem;
			}

			body.mobile-sidebar-layout #ml-sidebar-left #gold-zone .buy-placement-btn {
				padding: 3px 5px;
				font-size: 0.45rem;
			}
		}

		body.mobile-sidebar-layout #ml-sidebar-left #scoreboard .score-row {
			padding: 1px 2px;
			font-size: 0.55rem;
		}

		body.mobile-sidebar-layout #ml-sidebar-left #scoreboard .score-row .label {
			display: none;
		}

		body.mobile-sidebar-layout #ml-sidebar-left #scoreboard .score-row .color-box {
			width: 8px;
			height: 8px;
		}

		body.mobile-sidebar-layout #ml-sidebar-left #scoreboard .score-total {
			font-size: 0.7rem;
			padding: 2px;
		}

		body.mobile-sidebar-layout #ml-sidebar-left #scoreboard .score-total .label {
			display: none;
		}

		body.mobile-sidebar-layout .bonus-inventory {
			flex-direction: column;
			gap: 1px;
		}

		body.mobile-sidebar-layout .bonus-badge {
			padding: 2px 4px;
			font-size: 0.5rem;
		}

		body.mobile-sidebar-layout .bonus-count {
			font-size: 0.45rem;
			padding: 1px 3px;
		}

		body.mobile-sidebar-layout #ml-sidebar-right #card-choice-zone {
			padding: 3px;
			display: flex;
			flex-direction: column;
			gap: 4px;
		}

		body.mobile-sidebar-layout #ml-sidebar-right #card-choice-zone h2,
		body.mobile-sidebar-layout #ml-sidebar-right #kiesKaartTitel,
		body.mobile-sidebar-layout #ml-sidebar-right #card-choice-zone br {
			display: none !important;
		}

		body.mobile-sidebar-layout #ml-sidebar-right #card-options {
			flex-direction: column;
			gap: 3px;
			order: 1;
		}

		/* Action buttons below cards */
		body.mobile-sidebar-layout #ml-sidebar-right #card-action-buttons {
			order: 2;
			flex-direction: row;
			flex-wrap: wrap;
			justify-content: center;
			gap: 3px;
			margin-top: 4px;
			padding-top: 4px;
			border-top: 1px solid rgba(0,0,0,0.1);
		}

		/* Portrait: smaller cards */
		body.mobile-sidebar-layout #ml-sidebar-right .card-option {
			width: 44px;
			min-height: 50px;
			padding: 2px;
			--preview-cell: 6px;
		}

		body.mobile-sidebar-layout #ml-sidebar-right .card-option .card-cell {
			width: 6px;
			height: 6px;
		}

		body.mobile-sidebar-layout #ml-sidebar-right .card-label {
			font-size: 0.4rem;
			padding: 1px 2px;
		}

		/* Landscape: allow slightly larger cards */
		@media (orientation: landscape) {
			body.mobile-sidebar-layout #ml-sidebar-right .card-option {
				width: 58px;
				min-height: 70px;
				padding: 4px;
				--preview-cell: 10px;
			}

			body.mobile-sidebar-layout #ml-sidebar-right .card-option .card-cell {
				width: 9px;
				height: 9px;
			}

			body.mobile-sidebar-layout #ml-sidebar-right .card-label {
				font-size: 0.5rem;
				padding: 2px 4px;
			}
		}

		body.mobile-sidebar-layout #ml-sidebar-right .card-action-btn {
			width: 22px;
			height: 22px;
			min-width: 22px;
			padding: 2px;
		}

		body.mobile-sidebar-layout #ml-sidebar-right .card-action-btn::before {
			font-size: 0.65rem;
		}

		/* Landscape: larger action buttons */
		@media (orientation: landscape) {
			body.mobile-sidebar-layout #ml-sidebar-right .card-action-btn {
				width: 24px;
				height: 24px;
				min-width: 24px;
				padding: 3px;
			}

			body.mobile-sidebar-layout #ml-sidebar-right .card-action-btn::before {
				font-size: 0.7rem;
			}
		}
		
		.zone.portal-active {
			box-shadow: 0 0 12px 4px rgba(100, 200, 255, 0.6);
			animation: portalPulse 2s ease-in-out infinite;
		}
		
		@keyframes portalPulse {
			0%, 100% { box-shadow: 0 0 12px 4px rgba(100, 200, 255, 0.6); }
			50% { box-shadow: 0 0 20px 6px rgba(150, 220, 255, 0.8); }
		}

		/* Blue zone scroll - lang uitgezoomd, kort ingezoomd */


		#blue-zone.zoom-focus {
			/* Keep the zoomed blue zone ~2/3 of the viewport height. */
			max-height: 66vh;
			overflow-y: auto;
			overflow-x: hidden;
			/* Keep blue scrollable but hide the scrollbar visuals (no "scroll wheel"). */
			scrollbar-width: none; /* Firefox */
			-ms-overflow-style: none; /* IE/Edge legacy */
		}
		#blue-zone.zoom-focus::-webkit-scrollbar {
			width: 0;
			height: 0;
			display: none;
		}

		/*
		#red-zone {
			width: 430px;
		}
			*/

		#original-card-zone {
			width: 430px;
		}

		/* Zone navigation arrows */
		.zone-nav-arrow {
			position: fixed;
			top: 50%;
			transform: translateY(-50%);
			z-index: calc(var(--z-zoom) + 1);
			background: rgba(255, 255, 255, 0.9);
			border: 2px solid rgba(40, 55, 120, 0.3);
			border-radius: 50%;
			width: 48px;
			height: 48px;
			display: flex;
			align-items: center;
			justify-content: center;
			font-size: 24px;
			cursor: pointer;
			transition: all 0.2s ease;
			box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
			user-select: none;
		}

		.zone-nav-arrow:hover {
			background: rgba(255, 255, 255, 1);
			transform: translateY(-50%) scale(1.1);
			box-shadow: 0 6px 16px rgba(0, 0, 0, 0.3);
		}

		.zone-nav-arrow:active {
			transform: translateY(-50%) scale(0.95);
		}

		.zone-nav-arrow-left {
			left: 20px;
		}

		.zone-nav-arrow-right {
			right: 20px;
		}

		body.dark-mode .zone-nav-arrow {
			background: rgba(30, 35, 50, 0.9);
			border-color: rgba(140, 150, 200, 0.4);
			color: rgba(240, 242, 255, 0.9);
		}

		body.dark-mode .zone-nav-arrow:hover {
			background: rgba(40, 45, 60, 1);
		}

		/* === Mobile scaling tweaks (<=650px) === */

	/* ============================================
	   CARD CHOICE ZONE - ADDITIONAL FEATURES
	   ============================================
	   Golden cards and selection disabled states
	*/
	.card-option.card-golden {
		position: relative;
		overflow: hidden;
		background: linear-gradient(135deg, #fff9e6 0%, #ffe082 30%, #f6c84a 60%, #c78c1f 100%);
		border: 1px solid rgba(220,180,60,0.9);
		box-shadow: 0 28px 56px rgba(184,120,18,0.45), inset 0 1px 0 rgba(255,255,255,0.6);
	}

	@keyframes goldenCardShine {
		0% { transform: translateX(-70%) rotate(20deg); }
		100% { transform: translateX(70%) rotate(20deg); }
	}

	/* Subtle shine over the golden frame (does not affect the block colors). */
	.card-option.card-golden::before {
		content: '';
		position: absolute;
		top: -40%;
		left: -40%;
		width: 180%;
		height: 180%;
		background: linear-gradient(90deg, rgba(255,255,255,0) 0%, rgba(255,255,255,0.55) 45%, rgba(255,255,255,0) 70%);
		opacity: 0.22;
		pointer-events: none;
		transform: translateX(-70%) rotate(20deg);
		animation: goldenCardShine 3.2s linear infinite;
		z-index: 1;
	}

	.card-option.card-golden .card-pattern,
	.card-option.card-golden .card-label,
	.card-option.card-golden .card-meta {
		position: relative;
		z-index: 2;
	}

	.card-option.card-golden::after {
		background: linear-gradient(120deg, rgba(255,255,255,0.95), rgba(255,255,255,0) 60%);
		opacity: 0.72;
		mix-blend-mode: overlay;
	}

	.card-option.card-golden .card-label {
		background: rgba(120,80,0,0.1);
		color: #7c4d00;
	}

	#card-choice-zone .card-option.selection-disabled {
		opacity: 0.45;
		pointer-events: none;
		filter: grayscale(0.25);
	}

	body.dark-mode .card-option.card-golden {
		background: linear-gradient(135deg, #5b4a14 0%, #8a6a1c 35%, #bf952a 70%, #e3c45e 100%);
		border: 1px solid rgba(200,160,30,0.8);
		box-shadow: 0 28px 52px rgba(0,0,0,0.6), inset 0 1px 0 rgba(255,255,255,0.08);
	}

	body.dark-mode .card-option.card-golden::before {
		opacity: 0.18;
	}

	body.dark-mode .card-option.card-golden .card-label {
		background: rgba(255,220,120,0.12);
		color: #ffe79a;
	}

	/*
		#card-choice-zone defines its own (more specific) `.card-option` background later.
		These overrides ensure golden styling remains visible inside the card-choice UI.
	*/
	#card-choice-zone .card-option.card-golden {
		background: linear-gradient(135deg, #fff9e6 0%, #ffe082 30%, #f6c84a 60%, #c78c1f 100%);
		border: 1px solid rgba(220,180,60,0.9);
		box-shadow: 0 28px 56px rgba(184,120,18,0.45), inset 0 1px 0 rgba(255,255,255,0.6);
	}

	body.dark-mode #card-choice-zone .card-option.card-golden {
		background: linear-gradient(135deg, #5b4a14 0%, #8a6a1c 35%, #bf952a 70%, #e3c45e 100%);
		border: 1px solid rgba(200,160,30,0.8);
		box-shadow: 0 28px 52px rgba(0,0,0,0.6), inset 0 1px 0 rgba(255,255,255,0.08);
	}

	body.dark-mode #card-choice-zone .card-option.selection-disabled {
		opacity: 0.32;
		filter: grayscale(0.4);
	}

	/* Deck kopie kaart (extraHandSize upgrade) */
	#card-choice-zone .card-option.card-deck-copy {
		position: relative;
		border: 2px dashed rgba(100, 140, 255, 0.6);
	}
	#card-choice-zone .card-option.card-deck-copy::before {
		content: 'ðŸ“‹';
		position: absolute;
		top: -8px;
		right: -8px;
		font-size: 16px;
		background: #fff;
		border-radius: 50%;
		padding: 2px;
		box-shadow: 0 2px 6px rgba(0,0,0,0.2);
		z-index: 10;
	}
	body.dark-mode #card-choice-zone .card-option.card-deck-copy {
		border-color: rgba(140, 180, 255, 0.5);
	}
	body.dark-mode #card-choice-zone .card-option.card-deck-copy::before {
		background: #2a2a3a;
	}

	/* Lucky draw kopie kaart */
	#card-choice-zone .card-option.card-lucky-copy {
		position: relative;
		border: 2px dashed rgba(80, 200, 80, 0.6);
	}
	#card-choice-zone .card-option.card-lucky-copy::before {
		content: 'ðŸ€';
		position: absolute;
		top: -8px;
		right: -8px;
		font-size: 16px;
		background: #fff;
		border-radius: 50%;
		padding: 2px;
		box-shadow: 0 2px 6px rgba(0,0,0,0.2);
		z-index: 10;
	}
	body.dark-mode #card-choice-zone .card-option.card-lucky-copy {
		border-color: rgba(120, 220, 120, 0.5);
	}
	body.dark-mode #card-choice-zone .card-option.card-lucky-copy::before {
		background: #2a2a3a;
	}

	/*
		EN:
		- DUPLICATE/OVERRIDE: There are many `@media (max-width: 650px)` blocks in this file.
		  They stack and later rules win, so the *order* in this CSS file is part of the behavior.
		- TIP: If something "randomly" changes on mobile, search for the same selector in later @media blocks.
	*/
	@media (max-width: 650px) {


	#bottom-bar {
		padding-left: 5px;
		padding-right: 5px;
	}

	  #bottom-bar-score,
	  #bottom-bar-coins {
		flex: 0 0 50%;
		min-width: 0;
	  }

	  #bottom-bar #scoreboard,
	  #bottom-bar #gold-zone {
		width: 100%;
		padding: 6px 10px;
		box-sizing: border-box;
	  }

	  #bottom-bar #gold-zone {
		min-width: 0;
	  }

	  #bottom-bar #new-cards-btn {
		height: 48px;
		padding: 8px 12px;
		font-size: 0.76rem;
	  }

	  #bottom-bar #rotate-card-btn {
		height: 44px;
		padding: 7px 12px;
		font-size: 0.7rem;
		margin-top: 8px;
		width: 104px;
	  }

	  #bottom-bar #card-options .card-option {
		max-width: 110px;
	  }
	}

	@media (max-width: 650px) {
	  .bottom-bar-footer {
		display: flex;
		flex-direction: column;
		align-items: stretch;
		gap: 2px;
		justify-content: flex-start;
		margin-top: 10px;
	  }

	  #bottom-bar-left {
		display: flex;
		flex-direction: column;
		flex-wrap: nowrap;
		gap: 4px;
		flex: 1 1 auto;
		min-width: 0;
		align-items: stretch;
	  }

	  #bottom-bar-bonus {
		order: 2;
		flex: 0 0 auto;
		display: flex;
		flex-direction: column;
		align-items: stretch;
		justify-content: flex-start;
		gap: 8px;
	  }

	  #bottom-bar-score-coins {
		display: flex;
		flex-direction: row;
		gap: 4px;
		align-items: center;
		order: 3;
		flex: 1 1 auto;
		min-width: 0;
	  }

	  #bottom-bar-score {
		flex: 1 1 auto;
		min-width: 0;
	  }

	  #bottom-bar-coins {
		display: none !important;
	  }

	  #bottom-bar #scoreboard,
	  #bottom-bar #gold-zone {
		width: 100%;
		box-sizing: border-box;
		height: auto;
	  }

	  #bottom-bar #bonus-zone {
		width: auto;
		flex: 1 1 auto;
		min-width: 0;
		padding: 6px 8px;
	  }

	  /* Place the coin panel next to the bonus inventory. */
	  #bottom-bar-bonus #gold-zone {
		width: 100% !important;
		flex: 0 0 auto;
		padding: 3px 6px;
		margin: 0;
		display: flex;
		flex-direction: column;
		align-items: stretch;
		justify-content: flex-start;
		gap: 4px;
	  }
	  #bottom-bar-bonus #gold-zone .buy-placement-btn {
		margin-left: 0;
	  }
	  

	#bottom-bar #collected-coins {
		grid-template-rows: repeat(3, 12px);
		grid-auto-columns: 12px;
		column-gap: 4px;
		row-gap: 4px;
	}
	}


	@media (max-width: 650px) {
		:root {
			--bottom-bar-height: 140px;
			--bottom-bar-gap: 4px;
			--bottom-bar-bottom-offset: -16px;
			--card-hand-lift: 0px;
			--hand-card-width: 52px;
			--hand-card-gap: 4px;
			--hand-card-height: 78px;
		}

		#bottom-bar {
			padding-left: 5px;
			padding-right: 5px;
			margin-bottom: 5px;
		}

		#bottom-bar #scoreboard,
		#bottom-bar #gold-zone {
			padding: 6px 8px;
		}

		#bottom-bar #gold-zone {
			min-width: 0;
			gap: 9px;
		}

		#bottom-bar #card-options {
			padding-left: 0;
			padding-right: 0;
			touch-action: none;
			overflow-y: hidden;
		}

	  #bonus-zone .bonus-hint {
		display: none;
	  }

	  #bottom-bar #scoreboard {
		--score-chip-gap: 3px;
	  }
	  
	  /* Hide desktop bonus-zone on mobile (it's in bottom-bar) */
	  #original-bonus-zone {
		display: none;
	  }

	  #bottom-bar #scoreboard .score-row {
		font-size: 0.62rem;
		padding: 2px 4px;
	  }

	  #bottom-bar #scoreboard .score-row .color-box {
		width: 8px;
		height: 8px;
	  }

	  #bottom-bar #scoreboard .score-row .score {
		font-size: 0.66rem;
	  }

	  #bottom-bar #scoreboard .score-total {
		font-size: 0.68rem;
	  }

	  #bottom-bar #scoreboard .score-total .total-score {
		font-size: 0.78rem;
	  }

	  #bottom-bar #scoreboard .score-total .label {
		font-size: 0.64rem;
	  }

	#bottom-bar #card-choice-zone .card-option {
		width: 98px;
		min-height: 18px;
		gap: 9px;
	}

	  #bottom-bar #new-cards-btn {
		height: 36px;
		padding: 6px 11px;
		font-size: 0.66rem;
	  }

	  #bottom-bar #rotate-card-btn {
		height: 34px;
		padding: 6px 10px;
		font-size: 0.62rem;
		width: 102px;
		margin-top: 6px;
	  }

	#bottom-bar #collected-coins {
		grid-template-rows: repeat(3, 12px);
		grid-auto-columns: 12px;
		column-gap: 4px;
		row-gap: 4px;
	}

	#bottom-bar .coin {
		width: 12px;
		height: 12px;
	}
	}

	@media (max-width: 520px) {
	  :root {
		--bottom-bar-height: 120px;
		--bottom-bar-gap: 4px;
		--card-hand-lift: 0px;
		--hand-card-width: 56px;
		--hand-card-gap: 4px;
		--hand-card-height: 70px;
	  }

	  #bottom-bar {
		padding-left: 4px;
		padding-right: 4px;
		padding-bottom: 4px;
	  }

	  #bottom-bar-cards {
		margin-top: 0;
		height: 80px;
	  }

	  #bottom-bar #card-options {
		display: flex;
		gap: 4px;
		align-items: stretch;
		justify-content: flex-start;
		flex-wrap: nowrap;
		scroll-snap-type: x proximity;
		flex: 1 1 auto;
		min-width: 0;
		width: auto;
		max-width: 100%;
		transform: translateY(0px);
		padding: 0 0 8px 0;
		touch-action: pan-x;
		overflow-x: auto;
		overflow-y: hidden;
		scrollbar-width: thin;
		scrollbar-color: rgba(255,255,255,0.3) transparent;
	  }
	  
	  #bottom-bar #card-options::-webkit-scrollbar {
		height: 4px;
	  }
	  #bottom-bar #card-options::-webkit-scrollbar-track {
		background: transparent;
		border-radius: 2px;
	  }
	  #bottom-bar #card-options::-webkit-scrollbar-thumb {
		background: linear-gradient(90deg, rgba(255,255,255,0.25), rgba(200,210,255,0.35));
		border-radius: 2px;
	  }
	  #bottom-bar #card-options::-webkit-scrollbar-thumb:hover {
		background: linear-gradient(90deg, rgba(255,255,255,0.4), rgba(200,210,255,0.5));
	  }

	  #bottom-bar #card-choice-zone .card-option {
		width: var(--hand-card-width);
		min-height: 80px;
		padding: 3px 4px 5px;
		gap: 2px;
	  }

	  #bottom-bar #card-choice-zone .card-option .card-cell {
		width: 8px;
		height: 8px;
	  }

	  #bottom-bar #card-choice-zone .card-option .card-pattern {
		gap: var(--preview-gap);
	  }

	  #bottom-bar #card-choice-zone .card-option .card-label {
		font-size: 0.52rem;
		padding: 1px 4px;
		gap: 1px;
	  }

	  #bottom-bar #card-choice-zone .card-option .card-label .label-dot {
		width: 5px;
		height: 5px;
	  }

	  #bottom-bar #new-cards-btn,
	  #bottom-bar #rotate-card-btn {
		width: 40px;
		height: 40px;
	  }

	  #bottom-bar #new-cards-btn::before {
		font-size: 1.6rem;
	  }

	  #bottom-bar #rotate-card-btn::before {
		font-size: 1.4rem;
	  }

	  .deck-count {
		padding: 5px 10px;
		font-size: 0.9rem;
		min-width: 45px;
		gap: 5px;
		border-radius: 9px;
	  }

	  .deck-count::before {
		font-size: 1rem;
	  }


	  #bottom-bar-left {
		gap: 3px;
	  }

	  .bottom-bar-footer {
		padding: 2px 3px 0;
	  }
	}


	@media (max-width: 650px) {
		:root {
			/* Use 0.5 for pixel-perfect scaling: 2px gaps become clean 1px after scaling */
			--board-scale: 0.5;
		}

		/* Classic mode (mobile): show ONLY the board + hamburger menu. */
		body.classic-mode #bottom-bar,
		body.classic-mode #card-choice-zone,
		body.classic-mode #bonus-zone,
		body.classic-mode #scoreboard,
		body.classic-mode #objective-zone,
		body.classic-mode #mobile-objective-banner,
		body.classic-mode #buy-placement-container,
		body.classic-mode #original-coins-zone,
		body.classic-mode #gold-zone,
		body.classic-mode #dark-mode-toggle,
		body.classic-mode .zone-info-btn,
		body.classic-mode .zone-info-popover {
			display: none !important;
		}

		/* Classic mode: don't scale down; board should fill the screen. */
		body.classic-mode {
			--board-scale: 1;
		}

		/* Hide the legacy UI column so the board uses the full width. */
		body.classic-mode #board > .column:last-child {
			display: none !important;
		}

		#original-card-zone {
			width: auto;
			max-width: 100%;
		}

		.board {
			gap: 2px;
			margin: 0;
			padding: 2px;
			transform-origin: top left;
			transition: transform 0.4s ease;	
			left: 50%;
			transform: translateX(-50%) scale(var(--board-scale, 0.5));
			max-height: none;
		}

		/* Bottom bar: make the 3 hand cards visibly smaller (â‰ˆ25%), while keeping cell-size identical to the board. */
		#bottom-bar #card-choice-zone .card-option {
			width: var(--hand-card-width);
			min-height: var(--hand-card-height);
			padding: 3px 4px;
			gap: 2px;
			justify-content: flex-start;
		}
		#bottom-bar #card-choice-zone .card-pattern {
			gap: var(--preview-gap);
		}
		#bottom-bar #card-choice-zone .card-label {
			font-size: 0.52rem;
			padding: 1px 4px;
			gap: 3px;
		}
		#bottom-bar #card-choice-zone .card-meta {
			font-size: 0.6rem;
		}

		/* Red zone sub-grids: center the grid inside each quadrant (also when NOT zoomed). */
		#red-zone.red-group > .zone {
			display: flex;
			align-items: center;
			justify-content: center;
		}
		#red-zone.red-group .grid {
			margin: 0;
		}

		/* Zones compacter maken voor betere fit */
		/* Green grid (lichtgroene binnenste area) beperken (niet tijdens zoom) */
		body:not(.zoomed-in) #green-grid {
			min-width: calc(15 * var(--cell-size)) !important;
			max-width: calc(15 * var(--cell-size) + 20px) !important;
		}
		/* Zoomed-in: groen mag breder (2Ã—) zodat niets afkapt */
		body.zoomed-in #green-grid {
			min-width: calc(30 * var(--cell-size)) !important;
			max-width: calc(30 * var(--cell-size) + 20px) !important;
		}

		/* Mobile: blue is vertically long by design; keep it scrollable but not a giant strip. */
		body:not(.zoomed-in) #blue-zone,
		#blue-zone--placeholder {
			overflow: auto;
		}

		/* World 2: verberg de (witte) scrollbar in de blauwe zone (blijft wel scrollbaar) */
		#blue-zone {
			scrollbar-width: none;
			-ms-overflow-style: none;
		}
		#blue-zone::-webkit-scrollbar {
			width: 0;
			height: 0;
			display: none;
		}

		/* Blue zone met scroll in zoom voor kaarten zichtbaarheid */
		#blue-zone.zoom-focus {
			max-height: 66vh;
			overflow-y: auto;
			scrollbar-width: none;
			-ms-overflow-style: none;
		}
		#blue-zone.zoom-focus::-webkit-scrollbar {
			width: 0;
			height: 0;
			display: none;
		}
		
	}

	@media (max-width: 600px) {
			:root { --bottom-bar-height: 211px; }
		.board {
			gap: 3px;
			transform-origin: top left;
			transition: transform 0.4s ease;	
			left: 50%;
			transform: translateX(-50%) scale(var(--board-scale, 0.5));
			max-height: none;
		}

		/* Green grid (lichtgroene binnenste area) beperken (niet tijdens zoom) */
		body:not(.zoomed-in) #green-grid {
			min-width: calc(15 * var(--cell-size)) !important;
			max-width: calc(15 * var(--cell-size) + 20px) !important;
		}
		/* Zoomed-in: groen mag breder (2Ã—) zodat niets afkapt */
		body.zoomed-in #green-grid {
			min-width: calc(30 * var(--cell-size)) !important;
			max-width: calc(30 * var(--cell-size) + 20px) !important;
		}

		#blue-zone.zoom-focus {
			max-height: 66vh;
		}

		/* Actieve zone komt BOVEN de blur - behoud aspect ratio */
		.zone.zoom-focus {
		  position: fixed;
		  top: 32%;
		  left: 50%;
		  transform: translate(-50%, -50%) scale(0.95);
		  z-index: var(--z-zoom);
		  box-shadow: 0 0 30px rgba(0, 0, 0, 0.5);
		  margin: 2px;
		  padding: 3px;
		  border-radius: 6px;
		}

		/* Green zone zoom-focus specifiek */
		#green-zone.zoom-focus {
		  margin: 2px;
		  padding: 3px;
		  border-radius: 6px;
		}

		/* Red zone: behoud originele verhoudingen bij zoom */
		#red-zone.zoom-focus {
		  flex-wrap: wrap !important;
		  flex-direction: row !important;
		  width: auto !important;
		  min-width: 380px !important;
		  height: auto !important;
		  max-width: 90vw;
		}
		
	}
	
	@media (max-width: 550px) {
			:root { --bottom-bar-height: 196px; }
		.board {
			gap: 3px;
			transform-origin: top left;
			transition: transform 0.4s ease;	
			left: 50%;
			transform: translateX(-50%) scale(var(--board-scale, 0.5));
			max-height: none;
		}

		#blue-zone.zoom-focus {
			max-height: 66vh;
		}

		/* Actieve zone komt BOVEN de blur */
		.zone.zoom-focus {
		  position: fixed;
		  top: 35%;
		  left: 50%;
		  transform: translate(-50%, -50%) scale(0.95);
		  z-index: var(--z-zoom);
		  box-shadow: 0 0 30px rgba(0, 0, 0, 0.5);
		}

		/* Red zone: behoud originele verhoudingen bij zoom */
		#red-zone.zoom-focus {
		  flex-wrap: wrap !important;
		  flex-direction: row !important;
		  width: auto !important;
		  min-width: 380px !important;
		  height: auto !important;
		  max-width: 90vw;
		}
	
	}
	  
	@media (max-width: 510px) {
	
		.board {
			gap: 3px;
			transform-origin: top left;
			transition: transform 0.4s ease;	
			left: 50%;
			transform: translateX(-50%) scale(var(--board-scale, 0.5));
			max-height: none;
			padding: 0;
		}

		#blue-zone.zoom-focus {
			max-height: 66vh;
		}
	
	}

	@media (max-width: 490px) {
	
		:root {
			--bottom-bar-height: 175px;
		}
	
		.board {
			gap: 2px;
			transform-origin: top left;
			transition: transform 0.4s ease;	
			left: 50%;
			transform: translateX(-50%) scale(var(--board-scale, 0.5));
			max-height: none;
			padding: 0;
		}


		#blue-zone.zoom-focus {
			max-height: 66vh;
		}
		
		.zone.zoom-focus {
			transform: translate(-50%, -50%) scale(0.95);
			max-height: 80vh;
			overflow: hidden;
		}
		#blue-zone.zoom-focus {
			overflow-y: auto;
		}



		.bottom-bar-footer {
			margin-top: 0px;
			padding-top: 0px;
		}
	
	}

	@media (max-width: 450px) {
	
		:root {
			--bottom-bar-height: 175px;
		}
	
		.board {
			gap: 2px;
			transform-origin: top left;
			transition: transform 0.4s ease;	
			left: 50%;
			transform: translateX(-50%) scale(var(--board-scale, 0.5));
			max-height: none;
			padding: 0;
		}

		#blue-zone.zoom-focus {
			max-height: 66vh;
		}
		
		.zone.zoom-focus {
			transform: translate(-50%, -50%) scale(0.95);
			max-height: 80vh;
			overflow: hidden;
		}
		#blue-zone.zoom-focus {
			overflow-y: auto;
		}



		.bottom-bar-footer {
			margin-top: 0px;
			padding-top: 0px;
		}
	
	}

	@media (max-width: 430px) {
	
		:root {
			--bottom-bar-height: 175px;
		}
	
		.board {
			gap: 2px;
			transform-origin: top left;
			transition: transform 0.4s ease;	
			left: 50%;
			transform: translateX(-50%) scale(var(--board-scale, 0.5));
			max-height: none;
			padding: 0;
		}

		#blue-zone.zoom-focus {
			max-height: 66vh;
		}
		
		.zone.zoom-focus {
			transform: translate(-50%, -50%) scale(0.95);
			max-height: 80vh;
			overflow: hidden;
		}
		#blue-zone.zoom-focus {
			overflow-y: auto;
		}


		.bottom-bar-footer {
			margin-top: 0px;
			padding-top: 0px;
		}
	
	}

	@media (max-width: 410px) {
	
		:root {
			--bottom-bar-height: 175px;
		}
	
		.board {
			gap: 2px;
			transform-origin: top left;
			transition: transform 0.4s ease;	
			left: 50%;
			transform: translateX(-50%) scale(var(--board-scale, 0.5));
			max-height: none;
		}

		.zone.zoom-focus {
			transform: translate(-50%, -50%) scale(0.93);
		}


	}
	
	@media (max-width: 390px) {
	
		:root {
			--bottom-bar-height: 175px;
		}
	
		.board {
			gap: 2px;
			transform-origin: top left;
			transition: transform 0.4s ease;	
			left: 50%;
			transform: translateX(-50%) scale(var(--board-scale, 0.5));
			max-height: none;
		}

		.zone.zoom-focus {
			transform: translate(-50%, -50%) scale(0.60);
		}

	
	}

	/* ============================================
	   ZONE HEADERS
	   ============================================
	   H2 titels die bovenaan elke zone verschijnen (bijv. "Geel vak", "Blauw vak")
	   Dark mode krijgt lichtere grijstint voor betere leesbaarheid
	*/
	h2 { color: #555; margin:0 0 8px; font-size:1rem; text-align:center }
	body.dark-mode h2 { color: #b0b0b0; }

	/* ============================================
	   ZONE KLEUREN & AFMETINGEN
	   ============================================
	   Elk speelvak (zone) krijgt zijn eigen kleur, breedte en hoogte
	   Placeholder varianten zijn voor drag-and-drop preview
	   Dark mode krijgt donkere gradient overlays (zie verderop)
	*/
	#yellow-zone,
	#yellow-zone--placeholder { background:#f0dc7d; height: 450px; min-width: 300px; padding: 14px; }
	/* Yellow (World 2): keep the generated grid visually centered (equal top/bottom spacing). */
	#yellow-zone,
	#yellow-zone--placeholder {
		display: flex;
		flex-direction: column;
		align-items: center;
		justify-content: center;
	}
	#green-zone,
	#green-zone--placeholder { background:#a8d5a2; }
	/* World 2: keep green zone square (same width, more height). */
	body.world-2:not(.zoomed-in) #green-zone,
	body.world-2:not(.zoomed-in) #green-zone--placeholder {
		/* Width is set below; match height to that width. */
		height: calc(13 * var(--cell-size) + 80px);
		max-height: calc(13 * var(--cell-size) + 80px);
		overflow: auto;
	}
	/* Green (World 2 request): hide scrollbar visuals while keeping scroll. */
	#green-zone {
		scrollbar-width: none; /* Firefox */
		-ms-overflow-style: none; /* IE/Edge legacy */
	}
	#green-zone::-webkit-scrollbar {
		width: 0;
		height: 0;
		display: none;
	}
	#green-zone {
		cursor: grab;
	}
	#green-zone.drag-scroll-active {
		cursor: grabbing;
	}
	/* World 1: disable scrolling in green zone */
	#green-zone.no-scroll {
		overflow: hidden !important;
		cursor: default !important;
	}
	#green-zone.no-scroll.drag-scroll-active {
		cursor: default !important;
	}

	/* Desktop: beperk groene en rode zone breedte */
	@media (min-width: 651px) {
		#green-zone,
		#green-zone--placeholder {
			width: calc(13 * var(--cell-size) + 80px);
			max-width: calc(13 * var(--cell-size) + 80px);
		}
		#green-grid {
			max-width: calc(13 * var(--cell-size) + 40px);
		}
		/* Red zone should match the green zone width (user request). */
		#red-zone,
		#red-zone--placeholder {
			width: calc(13 * var(--cell-size) + 80px);
			max-width: calc(13 * var(--cell-size) + 80px);
			margin: 0;
		}
	}

	#yellow-zone,
	#yellow-zone--placeholder,
	#purple-zone,
	#purple-zone--placeholder {
		overflow: hidden;
	}
	#purple-zone,
	#purple-zone--placeholder { background:#a48dcc; height: 310px;  }
	#blue-zone,
	#blue-zone--placeholder { background:#6ba8d8; width: 180px; height: 791px; }

	/* Blue (World 2): keep scroll but hide the (white) scrollbar visuals on desktop too. */
	#blue-zone {
		overflow-y: auto;
		overflow-x: auto;
		scrollbar-width: none; /* Firefox */
		-ms-overflow-style: none; /* IE/Edge legacy */
	}
	#blue-zone::-webkit-scrollbar {
		width: 0;
		height: 0;
		display: none;
	}
	#blue-zone #blue-grid {
		scrollbar-width: none;
		-ms-overflow-style: none;
	}
	#blue-zone #blue-grid::-webkit-scrollbar {
		width: 0;
		height: 0;
		display: none;
	}
	#gold-zone,
	#gold-zone--placeholder { background:#fffbea; height: 100px; width: 280px; box-shadow: 0 0 8px rgba(0,0,0,0.4); }
	#red-zone,
	#red-zone--placeholder { background:#de838c; height: auto; min-height: 323px;  margin: 15px; border-radius: 10px; box-shadow: 0 2px 6px rgba(0,0,0,0.12);
	  box-sizing: border-box; padding: 10px; touch-action: manipulation; overflow: visible; }
	#red-zone.red-group {
		display: grid;
		grid-template-columns: repeat(2, max-content);
		justify-content: center;
		gap: 18px;
	}
	#red-zone.red-group > .zone {
		margin: 0 !important;
	}
	  
	#red-grid1,
	#red-grid1--placeholder { background:#de838c; margin: 15px; border-radius: 0; border:0; box-shadow: none !important; }
	#red-grid2,
	#red-grid2--placeholder { background:#de838c; margin: 15px; border-radius: 0; border:0; box-shadow: none; }
	#red-grid3,
	#red-grid3--placeholder { background:#de838c; margin: 15px; border-radius: 0; border:0; box-shadow: none; }
	#red-grid4,
	#red-grid4--placeholder { background:#de838c; margin: 15px; border-radius: 0; border:0; box-shadow: none; }
	@media (min-width: 651px) {
		#red-zone.red-group #red-grid1,
		#red-zone.red-group #red-grid2,
		#red-zone.red-group #red-grid3,
		#red-zone.red-group #red-grid4 {
			margin: 0 !important;
		}
	}

	/* DARK MODE: Override zone kleuren met donkere gradient */

	body.dark-mode #gold-zone--placeholder { 
		background: linear-gradient(145deg, #2d2920, #232119);
		border: 1px solid #3d3930;
	}
	

	/* ============================================
	   CEL KLEUREN PER ZONE
	   ============================================
	   Elke zone heeft cellen met hun eigen kleur schema
	   .cell = standaard (niet ingevuld)
	   .cell.active = ingevuld/actief (donkerder kleur)
	   .end-cell = speciale eindcel in groen vak
	*/
	#yellow-zone .cell,
	#yellow-zone--placeholder .cell { background: #fff3b0; color: #3e2f00; border-color: #fffba8; }
	#red-zone .cell,
	#red-zone--placeholder .cell { background: #ffd6d1; color: #4b0000; border-color: #ff7b73; }
	#purple-zone .cell,
	#purple-zone--placeholder .cell { background: #f3e8fa; border-color: #e6a8ff; }
	#green-zone .cell,
	#green-zone--placeholder .cell { background: #d6f5d6; color: #003300; border-color: #c1ffa8; } 
	#green-zone .cell.end-cell,
	#green-zone--placeholder .cell.end-cell {background-color: #7bba7b !important; border-color: #7bb57f; } 
	#blue-zone .cell,
	#blue-zone--placeholder .cell { background: #d6eaff; color: #001f3f; border-color: #a8d8ff; }
	#yellow-zone .cell.active,
	#yellow-zone--placeholder .cell.active { background: #cfba51; border-color: #f7dc54; } 
	#red-zone .cell.active,
	#red-zone--placeholder .cell.active { background: #b56069; border-color: #ff7b73; }
	#purple-zone .cell.active,
	#purple-zone--placeholder .cell.active { background: #8f76b8; color: #33004b; border-color: #e6a8ff; }
	#green-zone .cell.active,
	#green-zone--placeholder .cell.active { background: #92c28c; border-color: #c1ffa8; }
	#green-zone .cell.end-cell.active,
	#green-zone--placeholder .cell.end-cell.active {background-color: #5da35d !important; border-color: #518755; } 
#yellow-zone .cell.end-cell.active,
#yellow-zone--placeholder .cell.end-cell.active { background-color: #cfae4a !important; border-color: #b8963c !important; }
#purple-zone .cell.end-cell.active,
#purple-zone--placeholder .cell.end-cell.active { background-color: #7a5aa8 !important; border-color: #62478a !important; }
#blue-zone .cell.end-cell.active,
#blue-zone--placeholder .cell.end-cell.active { background-color: #3b7aa4 !important; border-color: #2f6386 !important; }

	/* Bold start cells should keep the normal active background but have a thicker/darker border */
	#green-zone .cell.bold-cell.active,
	#green-zone--placeholder .cell.bold-cell.active {
		background-color: #92c28c !important; /* match normal green active */
		border-color: #2b572b !important;
	}

	/* Start cell in green should not use the dark end-cell active color */
	#green-zone .cell.start-cell.active,
	#green-zone--placeholder .cell.start-cell.active { background-color: #92c28c !important; border-color: #c1ffa8 !important; }
	#blue-zone .cell.active,
	#blue-zone--placeholder .cell.active { background: #5689b0; border-color: #a8d8ff; }

	/* ============================================
	   COIN SYMBOL STYLING
	   ============================================
	   Gebruik Segoe UI Symbol / Apple Color Emoji voor coin emoji
	   zodat het correct wordt weergegeven in alle browsers
	*/
	.coin-symbol {
		font-family: "Segoe UI Symbol", "Segoe UI Emoji", "Apple Color Emoji", "Noto Color Emoji", Arial, sans-serif;
	}
	
	/* Algemene emoji ondersteuning voor toast berichten, feedback, etc. */
	.toast-message,
	.blackhole-feedback,
	.blackhole-subtext,
	.objective-toast,
	.modal-score-summary,
	.round-summary-icon,
	.card-label,
	[class*="feedback"],
	[class*="toast"] {
		font-family: "Segoe UI", -apple-system, BlinkMacSystemFont, sans-serif, "Segoe UI Symbol", "Segoe UI Emoji", "Apple Color Emoji", "Noto Color Emoji";
	}
	
	/* ============================================
	   GRID LAYOUT BASIS
	   ============================================
	   Basisstijl voor alle grid containers binnen zones
	   Gebruikt CSS Grid voor automatische cel positionering
	*/
	.grid { display: grid; gap: var(--board-grid-gap, 2px); justify-content: center; margin: 20px; }
	/* Yellow (World 2): remove inner grid margin so spacing stays even and not clipped. */
	#yellow-zone #yellow-grid.grid,
	#yellow-zone--placeholder #yellow-grid.grid {
		margin: 0;
	}
	/* Purple: match Yellow centering (no inner grid margin). */
	#purple-zone #purple-grid.grid,
	#purple-zone--placeholder #purple-grid.grid {
		margin: 0;
	}
	/* Green: remove inner margin so the darker outer rim disappears. */
	#green-zone #green-grid {
		margin: 0;
		background: transparent;
	}
	
	/* ============================================
	   CEL STIJLEN - BASIS
	   ============================================
	   De individuele cellen in elk speelvak
	   .edge-cell = rode gloed voor rand-cellen (in rood vak)
	   .bold-cell = dikke zwarte rand
	   .end-cell = groene eindcel
	   .active = ingevuld met animatie
	   .gold-cell = heeft gouden muntje symbool
	*/
	.cell.edge-cell {
	  border: 2px solid rgba(255,80,80,0.95);
	  box-shadow: 0 0 10px 3px rgba(255,80,80,0.45);
	  z-index: 6; /* op de root-cellen liggen */
	  transition: box-shadow 0.18s ease, border 0.18s ease;
	}
	.cell{
	  width: var(--cell-size);
	  height: var(--cell-size);
	  background: #f9fafc;      
	  color: #222;
	  border: 1px solid #d8dee9;
	  box-shadow: 0 1px 2px rgba(0,0,0,0.05);
	  border-radius: calc(var(--cell-size) / 4);
	  position:relative;
	  user-select:none;
	  display: flex;
	  align-items: center;
	  justify-content: center;
	  transition: background 0.25s, transform 0.15s;
	  animation: growRoot 0.3s forwards;
	}

	/* Green root cells are absolutely positioned; shrink + center them to create visible spacing. */
	#green-grid .root-cell:not(.void-cell) {
		width: calc(var(--cell-size) - 2px);
		height: calc(var(--cell-size) - 2px);
		transform: translate(1px, 1px);
	}



	/* WORLD 2 (Yellow): Alternate diagonal shading so players see the diagonal-row rule.
	   Keep it subtle and do NOT affect active/void cells. */
	#yellow-grid .cell.diag-shade-odd:not(.void-cell):not(.active) {
	  filter: brightness(0.985);
	}
	body.dark-mode #yellow-grid .cell.diag-shade-odd:not(.void-cell):not(.active) {
	  filter: brightness(1.06);
	}

	/* WORLD 2 (Purple): Buitenste 2 ringen met subtiel andere achtergrondkleur */
	#purple-grid .cell.outer-ring-0:not(.void-cell):not(.active) {
	  /* Buitenste ring: iets lichter (subtiel) */
	  background: #efe8f7;
	  filter: brightness(1.00);
	}
	#purple-grid .cell.outer-ring-1:not(.void-cell):not(.active) {
	  /* Tweede ring: nog iets lichter */
	  background: #f3eefb;
	  filter: brightness(1.00);
	}
	body.dark-mode #purple-grid .cell.outer-ring-0:not(.void-cell):not(.active) {
	  background: #d3c3ea;
	  filter: brightness(0.97);
	}
	body.dark-mode #purple-grid .cell.outer-ring-1:not(.void-cell):not(.active) {
	  background: #d9ccec;
	  filter: brightness(0.97);
	}

	/* Ensure golden card frame shows in the bottom-bar hand (more specific than the hand card background rules). */
	#bottom-bar #card-choice-zone .card-option.card-golden {
		background: linear-gradient(135deg, #fff9e6 0%, #ffe082 30%, #f6c84a 60%, #c78c1f 100%);
		border: 1px solid rgba(220,180,60,0.9);
		box-shadow: 0 28px 56px rgba(184,120,18,0.45), inset 0 1px 0 rgba(255,255,255,0.6);
	}
	body.dark-mode #bottom-bar #card-choice-zone .card-option.card-golden {
		background: linear-gradient(135deg, #5b4a14 0%, #8a6a1c 35%, #bf952a 70%, #e3c45e 100%);
		border: 1px solid rgba(200,160,30,0.8);
		box-shadow: 0 28px 52px rgba(0,0,0,0.6), inset 0 1px 0 rgba(255,255,255,0.08);
	}
	.cell.void-cell {
	  visibility: hidden;
	  pointer-events: none;
	  border: none;
	  background: transparent;
	  box-shadow: none;
	  animation: none;
	}
	.cell:hover { background: #eef3ff; }
	.cell.active { background: #cde3ff; border-color: #a8c9ff; color: #000; transform: scale(1.1); box-shadow: 0 0 8px rgba(58,111,247,0.25); }
	.cell.bold-cell{ border:2px solid #2c3333 !important }
	.cell.end-cell{ background:#a7d6aa; border-color:#a7d6aa }
	.cell.end-cell.active{ background:#81b884 }
	.cell.trap-cell { position: relative; }
	.cell.trap-triggered {
	  box-shadow: 0 0 12px rgba(196,56,56,0.55), inset 0 0 10px rgba(196,56,56,0.45);
	  animation: trapPulse 0.5s ease;
	}

	@keyframes trapPulse {
	  0% { transform: scale(1); }
	  50% { transform: scale(1.05); }
	  100% { transform: scale(1); }
	}
	
	/* ============================================
	   SYMBOLEN IN CELLEN
	   ============================================
	   Gekleurde vierkantjes die in cellen kunnen verschijnen
	   Tonen welke kleur/zone de cel vertegenwoordigt
	*/
	.symbol { display: inline-block; width: 14px; height: 14px; border-radius: 4px; margin: auto; border:2px solid #444; background-color: #999; }
	.symbol.yellow { background-color: #fff48f; }
	.symbol.green  { background-color: #69cf57; }
	.symbol.purple { background-color: #ae7eed; }
	.symbol.blue   { background-color: #76a0e3; }
	.symbol.red    { background-color: #ed7e89; }
	.symbol.trap-symbol {
	  width: 18px;
	  height: 18px;
	  border-radius: 2px;
	  background: #656565;
	  border: none;
	  transform: rotate(45deg) scale(0.75);
	  pointer-events: none;
	  position: relative;
	  overflow: hidden;
	}

	.symbol.trap-symbol::after {
	  content: "";
	  position: absolute;
	  inset: 4px;
	  border-radius: 1px;
	  background: linear-gradient(135deg, rgba(255,255,255,0.2) 0%, rgba(255,255,255,0) 50%);
	  opacity: 0.8;
	}

	.symbol.trap-symbol.trap-symbol--pit::after {
	  opacity: 0.6;
	}

	.symbol.trap-symbol.trap-symbol--black-hole {
	  background: radial-gradient(circle, #1a1a2e 0%, #0a0a15 60%, #000000 100%);
	  border-radius: 50%;
	  box-shadow: 
		0 0 15px rgba(138, 43, 226, 0.6),
		0 0 25px rgba(75, 0, 130, 0.4),
		inset 0 0 20px rgba(138, 43, 226, 0.3);
	  border: 2px solid rgba(138, 43, 226, 0.4);
	}

	.symbol.trap-symbol.trap-symbol--black-hole::after {
	  background: radial-gradient(circle, rgba(138, 43, 226, 0.2) 0%, transparent 70%);
	  opacity: 1;
	  border-radius: 50%;
	  animation: black-hole-pulse 2s ease-in-out infinite;
	}

	/* Mega Bonus Symbol - grotere bonus met shimmer effect */
	.symbol.mega-bonus-symbol {
	  width: 120%;
	  height: 120%;
	  border-radius: 8px;
	  cursor: pointer;
	  display: flex;
	  align-items: center;
	  justify-content: center;
	  font-size: 24px;
	  font-weight: bold;
	  position: absolute;
	  top: 50%;
	  left: 50%;
	  transform: translate(-50%, -50%);
	  transition: transform 0.2s ease;
	  z-index: 15;
	  /* Gradient glim effect over bonus color */
	  background: linear-gradient(135deg, 
		rgba(255, 255, 255, 0.4) 0%, 
		transparent 40%, 
		transparent 60%, 
		rgba(255, 255, 255, 0.4) 100%);
	  background-size: 200% 200%;
	  animation: mega-bonus-glim 2.5s ease-in-out infinite;
	  box-shadow: 0 0 15px rgba(255, 255, 255, 0.5), 
				  inset 0 0 20px rgba(255, 255, 255, 0.3);
	}

	.symbol.mega-bonus-symbol:hover {
	  transform: translate(-50%, -50%) scale(1.15);
	}

	/* Upgrade Shop Symbol - shop icoon met gouden gloed */
	.symbol.upgrade-shop-symbol {
	  width: 100%;
	  height: 100%;
	  border-radius: 8px;
	  cursor: pointer;
	  display: flex;
	  align-items: center;
	  justify-content: center;
	  font-size: 24px;
	  font-weight: bold;
	  position: absolute;
	  top: 50%;
	  left: 50%;
	  transform: translate(-50%, -50%);
	  transition: transform 0.2s ease;
	  z-index: 15;
		/* Diamond-like cool gradient to distinguish from traps */
		background: linear-gradient(135deg, #e6fbff 0%, #bfefff 40%, #9ad8ff 100%);
		color: #0b3b4a;
		box-shadow: 0 0 8px rgba(60,160,200,0.25), inset 0 0 6px rgba(255,255,255,0.6);
	}

/* Diamond glyph styling for inline text (toasts, titles) */
.diamond-glyph { color: #0b3b4a; font-weight: 700; text-shadow: 0 1px 0 rgba(255,255,255,0.25); }
body.dark-mode .diamond-glyph { color: #bfefff; }

	.symbol.upgrade-shop-symbol:hover {
	  transform: translate(-50%, -50%) scale(1.15);
	}

	@keyframes upgrade-shop-glim {
	  0%, 100% { 
		background-position: 0% 50%;
	  }
	  50% { 
		background-position: 100% 50%;
	  }
	}

	@keyframes mega-bonus-glim {
	  0%, 100% { 
		background-position: 0% 50%;
	  }
	  50% { 
		background-position: 100% 50%;
	  }
	}

	@keyframes black-hole-pulse {
		0%, 100% {
			transform: scale(1);
			opacity: 0.8;
		}
		50% {
			transform: scale(1.1);
			opacity: 1;
		}
	}
	
	/* Portal cel styling */
	.portal-cell {
		animation: portal-pulse 2s ease-in-out infinite;
		z-index: 10 !important;
	}

	.portal-symbol {
		position: absolute;
		top: 50%;
		left: 50%;
		transform: translate(-50%, -50%);
		font-size: 24px;
		z-index: 100;
		pointer-events: none;
		filter: drop-shadow(0 0 10px rgba(100, 150, 255, 1));
		animation: portal-rotate 3s linear infinite;
		text-shadow: 0 0 15px rgba(100, 150, 255, 0.8);
	}

	@keyframes portal-pulse {
		0%, 100% {
			box-shadow: 0 0 15px rgba(100, 150, 255, 0.8), inset 0 0 15px rgba(100, 150, 255, 0.5);
		}
		50% {
			box-shadow: 0 0 30px rgba(100, 150, 255, 1), inset 0 0 20px rgba(100, 150, 255, 0.7);
		}
	}

	@keyframes portal-rotate {
		0% { transform: translate(-50%, -50%) rotate(0deg); }
		100% { transform: translate(-50%, -50%) rotate(360deg); }
	}
	
	/* Gouden muntje binnen een cel (gebruikt ::after pseudo-element) */
	.gold-cell::after { content: ""; position: absolute; top: 4px; left: 4px; width: 12px; height: 12px; border-radius: 50%; background: #ffea63; border: 2px solid #171615; z-index: 1; }
	.cell.active.gold-cell::after{ background:#edcd21 }
	
	/* ============================================
	   MUNTEN VERZAMELING (GOUDEN VAK)
	   ============================================
	   Container voor de 20 muntjes in het gouden vak
	   Toont hoeveel munten je hebt verzameld/gebruikt
	*/
	#collected-coins{ display:flex; gap:6px; flex-wrap:wrap; justify-content:center; margin-top:5px;  }
	
	/* ============================================
	   INDIVIDUELE MUNTEN
	   ============================================
	   Elk muntje heeft 3 states:
	   - standaard (grijs, niet verzameld)
	   - .active (goudkleurig, verzameld maar niet gebruikt)
	   - .used (donkergrijs, al uitgegeven in shop)
	*/
	.coin {
		width: 18px;
		height: 18px;
		border-radius: 50%;
		background: rgba(255,255,255,0.18);
		border: 1px solid rgba(255,255,255,0.28);
		box-shadow: inset 0 0 0 1px rgba(0,0,0,0.25), 0 0 6px rgba(0,0,0,0.25);
		transition: transform 0.2s ease, background 0.2s ease, border-color 0.2s ease, box-shadow 0.2s ease;
	}

	.coin.active {
		background: radial-gradient(circle at 30% 30%, #fff6b5, #f7bb36 70%);
		border-color: #f3b12b;
		box-shadow: 0 0 8px rgba(255,209,90,0.78), inset 0 0 2px rgba(255,255,255,0.85);
		transform: scale(1.05);
	}

	.coin.used {
		background: rgba(80,82,95,0.65);
		border-color: rgba(120,124,140,0.6);
		box-shadow: inset 0 0 0 1px rgba(0,0,0,0.4);
		transform: scale(1);
	}

	body.dark-mode .coin {
		background: rgba(255,255,255,0.14);
		border-color: rgba(255,255,255,0.24);
	}

	body.dark-mode .coin.active {
		background: radial-gradient(circle at 30% 30%, #ffe58c, #f5b72f 70%);
	}

	body.dark-mode .coin.used {
		background: rgba(60,60,72,0.7);
		border-color: rgba(110,110,130,0.55);
		box-shadow: inset 0 0 0 1px rgba(0,0,0,0.55);
	}

	/* ============================================
	   +1 BLOKPLAATSING KNOP
	   ============================================ */
	.buy-placement-btn {
		display: flex;
		align-items: center;
		justify-content: center;
		gap: 6px;
		margin-top: 10px;
		padding: 8px 14px;
		border: 1px solid rgba(26,32,48,0.16);
		border-radius: 8px;
		background: linear-gradient(155deg, #eff3ff 0%, #dbe2f6 100%);
		color: #2b3148;
		font-weight: 600;
		font-size: 0.9rem;
		cursor: pointer;
		transition: transform 0.15s ease, box-shadow 0.15s ease, background 0.15s ease;
		box-shadow: 0 12px 20px rgba(10,12,20,0.22);
	}
	.buy-placement-btn:hover:not(:disabled) {
		transform: translateY(-2px);
		box-shadow: 0 18px 28px rgba(10,12,20,0.28);
		background: linear-gradient(155deg, #f4f7ff 0%, #e2e8fb 100%);
	}
	.buy-placement-btn:active:not(:disabled) {
		transform: translateY(0);
		box-shadow: 0 10px 18px rgba(10,12,20,0.22);
	}
	.buy-placement-btn:disabled {
		opacity: 0.5;
		cursor: not-allowed;
		background: linear-gradient(135deg, #e0e0e0, #bdbdbd);
		border-color: rgba(26,32,48,0.16);
		color: #757575;
	}
	.buy-placement-arrow {
		font-size: 1.05rem;
		line-height: 1;
		opacity: 0.9;
		transform: translateY(-0.5px);
	}
	/* Hide the arrow on touch devices */
	@media (pointer: coarse) {
		.buy-placement-arrow {
			display: none;
		}
	}
	.buy-placement-rainbow-cell {
		width: 18px;
		height: 18px;
		/* Border-radius: max 5px, minder rond */
		border-radius: min(5px, calc(18px / 5));
		display: inline-block;
		box-shadow: inset 0 0 0 1px rgba(0,0,0,0.22), 0 2px 6px rgba(0,0,0,0.22);
		background: linear-gradient(
			135deg,
			#ff5757 0%,
			#ffbf3a 22%,
			#8cff6a 45%,
			#47b1ff 70%,
			#b16cff 100%
		);
	}
	.buy-placement-cost {
		display: flex;
		gap: 3px;
		background: rgba(0,0,0,0.1);
		padding: 2px 6px;
		border-radius: 4px;
		font-size: 0.8rem;
	}
	.buy-placement-cost .coin-icon {
		display: inline-block;
		width: 0.9em;
		height: 0.9em;
		border-radius: 50%;
		background: radial-gradient(circle at 30% 30%, #fff6b5, #f7bb36 60%, #d49f20);
		box-shadow: inset 0 -1px 2px rgba(0,0,0,0.2);
		border: 1px solid #c9960a;
	}
	body.dark-mode .buy-placement-btn {
		background: linear-gradient(160deg, #2c3144 0%, #222635 100%);
		border-color: rgba(140,150,200,0.3);
		color: rgba(235,238,255,0.88);
		box-shadow: 0 16px 30px rgba(0,0,0,0.42);
	}
	body.dark-mode .buy-placement-btn:hover:not(:disabled) {
		background: linear-gradient(160deg, #333a52 0%, #252a3b 100%);
		box-shadow: 0 20px 34px rgba(0,0,0,0.5);
	}
	body.dark-mode .buy-placement-btn:disabled {
		background: linear-gradient(135deg, #3a3a3a, #2a2a2a);
		border-color: rgba(140,150,200,0.2);
		color: #888;
		transform: scale(1);
	}
	body.dark-mode .buy-placement-rainbow-cell {
		box-shadow: inset 0 0 0 1px rgba(255,255,255,0.12), 0 2px 8px rgba(0,0,0,0.55);
	}

	/* Gekocht blok preview in gold zone */
	#buy-placement-container {
		display: flex;
		justify-content: center;
		margin-top: 10px;
	}
	.purchased-block-preview {
		display: flex;
		flex-direction: column;
		align-items: center;
		gap: 6px;
		padding: 10px 16px;
		background: linear-gradient(135deg, rgba(240,98,114,0.15), rgba(255,245,90,0.15), rgba(78,211,70,0.15), rgba(93,144,240,0.15));
		border: 2px dashed rgba(150,100,200,0.5);
		border-radius: 10px;
		cursor: grab;
		transition: transform 0.15s ease, box-shadow 0.15s ease;
		animation: pulse-glow 1.5s ease-in-out infinite;
	}
	.purchased-block-preview:hover {
		transform: scale(1.05);
		box-shadow: 0 4px 16px rgba(150,100,200,0.3);
	}
	.purchased-block-preview:active {
		cursor: grabbing;
	}
	.purchased-block-cell {
		width: 28px;
		height: 28px;
		border-radius: 4px;
		background: linear-gradient(45deg, #f06272, #fff25a, #4ed346, #5d90f0, #a35eff);
		border: 2px solid rgba(255,255,255,0.5);
		box-shadow: 0 2px 8px rgba(0,0,0,0.2);
	}
	.purchased-block-label {
		font-size: 0.75rem;
		font-weight: 600;
		color: #6b4d8a;
	}
	@media (max-width: 650px) {
		.purchased-block-label {
			display: none;
		}
		.purchased-block-preview {
			gap: 4px;
			padding: 8px 12px;
		}
	}
	body.dark-mode .purchased-block-preview {
		background: linear-gradient(135deg, rgba(240,98,114,0.1), rgba(255,245,90,0.1), rgba(78,211,70,0.1), rgba(93,144,240,0.1));
		border-color: rgba(180,140,220,0.4);
	}
	body.dark-mode .purchased-block-label {
		color: #c9b0e8;
	}
	/* Keep the purchased preview visible everywhere; it's the drag handle to place the bought block. */
	@keyframes pulse-glow {
		0%, 100% { box-shadow: 0 0 8px rgba(150,100,200,0.2); }
		50% { box-shadow: 0 0 16px rgba(150,100,200,0.4); }
	}
	
	/* ============================================
	   SCOREBORD
	   ============================================
	   Toont score per kleur + totaal
	   Gepositioneerd in kolom 4 op desktop, in bottom-bar op mobiel
	   Score-rows gebruiken kleur-dots voor compactheid
	*/
	#scoreboard {
	  background: #fffbea;
	  border-radius: 12px;
	  padding: 16px 20px;
	  color: #333;
	  font-family: "Segoe UI", sans-serif;
	  width: 280px;
	  position: relative;
	  z-index: 1;
	  box-shadow: 0 0 8px rgba(0,0,0,0.4);
	  display: flex;
	  flex-direction: column;
	  align-items: stretch;
	  gap: 12px;
	}

	#scoreboard h2 {
	  margin: 0;
	}

	body.dark-mode #scoreboard {
	  background: linear-gradient(145deg, #2d2920, #232119);
	  border: 1px solid #3d3930;
	  color: #e0e0e0;
	}

	.score-row { 
	  display: flex; 
	  align-items: center; 
	  justify-content: space-between; 
	  background: #eee; 
	  padding: 6px 10px; 
	  border-radius: 8px; 
	  margin: 0;
	  position: relative;
	  transition: transform 0.1s ease, background 0.3s, box-shadow 0.3s; 
	}

	/* Zone-info knopjes (links boven in elke zone) */
	.zone-info-btn {
		position: absolute;
		left: 8px;
		top: 8px;
		z-index: 20;
		width: 20px;
		height: 20px;
		border-radius: 999px;
		border: 1px solid rgba(0,0,0,0.18);
		background: rgba(255,255,255,0.7);
		color: rgba(0,0,0,0.75);
		font-weight: 800;
		font-size: 12px;
		line-height: 1;
		display: inline-flex;
		align-items: center;
		justify-content: center;
		cursor: pointer;
		padding: 0;
		-webkit-user-select: none;
		user-select: none;
	}

	/* When a zone is scrollable, pin the info UI to the zone viewport. */
	#blue-zone .zone-info-btn,
	#green-zone .zone-info-btn {
		position: sticky;
		top: 8px;
		left: 8px;
		margin: 0 0 -20px 0;
	}
	#blue-zone .zone-info-popover,
	#green-zone .zone-info-popover {
		position: sticky;
		top: 34px;
		left: 8px;
		margin: 0 0 -140px 0;
	}

	body.dark-mode .zone-info-btn {
		border-color: rgba(255,255,255,0.18);
		background: rgba(0,0,0,0.2);
		color: rgba(255,255,255,0.82);
	}

	.zone-info-btn:focus {
		outline: 2px solid rgba(0,0,0,0.25);
		outline-offset: 2px;
	}

	body.dark-mode .zone-info-btn:focus {
		outline-color: rgba(255,255,255,0.22);
	}

	.zone-info-popover {
		position: absolute;
		left: 8px;
		right: 8px;
		top: 34px;
		z-index: 30;
		display: none;
		padding: 10px 12px;
		border-radius: 10px;
		background: rgba(255,255,255,0.95);
		border: 1px solid rgba(0,0,0,0.14);
		box-shadow: 0 8px 20px rgba(0,0,0,0.18);
		font-size: 0.82rem;
		line-height: 1.25;
		color: rgba(0,0,0,0.78);
		-webkit-backdrop-filter: blur(6px);
		backdrop-filter: blur(6px);
	}

	body.dark-mode .zone-info-popover {
		background: rgba(35, 33, 25, 0.96);
		border-color: rgba(255,255,255,0.12);
		box-shadow: 0 10px 22px rgba(0,0,0,0.55);
		color: rgba(255,255,255,0.85);
	}

	.zone[data-info-open="true"] .zone-info-popover {
		display: block;
	}
	
	body.dark-mode .score-row {
	  background: #383838;
	  color: #e0e0e0;
	}

	.score-row:hover { transform: scale(1.03); background: #383838; }
	
	/* Score highlighting voor behaalde doelstellingen */
	.score-row.objective-achieved {
	  box-shadow: 0 0 10px 2px rgba(255, 215, 0, 0.6);
	  animation: objective-pulse 2s ease-in-out infinite;
	}
	
	body.dark-mode .score-row.objective-achieved {
	  box-shadow: 0 0 12px 2px rgba(255, 215, 0, 0.7);
	  animation: objective-pulse-dark 2s ease-in-out infinite;
	}
	
	@keyframes objective-pulse {
	  0%, 100% { box-shadow: 0 0 10px 2px rgba(255, 215, 0, 0.6); }
	  50% { box-shadow: 0 0 15px 3px rgba(255, 215, 0, 0.8); }
	}
	
	@keyframes objective-pulse-dark {
	  0%, 100% { box-shadow: 0 0 12px 2px rgba(255, 215, 0, 0.7); }
	  50% { box-shadow: 0 0 18px 4px rgba(255, 215, 0, 0.9); }
	}

	body.dark-mode .score-row:hover {
	  background: #484848;
	}

	.color-box { width: 14px; height: 14px; border-radius: 3px; margin-right: 8px; }
	.label { flex: 1; font-size: 0.9em; }
	.score { font-weight: bold; font-size: 1em; }
	.score-row.yellow .color-box { background-color: #f7e757; }
	.score-row.red .color-box { background-color: #ed7e89; }
	.score-row.green .color-box { background-color: #69cf57; }
	.score-row.purple .color-box { background-color: #ae7eed; }
	.score-row.blue .color-box { background-color: #76a0e3; }
	.score-row.bonus .color-box { background-color: #C0C0C0; }
	#scoreboard hr {
	  width: 100%;
	  border: none;
	  border-top: 1px solid rgba(0,0,0,0.08);
	  margin: 0;
	}

	body.dark-mode #scoreboard hr {
	  border-top-color: rgba(255,255,255,0.12);
	}

	#scoreboard .score-total {
	  display: flex;
	  align-items: center;
	  justify-content: space-between;
	  gap: 6px;
	  padding: 4px 8px;
	  background: #f0ead8;
	  border-radius: 6px;
	  border: 1px solid #d9d0bd;
	  font-weight: 600;
	  color: #333;
	  margin-top: 3px;
	  font-size: 0.9rem;
	  transition: box-shadow 0.3s;
	}
	
	/* Total score highlighting voor behaalde doelstellingen */
	#scoreboard .score-total.objective-achieved {
	  box-shadow: 0 0 10px 2px rgba(255, 215, 0, 0.6);
	  animation: objective-pulse 2s ease-in-out infinite;
	}
	
	body.dark-mode #scoreboard .score-total.objective-achieved {
	  box-shadow: 0 0 12px 2px rgba(255, 215, 0, 0.7);
	  animation: objective-pulse-dark 2s ease-in-out infinite;
	}

	body.dark-mode #scoreboard .score-total {
	  background: #2f3239;
	  border-color: #3d4048;
	  color: #e5e5e5;
	}

	#scoreboard .trap-summary {
	  display: flex;
	  flex-direction: column;
	  gap: 6px;
	  padding: 10px 12px;
	  border-radius: 12px;
	  background: rgba(0,0,0,0.035);
	  border: 1px solid rgba(0,0,0,0.06);
	}

	#scoreboard .trap-summary-header {
	  display: flex;
	  justify-content: space-between;
	  align-items: center;
	  font-size: 0.78rem;
	  letter-spacing: 0.05em;
	  text-transform: uppercase;
	  color: rgba(0,0,0,0.55);
	}

	#scoreboard .trap-summary-header .trap-label {
	  font-weight: 600;
	}

	#scoreboard .trap-count {
	  font-weight: 600;
	  font-size: 0.85rem;
	  color: #c43838;
	}

	#scoreboard .trap-preview {
	  display: flex;
	  flex-wrap: wrap;
	  gap: 8px;
	  align-items: center;
	  overflow: hidden;
	  padding-bottom: 0;
	  scrollbar-width: none;
	}

	#scoreboard .trap-preview.trap-preview--compact {
	  gap: 6px;
	  row-gap: 4px;
	}

	#scoreboard .trap-preview:empty::after {
	  content: 'Geen valkuilen geactiveerd';
	  font-size: 0.85rem;
	  color: rgba(0,0,0,0.45);
	  font-style: italic;
	}

	.trap-preview::-webkit-scrollbar {
	  display: none;
	}

	.trap-preview::-webkit-scrollbar-track {
	  background: rgba(0,0,0,0.05);
	  border-radius: 6px;
	}

	.trap-preview::-webkit-scrollbar-thumb {
	  background: rgba(196,56,56,0.4);
	  border-radius: 6px;
	}

	.trap-preview--compact .trap-icon {
	  display: none;
	}

	.trap-compact-chip {
	  display: inline-flex;
	  align-items: center;
	  gap: 4px;
	  padding: 2px 9px;
	  border-radius: 999px;
	  font-weight: 600;
	  font-size: 0.8rem;
	  background: rgba(196,56,56,0.12);
	  color: #a51111;
	  border: 1px solid rgba(196,56,56,0.28);
	}

	.trap-compact-chip::before {
	  content: attr(data-symbol);
	  font-size: 1rem;
	  line-height: 1;
	}

	.trap-compact-chip span {
	  pointer-events: none;
	}

	.trap-compact-chip--black-hole {
	  background: rgba(62, 44, 143, 0.12);
	  color: #3e2c8f;
	  border-color: rgba(62, 44, 143, 0.26);
	}

	.trap-icon {
	  position: relative;
	  width: 40px;
	  height: 40px;
	  flex: 0 0 auto;
	  display: flex;
	  align-items: center;
	  justify-content: center;
	  border-radius: 10px;
	  background: radial-gradient(circle at 30% 30%, #ffeaea, #f6d3d3);
	  border: 1px solid rgba(196,56,56,0.35);
	  box-shadow: 0 4px 10px rgba(196,56,56,0.18);
	  font-size: 1.4rem;
	  color: #a51111;
	  transition: transform 0.2s ease, box-shadow 0.2s ease;
	}

	.trap-icon .penalty-chip {
	  position: absolute;
	  right: -4px;
	  bottom: -6px;
	  background: #2a0b0b;
	  color: #ffb3b3;
	  font-size: 0.7rem;
	  font-weight: 600;
	  padding: 1px 5px;
	  border-radius: 10px;
	  border: 1px solid rgba(255,255,255,0.25);
	  box-shadow: 0 4px 8px rgba(0,0,0,0.2);
	}

	.trap-icon.trap-icon--black-hole {
	  background: radial-gradient(circle at 35% 28%, #f1ecff 0%, #d7d1fb 60%, #bfb6ef 100%);
	  border-color: rgba(110, 80, 210, 0.35);
	  color: #3e2c8f;
	  box-shadow: 0 6px 14px rgba(80, 60, 160, 0.28);
	}

	.trap-icon.trap-icon--black-hole .penalty-chip {
	  background: rgba(40, 28, 100, 0.9);
	  color: #efe8ff;
	  border-color: rgba(255,255,255,0.38);
	}

	.trap-icon span {
	  pointer-events: none;
	}

	.trap-icon span:first-child {
	  font-size: 1.05rem;
	}

	.trap-icon.highlight {
	  transform: translateY(-3px) scale(1.05);
	  box-shadow: 0 8px 16px rgba(196,56,56,0.36);
	}

	#scoreboard .score-total .label {
	  font-size: 0.85rem;
	  letter-spacing: 0.08em;
	  text-transform: uppercase;
	  opacity: 0.8;
	}

	#scoreboard .score-total .total-score {
	  font-size: 2.2rem;
	  line-height: 1;
	  font-weight: 700;
	  color: #2b1a00;
	}

	#bonus-score[data-blackhole-extra]:not([data-blackhole-extra="0"])::after {
	  content: ' +' attr(data-blackhole-extra);
	  font-size: 0.7em;
	  margin-left: 6px;
	  color: #6b63c9;
	}

	body.dark-mode #scoreboard .score-total {
	  background: linear-gradient(140deg, #3a331f, #2b2619);
	  border-color: rgba(255, 199, 63, 0.25);
	  color: #f6f1dd;
	  box-shadow: 0 16px 30px rgba(0,0,0,0.35);
	}

	body.dark-mode #scoreboard .trap-summary {
	  background: rgba(255,255,255,0.03);
	  border-color: rgba(255,255,255,0.07);
	}
	body.dark-mode #bonus-score[data-blackhole-extra]:not([data-blackhole-extra="0"])::after {
	  color: #d5d0ff;
	}

	body.dark-mode .trap-icon {
	  background: radial-gradient(circle at 30% 30%, #3c1e1e, #281111);
	  border-color: rgba(196,56,56,0.45);
	  color: #f3bbbb;
	  box-shadow: 0 4px 12px rgba(0,0,0,0.45);
	}

	body.dark-mode .trap-icon.trap-icon--black-hole {
	  background: radial-gradient(circle at 38% 32%, #403472 0%, #291f55 58%, #110b30 100%);
	  border-color: rgba(150,120,240,0.55);
	  color: #d9d5ff;
	  box-shadow: 0 6px 16px rgba(50,30,120,0.45);
	}

	body.dark-mode .trap-icon .penalty-chip {
	  background: rgba(70,20,20,0.85);
	  color: #ffc9c9;
	}

	body.dark-mode .trap-icon.trap-icon--black-hole .penalty-chip {
	  background: rgba(24,18,70,0.9);
	  color: #f0ecff;
	}

	body.dark-mode #scoreboard .trap-summary-header {
	  color: rgba(255,240,210,0.6);
	}

	body.dark-mode #scoreboard .trap-summary-header .trap-label {
	  color: rgba(255,240,210,0.9);
	}

	body.dark-mode #scoreboard .trap-count {
	  color: #ff8585;
	}

	body.dark-mode #scoreboard .trap-preview:empty::after {
	  color: rgba(255,255,255,0.35);
	}

	body.dark-mode .trap-preview::-webkit-scrollbar-track {
	  background: rgba(255,255,255,0.05);
	}

	body.dark-mode .trap-preview::-webkit-scrollbar-thumb {
	  background: rgba(255,120,120,0.45);
	}

	body.dark-mode .trap-compact-chip {
	  background: rgba(196,56,56,0.18);
	  color: #ffb3b3;
	  border-color: rgba(196,56,56,0.32);
	}

	body.dark-mode .trap-compact-chip--black-hole {
	  background: rgba(79, 64, 150, 0.22);
	  color: #d6d1ff;
	  border-color: rgba(131, 117, 210, 0.35);
	}

	body.dark-mode .trap-icon {
	  background: radial-gradient(circle at 30% 30%, #4b1c1c, #2a1212);
	  border-color: rgba(255,120,120,0.45);
	  color: #ffb3b3;
	  box-shadow: 0 4px 10px rgba(0,0,0,0.4);
	}

	body.dark-mode .trap-icon .penalty-chip {
	  background: #901717;
	  color: #ffe0e0;
	  border-color: rgba(0,0,0,0.45);
	}

	body.dark-mode #scoreboard .score-total .label {
	  color: rgba(255, 243, 205, 0.8);
	}

	body.dark-mode #scoreboard .score-total .total-score {
	  color: #ffe6a3;
	}

	/* ============================================
	   HIGH SCORE POPUP & MODAL
	   ============================================
	*/
	.highscore-toast {
		position: fixed;
		top: 80px;
		left: 50%;
		transform: translate(-50%, 0) scale(0.96);
		background: linear-gradient(120deg, #fff7d1, #ffe089);
		color: #2a1b00;
		padding: 14px 20px;
		border-radius: 16px;
		display: flex !important;
		align-items: center;
		gap: 12px;
		box-shadow: 0 18px 40px rgba(0,0,0,0.32);
		font-weight: 600;
		z-index: 2147483647 !important;
		opacity: 0;
		animation: highscoreToastEnter 0.35s ease forwards;
		pointer-events: none;
	}

	.highscore-toast__icon {
		font-size: 1.5rem;
	}

	.highscore-toast__score {
		font-size: 1.25rem;
		font-weight: 800;
	}

	body.dark-mode .highscore-toast {
		background: linear-gradient(120deg, #2f2a1f, #4d3f1d);
		color: #fff6cc;
		box-shadow: 0 20px 46px rgba(0,0,0,0.6);
	}

	@keyframes highscoreToastEnter {
		0% { opacity: 0; transform: translate(-50%, -30px) scale(0.8); }
		70% { opacity: 1; transform: translate(-50%, 6px) scale(1.03); }
		100% { opacity: 1; transform: translate(-50%, 0) scale(1); }
	}

	/* High Score Modal */
	.highscore-modal-overlay {
		position: fixed;
		inset: 0;
		background: rgba(0,0,0,0.5);
		backdrop-filter: blur(4px);
		display: none;
		align-items: center;
		justify-content: center;
		z-index: 10000;
	}
	.highscore-modal-overlay.show { display: flex; }
	.highscore-modal {
		background: white;
		padding: 30px;
		border-radius: 12px;
		text-align: center;
		box-shadow: 0 10px 30px rgba(0,0,0,0.3);
		max-width: 90%;
		width: 300px;
	}
	body.dark-mode .highscore-modal {
		background: #2d2d2d;
		color: #eee;
	}
	.highscore-value {
		font-size: 3rem;
		font-weight: bold;
		color: #d4af37;
		margin: 20px 0;
	}
	.highscore-close-btn {
		background: #eee;
		border: none;
		padding: 10px 20px;
		border-radius: 6px;
		cursor: pointer;
		font-weight: bold;
	}
	.highscore-close-btn:hover { background: #ddd; }
	body.dark-mode .highscore-close-btn {
		background: #444;
		color: #eee;
	}
	body.dark-mode .highscore-close-btn:hover {
		background: #555;
	}

/* Saved-levels modal tweaks */
#saved-levels-modal .highscore-modal { width: 420px; max-width: 95%; text-align: left; }
#saved-levels-modal .highscore-modal h2 { margin: 0 0 12px 0; }
#saved-levels-modal #saved-levels-list { padding: 6px 4px; gap: 8px; }
#saved-levels-modal #saved-levels-list > div { display:flex; align-items:center; gap:8px; padding:8px; border-radius:6px; }
#saved-levels-modal #saved-levels-list > div:hover { background: rgba(0,0,0,0.03); }
#saved-levels-modal .highscore-modal button { padding:6px 10px; border-radius:6px; border:1px solid rgba(0,0,0,0.08); background:transparent; cursor:pointer; }
#saved-levels-modal .highscore-modal button:hover { background: rgba(0,0,0,0.04); }
#saved-levels-modal .trash-btn { color: #666; }
#saved-levels-modal .trash-btn:hover { color: #c0392b; }

/* Buttons: default + primary (blue) */
#saved-levels-modal .modal-btn { background: #f6f6f6; color: #222; border: 1px solid rgba(0,0,0,0.06); }
#saved-levels-modal .modal-btn.primary { background: linear-gradient(135deg,#4a90e2,#6fb1ff); color: #fff; border: none; }
#saved-levels-modal .modal-btn.primary:hover { filter: brightness(0.95); }

/* Dark mode overrides for better contrast */
body.dark-mode #saved-levels-modal .modal-btn { background: #3a3a3a; color: #eee; border: 1px solid rgba(255,255,255,0.04); }
body.dark-mode #saved-levels-modal .modal-btn.primary { background: linear-gradient(135deg,#2b6fb8,#4a90e2); color: #fff; }
body.dark-mode #saved-levels-modal .modal-btn.primary:hover { filter: brightness(1.05); }
body.dark-mode #saved-levels-modal .trash-btn { color: #ccc; }

/* Saved item title and label colors */
#saved-levels-modal .saved-title { font-size: 14px; color: rgba(0,0,0,0.9); }
body.dark-mode #saved-levels-modal .saved-title { color: #fff; }

/* Custom scrollbar for saved-levels list */
#saved-levels-modal #saved-levels-list::-webkit-scrollbar { width:10px; }
#saved-levels-modal #saved-levels-list::-webkit-scrollbar-track { background: transparent; }
#saved-levels-modal #saved-levels-list::-webkit-scrollbar-thumb { background: rgba(0,0,0,0.12); border-radius: 6px; }
#saved-levels-modal #saved-levels-list::-webkit-scrollbar-thumb:hover { background: rgba(0,0,0,0.18); }

/* Saved level item text */
#saved-levels-modal .saved-obj-text { font-size: 13px; color: rgba(0,0,0,0.85); opacity: 1; }
body.dark-mode #saved-levels-modal .saved-obj-text { color: #ddd; opacity: 0.95; }

	/* ============================================
	   ANIMATIES
	   ============================================
	*/
	@keyframes popIn {
	  to { transform: translate(-50%, -50%) scale(1); }
	}

	#card-choice-zone {
	  background: #fffbea;
	  border-radius: 12px;
	  color: #333;
	  font-family: "Segoe UI", sans-serif;
	  width: min(402px, 100%);
	  box-shadow: 0 0 8px rgba(0,0,0,0.4);
	  overflow: hidden;
	}

	body.dark-mode #card-choice-zone {
	  background: linear-gradient(145deg, #22252b, #1a1c21);
	  border: 1px solid #2d2f36;
	  box-shadow: 0 0 12px rgba(0,0,0,0.6);
	  color: #e5e5e5;
	}

	#card-controls {
		display: flex;
		flex-direction: row;
		align-items: flex-start;
		justify-content: center;
		gap: 16px;
		width: 100%;
		box-sizing: border-box;
	}

	#card-options {
		flex: 1 1 auto;
		min-width: 0;
		display: flex;
		flex-wrap: wrap;
		gap: 14px;
		justify-content: center;
		align-items: flex-start;
		margin: 0;
		padding: 0;
	}

	#card-action-buttons {
		display: flex;
		flex-direction: column;
		align-items: stretch;
		gap: 14px;
		max-width: 190px;
		width: 100%;
		flex: 0 0 auto;
	}

	.card-action-btn {
		position: relative;
		display: inline-flex;
		align-items: center;
		justify-content: flex-start;
		gap: 10px;
		width: 100%;
		min-width: 0;
		margin: 0;
		padding: 12px 16px;
		border-radius: 14px;
		border: 1px solid rgba(26,32,48,0.16);
		background: linear-gradient(155deg, #eff3ff 0%, #dbe2f6 100%);
		color: #2b3148;
		font-weight: 600;
		font-size: 0.88rem;
		letter-spacing: 0.04em;
		text-transform: none;
		box-shadow: 0 12px 20px rgba(10,12,20,0.22);
		cursor: pointer;
		transition: transform 0.18s ease, box-shadow 0.18s ease, border-color 0.25s ease, background 0.25s ease;
		min-height: 52px;
	}

	.card-action-btn::before {
		content: attr(data-icon);
		font-size: 1.4rem;
		line-height: 1;
	}

	.card-action-btn::after {
		content: attr(data-label);
		line-height: 1.1;
		white-space: nowrap;
	}

	/* Desktop: buttons zijn 52x52px iconen zonder tekst */
	@media (min-width: 651px) {
		/* Desktop must not show the mobile hand-scroll arrows. */
		.hand-scroll-btn,
		#card-controls.hand-scroll-enabled .hand-scroll-btn {
			display: none !important;
		}

		.card-action-btn {
			justify-content: center;
			padding: 12px;
			min-width: 52px;
			width: 52px;
			max-width: 52px;
			min-height: 52px;
			height: 52px;
		}

		.card-action-btn::after {
			display: none;
		}

		/* Ensure the â€œnext turnâ€ button matches the deck button and sits next to it. */
		#card-action-buttons .card-action-btn {
			width: 52px;
			max-width: 52px;
			min-width: 52px;
			justify-content: center;
		}
		#card-action-buttons .card-action-btn::after {
			display: none;
		}
		#card-action-buttons #new-cards-btn { order: 0; }
		#card-action-buttons #deck-preview { order: 1; }
		
		/* Deck preview: vierkant en zelfde kleur als andere buttons */
		.deck-preview {
			min-width: 52px;
			width: 52px;
			max-width: 52px;
			min-height: 52px;
			height: 52px;
			padding: 0;
			background: linear-gradient(155deg, #eff3ff 0%, #dbe2f6 100%);
			border: 1px solid rgba(26,32,48,0.16);
			border-radius: 14px;
			display: flex;
			flex-direction: column;
			align-items: center;
			justify-content: center;
			gap: 2px;
			box-shadow: 0 12px 20px rgba(10,12,20,0.2);
		}
		
		.deck-preview::before {
			content: 'ðŸ“š';
			font-size: 1.2rem;
			display: block;
			line-height: 1;
		}

		.deck-preview::after {
			display: none;
		}
		
		/* Deck preview: zorg dat icoon ook in portrait mode zichtbaar is */
		body.desktop-portrait .deck-preview::before {
			content: 'ðŸ“š';
			display: block;
		}

		.deck-count {
			position: static;
			min-width: auto;
			padding: 0;
			background: none;
			border: none;
			box-shadow: none;
			font-size: 0.75rem;
			font-weight: 700;
			color: #2b3148;
			line-height: 1;
		}

		.deck-count::before {
			display: none;
		}

		body.dark-mode .deck-preview {
			background: linear-gradient(160deg, #2c3144 0%, #222635 100%);
			border-color: rgba(140,150,200,0.3);
		}

		body.dark-mode .deck-count {
			color: rgba(235,238,255,0.88);
		}
	}

	.card-action-btn:hover:not(:disabled),
	.card-action-btn:focus-visible {
		transform: translateY(-2px);
		box-shadow: 0 18px 28px rgba(10,12,20,0.28);
	}

	.card-action-btn:focus-visible {
		outline: 3px solid rgba(86,122,255,0.55);
		outline-offset: 3px;
	}

	.card-action-btn:disabled {
		opacity: 0.55;
		cursor: not-allowed;
		transform: none;
		box-shadow: none;
	}

	body.dark-mode .card-action-btn {
		background: linear-gradient(160deg, #2c3144 0%, #222635 100%);
		border-color: rgba(140,150,200,0.3);
		color: rgba(235,238,255,0.88);
		box-shadow: 0 16px 30px rgba(0,0,0,0.42);
	}

	body.dark-mode .card-action-btn:hover:not(:disabled),
	body.dark-mode .card-action-btn:focus-visible {
		box-shadow: 0 20px 34px rgba(0,0,0,0.5);
	}

	/* Dark mode deck preview matching card buttons */
	body.dark-mode #card-action-buttons .deck-preview {
		background: linear-gradient(160deg, #2c3144 0%, #222635 100%);
		border-color: rgba(140,150,200,0.3);
	}

	body.dark-mode #card-action-buttons .deck-count {
		color: rgba(235,238,255,0.88);
	}

	.deck-preview {
		position: relative;
		display: inline-flex;
		align-items: center;
		justify-content: space-between;
		gap: 10px;
		padding: 12px 16px;
		border-radius: 14px;
		border: 1px solid rgba(26,32,48,0.16);
		background: linear-gradient(160deg, #ffffff 0%, #edf1ff 100%);
		box-shadow: 0 12px 20px rgba(10,12,20,0.2);
		color: #2b3148;
		cursor: pointer;
		transition: transform 0.18s ease, box-shadow 0.18s ease, border-color 0.25s ease, background 0.25s ease;
		min-height: 52px;
		flex: 0 0 auto;
	}

	.deck-preview::after {
		display: none;
	}

	.deck-preview:hover,
	.deck-preview:focus-visible {
		transform: translateY(-2px);
		box-shadow: 0 18px 28px rgba(10,12,20,0.28);
	}

	.deck-preview:focus-visible {
		outline: 3px solid rgba(86,122,255,0.55);
		outline-offset: 3px;
	}
	
	/* Verwijder outline in desktop modes */
	@media (min-width: 651px) {
		.deck-preview:focus-visible {
			outline: none;
		}
	}

	.deck-count {
		display: inline-flex;
		align-items: center;
		justify-content: center;
		gap: 4px;
		min-width: 54px;
		padding: 6px 10px;
		border-radius: 10px;
		background: rgba(255,255,255,0.9);
		border: 1px solid rgba(26,32,48,0.16);
		box-shadow: inset 0 -1px 0 rgba(255,255,255,0.75), 0 6px 12px rgba(10,12,20,0.18);
		font-size: 1.05rem;
		font-weight: 700;
		color: #2b3148;
		font-variant-numeric: tabular-nums;
	}

	/* Desktop: deck count centered zonder icon */
	@media (min-width: 651px) {
		.deck-count {
			position: absolute;
			top: 50%;
			left: 50%;
			transform: translate(-50%, -50%);
			min-width: auto;
			padding: 0;
			background: none;
			border: none;
			box-shadow: none;
		}

		.deck-count::before {
			display: none;
		}
	}

	.deck-count::before {
		content: '\1F4DA';
		font-size: 1.1rem;
	}

	body.dark-mode .deck-preview {
		background: linear-gradient(160deg, #2c3144 0%, #1f2333 100%);
		border-color: rgba(140,150,200,0.28);
		color: rgba(235,238,255,0.9);
		box-shadow: 0 18px 30px rgba(0,0,0,0.4);
	}

	body.dark-mode .deck-preview::after {
		color: rgba(235,238,255,0.75);
	}

	body.dark-mode .deck-preview:focus-visible {
		outline-color: rgba(120,160,255,0.7);
	}

	body.dark-mode .deck-count {
		background: rgba(18,22,36,0.92);
		border-color: rgba(120,140,220,0.38);
		color: rgba(235,238,255,0.88);
		box-shadow: inset 0 -1px 0 rgba(255,255,255,0.08), 0 6px 12px rgba(0,0,0,0.42);
	}

	#turn-counter-inline {
		display: none;
	}

	body.dark-mode #turn-counter-inline {
		background: linear-gradient(145deg, #22252b, #1a1c21);
		border: 1px solid #2d2f36;
		box-shadow: 0 6px 14px rgba(0,0,0,0.45);
		color: #e5e5e5;
	}

	.card-option {
		flex: 0 0 auto;
		width: 138px;
		min-height: 180px;
		padding: 0;
		display: flex;
		flex-direction: column;
		--preview-cell: 20px;
		align-items: center;
		justify-content: center;
		gap: 12px;
		border-radius: 16px;
		background: linear-gradient(165deg, #ffffff 0%, #eef2ff 45%, #dfe4ff 100%);
		border: 1px solid rgba(40,55,120,0.18);
		box-shadow: 0 18px 26px rgba(10,12,20,0.2);
		position: relative;
		overflow: visible;
		transition: transform 0.2s ease, box-shadow 0.2s ease, border-color 0.2s ease;
	}

	/* Desktop landscape request: cards a bit shorter (â‰ˆ10px). */
	body.desktop-landscape #card-choice-zone .card-option {
		min-height: 170px;
	}

	/* Desktop request: make cards ~20px smaller overall. */
	body.desktop-landscape .card-option {
		width: 118px;
	}

	.card-option::after {
		content: "";
		position: absolute;
		inset: 0;
		border-radius: inherit;
		background: linear-gradient(120deg, rgba(255,255,255,0.65), rgba(255,255,255,0) 58%);
		opacity: 0.45;
		pointer-events: none;
	}

	.card-option > * {
		position: relative;
		z-index: 1;
	}

	.card-option:hover {
		transform: translateY(-6px);
		box-shadow: 0 30px 48px rgba(20,30,60,0.32);
	}

	.card-option.selected {
		border-color: rgba(82,118,255,0.6);
		box-shadow: 0 32px 52px rgba(70,90,180,0.45);
	}

	/* Card control buttons voor mobiel en touch devices - fixed positie onderaan */
	.card-control-btn {
		position: fixed;
		/* Position bottom center for touch devices */
		bottom: calc(var(--bottom-bar-height) + 10px);
		width: 44px;
		height: 44px;
		border: 2px solid white;
		border-radius: 50%;
		display: none;
		align-items: center;
		justify-content: center;
		font-size: 20px;
		color: white;
		cursor: pointer;
		box-shadow: 0 4px 12px rgba(0,0,0,0.3);
		z-index: calc(var(--z-controls) + 10);
		user-select: none;
		transition: transform 0.15s ease, opacity 0.15s ease;
		pointer-events: auto;
		touch-action: manipulation;
	}

	.card-control-btn:hover {
		transform: scale(1.1);
	}

	.card-control-btn:active {
		transform: scale(0.95);
	}

	/* Toon buttons wanneer er een selectie is */
	.card-control-btn.visible {
		display: flex;
	}

	.card-control-rotate {
		left: 50%;
		margin-left: 75px;
		background: #4a90e2;
	}

	.card-control-mirror {
		left: 50%;
		margin-left: 25px;
		background: #9b59b6;
	}

	.card-control-cancel {
		left: 50%;
		margin-left: -25px;
		background: #e74c3c;
	}

	/* Touch portrait mode: buttons blijven onderaan gecentreerd */
	body.touch-portrait .card-control-btn {
		bottom: calc(var(--bottom-bar-height) + 10px);
		top: auto;
		right: auto;
	}
	
	/* Mobile sidebar landscape: buttons aan de rechterkant */
	body.mobile-sidebar-layout .card-control-btn {
		bottom: auto;
		top: 50%;
		left: auto;
		right: 15px;
		margin-left: 0;
	}
	body.mobile-sidebar-layout .card-control-rotate {
		transform: translateY(-85px);
	}
	body.mobile-sidebar-layout .card-control-mirror {
		transform: translateY(-30px);
	}
	body.mobile-sidebar-layout .card-control-cancel {
		transform: translateY(25px);
	}

	.card-control-btn:hover {
		transform: scale(1.1);
	}
	
	.card-control-btn:active {
		transform: scale(0.95);
	}

	body.dark-mode .card-control-rotate {
		background: #5a9fd4;
		border-color: #1e2128;
	}

	body.dark-mode .card-control-mirror {
		background: #8e44ad;
		border-color: #1e2128;
	}

	body.dark-mode .card-control-cancel {
		background: #c0392b;
		border-color: #1e2128;
	}

	.card-pattern {
		display: inline-grid;
		gap: var(--preview-gap, 2px);
		align-items: center;
		justify-items: center;
		justify-content: center;
		align-content: center;
	}

	.card-option .card-cell {
		width: var(--card-cell-size, 22px);
		height: var(--card-cell-size, 22px);
		/* Border-radius: max 5px, minder rond voor kleine cells */
		border-radius: min(5px, calc(var(--card-cell-size, 22px) / 5));
		border: 1px solid rgba(12,16,30,0.12);
		box-shadow: inset 0 0 4px rgba(0,0,0,0.18);
		background: rgba(255,255,255,0.95);
	}

	.card-label {
		display: inline-flex;
		align-items: center;
		gap: 6px;
		padding: 5px 10px;
		border-radius: 999px;
		background: rgba(20,24,36,0.06);
		font-size: 0.72rem;
		font-weight: 600;
		letter-spacing: 0.065em;
		text-transform: uppercase;
		color: rgba(20,24,36,0.62);
	}

	.card-label-dot {
		width: 9px;
		height: 9px;
		border-radius: 50%;
		box-shadow: 0 0 5px rgba(0,0,0,0.26);
	}

	.card-meta {
		font-size: 0.72rem;
		letter-spacing: 0.05em;
		color: rgba(20,24,36,0.55);
	}

	body.dark-mode .card-option {
		background: linear-gradient(160deg, #2d3142 0%, #232635 45%, #1b1e2c 100%);
		border-color: rgba(120,140,220,0.2);
		box-shadow: 0 26px 44px rgba(0,0,0,0.5);
	}

	body.dark-mode .card-option::after {
		opacity: 0.25;
	}

	body.dark-mode .card-option .card-cell {
		border-color: rgba(255,255,255,0.08);
		box-shadow: inset 0 0 6px rgba(0,0,0,0.35);
		background: rgba(18,22,32,0.6);
	}

	body.dark-mode .card-label {
		background: rgba(255,255,255,0.08);
		color: rgba(255,255,255,0.82);
	}

	body.dark-mode .card-label-dot {
		box-shadow: 0 0 6px rgba(0,0,0,0.45);
	}

	body.dark-mode .card-meta {
		color: rgba(255,255,255,0.65);
	}

	#card-options {
	  display: flex;
	  flex-wrap: wrap;
	  gap: 12px;
	  justify-content: center;
	  margin-top: 12px;
	}

	@keyframes coinPop {
	  0% { transform: translate(-50%, -50%) scale(0); opacity: 0.2; }
	  70% { transform: translate(-50%, -50%) scale(1.3); opacity: 1; }
	  100% { transform: translate(-50%, -50%) scale(1); }
	}


	@keyframes growRoot {
	  from { opacity: 0; transform: scale(0.5); }
	  to { opacity: 1; transform: scale(1); }
	}

	.modal-overlay {
		position: fixed;
		inset: 0;
		padding: 18px;
		display: none;
		align-items: flex-start;
		justify-content: center;
		background: rgba(10, 12, 20, 0.6);
		backdrop-filter: blur(6px);
		-webkit-backdrop-filter: blur(6px);
		z-index: 1200;
		overflow-y: auto;
	}

	.modal-overlay.show {
		display: flex;
	}

	.game-modal {
		background: #fffbea;
		border-radius: 16px;
		padding: 24px;
		width: min(420px, 100%);
		box-shadow: 0 26px 48px rgba(10, 12, 20, 0.34);
		border: 1px solid rgba(20, 24, 36, 0.18);
		color: #191d2a;
		position: relative;
	}

	body.dark-mode .game-modal {
		background: rgba(12, 14, 20, 0.95);
		border-color: rgba(255, 255, 255, 0.14);
		color: #f5f6ff;
		box-shadow: 0 30px 52px rgba(0, 0, 0, 0.55);
	}

	.game-modal h2 {
		margin-top: 0;
		margin-bottom: 8px;
		font-size: 1.35rem;
	}

	.game-modal p {
		margin: 8px 0;
		line-height: 1.5;
	}

	.modal-subtext {
		margin: 4px 0 0;
		font-size: 0.85rem;
		color: rgba(27, 33, 48, 0.7);
	}

	body.dark-mode .modal-subtext {
		color: rgba(245, 246, 255, 0.7);
	}

	.modal-actions {
		display: flex;
		flex-wrap: wrap;
		gap: 12px;
		justify-content: flex-end;
		margin-top: 20px;
	}

	.modal-actions button {
		background: linear-gradient(145deg, #ffd560, #ffb23c);
		border: 1px solid rgba(20, 24, 36, 0.14);
		border-radius: 10px;
		padding: 10px 18px;
		font-weight: 600;
		cursor: pointer;
		transition: transform 0.2s ease, box-shadow 0.2s ease;
		color: #1f2433;
	}

	.modal-actions button:hover:not(:disabled) {
		transform: translateY(-2px);
		box-shadow: 0 14px 28px rgba(10, 12, 20, 0.28);
	}

	.modal-actions button:disabled {
		opacity: 0.6;
		cursor: not-allowed;
		box-shadow: none;
	}

	body.dark-mode .modal-actions button {
		background: linear-gradient(145deg, #2f3546, #1c2233);
		border-color: rgba(255, 255, 255, 0.12);
		color: #f5f6ff;
	}

	.modal-score-summary {
		margin-top: 14px;
		display: flex;
		flex-direction: column;
		gap: 16px;
	}

	.round-summary-cards {
		display: flex;
		flex-wrap: wrap;
		gap: 12px;
		justify-content: center;
	}

	.round-summary-card {
		flex: 1 1 160px;
		min-width: 150px;
		padding: 14px 16px;
		border-radius: 16px;
		text-align: center;
		background: linear-gradient(145deg, rgba(255, 242, 196, 0.85), rgba(255, 214, 125, 0.9));
		border: 1px solid rgba(20, 24, 36, 0.08);
		box-shadow: 0 16px 24px rgba(31, 36, 51, 0.12);
	}

	.round-summary-card--coins {
		background: linear-gradient(145deg, rgba(255, 240, 200, 0.9), rgba(255, 199, 142, 0.95));
	}

	/* Unlock Modal Styles */
	.unlock-modal {
		max-width: 500px;
		text-align: center;
	}

	/* Modal button (Doorgaan knop) */
	.modal-button {
		background: linear-gradient(145deg, #667eea, #764ba2);
		border: 1px solid rgba(102, 126, 234, 0.3);
		border-radius: 10px;
		padding: 12px 28px;
		font-weight: 600;
		font-size: 1rem;
		cursor: pointer;
		transition: transform 0.2s ease, box-shadow 0.2s ease, background 0.2s ease;
		color: #fff;
		box-shadow: 0 8px 20px rgba(102, 126, 234, 0.3);
		margin-top: 10px;
	}

	.modal-button:hover {
		transform: translateY(-2px);
		box-shadow: 0 12px 28px rgba(102, 126, 234, 0.45);
		background: linear-gradient(145deg, #7a8ff0, #8a5cb8);
	}

	body.dark-mode .modal-button {
		background: linear-gradient(145deg, #4a5fb8, #5a3d8a);
		border-color: rgba(139, 159, 245, 0.4);
		box-shadow: 0 8px 20px rgba(74, 95, 184, 0.4);
	}

	body.dark-mode .modal-button:hover {
		background: linear-gradient(145deg, #5a6fc8, #6a4d9a);
		box-shadow: 0 12px 28px rgba(74, 95, 184, 0.55);
	}

	.unlock-modal-content {
		display: flex;
		flex-direction: column;
		align-items: center;
		gap: 20px;
	}

	.unlock-icon {
		font-size: 64px;
		animation: unlock-bounce 0.6s ease-out;
	}

	@keyframes unlock-bounce {
		0% { transform: scale(0) rotate(-180deg); opacity: 0; }
		50% { transform: scale(1.2) rotate(10deg); }
		100% { transform: scale(1) rotate(0deg); opacity: 1; }
	}

	.unlock-title {
		font-size: 1.8rem;
		margin: 0;
		background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
		-webkit-background-clip: text;
		-webkit-text-fill-color: transparent;
		background-clip: text;
	}

	body.dark-mode .unlock-title {
		background: linear-gradient(135deg, #8b9ff5 0%, #a77bc9 100%);
		-webkit-background-clip: text;
		-webkit-text-fill-color: transparent;
		background-clip: text;
	}

	.unlock-items-container {
		width: 100%;
		display: flex;
		flex-direction: column;
		gap: 16px;
	}

	.unlock-item {
		background: linear-gradient(145deg, rgba(102, 126, 234, 0.1), rgba(118, 75, 162, 0.1));
		border: 2px solid rgba(102, 126, 234, 0.3);
		border-radius: 12px;
		padding: 16px;
		display: flex;
		align-items: center;
		gap: 16px;
		animation: unlock-slide-in 0.4s ease-out backwards;
	}

	body.dark-mode .unlock-item {
		background: linear-gradient(145deg, rgba(102, 126, 234, 0.15), rgba(118, 75, 162, 0.15));
		border-color: rgba(139, 159, 245, 0.4);
	}

	.unlock-item:nth-child(2) { animation-delay: 0.1s; }
	.unlock-item:nth-child(3) { animation-delay: 0.2s; }
	.unlock-item:nth-child(4) { animation-delay: 0.3s; }

	@keyframes unlock-slide-in {
		from { 
			opacity: 0; 
			transform: translateX(-30px);
		}
		to {
			opacity: 1;
			transform: translateX(0);
		}
	}

	.unlock-item-icon {
		font-size: 32px;
		flex-shrink: 0;
	}

	.unlock-item-content {
		flex: 1;
		text-align: left;
	}

	.unlock-item-name {
		font-weight: bold;
		font-size: 1.1rem;
		margin-bottom: 4px;
		color: #667eea;
	}

	body.dark-mode .unlock-item-name {
		color: #8b9ff5;
	}

	.unlock-item-description {
		font-size: 0.9rem;
		opacity: 0.8;
		margin: 0;
	}

	.unlock-item--feature {
		border-color: rgba(102, 126, 234, 0.5);
		background: linear-gradient(145deg, rgba(102, 126, 234, 0.2), rgba(118, 75, 162, 0.2));
	}

	body.dark-mode .unlock-item--feature {
		border-color: rgba(139, 159, 245, 0.6);
		background: linear-gradient(145deg, rgba(102, 126, 234, 0.25), rgba(118, 75, 162, 0.25));
	}

	.unlock-item--feature .unlock-item-name {
		color: #8b6dff;
	}

	body.dark-mode .unlock-item--feature .unlock-item-name {
		color: #a899ff;
	}

	.unlock-item--challenge {
		border-color: rgba(255, 99, 71, 0.4);
		background: linear-gradient(145deg, rgba(255, 99, 71, 0.1), rgba(255, 140, 0, 0.1));
	}

	body.dark-mode .unlock-item--challenge {
		border-color: rgba(255, 140, 0, 0.5);
		background: linear-gradient(145deg, rgba(255, 99, 71, 0.15), rgba(255, 140, 0, 0.15));
	}

	.unlock-item--challenge .unlock-item-name {
		color: #ff6347;
	}

	body.dark-mode .unlock-item--challenge .unlock-item-name {
		color: #ff8c69;
	}

	body.dark-mode .round-summary-card {
		background: linear-gradient(145deg, rgba(46, 54, 78, 0.9), rgba(32, 39, 58, 0.95));
		border-color: rgba(255, 255, 255, 0.08);
		box-shadow: 0 18px 28px rgba(5, 8, 16, 0.6);
	}

	body.dark-mode .round-summary-card--coins {
		background: linear-gradient(145deg, rgba(66, 52, 22, 0.82), rgba(97, 76, 36, 0.92));
	}

	.round-summary-icon {
		display: block;
		font-size: 1.35rem;
		margin-bottom: 6px;
	}

	.round-summary-label {
		display: block;
		font-size: 0.75rem;
		letter-spacing: 0.18em;
		text-transform: uppercase;
		color: rgba(31, 36, 51, 0.7);
		margin-bottom: 4px;
	}

	body.dark-mode .round-summary-label {
		color: rgba(245, 246, 255, 0.6);
	}

	.round-summary-value {
		display: block;
		font-size: 2.1rem;
		font-weight: 700;
		color: #1f2433;
	}

	body.dark-mode .round-summary-value {
		color: #f5f6ff;
	}

	.round-summary-bonus {
		display: inline-flex;
		align-items: center;
		justify-content: center;
		margin-top: 8px;
		padding: 4px 10px;
		border-radius: 999px;
		font-size: 0.78rem;
		font-weight: 600;
		background: rgba(31, 36, 51, 0.08);
		color: #1f2433;
	}

	body.dark-mode .round-summary-bonus {
		background: rgba(245, 246, 255, 0.15);
		color: #f5f6ff;
	}

	.round-summary-bonus--muted {
		opacity: 0.6;
	}

	.modal-summary-line {
		display: flex;
		justify-content: space-between;
		align-items: center;
		gap: 12px;
		padding: 6px 0;
		font-size: 0.95rem;
		line-height: 1.5;
		border-bottom: 1px solid rgba(20, 24, 36, 0.1);
	}

	.modal-summary-line:last-child {
		border-bottom: none;
	}

	body.dark-mode .modal-summary-line {
		border-color: rgba(255, 255, 255, 0.12);
	}

	#deck-modal {
		width: min(90vw, 780px);
		max-height: 80vh;
	}

	.deck-modal-grid {
		display: grid;
		grid-template-columns: repeat(auto-fit, minmax(110px, 1fr));
		gap: 12px;
		margin-top: 14px;
		max-height: 56vh;
		overflow-y: auto;
		padding: 0 6px;
	}

	.deck-modal-grid::-webkit-scrollbar {
		width: 6px;
	}

	.deck-modal-grid::-webkit-scrollbar-thumb {
		background: rgba(80, 90, 110, 0.35);
		border-radius: 6px;
	}

	.deck-modal-grid .card-option {
		transform: none !important;
		width: 100%;
		max-width: 120px;
		min-height: 132px;
		margin: 0 auto;
		padding: 8px;
		gap: 8px;
		justify-content: flex-start;
	}

	/* The deck overview modal is a read-only preview: clicking should NOT select cards there. */
	#deck-modal-content.deck-modal-grid .card-option {
		pointer-events: none;
		cursor: default;
	}

	/* The golden unlock modal MUST be clickable (pick 1 of 3). */
	#golden-unlock-content.deck-modal-grid .card-option {
		pointer-events: auto;
		cursor: pointer;
	}

	.deck-modal-grid .card-pattern {
		gap: 3px;
	}

	/* Deck overview: smaller preview cells than the selectable hand cards. */
	.deck-modal-grid .card-option {
		--preview-cell: 14px;
	}

	.deck-modal-grid .deck-modal-card.deck-modal-card--depleted {
		opacity: 0.35;
		filter: saturate(35%);
	}

	/* Inactive blueprint badge: small exclamation in the corner. Exclude
	   multikleur cards (they are special and should not show this). */
	.deck-modal-grid .deck-modal-card.deck-modal-card--inactive {
		position: relative;
		opacity: 0.5;
		filter: grayscale(40%);
	}
	.deck-modal-grid .deck-modal-card.deck-modal-card--inactive::after {
		content: '!';
		position: absolute;
		top: 6px;
		right: 6px;
		background: #ffcc00;
		color: #3b2b00;
		font-weight: 700;
		font-size: 11px;
		line-height: 14px;
		width: 18px;
		height: 18px;
		border-radius: 10px;
		display: inline-flex;
		align-items: center;
		justify-content: center;
		box-shadow: 0 2px 4px rgba(0,0,0,0.25);
	}

	/* Explicit badge element styling (fallback for older browsers / layout) */
	.deck-modal-inactive-badge {
		position: absolute;
		top: 6px;
		right: 6px;
		width: 20px;
		height: 20px;
		border-radius: 10px;
		background: #ffcc00;
		color: #3b2b00;
		display: inline-flex;
		align-items: center;
		justify-content: center;
		font-weight: 700;
		font-size: 12px;
		box-shadow: 0 2px 4px rgba(0,0,0,0.25);
		pointer-events: none;
	}
	/* Hide badge for multikleur (rainbow) cards which already have their own corner mark */
	.deck-modal-grid .deck-modal-card[data-card-label*="MULTIKLEUR"].deck-modal-card--inactive::after,
	.deck-modal-grid .deck-modal-card[data-card-label*="RAINBOW"].deck-modal-card--inactive::after {
		display: none;
	}

	.deck-modal-grid .deck-modal-card.deck-modal-card--in-hand {
		opacity: 0.55;
	}

	.deck-modal-grid .card-option:hover,
	.deck-modal-grid .card-option:focus {
		transform: none;
		box-shadow: 0 18px 26px rgba(10,12,20,0.2);
	}

	body.dark-mode .deck-modal-grid .card-option:hover,
	body.dark-mode .deck-modal-grid .card-option:focus {
		box-shadow: 0 26px 44px rgba(0,0,0,0.5);
	}

	.deck-modal-grid .card-option .card-label,
	.deck-modal-grid .card-option .card-meta {
		justify-content: center;
	}

	.deck-modal-empty {
		margin: 18px 0 6px;
		text-align: center;
		color: rgba(0, 0, 0, 0.6);
	}

	.blackhole-modal {
	  width: min(92vw, 760px);
	  max-height: 82vh;
	}

	.blackhole-card-grid {
	  margin-top: 16px;
	}

	.blackhole-card-grid .blackhole-card {
	  pointer-events: auto;
	  cursor: pointer;
	  transition: transform 0.18s ease, box-shadow 0.18s ease, border-color 0.18s ease;
	}

	.blackhole-card-grid .blackhole-card:hover {
	  transform: translateY(-4px);
	  box-shadow: 0 22px 36px rgba(40, 32, 88, 0.25);
	}

	.blackhole-card-grid .blackhole-card.selected {
	  border-color: rgba(120, 100, 220, 0.58);
	  box-shadow: 0 26px 44px rgba(70, 60, 160, 0.35);
	}

	.blackhole-stats {
	  display: flex;
	  flex-wrap: wrap;
	  justify-content: space-between;
	  gap: 12px;
	  font-size: 0.95rem;
	  color: rgba(20,24,36,0.82);
	}

	.blackhole-stats strong {
	  font-weight: 700;
	  color: #3a3570;
	}

	.blackhole-feedback {
	  min-height: 18px;
	  font-size: 0.9rem;
	  color: rgba(40,40,60,0.8);
	  margin-top: 6px;
	  transition: opacity 0.2s ease;
	  opacity: 0;
	}

	.blackhole-feedback.show {
	  opacity: 1;
	}

	.blackhole-feedback[data-tone="warn"] {
	  color: #c43838;
	}

	.blackhole-actions {
	  display: flex;
	  justify-content: flex-end;
	  gap: 10px;
	}

	.blackhole-actions button {
	  min-width: 140px;
	}

	body.dark-mode .deck-modal-grid::-webkit-scrollbar-thumb {
		background: rgba(160, 170, 210, 0.25);
	}

	body.dark-mode .deck-modal-empty {
		color: rgba(255, 255, 255, 0.65);
	}
	body.dark-mode .deck-modal-grid .card-option {
	  background: linear-gradient(160deg, #2d3142 0%, #232635 45%, #1b1e2c 100%);
	  border: 1px solid rgba(120,140,220,0.2);
	  box-shadow: 0 18px 32px rgba(0,0,0,0.45);
	}

	body.dark-mode .deck-modal-grid .card-option.card-golden {
	  background: linear-gradient(135deg, #5b4a14 0%, #8a6a1c 35%, #bf952a 70%, #e3c45e 100%);
	  border: 1px solid rgba(200,160,30,0.8);
	  box-shadow: 0 22px 40px rgba(0,0,0,0.58), inset 0 1px 0 rgba(255,255,255,0.08);
	}

	body.dark-mode .deck-modal-grid .card-option::after {
	  background: linear-gradient(120deg, rgba(255,255,255,0.18), rgba(255,255,255,0));
	  opacity: 0.35;
	}

	body.dark-mode .deck-modal-grid .card-option.card-golden::after {
	  opacity: 0.28;
	}
	body.dark-mode .blackhole-stats {
	  color: rgba(220, 224, 248, 0.82);
	}

	body.dark-mode .blackhole-stats strong {
	  color: #d4cffd;
	}

	body.dark-mode .blackhole-feedback {
	  color: rgba(210, 210, 248, 0.75);
	}

	body.dark-mode .blackhole-feedback[data-tone="warn"] {
	  color: #ff9a9a;
	}

	/* Rules Modal Styling */
	#rules-modal {
		max-height: 80vh;
		overflow-y: auto;
	}

	.rules-section {
		margin-bottom: 20px;
	}

	.rules-section:last-child {
		margin-bottom: 0;
	}

	.rules-section h3 {
		margin: 0 0 10px 0;
		font-size: 1.1rem;
		font-weight: 700;
		color: rgba(20,24,36,0.9);
	}

	.rules-section ul {
		margin: 8px 0;
		padding-left: 24px;
	}

	.rules-section li {
		margin-bottom: 6px;
		line-height: 1.5;
	}

	.rules-section p {
		margin: 8px 0;
		line-height: 1.6;
	}

	.rules-section strong {
		color: rgba(20,24,36,0.95);
		font-weight: 600;
	}

	body.dark-mode .rules-section h3 {
		color: rgba(255, 255, 255, 0.95);
	}

	body.dark-mode .rules-section strong {
		color: rgba(255, 255, 255, 0.9);
	}

	/* ============================================
	   DECK MODAL & SHOP - MOBILE
	   ============================================ */
	@media (max-width: 650px) {
		#deck-modal {
			width: min(96vw, 560px);
			max-height: 74vh;
			padding: 12px;
		}

		#deck-modal h2 {
			font-size: 0.98rem;
			margin-bottom: 4px;
		}

		#deck-modal .modal-subtext {
			font-size: 0.78rem;
		}

		.deck-modal-grid {
			grid-template-columns: repeat(auto-fit, minmax(64px, 1fr));
			gap: 12px;
			padding: 0 2px;
			max-height: 54vh;
		}

		.deck-modal-grid .card-option {
			max-width: 82px;
			min-height: 112px;
			padding: 4px !important;
			overflow: hidden;
		}

		.deck-modal-grid .card-pattern {
			gap: 2px;
		}

		.deck-modal-grid .card-option {
			--preview-cell: 9px;
		}

		.deck-modal-grid .card-option .card-label {
			font-size: 0.52rem;
			padding: 2px 6px;
			gap: 4px;
			letter-spacing: 0.05em;
			text-transform: none;
			white-space: nowrap;
			max-width: 100%;
			overflow: hidden;
			text-overflow: ellipsis;
		}

		.deck-modal-grid .card-option .card-label-dot {
			width: 6px;
			height: 6px;
		}

		.deck-modal-grid .card-option .card-meta {
			font-size: 0.52rem;
			letter-spacing: 0.03em;
			white-space: nowrap;
			max-width: 100%;
			overflow: hidden;
			text-overflow: ellipsis;
		}
	}

	@media (max-width: 450px) {
		/* Deck Modal - kleinere kaarten met betere spacing */
		#deck-modal {
			width: min(94vw, 420px);
			max-height: 75vh;
			padding: 10px;
		}

		.deck-modal-grid {
			grid-template-columns: repeat(auto-fit, minmax(58px, 1fr));
			gap: 10px;
			max-height: 54vh;
		}

		.deck-modal-grid .card-option {
			min-height: 72px;
			max-width: 72px;
			padding: 4px !important;
			transform: none !important;
			overflow: hidden;
		}

		.deck-modal-grid .card-pattern {
			gap: var(--preview-gap);
		}

		.deck-modal-grid .card-option {
			--preview-cell: 8px;
		}

		.deck-modal-grid .card-option .card-label {
			font-size: 0.5rem;
			padding: 2px 6px;
			gap: 4px;
			letter-spacing: 0.03em;
			text-transform: none;
			white-space: nowrap;
			max-width: 100%;
			overflow: hidden;
			text-overflow: ellipsis;
		}

		.deck-modal-grid .card-option .card-meta {
			font-size: 0.5rem;
			letter-spacing: 0.02em;
			white-space: nowrap;
			max-width: 100%;
			overflow: hidden;
			text-overflow: ellipsis;
		}

		/* Shop Modal - compactere layout */
		#shop-modal {
			width: min(96vw, 420px) !important;
			max-height: 72vh;
			padding: 12px 14px;
			gap: 8px;
		}

		#shop-modal h2 {
			font-size: 0.88rem;
		}

		/* Verberg uitleg tekst */
		#shop-modal-message {
			display: none !important;
		}

		/* Verberg shop-card-header */
		.shop-card-header {
			display: none !important;
		}

		/* Shop cards - kleiner schalen */
		.shop-card {
			transform: scale(0.85);
			transform-origin: center;
			padding: 8px !important;
			gap: 6px !important;
		}

		.shop-card-list {
			grid-template-columns: repeat(2, 1fr) !important;
			gap: 16px;
		}

		.shop-card-preview {
			max-width: 100%;
		}

		.shop-card-preview .card-option {
			width: 100%;
			min-height: 120px;
		}

		/* Shop lower grid - force side by side with flexbox */
		.shop-lower-grid {
			display: flex !important;
			flex-direction: row !important;
			gap: 10px !important;
			width: 100% !important;
		}

		.shop-upgrades-section,
		.shop-bonus-section {
			flex: 1 1 0 !important;
			min-width: 0 !important;
			width: auto !important;
			max-width: none !important;
			padding: 12px !important;
			flex-direction: column !important;
			align-items: stretch !important;
			justify-content: flex-start !important;
			border-radius: 12px !important;
		}

		.shop-section-title {
			font-size: 0.72rem !important;
			margin-bottom: 10px !important;
		}

		.shop-section-title::before {
			font-size: 0.85rem !important;
		}

		.shop-upgrade-container {
			display: grid !important;
			grid-template-columns: repeat(2, minmax(0, 1fr)) !important;
			gap: 10px !important;
			width: 100% !important;
		}

		/* Bonus container ook single column */
		.shop-bonus-container {
			display: flex !important;
			flex-direction: column !important;
			gap: 10px !important;
			width: 100% !important;
		}

		/* Bonus cards compacter - verticale layout */
		.shop-bonus-card {
			flex-direction: column !important;
			align-items: flex-start !important;
			gap: 8px !important;
			padding: 10px 12px !important;
		}

		.shop-bonus-info {
			width: 100%;
			gap: 8px !important;
			font-size: 0.75rem !important;
		}

		.shop-bonus-swatch {
			width: 16px !important;
			height: 16px !important;
		}

		.shop-bonus-actions {
			width: 100%;
		}

		.shop-bonus-actions button {
			width: 100%;
			padding: 8px 12px !important;
			font-size: 0.75rem !important;
		}

		.shop-upgrade-card {
			padding: 12px !important;
			gap: 8px !important;
		}

		.shop-upgrade-card::before {
			height: 2px !important;
		}

		.shop-upgrade-header {
			font-size: 0.8rem !important;
		}

		.upgrade-icon {
			width: 28px !important;
			height: 28px !important;
			font-size: 1rem !important;
			border-radius: 8px !important;
		}

		.shop-upgrade-desc {
			font-size: 0.7rem !important;
			line-height: 1.35 !important;
		}

		.shop-upgrade-actions button {
			padding: 8px 14px !important;
			font-size: 0.75rem !important;
			border-radius: 8px !important;
		}

		.shop-empty-state {
			padding: 14px !important;
			font-size: 0.72rem !important;
		}
	}

	/* ============================================
	   SHOP MODAL - BASIS (DESKTOP)
	   ============================================
	   Pop-up winkel waar je met munten extra kaarten en upgrades kunt kopen
	   2-kolommen layout: kaarten links, upgrades rechts
	*/
	#shop-modal {
		display: flex;
		flex-direction: column;
		gap: 18px;
		padding: 24px;
		background: linear-gradient(160deg, rgba(255,255,255,0.98), rgba(232,238,252,0.92));
		border: 1px solid rgba(60,70,140,0.12);
		box-shadow: 0 32px 54px rgba(12,18,38,0.25);
		border-radius: 20px;
		max-width: 920px;
		width: min(92vw, 920px);
		margin: auto;
		max-height: calc(100vh - 36px);
		overflow-y: auto;
		overscroll-behavior: contain;
		-webkit-overflow-scrolling: touch;
		contain: layout paint;
		scrollbar-width: thin;
		scrollbar-color: rgba(100, 120, 180, 0.5) transparent;
	}

	/* Shop overlay: avoid nested scrolling (keeps scrolling smooth inside the modal). */
	#shop-modal-layer {
		overflow: hidden;
		overscroll-behavior: contain;
	}
	
	#shop-modal::-webkit-scrollbar {
		width: 8px;
	}
	#shop-modal::-webkit-scrollbar-track {
		background: transparent;
		border-radius: 4px;
	}
	#shop-modal::-webkit-scrollbar-thumb {
		background: linear-gradient(180deg, rgba(100, 120, 180, 0.6), rgba(80, 100, 160, 0.4));
		border-radius: 4px;
		border: 1px solid rgba(255,255,255,0.2);
	}
	#shop-modal::-webkit-scrollbar-thumb:hover {
		background: linear-gradient(180deg, rgba(120, 140, 200, 0.8), rgba(100, 120, 180, 0.6));
	}

	body.dark-mode #shop-modal {
		background: linear-gradient(160deg, rgba(28,30,44,0.96), rgba(20,22,35,0.96));
		border-color: rgba(140,150,220,0.22);
		box-shadow: 0 34px 60px rgba(0,0,0,0.55);
		scrollbar-color: rgba(140, 160, 220, 0.4) transparent;
	}
	body.dark-mode #shop-modal::-webkit-scrollbar-thumb {
		background: linear-gradient(180deg, rgba(100, 120, 180, 0.5), rgba(80, 100, 160, 0.3));
		border-color: rgba(255,255,255,0.1);
	}
	body.dark-mode #shop-modal::-webkit-scrollbar-thumb:hover {
		background: linear-gradient(180deg, rgba(120, 140, 200, 0.6), rgba(100, 120, 180, 0.5));
	}
	body.dark-mode .shop-coin-display {
		background: linear-gradient(145deg, rgba(42,44,62,0.92), rgba(32,34,52,0.9));
		border-color: rgba(160, 178, 255, 0.24);
		box-shadow: inset 0 0 0 1px rgba(255,255,255,0.08), 0 18px 34px rgba(0,0,0,0.5);
	}
	body.dark-mode .shop-coin-label {
		color: rgba(214, 220, 255, 0.72);
	}
	body.dark-mode .shop-coin-balance {
		color: #f6f7ff;
	}
	body.dark-mode .shop-coin-display.is-empty {
		background: linear-gradient(145deg, rgba(110, 32, 32, 0.4), rgba(140, 28, 28, 0.35));
		border-color: rgba(255, 120, 120, 0.35);
	}
	body.dark-mode .shop-coin-display.is-empty .shop-coin-label {
		color: rgba(255, 196, 196, 0.78);
	}
	body.dark-mode .shop-coin-display.is-empty .shop-coin-balance {
		color: rgba(255, 220, 220, 0.9);
	}

	.shop-modal-header {
		display: flex;
		flex-wrap: wrap;
		justify-content: space-between;
		align-items: center;
		gap: 16px;
	}

	.shop-coin-display {
		display: inline-flex;
		align-items: center;
		gap: 10px;
		padding: 6px 14px;
		border-radius: 999px;
		background: linear-gradient(145deg, rgba(255,255,255,0.96), rgba(236,246,255,0.92));
		border: 1px solid rgba(120,140,200,0.25);
		box-shadow: inset 0 0 0 1px rgba(255,255,255,0.25), 0 16px 28px rgba(14,22,48,0.16);
	}

	.shop-coin-label {
		font-size: 0.78rem;
		font-weight: 600;
		letter-spacing: 0.05em;
		text-transform: uppercase;
		color: rgba(24,32,60,0.68);
	}

	.shop-coin-balance {
		position: relative;
		font-weight: 700;
		font-size: 1.05rem;
		color: #1c253c;
		padding-left: 1.4em;
		min-width: 2.4em;
		text-align: right;
	}

	.shop-coin-balance::before {
		content: "";
		position: absolute;
		left: 0;
		top: 50%;
		transform: translateY(-50%);
		width: 1em;
		height: 1em;
		border-radius: 50%;
		background: radial-gradient(circle at 30% 30%, #fff6b5, #f7bb36 60%, #d49f20);
		box-shadow: inset 0 -2px 4px rgba(0,0,0,0.2), 0 1px 2px rgba(0,0,0,0.15);
		border: 1px solid #c9960a;
	}

	.shop-coin-display.is-empty {
		background: linear-gradient(145deg, rgba(245, 80, 80, 0.1), rgba(255, 140, 140, 0.12));
		border-color: rgba(220, 90, 90, 0.24);
	}

	.shop-coin-display.is-empty .shop-coin-label {
		color: rgba(160, 48, 48, 0.8);
	}

	.shop-coin-display.is-empty .shop-coin-balance {
		color: rgba(164, 52, 52, 0.9);
	}

	/* 2-kolommen grid voor shop inhoud */
	.shop-content-grid {
		display: flex;
		flex-direction: column;
		gap: 24px;
		margin-top: 12px;
		align-items: stretch;
	}
	
	.shop-lower-grid {
		display: grid;
		grid-template-columns: minmax(0, 1fr) minmax(0, 1fr);
		gap: 24px 28px;
		align-items: start;
	}

	/* Modal close button styling */
	.modal-close-btn {
		position: absolute;
		top: 16px;
		right: 16px;
		width: 32px;
		height: 32px;
		border: none;
		background: rgba(0,0,0,0.08);
		border-radius: 50%;
		font-size: 24px;
		line-height: 1;
		color: #666;
		cursor: pointer;
		transition: all 0.2s ease;
		display: flex;
		align-items: center;
		justify-content: center;
		padding: 0;
		z-index: 10;
	}

	.modal-close-btn:hover {
		background: rgba(0,0,0,0.12);
		color: #333;
		transform: scale(1.1);
	}

	body.dark-mode .modal-close-btn {
		background: rgba(255,255,255,0.1);
		color: #ccc;
	}

	body.dark-mode .modal-close-btn:hover {
		background: rgba(255,255,255,0.15);
		color: #fff;
	}

	/* Elke sectie (kaarten of upgrades) */
	.shop-section {
		display: flex;
		flex-direction: column;
		gap: 16px;
	}

	.shop-upgrades-section,
	.shop-bonus-section,
	.shop-freeplace-section {
		display: flex;
		flex-direction: column;
		align-items: stretch;
		gap: 14px;
		padding: 20px;
		border-radius: 16px;
		background: linear-gradient(160deg, rgba(248,250,255,0.95), rgba(240,244,255,0.9));
		border: 1px solid rgba(40,55,120,0.12);
		box-shadow: 0 8px 24px rgba(12,18,38,0.08);
		position: relative;
	}

	.shop-upgrades-section::before,
	.shop-bonus-section::before,
	.shop-freeplace-section::before {
		content: '';
		position: absolute;
		top: 0;
		left: 20px;
		right: 20px;
		height: 1px;
		background: linear-gradient(90deg, transparent, rgba(40,55,120,0.15), transparent);
	}

	body.dark-mode .shop-upgrades-section,
	body.dark-mode .shop-bonus-section,
	body.dark-mode .shop-freeplace-section {
		background: linear-gradient(160deg, rgba(36,40,60,0.95), rgba(24,28,44,0.95));
		border-color: rgba(150,170,240,0.2);
		box-shadow: 0 12px 32px rgba(0,0,0,0.4);
	}

	body.dark-mode .shop-upgrades-section::before,
	body.dark-mode .shop-bonus-section::before,
	body.dark-mode .shop-freeplace-section::before {
		background: linear-gradient(90deg, transparent, rgba(150,170,240,0.2), transparent);
	}

	.shop-section-title {
		margin: 0 0 4px 0;
		font-size: 0.85rem;
		font-weight: 700;
		letter-spacing: 0.08em;
		text-transform: uppercase;
		color: rgba(20,24,46,0.6);
		display: flex;
		align-items: center;
		gap: 8px;
	}

	.shop-section-title::before {
		content: 'âš™ï¸';
		font-size: 1rem;
	}

	.shop-bonus-section .shop-section-title::before {
		content: 'ðŸŽ';
	}

	body.dark-mode .shop-section-title {
		color: rgba(240,242,255,0.6);
	}

	.shop-upgrade-container {
		margin-top: 0;
		padding: 0;
		border-radius: 0;
		background: transparent;
		border: none;
		box-shadow: none;
		display: grid;
		grid-template-columns: repeat(2, 1fr);
		gap: 12px;
	}

	.shop-empty-state {
		margin: 0;
		padding: 20px;
		font-size: 0.85rem;
		font-weight: 500;
		color: rgba(24,32,52,0.55);
		text-align: center;
		background: rgba(0,0,0,0.03);
		border-radius: 12px;
		border: 1px dashed rgba(40,55,120,0.15);
	}

	body.dark-mode .shop-empty-state {
		color: rgba(235,238,255,0.5);
		background: rgba(255,255,255,0.03);
		border-color: rgba(150,170,240,0.15);
	}

	/* Kaarten sectie (links) met rechter border */
	.shop-cards-section {
		border-right: 1px solid rgba(40,55,120,0.12);
		padding-right: 20px;
	}

	@media (max-width: 720px) {
		.shop-cards-section {
			border-right: none;
			padding-right: 0;
			border-bottom: 1px solid rgba(40,55,120,0.12);
			padding-bottom: 18px;
		}
		.shop-upgrades-section,
		.shop-bonus-section {
			padding: 16px;
		}
		body.dark-mode .shop-cards-section {
			border-bottom-color: rgba(140,150,200,0.22);
		}
		.shop-card-list {
			grid-template-columns: 1fr;
		}
		.shop-card-price {
			align-self: flex-start;
		}
		.shop-card-actions {
			margin-top: 0;
		}
	}

	/* Grid van kaarten in de shop */
	.shop-card-list {
		display: grid;
		grid-template-columns: repeat(auto-fill, minmax(260px, 1fr));
		gap: 24px;
		align-items: stretch;
	}

	#shop-card-options {
		flex: 1 1 auto;
	}

	#shop-upgrade-container {
		flex: 0 0 auto;
	}

	body.dark-mode .shop-section-title {
		color: rgba(240,242,255,0.85);
	}

	body.dark-mode .shop-cards-section {
		border-right-color: rgba(140,150,200,0.25);
	}

	.shop-section--empty {
		opacity: 0.75;
	}

	.shop-empty-state {
		margin: 0;
		font-size: 0.84rem;
		font-weight: 600;
		color: rgba(24,32,52,0.68);
	}

	body.dark-mode .shop-empty-state {
		color: rgba(235,238,255,0.64);
	}

	/* Individuele shop kaart met prijs en koop knop */
	.shop-card {
		border: 2px solid rgba(40, 55, 120, 0.15);
		border-radius: 20px;
		padding: 20px;
		background: linear-gradient(155deg, rgba(255,255,255,0.98), rgba(248,252,255,0.95));
		display: flex;
		flex-direction: column;
		gap: 16px;
		box-shadow: 0 4px 16px rgba(12,18,38,0.08), 0 12px 40px rgba(12,18,38,0.12);
		transition: transform 0.2s ease, box-shadow 0.2s ease;
		position: relative;
		overflow: hidden;
	}
	
	.shop-card::before {
		content: '';
		position: absolute;
		top: 0;
		left: 0;
		right: 0;
		height: 4px;
		background: linear-gradient(90deg, #ffb347, #ffda76, #ffc65d);
		opacity: 0;
		transition: opacity 0.2s ease;
	}
	
	.shop-card:hover {
		transform: translateY(-4px);
		box-shadow: 0 8px 24px rgba(12,18,38,0.12), 0 16px 48px rgba(12,18,38,0.16);
	}
	
	.shop-card:hover::before {
		opacity: 1;
	}
	
	.shop-card-random {
		border-color: rgba(255, 215, 0, 0.4);
		background: linear-gradient(155deg, rgba(255,252,245,0.98), rgba(255,248,235,0.95));
	}
	
	.shop-card-random::before {
		background: linear-gradient(90deg, #ffd700, #ffed4e, #ffd700);
	}

	body.dark-mode .shop-card {
		background: linear-gradient(155deg, rgba(38,42,58,0.95), rgba(28,32,48,0.95));
		border-color: rgba(160, 170, 240, 0.22);
		box-shadow: 0 4px 16px rgba(0,0,0,0.25), 0 12px 40px rgba(0,0,0,0.35);
	}
	
	body.dark-mode .shop-card:hover {
		box-shadow: 0 8px 24px rgba(0,0,0,0.35), 0 16px 48px rgba(0,0,0,0.45);
	}
	
	body.dark-mode .shop-card-random {
		border-color: rgba(255, 215, 0, 0.3);
		background: linear-gradient(155deg, rgba(48,44,32,0.95), rgba(38,36,28,0.95));
	}

	.shop-card-header {
		display: flex;
		align-items: center;
		justify-content: space-between;
		gap: 12px;
		font-weight: 700;
		font-size: 1.05rem;
	}
	
	/* Verberg lege header voor random kaarten */
	.shop-card-random .shop-card-header:empty {
		display: none;
	}
	
	.shop-card-header span:first-child {
		flex: 1;
		color: #1a2644;
	}
	
	body.dark-mode .shop-card-header span:first-child {
		color: #e8ebff;
	}
	
	.card-meta {
		font-size: 0.75rem;
		font-weight: 700;
		padding: 4px 10px;
		border-radius: 12px;
		background: rgba(100, 120, 200, 0.12);
		color: #3d4e7a;
		letter-spacing: 0.05em;
		text-transform: uppercase;
	}
	
	body.dark-mode .card-meta {
		background: rgba(120, 140, 220, 0.18);
		color: #a8b8ff;
	}

	.shop-card-price {
		font-size: 1rem;
		font-weight: 700;
		color: #e67e22;
		letter-spacing: 0.02em;
		padding: 6px 14px;
		background: rgba(230, 126, 34, 0.08);
		border-radius: 12px;
		display: inline-block;
	}

	body.dark-mode .shop-card-price {
		color: #ffb84d;
		background: rgba(255, 184, 77, 0.12);
	}

	.shop-card-preview {
		display: flex;
		justify-content: center;
		align-items: center;
		padding: 20px;
		border-radius: 16px;
		background: linear-gradient(145deg, rgba(235,242,255,0.6), rgba(245,248,255,0.8));
		border: 1px solid rgba(100, 120, 200, 0.08);
		min-height: 160px;
	}

	body.dark-mode .shop-card-preview {
		background: linear-gradient(145deg, rgba(20,24,36,0.4), rgba(28,32,44,0.6));
		border-color: rgba(120, 140, 220, 0.12);
	}

	.shop-card-actions {
		display: flex;
		justify-content: stretch;
		align-items: center;
		margin-top: 4px;
	}

	.shop-card-actions button {
		flex: 1;
		background: linear-gradient(145deg, #ffb347, #ff9f33);
		border: 2px solid rgba(230, 126, 34, 0.3);
		border-radius: 14px;
		padding: 12px 24px;
		font-weight: 700;
		font-size: 0.95rem;
		letter-spacing: 0.04em;
		cursor: pointer;
		transition: all 0.2s ease;
		box-shadow: 0 4px 12px rgba(255, 140, 50, 0.25);
		color: #fff;
		text-shadow: 0 1px 2px rgba(0,0,0,0.2);
	}

	.shop-card-actions button:hover:not(:disabled) {
		transform: translateY(-2px);
		box-shadow: 0 6px 20px rgba(255, 140, 50, 0.35);
		background: linear-gradient(145deg, #ffc55a, #ffb347);
	}
	
	.shop-card-actions button:active:not(:disabled) {
		transform: translateY(0);
	}

	.shop-card-actions button:disabled {
		cursor: not-allowed;
		opacity: 0.5;
		box-shadow: none;
		background: linear-gradient(145deg, #aaa, #999);
		border-color: rgba(100, 100, 100, 0.3);
	}

	.shop-upgrade-container {
		margin-top: 0;
		padding: 0;
		border-radius: 0;
		background: transparent;
		border: none;
		box-shadow: none;
		display: grid;
		grid-template-columns: repeat(2, minmax(0, 1fr));
		gap: 12px;
		width: 100%;
	}

	.shop-upgrade-card {
		min-width: 0;
	}

	/* Mystery Card Styles */
	.mystery-card-container {
		width: 100%;
		height: 200px;
		perspective: 1000px;
		position: relative;
	}

	.mystery-card-inner {
		width: 100%;
		height: 100%;
		transition: transform 0.8s;
		transform-style: preserve-3d;
		position: relative;
	}

	.mystery-card-inner.flipped {
		transform: rotateY(180deg);
	}

	.mystery-card-front,
	.mystery-card-back {
		position: absolute;
		width: 100%;
		height: 100%;
		backface-visibility: hidden;
		display: flex;
		align-items: center;
		justify-content: center;
		border-radius: 12px;
	}

	.mystery-card-front {
		background: linear-gradient(145deg, #4a4a4a, #2a2a2a);
		border: 2px solid rgba(255, 215, 0, 0.5);
		box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
	}

	.mystery-card-front .question-mark {
		font-size: 96px;
		font-weight: bold;
		color: #ffd700;
		text-shadow: 0 0 20px rgba(255, 215, 0, 0.6);
		animation: pulse 2s ease-in-out infinite;
	}

	@keyframes pulse {
		0%, 100% {
			opacity: 1;
			transform: scale(1);
		}
		50% {
			opacity: 0.7;
			transform: scale(1.1);
		}
	}

	.mystery-card-back {
		transform: rotateY(180deg);
		background: white;
		padding: 15px;
	}

	body.dark-mode .mystery-card-back {
		background: rgba(28,32,44,0.95);
	}

	.shop-upgrade-container h3 {
		margin: 0;
		font-size: 0.92rem;
	}

	.shop-upgrade-container p {
		margin: 0;
		font-size: 0.78rem;
		color: rgba(20,24,36,0.7);
	}

	.shop-upgrade-actions {
		display: flex;
		gap: 10px;
		align-items: center;
		flex-wrap: wrap;
	}

	.shop-upgrade-actions button {
		background: linear-gradient(145deg, #ffe580, #ffbd4f);
		border: 1px solid rgba(140, 95, 10, 0.35);
		color: #5a2d00;
		border-radius: 999px;
		padding: 7px 16px;
		font-weight: 700;
		letter-spacing: 0.04em;
		cursor: pointer;
		transition: transform 0.2s ease, box-shadow 0.2s ease;
	}

	.shop-upgrade-actions button:disabled {
		opacity: 0.5;
		cursor: not-allowed;
		transform: none;
		box-shadow: none;
	}

	.shop-upgrade-actions button:not(:disabled):hover {
		transform: translateY(-1px);
		box-shadow: 0 10px 18px rgba(180,120,20,0.26);
	}

	.shop-bonus-container {
		display: grid;
		grid-template-columns: repeat(auto-fill, minmax(220px, 1fr));
		gap: 14px;
		align-items: start;
	}

	.shop-bonus-card {
		display: flex;
		align-items: center;
		justify-content: space-between;
		gap: 12px;
		padding: 10px 14px;
		border-radius: 14px;
		background: rgba(255,255,255,0.78);
		border: 1px solid rgba(40,55,120,0.12);
		box-shadow: 0 14px 26px rgba(12,18,38,0.12);
		height: 100%;
	}

	body.dark-mode .shop-bonus-card {
		background: rgba(28,30,48,0.92);
		border-color: rgba(150,170,240,0.18);
		box-shadow: 0 16px 30px rgba(0,0,0,0.45);
	}

	.shop-bonus-info {
		display: flex;
		align-items: center;
		gap: 10px;
		font-weight: 600;
		color: rgba(26,34,52,0.88);
	}

	body.dark-mode .shop-bonus-info {
		color: rgba(235,238,255,0.88);
	}

	.shop-bonus-swatch {
		width: 20px;
		height: 20px;
		border-radius: 6px;
		border: 2px solid rgba(0,0,0,0.08);
		box-shadow: inset 0 0 0 1px rgba(255,255,255,0.4);
	}

	body.dark-mode .shop-bonus-swatch {
		border-color: rgba(255,255,255,0.12);
		box-shadow: inset 0 0 0 1px rgba(0,0,0,0.35);
	}

	.shop-bonus-actions button {
		background: linear-gradient(145deg, #8be6ff, #44bdf1);
		border: 1px solid rgba(20,60,120,0.24);
		border-radius: 999px;
		padding: 7px 16px;
		font-weight: 700;
		color: #04344f;
		cursor: pointer;
		transition: transform 0.2s ease, box-shadow 0.2s ease;
		box-shadow: 0 12px 20px rgba(68,189,241,0.26);
	}

	.shop-bonus-actions button:hover:not(:disabled) {
		transform: translateY(-1px);
		box-shadow: 0 16px 28px rgba(68,189,241,0.32);
	}

	.shop-bonus-actions button:disabled {
		opacity: 0.45;
		cursor: not-allowed;
		box-shadow: none;
	}

	body.dark-mode .shop-bonus-actions button {
		color: #062f45;
	}
	body.dark-mode .shop-bonus-upgrade-btn {
		background: linear-gradient(145deg, #d8a640, #f0c04f);
		border-color: rgba(255,223,128,0.4);
		color: #fff6d2;
	}

	.shop-bonus-upgrade-btn {
		background: linear-gradient(145deg, #ffe580, #ffbd4f);
		border: 1px solid rgba(140, 95, 10, 0.35);
		color: #5a2d00;
	}

	.shop-bonus-upgrade-btn:hover:not(:disabled) {
		transform: translateY(-1px);
		box-shadow: 0 14px 24px rgba(180,120,20,0.25);
	}

	.shop-bonus-status {
		display: inline-flex;
		align-items: center;
		gap: 6px;
		font-size: 0.78rem;
		font-weight: 700;
		padding: 6px 12px;
		border-radius: 999px;
		background: linear-gradient(135deg, rgba(255,255,255,0.85), rgba(240,245,255,0.75));
		border: 1px solid rgba(120,140,200,0.28);
		color: rgba(26,32,52,0.78);
	}

	body.dark-mode .shop-bonus-status {
		background: linear-gradient(135deg, rgba(40,42,60,0.9), rgba(32,34,52,0.88));
		border-color: rgba(180,196,255,0.26);
		color: rgba(236,240,255,0.85);
	}

	.shop-upgrade-note {
		font-size: 0.72rem;
		color: rgba(20,24,36,0.65);
	}

	.shop-upgrade-card {
		padding: 16px 18px;
		border-radius: 16px;
		background: linear-gradient(155deg, rgba(255,255,255,0.95), rgba(248,250,255,0.9));
		border: 1px solid rgba(40,55,120,0.12);
		box-shadow: 0 8px 24px rgba(12,18,38,0.1);
		display: flex;
		flex-direction: column;
		gap: 12px;
		height: 100%;
		transition: transform 0.2s ease, box-shadow 0.2s ease;
		position: relative;
		overflow: hidden;
	}

	.shop-upgrade-card::before {
		content: '';
		position: absolute;
		top: 0;
		left: 0;
		right: 0;
		height: 3px;
		background: linear-gradient(90deg, #a78bfa, #818cf8, #6366f1);
		opacity: 0.7;
	}

	.shop-upgrade-card:hover {
		transform: translateY(-2px);
		box-shadow: 0 12px 32px rgba(12,18,38,0.15);
	}

	.shop-upgrade-card--locked {
		opacity: 0.6;
	}

	.shop-upgrade-card--locked::before {
		background: linear-gradient(90deg, #9ca3af, #6b7280);
	}

	.shop-upgrade-card--owned::before {
		background: linear-gradient(90deg, #34d399, #10b981, #059669);
	}

	.shop-upgrade-header {
		display: flex;
		align-items: center;
		gap: 10px;
		font-weight: 700;
		font-size: 0.95rem;
		color: #1a2644;
	}

	.upgrade-icon {
		font-size: 1.4rem;
		width: 36px;
		height: 36px;
		display: flex;
		align-items: center;
		justify-content: center;
		background: linear-gradient(145deg, rgba(167,139,250,0.15), rgba(129,140,248,0.1));
		border-radius: 10px;
		flex-shrink: 0;
	}

	.shop-upgrade-desc {
		margin: 0;
		font-size: 0.82rem;
		color: rgba(20,24,36,0.7);
		line-height: 1.45;
	}

	.shop-upgrade-price {
		display: inline-flex;
		align-items: center;
		gap: 4px;
		font-size: 0.85rem;
		font-weight: 700;
		color: #e67e22;
		padding: 4px 10px;
		background: rgba(230, 126, 34, 0.1);
		border-radius: 8px;
		margin-top: auto;
	}

	.shop-upgrade-actions {
		display: flex;
		gap: 10px;
		align-items: center;
		flex-wrap: wrap;
		margin-top: auto;
	}

	.shop-upgrade-actions button {
		background: linear-gradient(145deg, #a78bfa, #818cf8);
		border: none;
		color: #fff;
		border-radius: 10px;
		padding: 10px 18px;
		font-weight: 700;
		font-size: 0.85rem;
		letter-spacing: 0.03em;
		cursor: pointer;
		transition: transform 0.2s ease, box-shadow 0.2s ease;
		box-shadow: 0 4px 12px rgba(129,140,248,0.3);
	}

	.shop-upgrade-actions button:disabled {
		opacity: 0.5;
		cursor: not-allowed;
		transform: none;
		box-shadow: none;
		background: linear-gradient(145deg, #9ca3af, #6b7280);
	}

	.shop-upgrade-actions button:not(:disabled):hover {
		transform: translateY(-2px);
		box-shadow: 0 8px 20px rgba(129,140,248,0.4);
	}

	body.dark-mode .shop-upgrade-note {
		color: rgba(240,242,255,0.65);
	}

	body.dark-mode .shop-upgrade-card {
		background: linear-gradient(155deg, rgba(38,42,58,0.95), rgba(28,32,48,0.95));
		border-color: rgba(150,170,240,0.2);
		box-shadow: 0 8px 24px rgba(0,0,0,0.35);
	}

	body.dark-mode .shop-upgrade-card:hover {
		box-shadow: 0 12px 32px rgba(0,0,0,0.45);
	}

	body.dark-mode .shop-upgrade-header {
		color: #e8ebff;
	}

	body.dark-mode .upgrade-icon {
		background: linear-gradient(145deg, rgba(167,139,250,0.25), rgba(129,140,248,0.15));
	}

	body.dark-mode .shop-upgrade-desc {
		color: rgba(240,242,255,0.7);
	}

	body.dark-mode .shop-upgrade-price {
		color: #ffb84d;
		background: rgba(255, 184, 77, 0.15);
	}

	body.dark-mode .shop-upgrade-actions button {
		background: linear-gradient(145deg, #a78bfa, #818cf8);
		color: #fff;
	}

	body.dark-mode .shop-card-actions button {
		background: linear-gradient(145deg, #ffa940, #ff8835);
		border-color: rgba(255, 255, 255, 0.16);
	}

	.shop-card .card-option {
		flex: 0 0 auto;
		width: 138px;
		min-height: 180px;
		padding: 0;
		display: flex;
		flex-direction: column;
		align-items: center;
		justify-content: center;
		gap: 12px;
		border-radius: 16px;
		background: linear-gradient(165deg, #ffffff 0%, #eef2ff 45%, #dfe4ff 100%);
		border: 1px solid rgba(40,55,120,0.18);
		box-shadow: 0 18px 26px rgba(10,12,20,0.2);
		position: relative;
		overflow: hidden;
		transition: transform 0.2s ease, box-shadow 0.2s ease, border-color 0.2s ease;
	}

	.shop-card .card-option::after {
		content: "";
		position: absolute;
		inset: 0;
		border-radius: inherit;
		background: linear-gradient(120deg, rgba(255,255,255,0.65), rgba(255,255,255,0) 58%);
		opacity: 0.45;
		pointer-events: none;
	}

	.shop-card .card-option > * {
		position: relative;
		z-index: 1;
	}

	.shop-card .card-pattern {
		display: grid;
		gap: 4px;
		align-items: center;
		justify-items: center;
	}

	.shop-card .card-option .card-cell {
		width: 22px;
		height: 22px;
		/* Border-radius: max 5px, minder rond */
		border-radius: min(5px, calc(22px / 5));
		border: 1px solid rgba(12,16,30,0.12);
		box-shadow: inset 0 0 4px rgba(0,0,0,0.18);
		background: rgba(255,255,255,0.95);
	}

	.shop-card .card-label {
		display: inline-flex;
		align-items: center;
		gap: 6px;
		padding: 5px 10px;
		border-radius: 999px;
		background: rgba(30, 40, 70, 0.08);
		font-size: 0.72rem;
		font-weight: 600;
		letter-spacing: 0.04em;
		color: #2a2f45;
		box-shadow: inset 0 0 0 1px rgba(40,55,120,0.16);
	}

	.shop-card .card-label-dot {
		display: inline-block;
		width: 10px;
		height: 10px;
		border-radius: 50%;
		box-shadow: 0 0 6px rgba(0,0,0,0.2);
	}

	.shop-card .card-meta {
		font-size: 0.75rem;
		font-weight: 600;
		letter-spacing: 0.05em;
		text-transform: uppercase;
		color: rgba(30, 35, 60, 0.85);
	}

	body.dark-mode .shop-card .card-option {
		background: rgba(20, 24, 36, 0.82);
		border-color: rgba(255, 255, 255, 0.16);
		box-shadow: 0 18px 36px rgba(0, 0, 0, 0.5);
	}

	body.dark-mode .shop-card .card-option::after {
		background: linear-gradient(120deg, rgba(255,255,255,0.24), rgba(255,255,255,0) 62%);
	}

	body.dark-mode .shop-card .card-option .card-cell {
		border-color: rgba(255,255,255,0.08);
		background: rgba(32, 36, 52, 0.92);
	}

	body.dark-mode .shop-card .card-label {
		background: rgba(255,255,255,0.1);
		color: #f3f4ff;
		box-shadow: inset 0 0 0 1px rgba(255,255,255,0.18);
	}

	body.dark-mode .shop-card .card-meta {
		color: rgba(240, 242, 255, 0.75);
	}

	/* Mobile shop modal optimization */
	@media (max-width: 650px) {
		.game-modal {
			padding: 14px;
			width: clamp(320px, 94vw, 480px);
		}

		#shop-modal {
			width: clamp(320px, 94vw, 480px);
			max-height: 72vh;
			padding: 10px 16px;
			gap: 10px;
			overflow-y: auto;
		}

		#shop-modal h2 {
			font-size: 0.94rem;
			margin: 0 0 4px;
		}

		#shop-modal p {
			font-size: 0.74rem;
			margin: 0 0 6px 0;
		}

		.shop-content-grid {
			display: grid;
			grid-template-columns: minmax(0, 1fr);
			gap: 12px;
			margin-top: 8px;
			align-items: start;
		}

		.shop-section {
			min-width: 220px;
		}

		.shop-cards-section {
			border: none;
			padding-right: 0;
			padding-bottom: 0;
		}

		#shop-card-options {
			max-height: none;
			overflow: visible;
		}

		.shop-card-list {
			display: grid;
			grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
			gap: 10px;
			margin-top: 8px;
		}

		.shop-card {
			padding: 10px;
			gap: 8px;
			align-items: center;
		}

		.shop-card .card-option {
			width: 100%;
			max-width: none;
			min-height: 110px;
			gap: 6px;
		}

		.shop-card .card-pattern {
			gap: 2px;
		}

		.shop-card .card-option .card-cell {
			width: 12px;
			height: 12px;
			/* Border-radius: max 5px, minder rond */
			border-radius: min(5px, calc(12px / 5));
		}

		.shop-card .card-label {
			padding: 3px 6px;
			font-size: 0.6rem;
			gap: 3px;
		}

		.shop-card .card-label-dot {
			width: 6px;
			height: 6px;
		}

		.shop-card .card-meta {
			font-size: 0.62rem;
		}

		.shop-card-price {
			font-size: 0.78rem;
		}

		.shop-card-actions {
			width: 100%;
		}

		.shop-card-actions button {
			padding: 5px 10px;
			font-size: 0.78rem;
		}

		.modal-actions {
			gap: 8px;
			margin-top: 10px;
		}

		.modal-actions button {
			padding: 7px 14px;
			font-size: 0.84rem;
		}

		.shop-upgrade-container {
			padding: 0;
			margin-top: 0;
			display: grid;
			grid-template-columns: repeat(2, minmax(0, 1fr));
			gap: 10px;
		}

		.shop-upgrade-card {
			padding: 8px 10px;
			gap: 6px;
			height: 100%;
		}

		.shop-upgrade-header {
			font-size: 0.8rem;
			gap: 6px;
		}

		.upgrade-icon {
			font-size: 1rem;
		}

		.shop-upgrade-desc {
			font-size: 0.68rem;
			line-height: 1.35;
		}

		.shop-upgrade-price {
			font-size: 0.78rem;
		}

		.shop-upgrade-actions {
			justify-content: flex-start;
		}

		.shop-upgrade-actions button {
			padding: 5px 10px;
			font-size: 0.74rem;
		}
	}


	@media (max-width: 520px) {
		#shop-modal {
			width: clamp(300px, 96vw, 420px);
			max-height: 70vh;
			padding: 10px 14px;
			gap: 8px;
		}

		#shop-modal h2 {
			font-size: 0.9rem;
		}

		#shop-modal p {
			font-size: 0.72rem;
		}

		.shop-content-grid {
			grid-template-columns: minmax(0, 1fr);
			gap: 10px;
		}

		.shop-section-title {
			font-size: 0.8rem;
		}

		.shop-card-list {
			grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
			gap: 8px;
		}

		.shop-card {
			padding: 8px;
			gap: 6px;
		}

		.shop-card .card-option {
			min-height: 104px;
		}

		.shop-card .card-option .card-cell {
			width: 11px;
			height: 11px;
			/* Border-radius erft van base regel */
		}

		.shop-card-header {
			font-size: 0.74rem;
		}

		.shop-card-price {
			font-size: 0.76rem;
		}

		.shop-card-actions button {
			padding: 4px 10px;
			font-size: 0.76rem;
		}

		.modal-actions button {
			padding: 6px 12px;
			font-size: 0.82rem;
		}

		.shop-upgrade-card {
			padding: 7px 9px;
		}

		.shop-upgrade-header {
			font-size: 0.78rem;
		}

		.upgrade-icon {
			font-size: 0.96rem;
		}

		.shop-upgrade-desc {
			font-size: 0.65rem;
		}

		.shop-upgrade-container {
			grid-template-columns: repeat(2, minmax(0, 1fr));
			gap: 9px;
		}

		.shop-upgrade-actions button {
			padding: 4px 10px;
			font-size: 0.72rem;
		}
	}

	@media (max-width: 380px) {
		#shop-modal {
			width: clamp(280px, 96vw, 360px);
			max-height: 68vh;
			padding: 9px 12px;
			gap: 6px;
		}

		#shop-modal h2 {
			font-size: 0.86rem;
		}

		#shop-modal p {
			font-size: 0.68rem;
		}

		.shop-content-grid {
			grid-template-columns: minmax(0, 1fr);
			gap: 9px;
		}

		.shop-section-title {
			font-size: 0.76rem;
		}

		.shop-card-list {
			grid-template-columns: repeat(auto-fit, minmax(115px, 1fr));
			gap: 7px;
		}

		.shop-card {
			padding: 7px;
		}

		.shop-card .card-option {
			min-height: 98px;
		}

		.shop-card .card-option .card-cell {
			width: 10px;
			height: 10px;
			/* Border-radius erft van base regel */
		}

		.shop-card-header {
			font-size: 0.7rem;
		}

		.shop-card-price {
			font-size: 0.72rem;
		}

		.shop-card-actions button {
			padding: 4px 9px;
			font-size: 0.72rem;
		}

		.modal-actions {
			margin-top: 8px;
		}

		.modal-actions button {
			padding: 6px 10px;
			font-size: 0.8rem;
		}

		.shop-upgrade-card {
			padding: 6px 9px;
		}

		.shop-upgrade-header {
			font-size: 0.74rem;
		}

		.upgrade-icon {
			font-size: 0.92rem;
		}

		.shop-upgrade-desc {
			font-size: 0.62rem;
		}

		.shop-upgrade-container {
			grid-template-columns: repeat(2, minmax(0, 1fr));
			gap: 8px;
		}

		.shop-upgrade-actions button {
			padding: 4px 9px;
			font-size: 0.7rem;
		}
	}

	/* VERWIJDERD: Dubbele #card-choice-zone .card-option styling - deze stond al eerder gedefinieerd */

	@keyframes coinPop {
	  0% { transform: translate(-50%, -50%) scale(0); opacity: 0.2; }
	  70% { transform: translate(-50%, -50%) scale(1.3); opacity: 1; }
	  100% { transform: translate(-50%, -50%) scale(1); }
	}

	.objective-toast {
		position: fixed;
		top: 18px;
		left: 50%;
		transform: translateX(-50%);
		background: linear-gradient(135deg, #1f2a4d 0%, #283663 60%, #1e2959 100%);
		color: #f0f4ff;
		padding: 10px 18px;
		border-radius: 999px;
		font-size: 0.85rem;
		font-weight: 600;
		letter-spacing: 0.04em;
		box-shadow: 0 14px 28px rgba(10,22,60,0.35);
		opacity: 0;
		pointer-events: none;
		transition: opacity 0.25s ease, transform 0.25s ease;
		z-index: 1200;
	}

	body.dark-mode .objective-toast {
		background: linear-gradient(135deg, #101423 0%, #1a1f33 65%, #181c2b 100%);
		color: #f7f9ff;
		box-shadow: 0 16px 28px rgba(0,0,0,0.5);
	}

	.objective-toast.show {
		opacity: 1;
		transform: translateX(-50%) translateY(0);
	}


	@keyframes growRoot {
	  from { opacity: 0; transform: scale(0.5); }
	  to { opacity: 1; transform: scale(1); }
	}

	/* === Mobile layout (<=650px): keep compact 23-10 HUD === */
	@media (max-width: 650px) {
		body {
			display: block;
			position: relative;
			width: 100%;
			min-height: 100svh;
			height: 100svh;
			margin: 0;
			padding: 16px 8px calc(var(--bottom-bar-clearance) + 24px);
			padding-top: 62px;
			box-sizing: border-box;
			background: linear-gradient(180deg, #171822 0%, #101018 55%, #0a0b12 100%);
			color: #f5f6ff;
			overflow-x: hidden;
			overflow-y: hidden;
		}

		html {
			background: #101018;
		}

		body.dark-mode {
			background: linear-gradient(180deg, #0b0c10 0%, #040406 100%);
			color: #f5f6ff;
		}

		#mobile-objective-banner {
			display: flex;
			position: fixed;
			top: calc(env(safe-area-inset-top, 0px) + 4px);
			left: 10px;
			right: 10px;
			z-index: calc(var(--z-blur) + 20);
			justify-content: center;
			pointer-events: none;
		}

		body.zoomed-in #mobile-objective-banner {
			filter: none;
		}

		#mobile-objective-banner #objective-zone {
			pointer-events: none;
			width: min(100%, 328px);
			padding: 10px 12px 8px;
			gap: 4px;
			border-radius: 14px;
			box-shadow: 0 12px 26px rgba(10,18,35,0.28);
		}

		/* Mobile: force objective panel to stack (avoid desktop flex-row quirks and odd number spacing). */
		#mobile-objective-banner #objective-zone {
			display: flex;
			flex-direction: column;
			align-items: center;
			justify-content: center;
			text-align: center;
		}
		#mobile-objective-banner #objective-current {
			display: block;
			width: 100%;
			text-align: center;
		}
		#mobile-objective-banner #objective-current strong {
			white-space: nowrap;
		}

		#mobile-objective-banner #objective-zone h2 {
			margin: 0;
			font-size: 0.66rem;
			letter-spacing: 0.08em;
			text-transform: uppercase;
			color: rgba(20,24,36,0.72);
		}

		body.dark-mode #mobile-objective-banner #objective-zone h2 {
			color: rgba(230,235,255,0.8);
		}

		#mobile-objective-banner .objective-current {
			font-size: 0.78rem;
			line-height: 1.35;
		}

		#mobile-objective-banner .objective-history {
			display: none;
		}

		/* ============================================
		   HAMBURGER MENU KNOP (MOBIEL)
		   ============================================
		   Gouden ronde knop linksboven met 3 streepjes
		   Opent/sluit het controls menu
		   Animeer naar X wanneer open (.active class)
		*/
		#menu-toggle {
			position: fixed;
			left: 8px;
			top: 8px;
			display: flex;
			align-items: center;
			justify-content: center;
			flex-direction: column;
			gap: 3px;
			width: 30px;
			height: 30px;
			padding: 6px;
			border-radius: 6px;
			background: linear-gradient(145deg, #ffd560, #ffb23c);
			border: 1px solid rgba(255,255,255,0.35);
			box-shadow: 0 4px 10px rgba(0,0,0,0.28);
			cursor: pointer;
			transition: transform 0.2s ease, box-shadow 0.2s ease;
			z-index: var(--z-menu);
		}

		#menu-toggle:hover {
			transform: scale(1.05);
			box-shadow: 0 6px 14px rgba(0,0,0,0.32);
		}

		#menu-toggle span {
			display: block;
			width: 14px;
			height: 2px;
			background: #1c1c1c;
			border-radius: 2px;
			transition: transform 0.28s ease, opacity 0.28s ease;
		}

		#menu-toggle.active span:nth-child(1) { transform: translateY(6px) rotate(45deg); }
		#menu-toggle.active span:nth-child(2) { opacity: 0; }
		#menu-toggle.active span:nth-child(3) { transform: translateY(-6px) rotate(-45deg); }

		body.dark-mode #menu-toggle {
			background: linear-gradient(145deg, #2f3546, #1c2233);
			border-color: rgba(255,255,255,0.12);
		}

		body.dark-mode #menu-toggle span {
			background: rgba(255,255,255,0.88);
		}

		/* ============================================
		   CONTROLS MENU (MOBIEL)
		   ============================================
		   Pop-up menu met game controls (nieuw spel, reset, dark mode, etc.)
		   Verschijnt naast hamburger knop wanneer .open class wordt toegevoegd
		   Alleen op mobiel (<650px), op desktop is dit altijd fixed zichtbaar
		*/
		#controls {
			position: fixed;
			left: 64px;
			top: 12px;
			right: auto;
			bottom: auto;
			transform: translateX(0);
			opacity: 1;
			pointer-events: auto;
			background: rgba(18,20,28,0.96);
			border: 1px solid rgba(255,255,255,0.14);
			border-radius: 12px;
			padding: 10px 12px;
			box-shadow: 0 8px 20px rgba(0,0,0,0.38);
			transition: transform 0.28s ease, opacity 0.2s ease;
			z-index: calc(var(--z-controls) - 1);
			display: none;
			flex-direction: column;
			gap: 6px;
			min-width: 160px;
		}

		#controls.open {
			transform: translateX(0);
			opacity: 1;
			pointer-events: auto;
			display: flex;
		}

		body.dark-mode #controls {
			background: rgba(8,9,14,0.96);
			border-color: rgba(255,255,255,0.1);
		}

		#controls button {
			background: rgba(255,255,255,0.08);
			border: 1px solid rgba(255,255,255,0.18);
			color: #f5f6ff;
			padding: 10px 14px;
			border-radius: 8px;
			cursor: pointer;
			transition: background 0.2s ease;
			width: 100%;
			text-align: left;
			font-size: 0.9rem;
		}

		#controls button:disabled {
			opacity: 0.55;
			cursor: not-allowed;
		}

		#controls #debug-mode-toggle {
			display: flex;
			align-items: center;
			justify-content: space-between;
			gap: 12px;
			font-weight: 600;
		}

		#controls #debug-mode-toggle.debug-active {
			background: linear-gradient(145deg, rgba(112,198,255,0.28), rgba(72,132,255,0.32));
			border-color: rgba(112, 198, 255, 0.5);
			box-shadow: inset 0 0 0 1px rgba(255,255,255,0.18);
		}

		#controls button:hover:not(:disabled) {
			background: rgba(255,255,255,0.12);
		}

		/* Dark mode toggle binnen het menu (alleen mobiel) */
		#mobile-dark-mode-toggle {
			margin-top: 0;
		}

		body.dark-mode #mobile-dark-mode-toggle::before {
			content: 'â˜€ï¸ ';
		}

		body.dark-mode #mobile-dark-mode-toggle {
			background: rgba(255,255,255,0.12);
		}

		/* ============================================
		   BOTTOM BAR (MOBIEL)
		   ============================================
		   Vaste strip onderaan met kaarten, score en munten
		   Altijd zichtbaar tijdens mobiel spelen
		   Bevat:
		   - Kaart keuze (3 opties)
		   - Score overzicht (compacte dots)
		   - Munten teller
		   - Bonus status
		*/
		#bottom-bar {
			position: fixed;
			left: 0;
			right: 0;
			bottom: var(--bottom-bar-bottom-offset);
			height: auto;
			min-height: var(--bottom-bar-height);
			padding: 0 0 6px;
			padding-left: calc(5px + env(safe-area-inset-left, 0px));
			padding-right: calc(5px + env(safe-area-inset-right, 0px));
			display: flex;
			flex-direction: column;
			background: linear-gradient(180deg, rgba(47,50,68,0.95) 0%, rgba(33,36,52,0.97) 52%, rgba(22,24,36,0.98) 100%);
			border-radius: 18px 18px 0 0;
			border-top: 1px solid rgba(255,255,255,0.16);
			box-shadow: 0 -18px 40px rgba(0,0,0,0.42);
			backdrop-filter: blur(12px);
			-webkit-backdrop-filter: blur(12px);
			overflow-x: hidden;
			overflow-y: hidden;
			overscroll-behavior-y: contain;
			clip-path: none;
			z-index: var(--z-bottom);
		}

		body.dark-mode #bottom-bar {
			background: linear-gradient(180deg, rgba(20,22,32,0.96) 0%, rgba(14,16,26,0.98) 55%, rgba(8,9,16,0.99) 100%);
			border-top-color: rgba(255,255,255,0.1);
		}

		#bottom-bar-cards {
			display: flex;
			align-items: center;
			justify-content: flex-start;
			gap: 0;
			overflow-x: hidden;
			overflow-y: hidden;
			overscroll-behavior: contain;
			touch-action: pan-x;
			scrollbar-width: none; /* Firefox */
			-ms-overflow-style: none; /* IE/Edge legacy */
			padding: 0;
			margin-top: 0;
			transform: none;
			scroll-snap-type: x mandatory;
			border-radius: 0;
			background: transparent;
			border: none;
			flex: 0 0 auto;
			height: 100px;
			min-height: 80px;
			position: relative;
			z-index: 10;
			clip-path: none;
		}

		br {
		display: none;
		}

		.bottom-bar-footer {
			display: flex;
			justify-content: space-between;
			align-items: flex-end;
			gap: 0;
			padding: 0 4px 0;
			transform: none;
		}

		#bottom-bar-score-coins {
			display: flex;
			flex-direction: row;
			align-items: flex-end;
			justify-content: space-between;
			gap: 8px;
			width: 100%;
		}

		#bottom-bar-score,
		#bottom-bar-coins {
			display: flex;
			align-items: center;
		}

		#bottom-bar-score {
			justify-content: flex-start;
			flex: 1 1 auto;
			min-width: 0;
			max-width: 450px;
		}

		#bottom-bar-coins {
			justify-content: flex-end;
			flex: 0 0 auto;
			flex-direction: column;
			align-items: flex-end;
			gap: 4px;
			min-width: 0;
		}

		#bottom-bar-cards::-webkit-scrollbar {
			display: none;
		}

		#card-choice-zone {
			flex: 1 0 auto;
			display: flex;
			flex-direction: column;
			align-items: center;
			justify-content: center;
			background: none;
			width: 100%;
			height: 100%;
			padding: 0;
			margin: 0;
			overflow: visible;
			clip-path: none;
		}

		/* In de mobile bottom bar moet het kaartvlak geen â€œlos panelâ€ zijn.
		   Dit voorkomt een asymmetrische aflopende rand onder de kaarten. */
		#bottom-bar #card-choice-zone {
			background: transparent;
			border: none;
			border-radius: 0;
			box-shadow: none;
			position: relative;
			z-index: 0;
		}

		#card-controls {
			display: flex;
			flex-direction: row;
			align-items: center;
			justify-content: space-between;
			gap: 8px;
			width: 100%;
			position: relative;
			z-index: 12;
			overflow: visible;
			clip-path: none;
		}

		#card-options {
			flex: 1 1 auto;
			min-width: 0;
			max-width: none;
			overflow: visible;
			clip-path: none;
		}

		#card-action-buttons {
			display: flex;
			flex-direction: column;
			gap: 6px;
			align-items: center;
			justify-content: center;
			flex: 0 0 auto;
			width: auto;
			min-width: 0;
			max-width: none;
			margin: 0;
			padding-top: 0;
	}

	#card-action-buttons .deck-preview {
		order: 3;
		margin: 0;
	}

#card-action-buttons #new-cards-btn {
	order: 0;
}	#card-action-buttons #rotate-card-btn,
	#card-action-buttons #mirror-card-btn {
		order: 1;
		display: none; /* Verberg in mobiel, toon alleen in floating preview */
	}

	#card-action-buttons #turn-counter-inline {
		order: 4;
	}		#card-action-buttons .card-action-btn {
			min-height: 50px;
			width: 50px;
			flex: 0 0 auto;
			padding: 0;
			border-radius: 14px;
			display: flex;
			align-items: center;
			justify-content: center;
			gap: 0;
			font-size: 1rem;
			letter-spacing: 0;
			text-transform: none;
			box-shadow: 0 12px 22px rgba(10,12,20,0.25);
		}

		#card-action-buttons .card-action-btn::after {
			display: none;
		}

		#card-action-buttons .card-action-btn::before {
			font-size: 1.6rem;
		}

		/* Deck preview: zelfde stijl als card action buttons */
		#card-action-buttons .deck-preview {
			min-height: 50px;
			width: 50px;
			flex: 0 0 auto;
			padding: 0;
			border-radius: 14px;
			display: flex;
			align-items: center;
			justify-content: center;
			background: linear-gradient(155deg, #eff3ff 0%, #dbe2f6 100%);
			border: 1px solid rgba(26,32,48,0.16);
			box-shadow: 0 12px 22px rgba(10,12,20,0.25);
		}

		#card-action-buttons .deck-preview::after {
			display: none;
		}

	#card-action-buttons .deck-count {
		position: static;
		min-width: auto;
		padding: 0;
		background: none;
		border: none;
		box-shadow: none;
		font-size: 1rem;
		font-weight: 700;
		color: #2b3148;
	}		#turn-counter-inline {
			margin-top: 0;
			padding: 4px 8px;
			font-size: 0.7rem;
			box-shadow: 0 6px 12px rgba(10,12,20,0.18);
			border-radius: 10px;
		}

		#card-choice-zone::-webkit-scrollbar { display: none; }
		#kiesKaartTitel { display: none; }

		#card-controls {
			display: flex;
			flex-direction: row;
			align-items: center;
			justify-content: space-between;
			gap: 8px;
			width: 100%;
			position: relative;
		}

		.hand-scroll-btn {
			display: none;
			position: absolute;
			top: 50%;
			transform: translateY(-50%);
			width: 24px;
			height: 24px;
			border-radius: 999px;
			border: 1px solid rgba(26,32,48,0.16);
			background: rgba(239,243,255,0.7);
			box-shadow: 0 6px 10px rgba(10,12,20,0.14);
			color: rgba(74,82,104,0.85);
			font-size: 16px;
			font-weight: 900;
			line-height: 1;
			align-items: center;
			justify-content: center;
			z-index: 25;
			cursor: pointer;
			user-select: none;
			pointer-events: auto;
		}

		#card-controls.hand-scroll-enabled .hand-scroll-btn {
			display: inline-flex;
		}

		#hand-scroll-left {
			left: calc(6px + env(safe-area-inset-left, 0px));
		}

		#hand-scroll-right {
			/* Keep clear of the action button column on the right. */
			right: calc(58px + env(safe-area-inset-right, 0px));
		}

		#card-controls.hand-scroll-enabled #hand-scroll-left:disabled,
		#card-controls.hand-scroll-enabled #hand-scroll-right:disabled {
			opacity: 0.45;
			cursor: default;
			box-shadow: none;
		}

		#bottom-bar #card-options {
			display: flex;
			gap: 6px;
			align-items: stretch;
			justify-content: flex-start;
			flex-wrap: nowrap;
			scroll-snap-type: x proximity;
			flex: 1 1 auto;
			min-width: 0;
			width: auto;
			max-width: none;
			padding: 0;
			margin: 0;
			transform: translateY(0px);
			position: relative;
			z-index: 20;
			overflow-x: auto;
			overflow-y: hidden;
			touch-action: pan-x;
			clip-path: none;
		}

		#bottom-bar #card-options::-webkit-scrollbar { display: none; }

		#bottom-bar #new-cards-btn {
			display: flex;
			align-items: center;
			justify-content: center;
			height: 44px;
			width: 44px;
			padding: 0;
			margin: 0;
			font-weight: 400;
			font-size: 1.5rem;
			cursor: pointer;
			border-radius: 10px;
			border: 1px solid rgba(26,32,48,0.16);
			background: linear-gradient(155deg, #eff3ff 0%, #dbe2f6 100%);
			box-shadow: 0 8px 14px rgba(10,12,20,0.22);
			transition: transform 0.18s ease, box-shadow 0.18s ease, background 0.3s ease, border-color 0.3s ease;
			position: relative;
		}

		#bottom-bar #new-cards-btn::before {
			content: 'â†’';
			color: #4a5268;
			font-size: 1.8rem;
			font-weight: 700;
			position: absolute;
			top: 50%;
			left: 50%;
			transform: translate(-50%, -50%);
			transition: color 0.3s ease;
		}

		#bottom-bar #new-cards-btn.ready-for-next-turn {
			background: linear-gradient(155deg, #fef8e7 0%, #f0c149 100%);
			border-color: rgba(20,24,36,0.14);
		}

		#bottom-bar #new-cards-btn.ready-for-next-turn::before {
			color: #5a4a1e;
		}

		#bottom-bar #new-cards-btn:disabled {
			background: linear-gradient(155deg, #eff3ff 0%, #dbe2f6 100%);
			border-color: rgba(26,32,48,0.16);
			box-shadow: none;
			opacity: 0.6;
			cursor: default;
			transform: none;
			pointer-events: none;
		}

		#bottom-bar #new-cards-btn:disabled::before {
			color: rgba(74,82,104,0.6);
		}

		#bottom-bar #new-cards-btn.complete-round {
			background: linear-gradient(155deg, #e8f5e9 0%, #66bb6a 100%);
			border-color: rgba(46,125,50,0.3);
		}

		#bottom-bar #new-cards-btn.complete-round::before {
			content: 'âœ“';
			color: #1b5e20;
			font-size: 2rem;
			font-weight: 900;
		}

		@media (max-width: 520px) {
			#card-controls {
				gap: 6px;
			}

			#bottom-bar #new-cards-btn {
				height: 40px;
				width: 40px;
				border-radius: 10px;
			}

			#bottom-bar #new-cards-btn::before {
				font-size: 1.6rem;
			}

			#card-action-buttons .card-action-btn,
			#card-action-buttons .deck-preview {
				min-height: 44px;
				width: 44px;
				border-radius: 12px;
			}

			#hand-scroll-right {
				right: calc(54px + env(safe-area-inset-right, 0px));
			}

			/* Keep only the total coin text in the bottom bar. */
			#bottom-bar .coin,
			#bottom-bar #collected-coins {
				display: none !important;
			}
		}

		#bottom-bar #rotate-card-btn {
			display: none; /* Verberg in mobiel, alleen in floating preview */
		}

		#bottom-bar #rotate-card-btn::before {
			content: 'â†»';
			color: #4a5268;
			font-size: 1.6rem;
			position: absolute;
			top: 50%;
			left: 50%;
			transform: translate(-50%, -50%);
		}

		#bottom-bar #new-cards-btn:hover {
			transform: translateY(-2px);
			box-shadow: 0 12px 20px rgba(10,12,20,0.26);
		}

		#bottom-bar #rotate-card-btn:hover:not(:disabled) {
			transform: translateY(-1px);
			box-shadow: 0 10px 18px rgba(10,12,20,0.26);
		}

		#bottom-bar #rotate-card-btn:disabled {
			opacity: 0.6;
			box-shadow: none;
			transform: none;
		}

		body.dark-mode #bottom-bar #new-cards-btn {
			color: #f5f6ff;
			border-color: rgba(255,255,255,0.16);
			background: linear-gradient(155deg, #3c3f55 0%, #25283a 100%);
			box-shadow: 0 10px 18px rgba(0,0,0,0.4);
		}

		body.dark-mode #bottom-bar #new-cards-btn::before {
			color: rgba(255,255,255,0.75);
		}

		body.dark-mode #bottom-bar #new-cards-btn.ready-for-next-turn {
			background: linear-gradient(155deg, #ffd560 0%, #ffb23c 100%);
			border-color: rgba(255,255,255,0.35);
		}

		body.dark-mode #bottom-bar #new-cards-btn.ready-for-next-turn::before {
			color: #1c1c1c;
		}

		body.dark-mode #bottom-bar #new-cards-btn:disabled {
			background: linear-gradient(155deg, #3c3f55 0%, #25283a 100%);
			border-color: rgba(255,255,255,0.16);
			box-shadow: none;
			opacity: 0.6;
			cursor: default;
			transform: none;
			pointer-events: none;
		}

		body.dark-mode #bottom-bar #new-cards-btn:disabled::before {
			color: rgba(245,246,255,0.6);
		}

		body.dark-mode #bottom-bar #new-cards-btn.complete-round {
			background: linear-gradient(155deg, #2e7d32 0%, #1b5e20 100%);
			border-color: rgba(129,199,132,0.3);
		}

		body.dark-mode #bottom-bar #new-cards-btn.complete-round::before {
			color: #a5d6a7;
		}

		body.dark-mode #bottom-bar #rotate-card-btn {
			color: #f4f6ff;
			border-color: rgba(255,255,255,0.18);
			background: linear-gradient(155deg, #2b3247 0%, #1c2233 100%);
			box-shadow: 0 9px 18px rgba(0,0,0,0.4);
		}

		body.dark-mode #bottom-bar #rotate-card-btn:disabled {
			opacity: 0.5;
			box-shadow: none;
		}

		#bottom-bar #card-choice-zone .card-option {
			flex: 1 1 auto;
			width: var(--hand-card-width, 75px);
			max-width: var(--hand-card-width, 75px);
			min-height: var(--hand-card-height, 100px);
			padding: 4px 5px 6px;
			display: flex;
			flex-direction: column;
			align-items: center;
			justify-content: center;
			gap: 3px;
			border-radius: 12px;
			background: linear-gradient(165deg, #ffffff 0%, #eef2ff 45%, #dfe4ff 100%);
			border: 1px solid rgba(40,55,120,0.16);
			box-shadow: 0 20px 35px rgba(10,12,20,0.35), 0 8px 16px rgba(10,12,20,0.2);
			scroll-snap-align: center;
			transition: transform 0.2s ease, box-shadow 0.2s ease, border-color 0.2s ease;
			position: relative;
			overflow: hidden;
			z-index: 15;
		}

		#bottom-bar #card-choice-zone .card-option::after {
			content: "";
			position: absolute;
			inset: 0;
			border-radius: inherit;
			background: linear-gradient(120deg, rgba(255,255,255,0.65), rgba(255,255,255,0) 58%);
			opacity: 0.45;
			pointer-events: none;
		}

		#bottom-bar #card-choice-zone .card-option > * {
			position: relative;
			z-index: 1;
		}

		#bottom-bar #card-choice-zone .card-option:hover {
			transform: translateY(-6px);
			box-shadow: 0 26px 44px rgba(20,30,60,0.32);
		}

		#bottom-bar #card-choice-zone .card-option.selected {
			border-color: rgba(82,118,255,0.6);
			box-shadow: 0 28px 48px rgba(70,90,180,0.45);
		}

		#bottom-bar #card-choice-zone .card-pattern {
			display: grid;
			gap: var(--preview-gap);
			align-items: center;
			justify-items: center;
		}

		#bottom-bar #card-choice-zone .card-option .card-cell {
			width: 7px;
			height: 7px;
			/* Border-radius: max 5px, minder rond */
			border-radius: min(5px, calc(7px / 5));
			border: 1px solid rgba(12,16,30,0.1);
			box-shadow: inset 0 0 1px rgba(0,0,0,0.12);
		}

		#bottom-bar #card-choice-zone .card-label {
			display: inline-flex;
			align-items: center;
			gap: 2px;
			padding: 2px 5px;
			border-radius: 999px;
			background: rgba(20,24,36,0.06);
			font-size: 0.56rem;
			font-weight: 600;
			letter-spacing: 0.055em;
			text-transform: uppercase;
			color: rgba(20,24,36,0.62);
		}

		#bottom-bar #card-choice-zone .card-label span {
			display: inline-block;
		}

		#bottom-bar #card-choice-zone .card-label-dot {
			width: 6px;
			height: 6px;
			border-radius: 50%;
			box-shadow: 0 0 3px rgba(0,0,0,0.22);
		}

		#bottom-bar #card-choice-zone .card-meta {
			font-size: 0.6rem;
			letter-spacing: 0.045em;
			color: rgba(20,24,36,0.52);
		}

		body.dark-mode #bottom-bar #card-choice-zone .card-option {
			background: linear-gradient(160deg, #2d3142 0%, #232635 45%, #1b1e2c 100%);
			border-color: rgba(120,140,220,0.18);
			box-shadow: 0 20px 34px rgba(0,0,0,0.5);
		}

		body.dark-mode #bottom-bar #card-choice-zone .card-option::after {
			opacity: 0.25;
		}

		body.dark-mode #bottom-bar #card-choice-zone .card-option .card-cell {
			border-color: rgba(255,255,255,0.08);
			box-shadow: inset 0 0 6px rgba(0,0,0,0.35);
		}

		body.dark-mode #bottom-bar #card-choice-zone .card-label {
			background: rgba(255,255,255,0.08);
			color: rgba(255,255,255,0.8);
		}

		body.dark-mode #bottom-bar #card-choice-zone .card-label-dot {
			box-shadow: 0 0 6px rgba(0,0,0,0.45);
		}

		body.dark-mode #bottom-bar #card-choice-zone .card-meta {
			color: rgba(255,255,255,0.65);
		}

		@media (max-width: 450px) {
			#bottom-bar #card-options {
				transform: none;
			}

			#bottom-bar #card-choice-zone .card-option {
				width: var(--hand-card-width, 50px);
				min-height: var(--hand-card-height, 65px);
				padding: 2px;
			}

			#bottom-bar #card-choice-zone .card-option .card-cell {
				width: 7px;
				height: 7px;
			}

			#bottom-bar #card-choice-zone .card-label {
				font-size: 0.4rem;
			}

			#bottom-bar #card-choice-zone .card-meta {
				font-size: 0.45rem;
			}
			
			#turn-counter-inline {
				display: none;
			}
		}

		#bottom-bar #scoreboard {
			width: 100%;
			max-width: none;
			margin: 0;
			padding: 2px 3px;
			background: rgba(18,20,28,0.9);
			border: 1px solid rgba(255,255,255,0.12);
			border-radius: 10px;
			box-shadow: 0 8px 16px rgba(0,0,0,0.26);
			display: flex;
			flex-direction: row;
			flex-wrap: nowrap;
			gap: 4px;
			justify-content: space-between;
			align-items: center;
			color: #f5f6ff;
		}

		body.dark-mode #bottom-bar #scoreboard {
			background: rgba(12,14,22,0.92);
			border-color: rgba(255,255,255,0.14);
			color: #f5f6ff;
		}

		#bottom-bar #scoreboard::-webkit-scrollbar { display: none; }

		#bottom-bar #scoreboard::before,
		#bottom-bar #scoreboard hr {
			display: none;
		}

		#bottom-bar #scoreboard h2 {
			display: none;
		}

		#bottom-bar #scoreboard .score-row {
			display: flex;
			flex-direction: row;
			align-items: center;
			justify-content: center;
			gap: 4px;
			padding: 2px 4px;
			background: rgba(255,255,255,0.08);
			border-radius: 6px;
			color: inherit;
			font-size: 0.64rem;
			min-width: 0;
			flex: 1 1 auto;
		}

		#bottom-bar #scoreboard .score-row .color-box {
			width: 9px;
			height: 9px;
			border-radius: 50%;
			box-shadow: 0 0 5px rgba(0,0,0,0.26);
			flex-shrink: 0;
		}

		#bottom-bar #scoreboard .score-row .label {
			display: none;
		}

		#bottom-bar #scoreboard .score-row .score {
			margin: 0;
			font-weight: 700;
			font-size: 0.7rem;
			line-height: 1;
		}

		#bottom-bar #scoreboard .score-total {
			display: flex;
			flex-direction: row;
			align-items: center;
			justify-content: center;
			gap: 4px;
			padding: 2px 5px;
			background: rgba(255,255,255,0.12);
			border-radius: 6px;
			font-weight: 700;
			font-size: 0.72rem;
			min-width: 0;
			flex: 1 1 auto;
			box-shadow: none;
			border: none;
			color: inherit;
		}

		#bottom-bar #scoreboard .score-total::before {
			content: none;
		}

		#bottom-bar #scoreboard .score-total .label {
			display: inline;
			font-size: 0.6rem;
			letter-spacing: 0.04em;
			opacity: 0.75;
			line-height: 1;
		}

		#bottom-bar #scoreboard .score-total .total-score {
			font-size: 0.88rem;
			font-weight: 700;
			line-height: 1;
		}

		#bottom-bar #scoreboard .trap-summary {
			padding: 4px 6px;
			gap: 3px;
			border: none;
			border-radius: 6px;
			background: rgba(255,255,255,0.08);
		}

		#bottom-bar #scoreboard .trap-summary-header .trap-label,
		#bottom-bar #scoreboard .trap-summary-header .trap-count {
			display: none;
		}

		body.dark-mode #bottom-bar #scoreboard .trap-summary {
			background: rgba(255,255,255,0.04);
		}

		#bottom-bar #scoreboard .trap-summary-header {
			font-size: 0.58rem;
			letter-spacing: 0.05em;
		}

		#bottom-bar #scoreboard .trap-count {
			font-size: 0.62rem;
		}

		#bottom-bar #scoreboard .trap-preview {
			gap: 3px;
			padding-bottom: 0;
		}

		#bottom-bar #scoreboard .trap-preview.trap-preview--compact {
			gap: 4px;
		}

		#bottom-bar #scoreboard .trap-preview:empty::after {
			display: none;
		}

		#bottom-bar #scoreboard .trap-compact-chip {
			font-size: 0.62rem;
			padding: 1px 6px;
			border-radius: 12px;
		}

		#bottom-bar #scoreboard .trap-icon {
			width: 26px;
			height: 26px;
			border-radius: 8px;
			font-size: 1rem;
			box-shadow: 0 3px 6px rgba(196,56,56,0.16);
		}

		#bottom-bar #scoreboard .trap-icon .penalty-chip {
			right: -4px;
			bottom: -4px;
			font-size: 0.55rem;
			padding: 1px 4px;
		}

		#bottom-bar #scoreboard .trap-icon.trap-icon--black-hole {
			box-shadow: 0 4px 8px rgba(80,60,160,0.2);
		}

		#bottom-bar #gold-zone {
			width: auto;
			max-width: 100%;
			margin: 0;
			padding: 2px 6px;
			background: rgba(18,20,28,0.9);
			border: 1px solid rgba(255,255,255,0.12);
			border-radius: 8px;
			box-shadow: 0 8px 16px rgba(0,0,0,0.26);
			display: flex;
			flex-direction: row;
			align-items: center;
			justify-content: center;
			gap: 6px;
			color: #f5f6ff;
			height: auto;
			min-height: 0;
		}

		body.dark-mode #bottom-bar #gold-zone {
			background: rgba(12,14,22,0.92);
			border-color: rgba(255,255,255,0.14);
		}

		#bottom-bar #gold-zone h2 {
			display: none;
		}

		/* Deck preview (binnen card-action-buttons) */
		.deck-preview {
			display: flex;
			flex-direction: column;
			align-items: center;
			justify-content: center;
			gap: 4px;
			flex: 0 0 auto;
			cursor: pointer;
			background: none;
			border: none;
			box-shadow: none;
			padding: 0;
			min-height: 0;
			transition: transform 0.15s ease;
		}

		.deck-preview:hover {
			transform: translateY(-2px);
		}

		#card-action-buttons .deck-preview {
			order: 3;
			width: 100%;
		}
		
		/* Verberg het ðŸ“š icoon in mobiele versie - alleen deck-count tonen */
		#card-action-buttons .deck-preview::before {
			display: none;
		}

		#card-action-buttons .deck-preview::after {
			display: none;
		}

		#card-action-buttons .deck-preview:focus-visible {
			outline: 2px solid rgba(255,215,80,0.7);
			outline-offset: 4px;
		}

		body.dark-mode #card-action-buttons .deck-preview:focus-visible {
			outline-color: rgba(120,160,255,0.65);
		}

		#bottom-bar #card-action-buttons {
			position: relative;
		}

		#bottom-bar #card-action-buttons .deck-preview {
			position: static;
		}

		.deck-count {
			background: linear-gradient(145deg, #ffd560, #ffb23c);
			border: 1px solid rgba(255,255,255,0.35);
			border-radius: 10px;
			padding: 6px 10px;
			font-size: 0.95rem;
			font-weight: 700;
			color: #1c1c1c;
			box-shadow: 0 6px 12px rgba(0,0,0,0.26);
			min-width: 46px;
			text-align: center;
			display: flex;
			align-items: center;
			justify-content: center;
			gap: 4px;
			pointer-events: auto;
		}

		.deck-preview:focus-visible .deck-count {
			outline: 3px solid rgba(255, 215, 80, 0.9);
			outline-offset: 3px;
		}

		body.dark-mode .deck-preview:focus-visible .deck-count {
			outline-color: rgba(120, 160, 255, 0.8);
		}

		.deck-count::before {
			content: 'ðŸ“š';
			font-size: 1.1rem;
		}

		body.dark-mode .deck-count {
			background: linear-gradient(145deg, #2f3546, #1c2233);
			border-color: rgba(255,255,255,0.12);
			color: rgba(255,255,255,0.88);
		}

		.preview-card {
			display: none;
		}


		#bottom-bar #gold-zone h2 {
			display: none;
		}

		/* Mobile: keep coin counter next to the buy button. */
		#bottom-bar #gold-zone::before {
			display: none;
			content: none;
		}
		#bottom-bar #gold-zone::after {
			content: '\1FA99  ' attr(data-coin-text);
			display: inline-flex;
			align-items: center;
			justify-content: center;
			order: 1;
			text-align: center;
			font-size: 0.82rem;
			font-weight: 800;
			color: #f5f6ff;
			padding: 0;
			background: transparent;
			border: none;
			white-space: nowrap;
			opacity: 0.92;
			font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", "Helvetica Neue", Arial, sans-serif, "Segoe UI Emoji", "Apple Color Emoji", "Noto Color Emoji";
		}

		#bottom-bar #collected-coins {
			display: none !important;
		}
		
		/* Mobiele +1 blokplaatsing knop */
		#bottom-bar .buy-placement-btn {
			padding: 4px 8px;
			font-size: 0.7rem;
			border-radius: 6px;
			margin: 0;
			gap: 3px;
		}
		#bottom-bar .buy-placement-arrow {
			font-size: 0.9rem;
		}
		#bottom-bar .buy-placement-rainbow-cell {
			width: 14px;
			height: 14px;
			/* Border-radius: max 5px, minder rond */
			border-radius: min(5px, calc(14px / 5));
		}
		#bottom-bar .buy-placement-cost {
			padding: 1px 4px;
			font-size: 0.65rem;
		}

		#bottom-bar .coin {
			width: 13px;
			height: 13px;
			border-radius: 50%;
			background: rgba(255,255,255,0.18);
			border: 1px solid rgba(255,255,255,0.26);
			box-shadow: inset 0 0 0 1px rgba(0,0,0,0.22), 0 0 4px rgba(0,0,0,0.2);
			transition: transform 0.2s ease, background 0.2s ease, border-color 0.2s ease, box-shadow 0.2s ease;
		}

		#bottom-bar .coin.active {
			background: radial-gradient(circle at 30% 30%, #fff6b5, #f7bb36 70%);
			border-color: #f3b12b;
			box-shadow: 0 0 8px rgba(255,209,90,0.78), inset 0 0 2px rgba(255,255,255,0.85);
			transform: scale(1.05);
		}

		#bottom-bar .coin.used {
			background: rgba(80,82,95,0.65);
			border-color: rgba(120,124,140,0.6);
			box-shadow: inset 0 0 0 1px rgba(0,0,0,0.4);
			transform: scale(1);
		}

		body.dark-mode #bottom-bar .coin {
			background: rgba(255,255,255,0.14);
			border-color: rgba(255,255,255,0.24);
		}

		body.dark-mode #bottom-bar .coin.used {
			background: rgba(60,60,72,0.7);
			border-color: rgba(110,110,130,0.55);
			box-shadow: inset 0 0 0 1px rgba(0,0,0,0.55);
			transform: scale(1);
		}

		body.dark-mode #bottom-bar .coin.active {
			background: radial-gradient(circle at 30% 30%, #ffe58c, #f5b72f 70%);
		}

		/* Mobile bonus-inventory: hide labels, show only swatches + counts */
		@media (max-width: 650px) {
			/* Two-row footer:
			   - row 1 (top): bonus inventory + coin total + buy button
			   - row 2 (bottom): scoreboard
			   Keeps everything visible with minimal height. */
			#bottom-bar-left {
				display: flex;
				flex-direction: column;
				align-items: stretch;
				justify-content: flex-start;
				gap: 6px;
				width: 100%;
				min-width: 0;
			}

			#bottom-bar-bonus {
				display: flex !important;
				flex-direction: row;
				align-items: center;
				justify-content: flex-start;
				gap: 8px;
				min-width: 0;
				padding: 0;
			}

			#bottom-bar-score-coins {
				display: flex;
				flex-direction: row;
				gap: 0;
				align-items: stretch;
			}

			#bottom-bar-score {
				flex: 1 1 auto;
				min-width: 0;
			}

			/* Give the bonus inventory most of the width (70/30 split vs coins) WITHOUT leaving a visible gap. */
			#bottom-bar-bonus {
				gap: 6px;
			}
			#bottom-bar-bonus #bonus-zone {
				flex: 1 1 auto;
				min-width: 0;
			}
			#bottom-bar-bonus #gold-zone {
				flex: 0 0 auto;
				min-width: 0;
			}

			#bottom-bar #gold-zone {
				flex: 0 1 auto;
			}

			#bottom-bar #buy-placement-container {
				flex: 0 1 auto;
				display: flex;
				align-items: center;
				justify-content: center;
				order: 2;
				margin: 0;
				padding: 0;
			}

			/* Inside the bottom bar, the bonus zone should not look like a big panel. */
			#bottom-bar #bonus-zone {
				background: transparent !important;
				border: none !important;
				box-shadow: none !important;
				padding: 0 !important;
				gap: 0 !important;
			}

			#bottom-bar #bonus-zone h2,
			#bottom-bar #bonus-zone .bonus-hint {
				display: none !important;
			}

			/* One-line, low-height bonus badges: must fit 5 side-by-side. */
			#bottom-bar .bonus-inventory {
				display: flex;
				flex-wrap: nowrap;
				gap: 3px;
				align-items: center;
				justify-content: space-between;
				overflow: hidden;
				padding: 0;
			}
			#bottom-bar .bonus-inventory::-webkit-scrollbar { display: none; }

			#bottom-bar .bonus-badge {
				flex: 1 1 0;
				min-width: 0;
				padding: 2px 4px;
				border-radius: 10px;
				gap: 3px;
				font-size: 0.58rem;
				line-height: 1;
				justify-content: center;
			}

			#bottom-bar .bonus-badge .bonus-swatch {
				width: 10px;
				height: 10px;
			}

			#bottom-bar .bonus-badge .bonus-count {
				margin-left: 0;
				font-size: 0.58rem;
				padding: 0 4px;
			}

			/* #gold-zone is styled as a compact pill globally; no special nesting needed. */

			#bottom-bar #gold-zone::after {
				font-size: 0.82rem;
				font-weight: 800;
			}

			#bottom-bar .buy-placement-btn {
				padding: 4px 8px;
				font-size: 0.66rem;
				border-radius: 8px;
				margin-top: 0 !important;
			}

			#bottom-bar .buy-placement-cost {
				font-size: 0.62rem;
				padding: 1px 4px;
			}

			/* Ensure bonus inventory stays one line (no vertical wrap) and looks compact. */
			#bottom-bar-bonus .bonus-inventory {
				display: flex;
				flex-wrap: nowrap;
				gap: 3px;
				justify-content: space-between;
				align-items: center;
				overflow: hidden;
				padding: 0;
			}
			#bottom-bar-bonus .bonus-inventory::-webkit-scrollbar { display: none; }

			#bottom-bar-bonus #bonus-zone {
				background: transparent !important;
				border: none !important;
				box-shadow: none !important;
				padding: 0 !important;
			}

			#bottom-bar-bonus .bonus-badge .bonus-label { display: none !important; }
			#bottom-bar-bonus .bonus-badge .bonus-swatch {
				width: 10px;
				height: 10px;
				border-radius: 3px;
			}
			#bottom-bar-bonus .bonus-badge .bonus-count {
				margin-left: 0;
				font-size: 0.58rem;
				padding: 0 4px;
			}

			/* Mobile: show ONLY the total coin text (under the buy button), never the coin circles. */
			#bottom-bar #gold-zone::before {
				display: none !important;
				content: none !important;
			}
			#bottom-bar #gold-zone::after {
				display: block !important;
			}

			#bottom-bar #collected-coins,
			#bottom-bar .coin {
				display: none !important;
			}

			/* Mobile cards strip: keep buttons fully inside the bar.
			   Reduce left padding and reserve a bit more space on the right. */
			#bottom-bar #card-controls {
				gap: 6px;
			}
			#bottom-bar #card-options {
				padding-left: 2px;
				padding-right: 14px;
				max-width: none;
			}
			#bottom-bar #card-action-buttons {
				flex: 0 0 52px;
			}
		}

		@media (max-width: 550px) {
			/* Compact mode: prevent coins/buy from pushing bonus inventory away. */
			.bottom-bar-footer {
				margin-top: 0 !important;
			}

			#bottom-bar-bonus {
				gap: 6px;
			}
			#bottom-bar-bonus #bonus-zone {
				flex: 7 1 0 !important;
				min-width: 0 !important;
				padding: 0 !important;
			}
			#bottom-bar-bonus #gold-zone {
				flex: 3 1 0 !important;
				min-width: 0 !important;
			}
			#bottom-bar .bonus-inventory,
			#bottom-bar-bonus .bonus-inventory {
				margin: 0 !important;
				overflow: hidden !important;
				flex-wrap: nowrap !important;
				align-items: center;
			}

			#bottom-bar .bonus-badge {
				padding: 2px 5px;
				border-radius: 9px;
				font-size: 0.58rem;
			}
			#bottom-bar .bonus-badge .bonus-swatch {
				width: 10px;
				height: 10px;
			}
			#bottom-bar .bonus-badge .bonus-count {
				font-size: 0.58rem;
				padding: 0 4px;
			}

			#bottom-bar #gold-zone {
				padding: 2px 4px !important;
				background: transparent !important;
				border: none !important;
				box-shadow: none !important;
				gap: 6px !important;
			}

			#bottom-bar #gold-zone::before {
				display: none !important;
				content: none !important;
			}

			#bottom-bar #gold-zone::after {
				font-size: 0.76rem;
				font-weight: 800;
			}

			#bottom-bar .buy-placement-btn {
				margin-top: 0 !important;
				padding: 3px 6px !important;
				gap: 4px !important;
				border: none !important;
				box-shadow: none !important;
				font-size: 0.62rem !important;
			}
			#bottom-bar .buy-placement-arrow { font-size: 0.8rem !important; }
			#bottom-bar .buy-placement-rainbow-cell { width: 12px !important; height: 12px !important; border-radius: min(5px, calc(12px / 5)) !important; }
			#bottom-bar .buy-placement-cost { font-size: 0.58rem !important; padding: 0 3px !important; }

			/* Bonus upgrade shop is no longer accessed via a button. */
			#bonus-shop-btn,
			#bottom-bar #bonus-shop-btn {
				display: none !important;
			}

			/* Make the key action buttons smaller on very compact mobile. */
			#bottom-bar #new-cards-btn,
			#bottom-bar #bonus-shop-btn {
				height: 42px;
				padding: 6px 10px;
				font-size: 0.68rem;
			}

			#card-action-buttons .card-action-btn,
			#card-action-buttons .deck-preview {
				min-height: 42px;
				width: 42px;
				border-radius: 12px;
			}

			#card-action-buttons .deck-count {
				padding: 0;
				font-size: 0.72rem;
				border-radius: 0;
				min-width: 0;
			}
			#card-action-buttons .deck-count::before { display: none; }

			/* Deck: show icon above smaller number (narrower). */
			#card-action-buttons .deck-preview {
				flex-direction: column;
				gap: 2px;
			}
			#card-action-buttons .deck-preview::before {
				content: 'ðŸ“š';
				display: block;
				font-size: 1.05rem;
				line-height: 1;
			}
		}
	}


	.score-popup {
	  position: absolute;
	  font-size: 1.4rem;
	  font-weight: bold;
	  color: #222;
	  text-shadow: 0 0 8px rgba(255, 255, 255, 0.8);
	  pointer-events: none;
	  opacity: 0;
	  transform: translateY(0);
	  animation: floatUp 1s ease-out forwards;
	  z-index: var(--z-score);
	}

	@keyframes floatUp {
	  0% {
		opacity: 1;
		transform: translateY(0);
	  }
	  100% {
		opacity: 0;
		transform: translateY(-40px);
	  }
	}
	
	.sparkle {
	  position: absolute;
	  width: 16px;
	  height: 16px;
	  border-radius: 70%;
	  background: gold;
	  opacity: 0.5;
	  animation: sparkle 1.8s ease-out forwards;
	  pointer-events: none;
	  z-index: var(--z-score);
	}

	@keyframes sparkle {
	  0% { transform: scale(1) translate(0, 0); opacity: 1; }
	  100% { transform: scale(0) translate(var(--dx), var(--dy)); opacity: 0; }
	}
	
		/* Zorg dat .flash overal kan werken */
	.flash {
	  animation: flashAnim 0.4s ease;
	}

	@keyframes flashAnim {
	  0% {
		transform: scale(1.4);
		color: #fff;
		text-shadow: 0 0 8px #fff;
		filter: brightness(2);
	  }
	  100% {
		transform: scale(1);
		text-shadow: none;
		filter: brightness(1);

	  }
}


	/* ============================================
	   DARK MODE TOGGLE BUTTON (DESKTOP)
	   ============================================
	   Ronde knop rechtsboven voor dark/light mode wisselen
	   Alleen zichtbaar op desktop (>650px)
	   Op mobiel zit dark mode toggle in hamburger menu
	*/
	#dark-mode-toggle {
	  position: fixed;
	  top: 15px;
	  right: 15px;
	  background: #fff;
	  color: #333;
	  border: none;
	  border-radius: 50%;
	  width: 40px;
	  height: 40px;
	  font-size: 20px;
	  cursor: pointer;
	  box-shadow: 0 2px 6px rgba(0,0,0,0.25);
	  transition: background 0.3s, transform 0.2s;
	  z-index: 2000;
	}
	/* Dark/light is available in the hamburger menu; hide this floating button to save top space. */
	#dark-mode-toggle { display: none !important; }

	@media (max-width: 650px) {
	  #dark-mode-toggle {
		display: none; /* Op mobiel gebruiken we de knop in het menu */
	  }
	}

	#dark-mode-toggle:hover {
	  transform: scale(1.1);
	}

	/* ============================================
	   DARK MODE ALGEMEEN - DESKTOP/SHARED
	   ============================================
	   Extra dark mode styling voor desktop elementen
	   Basis dark mode staat bovenaan in het bestand
	*/

	/* Titels krijgen lichtblauwe gloed voor betere zichtbaarheid */
	body.dark-mode h1, 
	body.dark-mode #total-score {
	  color: #f0f3ff;
	  text-shadow: 0 0 10px rgba(100, 150, 255, 0.3);
	}

	body.dark-mode h2 {
	  color: #a0a3ad;
	  font-weight: 500;
	}

	/* Cellen: donker met blauwe gloed bij activatie */
	body.dark-mode .cell {
	  background: #272a31;
	  border: 1px solid #3a3d45;
	  color: #ddd;
	  transition: background 0.25s, transform 0.15s;
	}

	body.dark-mode .cell.active {
	  background: #3a6ff7;
	  color: #fff;
	  box-shadow: 0 0 8px rgba(58,111,247,0.4);
	}

	/* Hover effect op cellen */
	body.dark-mode .cell:hover {
	  background: #31343b;
	}

	/* Symbolen iets minder verzadigd in dark mode */
	body.dark-mode .symbol {
	  filter: brightness(0.9) saturate(0.9);
	}

	body.dark-mode .symbol.trap-symbol {
	  background: #555555;
	}

	body.dark-mode .symbol.trap-symbol::after {
	  background: linear-gradient(135deg, rgba(220,220,220,0.25) 0%, rgba(220,220,220,0) 50%);
	}

	body.dark-mode .symbol.trap-symbol.trap-symbol--black-hole {
	  background: radial-gradient(circle, #2a2a3e 0%, #1a1a2e 60%, #0a0a15 100%);
	  border-radius: 50%;
	  box-shadow: 
		0 0 20px rgba(138, 43, 226, 0.8),
		0 0 30px rgba(75, 0, 130, 0.6),
		inset 0 0 25px rgba(138, 43, 226, 0.4);
	  border: 2px solid rgba(138, 43, 226, 0.6);
	}

	body.dark-mode .symbol.trap-symbol.trap-symbol--black-hole::after {
	  background: radial-gradient(circle, rgba(138, 43, 226, 0.3) 0%, transparent 70%);
	  opacity: 1;
	  border-radius: 50%;
	}
	
	/* Gouden vak wordt donkergrijs met scoreboard styling */
	body.dark-mode #gold-zone { 
		background: linear-gradient(145deg, #22252b, #1a1c21);
		border: 1px solid #2d2f36;
		box-shadow: 0 0 12px rgba(0,0,0,0.6);
		color: #e5e5e5;
	}

	/* Scorebord dark mode styling */
	body.dark-mode #scoreboard {
	  background: linear-gradient(145deg, #22252b, #1a1c21);
	  border: 1px solid #2d2f36;
	  box-shadow: 0 0 12px rgba(0,0,0,0.6);
	  color: #e5e5e5;
	}
	
	body.dark-mode .score-row { 
		background: #2a2d35;
		color: #e5e5e5;
	}

	/* Dark mode knop zelf krijgt ook dark styling */
	body.dark-mode #dark-mode-toggle {
	  background: #2d2f35;
	  color: #f0f3ff;
	  box-shadow: 0 2px 6px rgba(0,0,0,0.5);
	}

	/* ============================================
	   KAART SYSTEEM - BASIS
	   ============================================
	   Kaarten die je kunt plaatsen op het bord
	   Gebruikt CSS Grid voor cel-layout binnen kaart
	*/
	.card {
	  display: grid;
	  background: #f0f0f0;
	  border-radius: 8px;
	  transition: transform 0.2s, box-shadow 0.2s;
	}
	
	/* kaarten */
	body.dark-mode .card {
	  background: #333;
	}
	
	.card:hover {
	  transform: scale(1.05);
	  box-shadow: 0 0 6px rgba(0,0,0,0.25);
	}
	.card-cell {
	  width: var(--card-cell-size, 20px);
	  height: var(--card-cell-size, 20px);
	  /* Border-radius: max 5px, minder rond voor kleine cells */
	  border-radius: min(5px, calc(var(--card-cell-size, 20px) / 5));
	}

	.card.selected {
	  outline: 3px solid #7a8aad;
	}
	
	body.dark-mode .card.selected {
	  outline: 3px solid #a7a9ad;
	}

	.draggable {
	  cursor: none;
	  transition: box-shadow 0.2s;
	  z-index: var(--z-draggable);
	}

	.draggable:active {
	  cursor: none;
	  box-shadow: 0 0 10px rgba(0,0,0,0.5);
	}
	
	/* preview styling - cells blijven exact dezelfde grootte als grid cells */
	.cell.preview-allowed {
	  outline: 2px solid rgba(0,200,100,0.8);
	  transition: outline 0.08s;
	}
	.cell.preview-denied {
	  outline: 2px solid rgba(220,20,60,0.8);
	  transition: outline 0.08s;
	}
	
	body.dragging * {
	  cursor: none !important;
	  -webkit-user-select: none !important;
	  user-select: none !important;
	}

	.draggable { touch-action: none; user-select: none; cursor: none; }

	/* ============================================
	   BONUS INVENTORY STYLING (GLOBAL)
	   ============================================
	   Werkt voor zowel desktop (#bonus-zone) als mobiel (#bottom-bar-bonus)
	   Specifieke overrides voor mobiel staan in de mobiele media queries
	*/
	:is(#bonus-zone, #bottom-bar-bonus) .bonus-badge {
		position: relative;
		overflow: hidden;
		appearance: none;
		display: inline-flex;
		align-items: center;
		gap: 6px;
		border: 1px solid transparent;
		border-radius: 12px;
		padding: 6px 10px;
		font-size: 0.74rem;
		color: #1c2434;
		background: linear-gradient(150deg, rgba(255,255,255,0.96) 0%, rgba(236,246,255,0.92) 100%);
		box-shadow: 0 10px 22px rgba(10, 12, 20, 0.22);
		transition: transform 0.15s ease, box-shadow 0.15s ease;
		cursor: pointer;
	}

	:is(#bonus-zone, #bottom-bar-bonus) .bonus-badge::before {
		content: "";
		position: absolute;
		inset: 0;
		background: linear-gradient(120deg, rgba(255,255,255,0.4), rgba(255,255,255,0));
		opacity: 0.45;
		pointer-events: none;
	}

	:is(#bonus-zone, #bottom-bar-bonus) .bonus-badge:not(.disabled):hover {
		transform: translateY(-1px);
		box-shadow: 0 14px 30px rgba(10, 12, 20, 0.28);
	}

	:is(#bonus-zone, #bottom-bar-bonus) .bonus-badge .bonus-count {
		background: rgba(255,255,255,0.32);
		color: inherit;
		margin-left: auto;
		font-variant-numeric: tabular-nums;
		font-weight: 600;
		padding: 2px 6px;
		border-radius: 12px;
	}

	:is(#bonus-zone, #bottom-bar-bonus) .bonus-badge .bonus-swatch {
		width: 14px;
		height: 14px;
		border-radius: 50%;
		flex-shrink: 0;
		box-shadow: inset 0 0 0 1px rgba(0,0,0,0.25);
	}

	:is(#bonus-zone, #bottom-bar-bonus) .bonus-badge .bonus-label {
		position: absolute;
		clip: rect(0 0 0 0);
		clip-path: inset(50%);
		height: 1px;
		width: 1px;
		overflow: hidden;
		white-space: nowrap;
	}

	:is(#bonus-zone, #bottom-bar-bonus) .bonus-badge[data-bonus-color="geel"] {
		background: linear-gradient(135deg, #fff2b0, #f2c94c);
		border-color: rgba(214, 176, 68, 0.6);
		color: #463100;
	}

	:is(#bonus-zone, #bottom-bar-bonus) .bonus-badge[data-bonus-color="rood"] {
		background: linear-gradient(135deg, #ffd6d3, #f58f9c);
		border-color: rgba(212, 112, 122, 0.55);
		color: #4a1420;
	}

	:is(#bonus-zone, #bottom-bar-bonus) .bonus-badge[data-bonus-color="groen"] {
		background: linear-gradient(135deg, #d5f5d2, #8fcfa0);
		border-color: rgba(104, 180, 126, 0.55);
		color: #143720;
	}

	:is(#bonus-zone, #bottom-bar-bonus) .bonus-badge[data-bonus-color="paars"] {
		background: linear-gradient(135deg, #eadcff, #b9a4f9);
		border-color: rgba(146, 110, 209, 0.55);
		color: #2d1955;
	}

	:is(#bonus-zone, #bottom-bar-bonus) .bonus-badge[data-bonus-color="blauw"] {
		background: linear-gradient(135deg, #d3e9ff, #8cbaf5);
		border-color: rgba(94, 138, 196, 0.55);
		color: #123357;
	}

	:is(#bonus-zone, #bottom-bar-bonus) .bonus-badge.active {
		box-shadow: 0 0 0 2px rgba(82,118,255,0.38), 0 12px 28px rgba(48,72,140,0.35);
	}

	:is(#bonus-zone, #bottom-bar-bonus) .bonus-badge.bonus-mastered {
		border-style: solid;
		box-shadow: 0 0 0 2px rgba(255, 215, 0, 0.6), 0 16px 30px rgba(255, 215, 0, 0.35);
	}

	:is(#bonus-zone, #bottom-bar-bonus) .bonus-badge.bonus-mastered .bonus-count {
		background: rgba(255, 255, 255, 0.6);
		color: inherit;
		font-weight: 700;
	}

	:is(#bonus-zone, #bottom-bar-bonus) .bonus-badge.disabled,
	:is(#bonus-zone, #bottom-bar-bonus) .bonus-badge:disabled {
		opacity: 0.9;
		box-shadow: none;
		border-style: dashed;
		color: inherit;
	}

	:is(#bonus-zone, #bottom-bar-bonus) .bonus-badge.bonus-mastered.disabled,
	:is(#bonus-zone, #bottom-bar-bonus) .bonus-badge.bonus-mastered:disabled {
		opacity: 1;
		border-style: solid;
	}

	:is(#bonus-zone, #bottom-bar-bonus) .bonus-badge.disabled::before,
	:is(#bonus-zone, #bottom-bar-bonus) .bonus-badge:disabled::before {
		opacity: 0.2;
	}

	:is(#bonus-zone, #bottom-bar-bonus) .bonus-badge.disabled::after,
	:is(#bonus-zone, #bottom-bar-bonus) .bonus-badge:disabled::after {
		content: "";
		position: absolute;
		inset: 0;
		background: linear-gradient(0deg, rgba(255,255,255,0.55), rgba(255,255,255,0));
		pointer-events: none;
	}

	/* Dark mode bonus badges */
	body.dark-mode :is(#bonus-zone, #bottom-bar-bonus) .bonus-badge {
		box-shadow: 0 16px 32px rgba(0,0,0,0.5);
		color: #f5f6ff;
	}
	body.dark-mode :is(#bonus-zone, #bottom-bar-bonus) .bonus-badge.bonus-mastered {
		box-shadow: 0 0 0 2px rgba(255, 214, 97, 0.7), 0 16px 34px rgba(255, 214, 97, 0.42);
	}

	body.dark-mode :is(#bonus-zone, #bottom-bar-bonus) .bonus-badge::before {
		background: linear-gradient(120deg, rgba(255,255,255,0.18), rgba(255,255,255,0));
		opacity: 0.3;
	}

	body.dark-mode :is(#bonus-zone, #bottom-bar-bonus) .bonus-badge[data-bonus-color="geel"] {
		background: linear-gradient(140deg, rgba(255, 207, 102, 0.24), rgba(198, 147, 44, 0.58));
		border-color: rgba(255, 207, 102, 0.45);
		color: #fff3c0;
	}

	body.dark-mode :is(#bonus-zone, #bottom-bar-bonus) .bonus-badge[data-bonus-color="rood"] {
		background: linear-gradient(140deg, rgba(255, 170, 174, 0.25), rgba(215, 90, 112, 0.6));
		border-color: rgba(215, 90, 112, 0.45);
		color: #ffd6dc;
	}

	body.dark-mode :is(#bonus-zone, #bottom-bar-bonus) .bonus-badge[data-bonus-color="groen"] {
		background: linear-gradient(140deg, rgba(158, 223, 175, 0.2), rgba(78, 148, 102, 0.55));
		border-color: rgba(118, 186, 136, 0.45);
		color: #ddffe7;
	}

	body.dark-mode :is(#bonus-zone, #bottom-bar-bonus) .bonus-badge[data-bonus-color="paars"] {
		background: linear-gradient(140deg, rgba(210, 186, 255, 0.24), rgba(120, 92, 190, 0.65));
		border-color: rgba(167, 132, 230, 0.45);
		color: #f0e9ff;
	}

	body.dark-mode :is(#bonus-zone, #bottom-bar-bonus) .bonus-badge[data-bonus-color="blauw"] {
		background: linear-gradient(140deg, rgba(168, 205, 255, 0.22), rgba(70, 116, 186, 0.6));
		border-color: rgba(120, 162, 226, 0.45);
		color: #e2f1ff;
	}

	body.dark-mode :is(#bonus-zone, #bottom-bar-bonus) .bonus-badge.active {
		box-shadow: 0 0 0 2px rgba(142,174,255,0.38), 0 16px 32px rgba(0,0,0,0.55);
	}

	body.dark-mode :is(#bonus-zone, #bottom-bar-bonus) .bonus-badge.disabled,
	body.dark-mode :is(#bonus-zone, #bottom-bar-bonus) .bonus-badge:disabled {
		opacity: 0.85;
		border-color: rgba(142,174,255,0.35);
	}

	body.dark-mode :is(#bonus-zone, #bottom-bar-bonus) .bonus-badge.disabled::after,
	body.dark-mode :is(#bonus-zone, #bottom-bar-bonus) .bonus-badge:disabled::after {
		background: linear-gradient(0deg, rgba(4,6,14,0.55), rgba(4,6,14,0));
	}

	body.dark-mode :is(#bonus-zone, #bottom-bar-bonus) .bonus-badge .bonus-count {
		background: rgba(12,14,20,0.55);
		color: #f5f6ff;
	}

	

	/* ============================================
	   DESKTOP LAYOUT (>650px)
	   ============================================
	   Op grotere schermen gebruiken we een 4-kolommen layout
	   zonder bottom-bar. Alle controls zijn altijd zichtbaar.
	   
	   Kolom 1: Paars + Rood vak
	   Kolom 2: Groen + Geel vak
	   Kolom 3: Blauw vak
	   Kolom 4: Score, Munten, Bonus, Doelen
	*/
	@media (min-width: 651px) {
	  html {
		background: #2d3142;
		overflow: hidden;
		height: 100%;
	  }

	  html, body {
		scrollbar-width: none;
		-ms-overflow-style: none;
	  }

	  html::-webkit-scrollbar,
	  body::-webkit-scrollbar {
		display: none;
		width: 0;
		height: 0;
	  }

	  body {
		display: grid;
		position: static;
		margin: 0;
		padding: 10px;
		min-height: 100vh;
		min-height: 100svh;
		width: 100%;
		background: #2d3142;
		color: #e5e5e5;
		overflow: hidden;
	  }

	  body.dark-mode {
		background: #1b1d22;
		color: #e5e5e5;
	  }

	  /* ============================================
	     DESKTOP LAYOUT REORGANISATIE
	     ============================================
	     - Doel bovenaan (boven de grids)
	     - Menu linksbovenin
	     - Grids centraal
	     - Score, bonussen en kaarten onderaan
	  */

  /* Wrapper voor desktop layout */
  #desktop-wrapper {
	display: grid;
	grid-template-areas:
	  "menu objective objective"
	  "left grids right"
	  "left bottom right";
		grid-template-columns: minmax(200px, 280px) 1fr minmax(200px, 290px);
	grid-template-rows: auto 1fr auto;
	gap: 16px;
	padding: 12px;
	/* Use 100% instead of 100vw to avoid horizontal clipping inside padded body. */
	width: 100%;
	height: calc(100vh - 20px);
	box-sizing: border-box;
	margin: 0 auto;
	position: relative;
	/* Allow board shadows / scaled content without being clipped by the wrapper. */
	overflow: visible;
	transform-origin: top center;
  }

	  /* Portrait mode: stack (objective -> board -> bottom) so nothing ends up off-screen on narrow widths. */
	  body.desktop-portrait {
		/* No scrolling - everything should fit */
		overflow: hidden;
	  }

	  body.desktop-portrait #desktop-wrapper {
		display: flex;
		flex-direction: column;
		flex-wrap: nowrap;
		align-items: center;
		justify-content: flex-start;
		gap: 4px;
		width: 100%;
		max-width: 100%;
		margin: 0 auto;
		padding: 6px;
		box-sizing: border-box;
		height: calc(100vh - 20px);
		height: calc(100svh - 20px);
		min-height: 0;
		max-height: none;
		overflow: hidden;
	  }

	  /* Hide empty sidebars in portrait: JS moves content into #desktop-bottom. */
	  body.desktop-portrait #desktop-left,
	  body.desktop-portrait #desktop-right {
		display: none !important;
	  }

	  /* Board area - don't stretch, just fit content and scale */
	  body.desktop-portrait #desktop-grids {
		flex: 0 0 auto;
		min-height: 0;
		width: 100%;
		display: flex;
		justify-content: center;
		align-items: flex-start;
		overflow: visible;
	  }

	  /* Scale board to fit in constrained portrait */
	  body.desktop-portrait #desktop-grids .board {
		transform-origin: top center;
	  }

	  body.desktop-portrait #desktop-bottom {
		flex: 0 0 auto;
		width: 100%;
		max-width: 100%;
		margin-top: 2px;
	  }

	  /* Narrow desktop portrait (split-screen / iPad-ish): keep bottom UI compact so the board keeps height. */
	  @media (min-width: 651px) and (max-width: 925px) {
		/* Compact objective in portrait */
		body.desktop-portrait #objective-zone {
			padding: 6px 12px;
			min-height: 32px;
			gap: 8px;
		}
		body.desktop-portrait #objective-zone h2 {
			font-size: 0.85rem;
		}
		body.desktop-portrait #objective-current {
			font-size: 0.8rem;
		}
		
		body.desktop-portrait #desktop-bottom {
			flex-wrap: nowrap;
			justify-content: center;
			align-items: stretch;
			gap: 8px;
			padding: 4px 8px;
			max-height: 160px;
		}

		body.desktop-portrait #desktop-bottom-left {
			flex: 0 0 140px !important;
			min-width: 130px !important;
			max-width: 160px !important;
		}

		body.desktop-portrait #desktop-bottom-center {
			flex: 1 1 auto !important;
			min-width: 180px !important;
			max-width: 350px !important;
			align-items: center;
		}
		
		/* On touch devices (iPad portrait), action buttons go INSIDE bottom-center, below cards */
		body.desktop-portrait.touch-portrait #desktop-bottom-center #card-action-buttons {
			display: flex !important;
			flex-direction: row;
			gap: 6px;
			align-items: center;
			justify-content: center;
			margin-top: 6px;
			padding: 0;
			width: 100%;
		}
		body.desktop-portrait.touch-portrait #desktop-bottom-center .card-action-btn,
		body.desktop-portrait.touch-portrait #desktop-bottom-center .deck-preview {
			width: 36px;
			min-width: 36px;
			height: 36px;
			min-height: 36px;
			padding: 6px;
		}

		body.desktop-portrait #desktop-bottom-buttons {
			flex: 0 0 auto;
			min-width: 0;
			width: auto;
		}

		body.desktop-portrait #desktop-bottom-right {
			flex: 0 0 110px !important;
			min-width: 100px !important;
			max-width: 130px !important;
		}

		/* Card panel: remove extra vertical chrome and force a single row of cards. */
		body.desktop-portrait #card-choice-zone {
			padding: 4px 6px;
		}
		body.desktop-portrait #card-choice-zone h2,
		body.desktop-portrait #kiesKaartTitel,
		body.desktop-portrait #card-choice-zone br {
			display: none !important;
		}
		body.desktop-portrait #desktop-bottom-center #card-controls {
			flex-direction: row;
			justify-content: center;
			width: fit-content;
		}
		body.desktop-portrait #desktop-bottom-center #card-options {
			flex-wrap: nowrap;
			justify-content: center;
			gap: 6px;
			width: fit-content;
		}
		body.desktop-portrait #desktop-bottom-center .card-option {
			width: 60px;
			max-width: 60px;
			min-height: 85px;
			padding: 4px;
			gap: 4px;
			--preview-cell: 12px;
		}
		body.desktop-portrait #desktop-bottom-center .card-option .card-cell {
			width: 10px;
			height: 10px;
		}
		body.desktop-portrait #desktop-bottom-center .card-label {
			font-size: 0.5rem;
			padding: 2px 4px;
		}

		/* Buttons: smaller footprint in the dedicated portrait button column. */
		body.desktop-portrait #desktop-bottom-buttons #card-action-buttons {
			display: flex !important;
			flex-direction: column;
			gap: 4px;
			align-items: center;
			justify-content: flex-start;
			margin: 0;
			padding: 0;
		}
		body.desktop-portrait #desktop-bottom-buttons .card-action-btn,
		body.desktop-portrait #desktop-bottom-buttons .deck-preview {
			width: 36px;
			min-width: 36px;
			max-width: 36px;
			height: 36px;
			min-height: 36px;
			padding: 6px;
		}
		body.desktop-portrait #desktop-bottom-buttons .card-action-btn::before {
			font-size: 0.95rem;
		}
		body.desktop-portrait #desktop-bottom-buttons .deck-preview::before {
			font-size: 0.9rem;
		}
		body.desktop-portrait #desktop-bottom-buttons .deck-count {
			font-size: 0.6rem;
		}

		/* Scoreboard: compact but readable */
		body.desktop-portrait #scoreboard {
			padding: 6px 8px;
			background: rgba(40, 45, 60, 0.9);
			border-radius: 8px;
		}
		body.desktop-portrait #scoreboard h2,
		body.desktop-portrait #scoreboard hr {
			display: none;
		}
		body.desktop-portrait #scoreboard .score-row {
			font-size: 0.75rem;
			padding: 2px 4px;
			gap: 6px;
		}
		body.desktop-portrait #scoreboard .score-row .label {
			display: none;
		}
		body.desktop-portrait #scoreboard .score-row .color-box {
			width: 12px;
			height: 12px;
		}
		body.desktop-portrait #scoreboard .score-total {
			padding: 4px 6px;
			gap: 6px;
			margin-top: 4px;
			border-top: 1px solid rgba(255,255,255,0.2);
		}
		body.desktop-portrait #scoreboard .score-total .label {
			display: inline;
			font-size: 0.7rem;
			opacity: 0.8;
		}
		body.desktop-portrait #scoreboard .score-total .total-score {
			font-size: 0.95rem;
			font-weight: bold;
		}
		body.desktop-portrait #scoreboard .score-total {
			justify-content: center;
		}

		/* Bonus panel: compact */
		body.desktop-portrait #bonus-zone {
			padding: 4px 6px;
			background: rgba(40, 45, 60, 0.9);
			border-radius: 6px;
		}
		body.desktop-portrait #bonus-zone h2,
		body.desktop-portrait #bonus-zone .bonus-hint {
			display: none;
		}
		body.desktop-portrait .bonus-inventory {
			gap: 2px;
			flex-wrap: wrap;
			justify-content: center;
		}
		body.desktop-portrait .bonus-badge {
			padding: 2px 4px;
			font-size: 0.55rem;
		}
		body.desktop-portrait .bonus-count {
			font-size: 0.5rem;
			padding: 1px 3px;
		}

		/* Coins: ultra-compact inline with buy button */
		body.desktop-portrait #gold-zone {
			flex-direction: row;
			align-items: center;
			justify-content: flex-start;
			gap: 4px;
			padding: 4px 6px;
			min-height: 0;
			max-height: 36px;
			background: rgba(40, 45, 60, 0.9);
			border-radius: 6px;
			flex-wrap: nowrap;
			overflow: visible;
		}
		body.desktop-portrait #gold-zone h2 {
			display: none;
		}
		body.desktop-portrait #gold-zone::after {
			content: attr(data-coin-text) ' ðŸª™';
			font-size: 0.7rem;
			font-weight: bold;
			text-align: center;
			color: #ffd700;
			display: inline;
			flex: 0 0 auto;
			white-space: nowrap;
			min-width: 40px;
		}
		body.desktop-portrait #gold-zone #buy-placement-container {
			margin: 0;
			flex: 0 1 auto;
			min-width: 0;
		}
		body.desktop-portrait #gold-zone .buy-placement-btn {
			padding: 3px 5px;
			max-width: 70px;
			width: auto;
			white-space: nowrap;
			font-size: 0.5rem;
			border-radius: 4px;
			overflow: hidden;
			text-overflow: ellipsis;
		}
		body.desktop-portrait #collected-coins {
			display: none !important;
		}

		/* Remove fixed zone heights - let them scale naturally */
		body.desktop-portrait #blue-zone,
		body.desktop-portrait #blue-zone--placeholder,
		body.desktop-portrait #green-zone,
		body.desktop-portrait #green-zone--placeholder {
			height: auto;
			min-height: 0;
		}
	  }

	  /* Short desktop height (<=925px) in landscape: use same compact styles as narrow portrait.
	     This ensures portrait mode kicks in when there's not enough vertical space. */
	  @media (min-width: 926px) and (max-height: 925px) and (orientation: landscape) {
		body.desktop-portrait #objective-zone {
			padding: 6px 12px;
			min-height: 32px;
			gap: 8px;
		}
		body.desktop-portrait #objective-zone h2 {
			font-size: 0.85rem;
		}
		body.desktop-portrait #objective-current {
			font-size: 0.8rem;
		}
		
		body.desktop-portrait #desktop-bottom {
			flex-wrap: nowrap;
			justify-content: center;
			align-items: stretch;
			gap: 8px;
			padding: 4px 8px;
			max-height: 140px;
		}

		body.desktop-portrait #desktop-bottom-left {
			flex: 0 0 140px !important;
			min-width: 130px !important;
			max-width: 160px !important;
		}

		body.desktop-portrait #desktop-bottom-center {
			flex: 1 1 auto !important;
			min-width: 180px !important;
			max-width: 450px !important;
			align-items: center;
		}

		body.desktop-portrait #desktop-bottom-buttons {
			flex: 0 0 auto;
			min-width: 0;
			width: auto;
		}

		body.desktop-portrait #desktop-bottom-right {
			flex: 0 0 100px !important;
			min-width: 90px !important;
			max-width: 140px !important;
		}

		/* Card panel: compact horizontal row */
		body.desktop-portrait #card-choice-zone {
			padding: 4px 6px;
		}
		body.desktop-portrait #card-choice-zone h2,
		body.desktop-portrait #kiesKaartTitel,
		body.desktop-portrait #card-choice-zone br {
			display: none !important;
		}
		body.desktop-portrait #desktop-bottom-center #card-controls {
			flex-direction: row;
			justify-content: center;
			width: fit-content;
		}
		body.desktop-portrait #desktop-bottom-center #card-options {
			flex-wrap: nowrap;
			justify-content: center;
			gap: 6px;
			width: fit-content;
		}
		body.desktop-portrait #desktop-bottom-center .card-option {
			width: 60px;
			max-width: 60px;
			min-height: 85px;
			padding: 4px;
			gap: 4px;
			--preview-cell: 12px;
		}
		body.desktop-portrait #desktop-bottom-center .card-option .card-cell {
			width: 10px;
			height: 10px;
		}
		body.desktop-portrait #desktop-bottom-center .card-label {
			font-size: 0.5rem;
			padding: 2px 4px;
		}

		/* Buttons: compact column */
		body.desktop-portrait #desktop-bottom-buttons #card-action-buttons {
			display: flex !important;
			flex-direction: column;
			gap: 4px;
			align-items: center;
			justify-content: flex-start;
			margin: 0;
			padding: 0;
		}
		body.desktop-portrait #desktop-bottom-buttons .card-action-btn,
		body.desktop-portrait #desktop-bottom-buttons .deck-preview {
			width: 36px;
			min-width: 36px;
			max-width: 36px;
			height: 36px;
			min-height: 36px;
			padding: 6px;
		}

		/* Scoreboard: compact */
		body.desktop-portrait #scoreboard {
			padding: 6px 8px;
			background: rgba(40, 45, 60, 0.9);
			border-radius: 8px;
		}
		body.desktop-portrait #scoreboard h2,
		body.desktop-portrait #scoreboard hr {
			display: none;
		}
		body.desktop-portrait #scoreboard .score-row {
			font-size: 0.75rem;
			padding: 2px 4px;
			gap: 6px;
		}
		body.desktop-portrait #scoreboard .score-row .label {
			display: none;
		}
		body.desktop-portrait #scoreboard .score-row .color-box {
			width: 12px;
			height: 12px;
		}
		body.desktop-portrait #scoreboard .score-total {
			padding: 4px 6px;
			gap: 6px;
			margin-top: 4px;
		}
		body.desktop-portrait #scoreboard .score-total .total-score {
			font-size: 0.95rem;
			font-weight: bold;
		}

		/* Bonus panel: compact */
		body.desktop-portrait #bonus-zone {
			padding: 4px 6px;
			background: rgba(40, 45, 60, 0.9);
			border-radius: 6px;
		}
		body.desktop-portrait #bonus-zone h2,
		body.desktop-portrait #bonus-zone .bonus-hint {
			display: none;
		}
		body.desktop-portrait .bonus-inventory {
			gap: 2px;
			flex-wrap: wrap;
			justify-content: center;
		}
		body.desktop-portrait .bonus-badge {
			padding: 2px 4px;
			font-size: 0.55rem;
		}
		body.desktop-portrait .bonus-count {
			font-size: 0.5rem;
			padding: 1px 3px;
		}

		/* Coins: compact with visible coin icon */
		body.desktop-portrait #gold-zone {
			flex-direction: row;
			align-items: center;
			justify-content: center;
			gap: 6px;
			padding: 4px 8px;
			min-height: 0;
			max-height: 36px;
			background: rgba(40, 45, 60, 0.9);
			border-radius: 6px;
			flex-wrap: nowrap;
			overflow: visible;
		}
		body.desktop-portrait #gold-zone h2 {
			display: none;
		}
		body.desktop-portrait #gold-zone::after {
			content: attr(data-coin-text) ' ðŸª™';
			font-size: 0.8rem;
			font-weight: bold;
			text-align: center;
			color: #ffd700;
			display: inline;
			flex: 0 0 auto;
			white-space: nowrap;
		}
		body.desktop-portrait #gold-zone #buy-placement-container {
			margin: 0;
			flex: 0 1 auto;
			min-width: 0;
		}
		body.desktop-portrait #gold-zone .buy-placement-btn {
			padding: 4px 6px;
			max-width: 100px;
			width: auto;
			white-space: nowrap;
			font-size: 0.55rem;
			border-radius: 4px;
			overflow: hidden;
			text-overflow: ellipsis;
		}
		body.desktop-portrait #collected-coins {
			display: none !important;
		}

		/* Remove fixed zone heights */
		body.desktop-portrait #blue-zone,
		body.desktop-portrait #blue-zone--placeholder,
		body.desktop-portrait #green-zone,
		body.desktop-portrait #green-zone--placeholder {
			height: auto;
			min-height: 0;
		}
	  }

	  #desktop-bottom-left,
	  #desktop-bottom-center,
	  #desktop-bottom-buttons,
	  #desktop-bottom-right {
		display: flex;
		flex-direction: column;
		gap: 12px;
		flex-shrink: 1;
	  }
	  
	  #desktop-bottom-left,
	  #desktop-bottom-right {
		flex: 1 1 220px;
		min-width: 160px;
		max-width: 280px;
	  }
	  
	  #desktop-bottom-buttons {
		display: none; /* Hidden in landscape, shown in portrait */
		flex: 0 0 auto;
	  }

	  /* Portrait mode: elementen verdelen */
	  body.desktop-portrait #desktop-bottom-left {
		flex: 1 1 220px;
		min-width: 160px;
		max-width: 260px;
	  }

	  body.desktop-portrait #desktop-bottom-center {
		flex: 2 1 320px;
		min-width: 220px;
		max-width: 520px;
		align-items: stretch;
	  }

	  body.desktop-portrait #desktop-bottom-right {
		flex: 1 1 200px;
		min-width: 150px;
		max-width: 260px;
	  }
	  
	  body.desktop-portrait #desktop-bottom-buttons {
		display: flex;
		flex-direction: column;
		justify-content: flex-start;
		align-items: center;
		flex: 0 0 auto;
		width: auto;
	  }

  @media (max-width: 400px) {
	body.desktop-portrait #desktop-wrapper {
	  transform: scale(0.75);
	}
  }

  @media (max-width: 350px) {
	body.desktop-portrait #desktop-wrapper {
	  transform: scale(0.7);
	}
  }

  /* iPad / constrained landscape: when right sidebar would overflow, scale the whole layout */
  @media (min-width: 651px) and (max-width: 1650px) and (orientation: landscape) {
	body.desktop-landscape #desktop-wrapper {
		grid-template-columns: minmax(120px, 160px) 1fr minmax(120px, 160px);
		gap: 6px;
		padding: 6px;
		max-width: 100vw;
		overflow: visible;
	}
	
	body.desktop-landscape #desktop-left,
	body.desktop-landscape #desktop-right {
		min-width: 110px;
		max-width: 160px;
		flex-shrink: 0;
	}
	
	body.desktop-landscape #desktop-right #card-choice-zone {
		padding: 6px;
	}
	
	body.desktop-landscape #desktop-right .card-option {
		width: 60px;
		min-height: 80px;
		padding: 5px;
		--preview-cell: 10px;
	}
	
	body.desktop-landscape #desktop-right .card-option .card-cell {
		width: 9px;
		height: 9px;
	}
	
	body.desktop-landscape #desktop-right .card-label {
		font-size: 0.5rem;
	}
	
	body.desktop-landscape #desktop-right #bonus-zone {
		padding: 5px;
	}
	
	body.desktop-landscape #desktop-right .bonus-badge {
		padding: 3px 5px;
		font-size: 0.55rem;
	}
	
	body.desktop-landscape #desktop-left #scoreboard {
		padding: 6px;
	}
	
	body.desktop-landscape #desktop-left #scoreboard h2 {
		font-size: 0.8rem;
	}
	
	body.desktop-landscape #desktop-left #scoreboard .score-row {
		font-size: 0.65rem;
		padding: 2px 3px;
	}
	
	body.desktop-landscape #desktop-left #gold-zone {
		padding: 5px 6px;
	}
  }

  /* Slightly wider screens (1100-1650px): allow a bit more room */
  @media (min-width: 1101px) and (max-width: 1650px) and (orientation: landscape) {
	body.desktop-landscape #desktop-wrapper {
		grid-template-columns: minmax(150px, 200px) 1fr minmax(150px, 200px);
		gap: 10px;
		padding: 10px;
	}
	
	body.desktop-landscape #desktop-left,
	body.desktop-landscape #desktop-right {
		min-width: 140px;
		max-width: 200px;
	}
	
	body.desktop-landscape #desktop-right .card-option {
		width: 75px;
		min-height: 95px;
		padding: 6px;
		--preview-cell: 12px;
	}
	
	body.desktop-landscape #desktop-right .card-option .card-cell {
		width: 11px;
		height: 11px;
	}
	
	body.desktop-landscape #desktop-right .card-label {
		font-size: 0.55rem;
	}
	
	body.desktop-landscape #desktop-left #scoreboard h2 {
		font-size: 0.9rem;
	}
	
	body.desktop-landscape #desktop-left #scoreboard .score-row {
		font-size: 0.7rem;
		padding: 2px 4px;
	}
  }

  /* Very constrained iPad landscape: force portrait-style bottom layout */
  @media (min-width: 651px) and (max-width: 950px) and (max-height: 700px) and (orientation: landscape) {
	body.desktop-landscape #desktop-wrapper {
		display: flex;
		flex-direction: column;
		align-items: center;
	}
	
	body.desktop-landscape #desktop-left,
	body.desktop-landscape #desktop-right {
		display: none !important;
	}
	
	body.desktop-landscape #desktop-bottom {
		display: flex !important;
		flex-wrap: wrap;
		justify-content: center;
		gap: 8px;
		width: 100%;
	}
  }

	  /* Menu linksbovenin - altijd zichtbaar */
	  #desktop-menu {
		grid-area: menu;
		display: flex !important;
		align-items: flex-start;
		justify-content: flex-start;
		z-index: 1002;
		position: sticky;
		top: 0;
	  }

	  /* Hamburger button - altijd zichtbaar in desktop */
	  #desktop-menu-toggle {
		display: none !important;
		flex-direction: column;
		justify-content: center;
		align-items: center;
		width: 50px;
		height: 50px;
		background: #fffbea;
		border: 1px solid #e3e6ea;
		border-radius: 12px;
		cursor: pointer;
		transition: all 0.3s ease;
		box-shadow: 0 2px 8px rgba(0,0,0,0.15);
		position: relative;
		z-index: 1003;
	  }

	  #desktop-menu-toggle:hover {
		background: #fff5d1;
		transform: translateY(-2px);
		box-shadow: 0 4px 12px rgba(0,0,0,0.2);
	  }

	  #desktop-menu-toggle span {
		width: 24px;
		height: 3px;
		background: #2b3148;
		border-radius: 2px;
		transition: all 0.3s ease;
		display: block;
		margin: 3px 0;
	  }

	  #desktop-menu-toggle.active span:nth-child(1) {
		transform: rotate(45deg) translate(8px, 8px);
	  }

	  #desktop-menu-toggle.active span:nth-child(2) {
		opacity: 0;
	  }

	  #desktop-menu-toggle.active span:nth-child(3) {
		transform: rotate(-45deg) translate(8px, -8px);
	  }

	  body.dark-mode #desktop-menu-toggle {
		background: #2d2f36;
		border-color: #4a4c54;
	  }

	  body.dark-mode #desktop-menu-toggle span {
		background: #eee;
	  }

	  body.dark-mode #desktop-menu-toggle:hover {
		background: #3a3c44;
	  }

	  #controls {
		position: fixed !important;
		left: 64px;
		top: 12px;
		opacity: 1 !important;
		pointer-events: auto !important;
		background: #fffbea;
		border: 1px solid #e3e6ea;
		border-radius: 12px;
		box-shadow: 0 4px 16px rgba(0,0,0,0.2);
		padding: 12px;
		display: none !important;
		flex-direction: column;
		gap: 8px;
		width: 220px;
		margin: 0;
		z-index: calc(var(--z-menu) - 1);
	  }

	  #controls.open {
		display: flex !important;
	  }

  /* Doel bovenaan */
  #desktop-objective {
	grid-area: objective;
	display: flex;
	justify-content: center;
	align-items: center;
	width: 100%;
  }

  /* In landscape mode: objective alleen boven grids kolom */
  body:not(.desktop-portrait) #desktop-objective {
	grid-column: 2 / 3; /* Alleen boven de grids kolom */
  }

  #objective-zone {
	margin: 0 auto;
	padding: 14px 24px 10px;
	width: 100%;
	max-width: 100%;
	min-height: 50px;
	display: flex;
	align-items: center;
	gap: 16px;
	justify-content: center;
	text-align: center;
	box-sizing: border-box;
	background: #fffbea;
	border-radius: 10px;
	border: 1px solid #e3e6ea;
	box-shadow: 0 2px 6px rgba(0,0,0,0.12);
  }	  body.dark-mode #objective-zone {
		background: linear-gradient(145deg, #22252b, #1a1c21);
		border: 1px solid #2d2f36;
		box-shadow: 0 4px 10px rgba(0,0,0,0.5);
		color: #e5e5e5;
	  }

	  #objective-zone h2 {
		margin: 0;
		font-size: 1.1rem;
		font-weight: 600;
		white-space: nowrap;
		flex-shrink: 0;
		color: #333;
	  }

	  body.dark-mode #objective-zone h2 {
		color: #e5e5e5;
	  }

	  #objective-current {
		margin: 0;
		padding: 0;
		font-size: 0.95rem;
		line-height: 1.3;
		flex: 1;
		display: flex;
		align-items: center;
		gap: 8px;
	  }

	  /* Verwijder het doelwit icoontje */
	  #objective-current::before {
		content: none;
	  }

	  #objective-history {
		margin: 0;
		padding: 0;
		display: none; /* Verberg history op desktop voor compactheid */
	  }

	  /* Verberg empty state tekst op desktop */
	  .objective-empty-state {
		display: none;
	  }

	  /* Board met grids centraal */
	  #desktop-grids {
		grid-area: grids;
		display: flex;
		justify-content: center;
		align-items: center;
		overflow: visible;
	  }

	  /* Half-screen desktop landscape (â‰ˆ900-1200px): tighten sidebars + gaps so the full board fits. */
	  @media (min-width: 651px) and (max-width: 1200px) and (orientation: landscape) {
		body.desktop-landscape #desktop-wrapper {
			grid-template-columns: minmax(88px, 118px) 1fr minmax(88px, 118px);
			gap: 3px;
			padding: 4px;
			margin: 0;
		}
		body.desktop-landscape #desktop-left,
		body.desktop-landscape #desktop-right {
			min-width: 88px;
			max-width: 118px;
		}
		body.desktop-landscape #desktop-right .card-option {
			width: 54px;
			min-height: 76px;
			padding: 4px;
			--preview-cell: 9px;
		}
		body.desktop-landscape #desktop-right .card-option .card-cell {
			width: 8px;
			height: 8px;
		}
		body.desktop-landscape #desktop-right .card-label {
			font-size: 0.48rem;
		}
		body.desktop-landscape #desktop-left #scoreboard {
			padding: 5px;
		}
		body.desktop-landscape #desktop-left #gold-zone {
			padding: 4px 5px;
		}
	  }

	  /* Extra fit: if the window is narrow, slightly reduce cell-size (keeps proportions consistent). */
	  @media (min-width: 651px) and (max-width: 1200px) and (orientation: landscape) {
		body.desktop-landscape {
			--cell-size: 26px;
		}
	  }

	  /* Extra-tight landscape for small desktop widths: pull sidebars inward so right sidebar stays visible. */
	  @media (min-width: 651px) and (max-width: 1050px) and (orientation: landscape) {
		body.desktop-landscape #desktop-wrapper {
			grid-template-columns: minmax(82px, 108px) 1fr minmax(82px, 108px);
			gap: 2px;
			padding: 2px;
			margin: 0;
		}
		body.desktop-landscape #desktop-left,
		body.desktop-landscape #desktop-right {
			min-width: 82px;
			max-width: 108px;
		}
		body.desktop-landscape #desktop-right .card-option {
			width: 52px;
			min-height: 72px;
			padding: 3px;
			--preview-cell: 8px;
		}
		body.desktop-landscape #desktop-right .card-option .card-cell {
			width: 7px;
			height: 7px;
		}
		body.desktop-landscape #desktop-left #scoreboard,
		body.desktop-landscape #desktop-left #gold-zone {
			padding: 4px;
		}
	  }

	  .board {
		display: flex;
		gap: 12px;
		margin: 0;
		transform: none;
		max-height: none;
	  }

	  .column {
		transform: none;
	  }

	  /* Eerste 3 kolommen (grids) naast elkaar */
	  .column:nth-child(1),
	  .column:nth-child(2),
	  .column:nth-child(3) {
		flex: 0 0 auto;
		width: auto;
	  }

	  /* 4e kolom verbergen op desktop */
	  .column:nth-child(4) {
		display: none;
	  }

	  /* Linker sidebar voor score en munten */
	  #desktop-left {
		grid-area: left;
		display: flex;
		flex-direction: column;
		gap: 12px;
		overflow-y: auto;
		overflow-x: hidden;
		scrollbar-width: thin;
		scrollbar-color: rgba(80, 90, 110, 0.35) transparent;
	  }

	  /* Rechter sidebar voor kaarten en bonussen */
	  #desktop-right {
		grid-area: right;
		display: flex;
		flex-direction: column;
		gap: 12px;
		overflow-y: auto;
		overflow-x: hidden;
		scrollbar-width: thin;
		scrollbar-color: rgba(80, 90, 110, 0.35) transparent;
	  }

	  /* Wanneer de kaartenlijst zelf scrollt (4+ kaarten), laat de sidebar NIET meescrollen.
	     Dit voorkomt dat het muiswiel op #desktop-right "verdwijnt" i.p.v. in #card-options. */
	  #desktop-right.hand-has-scroll {
		overflow-y: hidden;
	  }

	  #desktop-left::-webkit-scrollbar,
	  #desktop-right::-webkit-scrollbar {
		width: 8px;
	  }

	  #desktop-left::-webkit-scrollbar-thumb,
	  #desktop-right::-webkit-scrollbar-thumb {
		background: rgba(80, 90, 110, 0.35);
		border-radius: 10px;
	  }

	  body.dark-mode #desktop-left::-webkit-scrollbar-thumb,
	  body.dark-mode #desktop-right::-webkit-scrollbar-thumb {
		background: rgba(255, 255, 255, 0.16);
	  }

  /* Bottom section voor alle modes */
  #desktop-bottom {
	grid-area: bottom;
	display: flex;
	gap: 12px;
	align-items: start;
	width: 100%;
	flex-wrap: nowrap;
	justify-content: space-between;
  }

  /* Landscape mode: verberg de bottom bar (scores + bonussen zijn in sidebars) */
  body:not(.desktop-portrait) #desktop-bottom {
	display: none;
  }

  /* Portrait mode: toon bottom bar - clean consolidated layout */
  body.desktop-portrait #desktop-bottom {
	display: flex;
	flex-wrap: wrap;
	justify-content: center;
	align-items: flex-start;
	gap: 10px;
	width: 100%;
	max-width: 100%;
	padding: 0 10px;
	box-sizing: border-box;
  }

  #desktop-bottom-left,
  #desktop-bottom-center,
  #desktop-bottom-buttons,
  #desktop-bottom-right {
	display: flex;
	flex-direction: column;
	gap: 10px;
	flex-shrink: 1;
  }

  body.desktop-portrait #desktop-bottom-left {
	flex: 1 1 200px;
	min-width: 140px;
	max-width: 240px;
  }

  body.desktop-portrait #desktop-bottom-center {
	flex: 2 1 300px;
	min-width: 220px;
	max-width: 500px;
  }

  body.desktop-portrait #desktop-bottom-right {
	flex: 1 1 180px;
	min-width: 130px;
	max-width: 220px;
  }

  body.desktop-portrait #desktop-bottom-buttons {
	display: flex;
	flex-direction: column;
	justify-content: flex-start;
	align-items: center;
	flex: 0 0 auto;
	width: auto;
  }

  #desktop-bottom-buttons {
	display: none; /* Hidden in landscape */
  }

	  /* Portrait mode: bonus inventory verticaal */
	  body.desktop-portrait .bonus-inventory {
		flex-direction: column;
		align-items: stretch;
		gap: 4px;
	  }
	  
	  body.desktop-portrait .bonus-badge {
		padding: 6px 8px;
		font-size: 0.7rem;
		min-height: auto;
	  }
	  
	  body.desktop-portrait .bonus-count {
		font-size: 0.65rem;
		padding: 2px 5px;
	  }

	  /* Portrait mode: toon munten onder bonussen */
	  body.desktop-portrait #desktop-bottom-right #gold-zone {
		order: 10;
	  }

	  /* Portrait mode: hide coin grid, show text counter like mobile */
	  body.desktop-portrait #gold-zone {
		display: flex;
		flex-direction: row;
		align-items: center;
		justify-content: flex-start;
		gap: 10px;
		min-height: auto;
		max-height: none;
		padding: 6px 10px;
		min-width: auto;
	  }

	  body.desktop-portrait #gold-zone h2 {
		display: none;
	  }

	  body.desktop-portrait #gold-zone::after {
		content: '\1FA99  ' attr(data-coin-text);
		display: block;
		flex: 0 0 auto;
		text-align: center;
		font-size: 0.95rem;
		font-weight: 700;
		color: #333;
		padding: 0;
		background: transparent;
		border-radius: 0;
		border: none;
		white-space: nowrap;
		font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", "Helvetica Neue", Arial, sans-serif, "Segoe UI Emoji", "Apple Color Emoji", "Noto Color Emoji";
	  }

	  body.desktop-portrait #gold-zone #buy-placement-container {
		margin-top: 0;
		margin-left: auto;
	  }

	  body.desktop-portrait #gold-zone .buy-placement-btn {
		margin-top: 0;
		padding: 6px 10px;
		max-width: 180px;
		width: fit-content;
	  }

	  body.desktop-portrait #collected-coins {
		display: none !important;
	  }

	  body.dark-mode.desktop-portrait #gold-zone::after {
		color: #e5e5e5;
	  }

	  #desktop-bottom-center {
		display: flex;
		flex-direction: column;
		justify-content: flex-start;
		align-items: center;
		flex: 1 1 auto;
		min-width: 0;
		gap: 12px;
	  }

	  /* Portrait mode: card-choice-zone past zich aan */
	  body.desktop-portrait #card-choice-zone {
		width: 100%;
	  }

	  /* Portrait mode: card action buttons in separate middle zone */
	  body.desktop-portrait #card-controls {
		flex-direction: column;
		align-items: center;
	  }
	  
	  body.desktop-portrait #card-options {
		width: 100%;
	  }
	  
	  body.desktop-portrait .card-option {
		max-width: 90px;
		min-height: 140px;
		padding: 8px 6px;
	  }
	  
	  body.desktop-portrait .card-option .card-cell {
		width: 16px;
		height: 16px;
	  }

	  body.desktop-portrait #card-controls #card-action-buttons {
		display: none !important;
	  }
	  
	  body.desktop-portrait #desktop-bottom-buttons #card-action-buttons {
		display: flex !important;
		flex-direction: column;
		align-items: center;
		flex: 0 0 auto;
		width: auto;
	  }

	  /* Kaarten in rechter sidebar: verticaal gestapeld */
	  #desktop-right #card-choice-zone {
		width: 100%;
		background: #fffbea;
		border: 1px solid #e3e6ea;
		border-radius: 10px;
		padding: 12px;
		display: flex;
		flex-direction: column;
		min-height: 0;
	  }

	  body.dark-mode #desktop-right #card-choice-zone {
		background: linear-gradient(145deg, #22252b, #1a1c21);
		border: 1px solid #2d2f36;
	  }

	  #desktop-right #card-options {
		display: flex;
		flex-direction: column;
		gap: 12px;
		align-items: stretch;
		overflow-x: hidden;
		flex: 1 1 auto;
		min-height: 0;
		padding-bottom: 8px;
		padding-right: 10px;
	  }

	  /* Desktop sidebar: cards should use the available width (less cramped). */
	  #desktop-right #card-choice-zone .card-option {
		width: calc(100% - 20px);
		margin-left: auto;
		margin-right: auto;
		min-width: 0;
		box-sizing: border-box;
	  }
	  
	  /* Scrolling alleen wanneer er 4+ kaarten zijn (class toegevoegd via JS) */
	  #desktop-right #card-options.has-scroll {
		max-height: 610px;
		min-height: 0 !important;
		overflow-y: auto !important;
		scrollbar-width: thin;
		scrollbar-color: rgba(100, 120, 180, 0.5) transparent;
	  }
	  
	  #desktop-right #card-options.has-scroll::-webkit-scrollbar {
		width: 6px;
	  }
	  #desktop-right #card-options.has-scroll::-webkit-scrollbar-track {
		background: transparent;
		border-radius: 3px;
	  }
	  #desktop-right #card-options.has-scroll::-webkit-scrollbar-thumb {
		background: linear-gradient(180deg, rgba(100, 120, 180, 0.6), rgba(80, 100, 160, 0.4));
		border-radius: 3px;
	  }
	  #desktop-right #card-options.has-scroll::-webkit-scrollbar-thumb:hover {
		background: linear-gradient(180deg, rgba(120, 140, 200, 0.8), rgba(100, 120, 180, 0.6));
	  }
	  
	  body.dark-mode #desktop-right #card-options.has-scroll {
		scrollbar-color: rgba(140, 160, 220, 0.4) transparent;
	  }
	  body.dark-mode #desktop-right #card-options.has-scroll::-webkit-scrollbar-thumb {
		background: linear-gradient(180deg, rgba(100, 120, 180, 0.5), rgba(80, 100, 160, 0.3));
	  }

	  /* Buttons centreren onder kaarten op desktop */
	  #desktop-right > #card-action-buttons,
	  #card-choice-zone #card-action-buttons {
		display: flex !important;
		flex-direction: row;
		gap: 8px;
		align-items: center;
		justify-content: center;
		margin-top: 12px;
		margin-bottom: 12px;
		width: 100%;
		max-width: 100%;
		box-sizing: border-box;
		flex-wrap: wrap;
		padding: 0 8px;
	  }
	  
	  /* Hide buttons when still in card-controls during landscape layout */
	  body.desktop-landscape #card-controls #card-action-buttons {
		display: none !important;
	  }
	  
	  body.desktop-landscape #desktop-right > #card-action-buttons {
		display: flex !important;
		justify-content: center;
		gap: 10px;
	  }

	  body.desktop-landscape #desktop-right > #card-action-buttons .card-action-btn,
	  body.desktop-landscape #desktop-right > #card-action-buttons .deck-preview {
		flex: 0 0 auto;
		margin: 0;
	  }

	  body.desktop-landscape #gold-zone .buy-placement-btn {
		padding: 8px 10px;
		max-width: 150px;
		white-space: nowrap;
	  }

	  /* Verberg originele wrapper zones op desktop */
	  #original-coins-zone,
	  #original-score-zone,
	  #original-objective-zone,
	  #original-bonus-zone,
	  #original-card-zone,
	  #original-controls-zone {
		display: none;
	  }

	  /* Zone styling op desktop - geen achtergrond (wordt per zone ingesteld) */
	  /* Dark mode borders en shadows worden al bovenaan gedefinieerd */

	  /* Coins display integreren in scoreboard sectie */
	  #gold-zone {
		padding: 12px;
		margin: 0 0 12px 0;
		width: 100%;
		min-height: 140px;
		border-radius: 10px;
		border: 1px solid #e3e6ea;
		box-shadow: 0 2px 6px rgba(0,0,0,0.12);
		background: #fffbea !important;
		text-align: left;
		overflow: hidden;
	  }

	  /* Give the buy-placement button enough width so it never clips in the coin zone. */
	  #gold-zone #buy-placement-container {
		width: 100%;
		justify-content: stretch;
	  }
	  #gold-zone #buy-placement-btn {
		width: 100%;
	  }

	  /* Landscape mode: hide coin grid, show text counter (unless classic mode). */
	  body.desktop-landscape:not(.classic-mode) #gold-zone::after {
		content: '\1FA99  ' attr(data-coin-text);
		display: block;
		font-size: 1.2rem;
		font-weight: 800;
		color: #333;
		margin-top: 2px;
		white-space: nowrap;
		max-width: 100%;
		overflow: hidden;
		text-overflow: ellipsis;
		font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", "Helvetica Neue", Arial, sans-serif, "Segoe UI Emoji", "Apple Color Emoji", "Noto Color Emoji";
	  }
	  body.desktop-landscape:not(.classic-mode) #collected-coins {
		display: none !important;
	  }
	  body.dark-mode.desktop-landscape:not(.classic-mode) #gold-zone::after {
		color: #e5e5e5;
	  }

	  /* Classic mode: keep only the board + coins visible. */
	  body.classic-mode #card-choice-zone,
	  body.classic-mode #bonus-zone,
	  body.classic-mode #scoreboard,
	  body.classic-mode #objective-zone,
	  body.classic-mode #mobile-objective-banner,
	  body.classic-mode #buy-placement-container,
	  body.classic-mode #bottom-bar {
		display: none !important;
	  }

	  /* Classic mode: hide coins + zone info + theme toggle; only board + hamburger remain. */
	  body.classic-mode #original-coins-zone,
	  body.classic-mode #gold-zone,
	  body.classic-mode #collected-coins,
	  body.classic-mode #dark-mode-toggle,
	  body.classic-mode .zone-info-btn,
	  body.classic-mode .zone-info-popover {
		display: none !important;
	  }
	  body.classic-mode #board > .column:last-child {
		display: none !important;
	  }

	  /* Classic mode: hide next turn / shop / deck controls everywhere. */
	  body.classic-mode #card-action-buttons,
	  body.classic-mode #new-cards-btn,
	  body.classic-mode #bonus-shop-btn,
	  body.classic-mode #deck-preview {
		display: none !important;
	  }
	  body.classic-mode #gold-zone::after {
		content: none !important;
	  }
	  /* Classic mode: show max 20 coin slots. */
	  body.classic-mode #collected-coins .coin:nth-child(n+21) {
		display: none !important;
	  }

	  /* Classic mode: hamburger menu shows only essentials. */
	  body.classic-mode #controls button:not(#classic-mode-toggle):not(#print-btn) {
		display: none !important;
	  }

	  /* Classic mode: keep coins visible even on mobile layout. */
	  body.classic-mode #gold-zone {
		position: fixed;
		top: calc(10px + env(safe-area-inset-top, 0px));
		right: calc(10px + env(safe-area-inset-right, 0px));
		width: auto;
		max-width: 220px;
		z-index: calc(var(--z-ui, 200) + 2);
	  }

	  #gold-zone h2 {
		margin: 0 0 8px 0;
		font-size: 1.1rem;
		font-weight: 600;
		color: #333;
	  }

	  body.dark-mode #gold-zone {
		border: 1px solid #2d2f36 !important;
		box-shadow: 0 4px 10px rgba(0,0,0,0.5) !important;
		background: linear-gradient(145deg, #22252b, #1a1c21) !important;
		color: #e5e5e5;
	  }

	  body.dark-mode #gold-zone h2 {
		color: #e5e5e5;
	  }

	  #bonus-zone {
		width: 100%;
		padding: 10px;
		border-radius: 10px;
		border: 1px solid #e3e6ea;
		box-shadow: 0 2px 6px rgba(0,0,0,0.12);
		margin: 0;
		background: #fffbea;
		text-align: left;
	  }

	  #bonus-zone h2 {
		margin: 0 0 8px 0;
		font-size: 1.1rem;
		font-weight: 600;
		color: #333;
		display: block;
		color: #333;
	  }

	  #bonus-zone .bonus-hint {
		display: none;
	  }

	  body.dark-mode #bonus-zone {
		border: 1px solid #2d2f36;
		box-shadow: 0 4px 10px rgba(0,0,0,0.5);
		background: linear-gradient(145deg, #22252b, #1a1c21);
		color: #e5e5e5;
	  }

	  body.dark-mode #bonus-zone h2 {
		color: #e5e5e5;
	  }

	  body.dark-mode #bonus-zone h2 {
		color: #e5e5e5;
	  }

	  /* Desktop bottom columns spacing */
	  #desktop-bottom-left,
	  #desktop-bottom-right {
		display: flex;
		flex-direction: column;
		gap: 12px;
	  }

	  #desktop-bottom-center {
		display: flex;
		justify-content: center;
		align-items: flex-start;
	  }

	  /* Trap summary verbergen tot level 5 op desktop */
	  .trap-summary {
		display: none;
	  }
	  
	  body[data-traps-active="true"] .trap-summary {
		display: block;
	  }

	  /* ============================================
	     MOBIEL UI VERBERGEN OP DESKTOP
	     ============================================
	     Bottom-bar en gerelateerde elementen zijn alleen voor mobiel
	  */
	  #bottom-bar,
	  #bottom-bar-cards,
	  .bottom-bar-footer,
	  #bottom-bar-score,
	  #bottom-bar-coins,
	  #mobile-objective-banner {
		display: none !important;
	  }

	  /* Hamburger menu: fixed overlay so it doesn't take vertical space. */
	  #menu-toggle {
		display: flex;
		position: fixed;
		left: 12px;
		top: 12px;
		z-index: var(--z-menu);
		pointer-events: auto;
		align-items: center;
		justify-content: center;
		flex-direction: column;
		gap: 5px;
		width: 44px;
		height: 44px;
		padding: 10px;
		border-radius: 12px;
		background: linear-gradient(145deg, #ffd560, #ffb23c);
		border: 1px solid rgba(255,255,255,0.35);
		box-shadow: 0 8px 16px rgba(0,0,0,0.28);
		cursor: pointer;
		transition: transform 0.2s ease, box-shadow 0.2s ease;
	  }
	  #menu-toggle span {
		width: 20px;
		height: 2px;
		background: #1c1c1c;
		border-radius: 2px;
		transition: all 0.3s ease;
		display: block;
	  }
	  #menu-toggle.active span:nth-child(1) { transform: translateY(6px) rotate(45deg); }
	  #menu-toggle.active span:nth-child(2) { opacity: 0; }
	  #menu-toggle.active span:nth-child(3) { transform: translateY(-6px) rotate(-45deg); }
	  body.dark-mode #menu-toggle {
		background: linear-gradient(145deg, #2f3546, #1c2233);
		border-color: rgba(255,255,255,0.12);
	  }
	  body.dark-mode #menu-toggle span {
		background: rgba(255,255,255,0.88);
	  }

	  /* Legacy desktop toggle (unused): keep hidden so only #menu-toggle is visible. */
	  #desktop-menu-toggle {
		display: none !important;
	  }

	  /* Dark mode toggle is accessible via the hamburger menu; hide the standalone top-right button. */
	  #dark-mode-toggle {
		display: none !important;
	  }

	  /* Desktop request: remove rotate/mirror buttons from the UI. */
	  #rotate-card-btn,
	  #mirror-card-btn {
		display: none !important;
	  }

	  /* ============================================
	     CONTROLS MENU (DESKTOP)
	     ============================================
	     Op desktop zijn controls altijd zichtbaar in de layout
	  */

	  body.dark-mode #controls {
		background: #2d2f36;
		color: #eee;
		box-shadow: 0 4px 16px rgba(0,0,0,0.4);
		border-color: #4a4c54;
	  }

	  #controls button {
		background: #ffffff;
		border: 1px solid #ddd;
		color: #222;
		padding: 10px 14px;
		border-radius: 8px;
		cursor: pointer;
		transition: all 0.2s ease;
		font-size: 0.9rem;
		width: 100%;
		text-align: left;
	  }

	  #controls button:hover {
		background: #f0f0f0;
		transform: translateY(-1px);
	  }

	  body.dark-mode #controls button {
		background: #3a3c44;
		border-color: #4a4c54;
		color: #eee;
	  }

	  body.dark-mode #controls button:hover {
		background: #454750;
	  }

	#controls #debug-mode-toggle {
		display: inline-flex;
		align-items: center;
		gap: 10px;
		font-weight: 600;
	}

	#controls #debug-mode-toggle.debug-active {
		background: linear-gradient(145deg, #d8f3ff, #b6e2ff);
		border-color: #6fbef3;
		color: #0d3c60;
	}

	body.dark-mode #controls #debug-mode-toggle.debug-active {
		background: linear-gradient(145deg, #17435f, #1f587c);
		border-color: #39a1d9;
		color: #e4f6ff;
	}

	  body.dark-mode #controls button {
		background: #333;
		color: #eee;
		border-color: #555;
	  }

	  #controls button:hover:not(:disabled) {
		background: #f0f0f0;
	  }

	  body.dark-mode #controls button:hover:not(:disabled) {
		background: #444;
	  }

	  /* ============================================
	     KAART KEUZE ZONE (DESKTOP)
	     ============================================
	     Drijvende zone met 3 kaart opties
	     Altijd zichtbaar op vaste positie rechtsonder
	  */
	  #card-choice-zone {
		background: #fffbea;
		border-radius: 10px;
		color: #333;
		font-family: "Segoe UI", sans-serif;
		width: 100%;
		box-shadow: 0 2px 6px rgba(0,0,0,0.12);
		border: 1px solid #e3e6ea;
		margin: 0;
		padding: 10px;
		text-align: left;
	  }

	  #card-choice-zone h2 {
		margin: 0 0 8px 0;
		color: #333;
		font-size: 1.1rem;
		font-weight: 600;
		color: #333;
	  }

	  body.dark-mode #card-choice-zone {
		background: linear-gradient(145deg, #22252b, #1a1c21);
		border: 1px solid #2d2f36;
		box-shadow: 0 4px 10px rgba(0,0,0,0.5);
		color: #e5e5e5;
	  }

	  body.dark-mode #card-choice-zone h2 {
		color: #e5e5e5;
	  }

	  #kiesKaartTitel {
		display: block;
	  }

	  /* Container voor de 3 kaart opties */
	  #card-options {
		display: flex;
		flex-wrap: nowrap;
		gap: 8px;
		justify-content: center;
		align-items: flex-start;
		margin: 14px auto 18px;
	  }

	  /* Individuele kaart in keuze menu (desktop heeft meer ruimte) */
	  #card-choice-zone .card-option {
		display: flex;
		flex-direction: column;
		align-items: center;
		gap: 4px;
		width: auto;
		min-width: 120px;
		min-height: 180px;
		flex: 1 1 0;
		padding: 12px 8px;
		border-radius: 12px;
		background: linear-gradient(165deg, #ffffff 0%, #eef2ff 45%, #dfe4ff 100%);
		border: 1px solid rgba(40,55,120,0.18);
		box-shadow: 0 8px 16px rgba(10,12,20,0.15);
		transition: transform 0.2s, box-shadow 0.2s;
	  }

	  body.dark-mode #card-choice-zone .card-option {
		background: linear-gradient(160deg, #2d3142 0%, #232635 45%, #1b1e2c 100%);
		border: 1px solid rgba(120,140,220,0.2);
		box-shadow: 0 8px 20px rgba(0,0,0,0.4);
	  }

	  #card-choice-zone .card-option:hover {
		transform: scale(1.05);
		box-shadow: 0 0 10px rgba(0,0,0,0.25);
	  }

	  body.dark-mode #card-choice-zone .card-option:hover {
		box-shadow: 0 0 14px rgba(0,0,0,0.5);
	  }

	  #card-choice-zone .card-option.selected {
		outline: 3px solid #3a6ff7;
		border-color: #3a6ff7;
	  }

	  body.dark-mode #card-choice-zone .card-option.selected {
		outline: 3px solid #5a8fff;
		border-color: #5a8fff;
	  }

	  /* Positionering reset voor desktop (geen absolute positioning) */
	  #card-choice-zone .card-option::after {
		display: none;
	  }

	  #card-choice-zone .card-option > * {
		position: static;
	  }

	  /* Labels en metadata zichtbaar op desktop */
	  #card-choice-zone .card-label {
		display: inline-flex;
		margin-top: 8px;
	  }

	  #card-choice-zone .card-meta {
		display: block;
		margin-top: 4px;
	  }

	  /* Kaart patroon (grid met cellen) */
	  #card-choice-zone .card-pattern {
		display: grid;
		gap: var(--preview-gap);
		align-items: center;
		justify-items: center;
	  }

	  #card-choice-zone .card-option .card-cell {
		width: 20px;
		height: 20px;
		border-radius: 3px;
		border: none;
		box-shadow: none;
	  }

	  /* "Nieuwe kaarten" knop (desktop styling) */
	  #new-cards-btn {
		display: inline-flex;
		align-items: center;
		justify-content: flex-start;
		gap: 8px;
		margin: 0 auto;
		padding: 8px 12px;
		border-radius: 8px;
		border: 1px solid #999;
		background: #fafafa;
		color: #222;
		font-weight: 600;
		text-transform: none;
		letter-spacing: normal;
		cursor: pointer;
		transition: background 0.2s ease, transform 0.2s ease;
		position: relative;
	  }

	  #new-cards-btn::before {
		content: 'â†’';
		color: #4a5268;
		font-size: 1.8rem;
		font-weight: 700;
		position: relative;
		top: 0;
		left: 0;
		transform: none;
		transition: color 0.3s ease;
		line-height: 1;
	  }

	  #new-cards-btn.ready-for-next-turn {
		background: linear-gradient(155deg, #fef8e7 0%, #f0c149 100%);
		border-color: rgba(20,24,36,0.14);
	  }

	  #new-cards-btn.ready-for-next-turn::before {
		color: #5a4a1e;
	  }

	  #new-cards-btn:disabled::before {
		color: rgba(74,82,104,0.6);
	  }

	  #new-cards-btn.complete-round {
		background: linear-gradient(155deg, #e8f5e9 0%, #66bb6a 100%);
		border-color: rgba(46,125,50,0.3);
	  }

	  #new-cards-btn.complete-round::before {
		content: 'âœ“';
		color: #1b5e20;
		font-size: 2rem;
		font-weight: 900;
	  }

	  body.dark-mode #new-cards-btn {
		background: linear-gradient(145deg, #22252b, #1a1c21);
		border: 1px solid #2d2f36;
		box-shadow: 0 6px 14px rgba(0,0,0,0.45);
		color: #e5e5e5;
	  }

	  body.dark-mode #new-cards-btn::before {
		color: rgba(255,255,255,0.75);
	  }

	  body.dark-mode #new-cards-btn.ready-for-next-turn {
		background: linear-gradient(155deg, #ffd560 0%, #ffb23c 100%);
		border-color: rgba(255,255,255,0.35);
	  }

	  body.dark-mode #new-cards-btn.ready-for-next-turn::before {
		color: #1c1c1c;
	  }

	  body.dark-mode #new-cards-btn:disabled::before {
		color: rgba(245,246,255,0.6);
	  }

	  body.dark-mode #new-cards-btn.complete-round {
		background: linear-gradient(155deg, #2e7d32 0%, #1b5e20 100%);
		border-color: rgba(129,199,132,0.3);
	  }

	  body.dark-mode #new-cards-btn.complete-round::before {
		color: #a5d6a7;
	  }

	  #new-cards-btn:hover {
		background: #f0f0f0;
		transform: translateY(-2px);
	  }

	  body.dark-mode #new-cards-btn:hover {
		background: linear-gradient(150deg, #2a2d35, #1f2230);
		border-color: #373a42;
		box-shadow: 0 8px 18px rgba(0,0,0,0.5);
	  }

	  /* Compacte kaarten bij weinig ruimte - verberg labels en meta */
	  @media (min-width: 651px) and (max-width: 1100px) {
		#card-choice-zone .card-label,
		#card-choice-zone .card-meta {
		  display: none;
		}
		
		#card-choice-zone .card-option {
		  min-width: 80px;
		  min-height: 140px;
		  padding: 8px 4px;
		}
		
		#card-choice-zone .card-option .card-cell {
		  width: 18px;
		  height: 18px;
		}

		/* Knoppen worden icoon-only */
		#new-cards-btn,
		#rotate-card-btn {
		  width: 44px;
		  height: 44px;
		  padding: 0;
		  font-size: 0;
		  justify-content: center;
		}

		#new-cards-btn::before,
		#rotate-card-btn::before {
		  font-size: 1.8rem;
		  position: absolute;
		  top: 50%;
		  left: 50%;
		  transform: translate(-50%, -50%);
		}

		#rotate-card-btn {
		  margin-top: 8px;
		}

		/* Deck-count compacter maken */
		.deck-count {
		  height: 44px;
		  min-width: 44px;
		  padding: 6px 8px;
		  font-size: 0.95rem;
		}

		/* Deck preview tekst verbergen, alleen icoon en getal */
		.deck-preview {
		  padding: 6px 8px;
		  min-height: 44px;
		  width: auto;
		  gap: 4px;
		}

		.deck-preview::after {
		  display: none;
		}

		/* Turn counter styling - naast buttons */
		#turn-counter-inline {
		  text-align: left;
		  font-size: 0.9rem;
		  padding-left: 8px;
		}

		/* "Beurt" tekst verwijderen */
		#turn-counter-inline::before {
		  content: '';
		}

		/* Objective zone aanpassingen voor smaller schermen */
		#objective-zone {
		  width: 85%;
		  max-width: 900px;
		  padding: 8px 12px;
		}

		/* Zijkolommen kunnen krimpen */
		#desktop-bottom-left,
		#desktop-bottom-right {
		  width: auto;
		  min-width: 280px;
		  max-width: 360px;
		  flex-shrink: 1;
		}

		/* Desktop wrapper minder padding */
		#desktop-wrapper {
		  padding: 8px;
		  gap: 12px;
		}
	  }

	  /* Extra aanpassingen voor zeer smalle desktop schermen */
	  @media (min-width: 651px) and (max-width: 850px) {
		#objective-zone {
		  width: 92%;
		  max-width: 700px;
		  padding: 8px 12px;
		  font-size: 0.9rem;
		}

		#objective-zone h2 {
		  font-size: 0.9rem;
		}

		#objective-current {
		  font-size: 0.85rem;
		}

		#desktop-wrapper {
		  padding: 8px;
		  gap: 10px;
		}

		#desktop-bottom-left,
		#desktop-bottom-right {
		  min-width: 240px;
		  max-width: 320px;
		}

		#desktop-bottom {
		  gap: 8px;
		}
	  }

	  /* Narrow portrait desktop (651-900px): tighter layout to fit all elements */
	  @media (min-width: 651px) and (max-width: 900px) {
		body.desktop-portrait #desktop-bottom {
		  gap: 8px;
		  padding: 0 8px;
		}

		body.desktop-portrait #desktop-bottom-left {
		  flex: 0 1 180px;
		  min-width: 130px;
		  max-width: 200px;
		}

		body.desktop-portrait #desktop-bottom-center {
		  flex: 1 1 340px;
		  min-width: 240px;
		  max-width: 480px;
		}

		body.desktop-portrait #desktop-bottom-right {
		  flex: 0 1 160px;
		  min-width: 120px;
		  max-width: 200px;
		}

		/* Compact scoreboard for narrow widths */
		body.desktop-portrait #scoreboard {
		  max-width: 190px;
		  padding: 4px 5px;
		  font-size: 0.8rem;
		}

		body.desktop-portrait #scoreboard .score-row {
		  padding: 1px 3px;
		  font-size: 0.75rem;
		}

		body.desktop-portrait #scoreboard .score-total {
		  padding: 3px 5px;
		  font-size: 0.78rem;
		}

		body.desktop-portrait #gold-zone {
		  padding: 2px 6px;
		  font-size: 0.85rem;
		}

		body.desktop-portrait .bonus-badge {
		  padding: 4px 6px;
		  font-size: 0.68rem;
		}
	  }

	  #rotate-card-btn {
		display: inline-flex;
		align-items: center;
		justify-content: flex-start;
		gap: 8px;
		margin: 6px auto 0;
		padding: 8px 14px;
		border-radius: 8px;
		border: 1px solid #9aa1b1;
		background: #e9edf7;
		color: #1f2532;
		font-weight: 600;
		text-transform: none;
		letter-spacing: 0.01em;
		cursor: pointer;
		transition: background 0.2s ease, transform 0.2s ease, opacity 0.2s ease;
		position: relative;
	  }

	  #rotate-card-btn::before {
		content: 'â†»';
		color: #4a5268;
		font-size: 1.6rem;
		position: relative;
		top: 0;
		left: 0;
		transform: none;
		line-height: 1;
	  }

	  body.dark-mode #rotate-card-btn {
		background: linear-gradient(145deg, #22252b, #1a1c21);
		border: 1px solid #2d2f36;
		box-shadow: 0 6px 14px rgba(0,0,0,0.45);
		color: #e5e5e5;
	  }

	  body.dark-mode #rotate-card-btn::before {
		color: rgba(255,255,255,0.75);
	  }

	  #rotate-card-btn:hover:not(:disabled) {
		background: #dbe2f2;
		transform: translateY(-1px);
	  }

	  body.dark-mode #rotate-card-btn:hover:not(:disabled) {
		background: linear-gradient(150deg, #2a2d35, #1f2230);
		border-color: #373a42;
		box-shadow: 0 8px 18px rgba(0,0,0,0.5);
	  }

	  #rotate-card-btn:disabled {
		opacity: 0.55;
		cursor: not-allowed;
		transform: none;
	  }

	  #scoreboard {
		background: #fffbea;
		border-radius: 10px;
		padding: 6px;
		color: #333;
		width: 100%;
		box-shadow: 0 2px 6px rgba(0,0,0,0.12);
		border: 1px solid #e3e6ea;
		margin: 0;
	  }

	  #scoreboard h2 {
		margin: 0 0 3px 0;
		font-size: 0.95rem;
	  }

	  #scoreboard .score-row {
		padding: 2px 6px;
		margin-bottom: 1px;
		font-size: 0.85rem;
	  }

	  #scoreboard hr {
		margin: 2px 0;
	  }

	  body.dark-mode #scoreboard {
		background: linear-gradient(145deg, #22252b, #1a1c21);
		border: 1px solid #2d2f36;
		box-shadow: 0 4px 10px rgba(0,0,0,0.5);
		color: #e5e5e5;
	  }

	  #scoreboard h2,
	  #scoreboard hr {
		display: block;
	  }

	  body.dark-mode #scoreboard h2 {
		color: #e5e5e5;
	  }

	  body.dark-mode #scoreboard hr {
		border-color: #3d4048;
	  }

	  #scoreboard .score-row {
		background: #f5f0e4;
		padding: 3px 6px;
		margin-bottom: 2px;
		border-radius: 5px;
		color: #333;
		transition: transform 0.1s ease, background 0.3s;
	  }

	  body.dark-mode #scoreboard .score-row {
		background: #2a2d35;
		color: #e5e5e5;
	  }

	  #scoreboard .score-row:hover {
		transform: scale(1.02);
		background: #ebe4d4;
		color: #222;
	  }

	  body.dark-mode #scoreboard .score-row:hover {
		background: #32353d;
	  }

	  #scoreboard .score-row .label {
		display: inline;
		font-size: 0.8rem;
	  }

	  #scoreboard .score-row .color-box {
		width: 10px;
		height: 10px;
		border-radius: 2px;
	  }

	  #scoreboard .score-total {
		font-size: 0.9rem;
		margin-top: 3px;
		padding: 4px 8px;
		background: #f0ead8;
		border-radius: 6px;
		border: 1px solid #d9d0bd;
		color: #333;
		font-weight: 600;
	  }

	  body.dark-mode #scoreboard .score-total {
		background: #2f3239;
		border-color: #3d4048;
		color: #e5e5e5;
	  }

	#objective-zone {
		display: flex;
		flex-direction: column;
		gap: 8px;
		background: #fffbea;
		border: 1px solid #e3e6ea;
		box-shadow: 0 2px 6px rgba(0,0,0,0.12);
		position: relative;
		z-index: var(--z-zoom);
		text-align: left;
		justify-content: flex-start;
	}

	  #mobile-objective-banner {
		display: none;
	  }

	  body.dark-mode #objective-zone {
		background: linear-gradient(145deg, #22252b, #1a1c21);
		border: 1px solid #2d2f36;
		box-shadow: 0 4px 10px rgba(0,0,0,0.5);
		color: #e5e5e5;
	  }

	  #objective-zone h2 {
		margin-bottom: 4px;
	  }

	  .objective-current {
		font-size: 0.92rem;
		font-weight: 600;
		line-height: 1.35;
	  }

	  .objective-history {
		list-style: none;
		margin: 0;
		padding: 0;
		display: flex;
		flex-direction: column;
		gap: 6px;
		font-size: 0.78rem;
		color: rgba(20,24,36,0.6);
	  }

	  body.dark-mode .objective-history {
		color: rgba(255,255,255,0.6);
	  }

	  .objective-history li {
		display: flex;
		align-items: center;
		gap: 6px;
	  }

	  .objective-history li::before {
		content: "âœ”";
		font-size: 0.8rem;
		color: #2c9a4b;
	  }

	  body.dark-mode .objective-history li::before {
		color: #7fe48e;
	  }

	  .objective-empty-state {
		font-size: 0.76rem;
		color: rgba(20,24,36,0.6);
	  }

	  body.dark-mode .objective-empty-state {
		color: rgba(255,255,255,0.55);
	  }

	  #bonus-zone,
	  #original-bonus-zone .zone {
		display: flex;
		flex-direction: column;
		gap: 10px;
		background: #fffbea;
		border: 1px solid #e3e6ea;
		box-shadow: 0 2px 6px rgba(0,0,0,0.12);
		text-align: left;
	  }

	  /* Desktop Dark Mode voor Bonus Zone - mooie gradient zoals objective-zone */
	  body.dark-mode #bonus-zone,
	  body.dark-mode #original-bonus-zone .zone {
		background: linear-gradient(145deg, #22252b, #1a1c21);
		border: 1px solid #2d2f36;
		box-shadow: 0 4px 10px rgba(0,0,0,0.5);
		color: #e5e5e5;
	  }

	  #bonus-zone h2,
	  #original-bonus-zone .zone h2 {
		margin: 0;
	  }

	  body.dark-mode #bonus-zone h2,
	  body.dark-mode #original-bonus-zone .zone h2 {
		color: #e4e8ff;
	  }

	  .bonus-inventory {
		display: flex;
		flex-wrap: wrap;
		gap: 8px;
	  }

	  /* Bonus badge styling wordt nu volledig afgehandeld door de globale :is(#bonus-zone, #bottom-bar-bonus) .bonus-badge sectie */

	  #bottom-bar-score,
	  #bottom-bar-bonus,
	  #bottom-bar-coins {
		flex: 1 1 0;
	  }

	  .symbol.bonus-used {
		opacity: 0.25;
		filter: grayscale(0.4);
	  }

	  /* Note: Volledige dark mode styling voor desktop zones staat verderop 
	     in de dedicated DESKTOP DARK MODE secties na de #gold-zone styling */
	}

#original-coins-zone:empty,
	#original-score-zone:empty,
	#original-objective-zone:empty,
	#original-card-zone:empty,
	#original-controls-zone:empty,
	#gold-zone:empty,
	#scoreboard:empty,
	#card-choice-zone:empty,
	#controls-zone:empty {
	  display: none;
	}

	/* Extra mobile finetuning for smaller screens */
	@media (max-width: 520px) {
	  #bottom-bar-bonus .bonus-inventory {
		gap: 8px;
	  }

	  #bottom-bar-bonus .bonus-badge {
		padding: 5px 10px;
		font-size: 0.7rem;
	  }

	  #bottom-bar-bonus .bonus-swatch {
		width: 12px;
		height: 12px;
	  }

	  #bottom-bar-bonus .bonus-count {
		font-size: 0.68rem;
		padding: 2px 6px;
	  }
	}

	@media (max-width: 400px) {
	  #bottom-bar-bonus .bonus-inventory {
		gap: 6px;
	  }

	  #bottom-bar-bonus .bonus-badge {
		padding: 4px 8px;
		font-size: 0.66rem;
	  }

	  #bottom-bar-bonus .bonus-swatch {
		width: 10px;
		height: 10px;
	  }

	  #bottom-bar-bonus .bonus-count {
		font-size: 0.64rem;
		padding: 1px 5px;
	  }
	}

	/* print */
	@media print {
	  body {
		background: white;
		margin: 0;
		-webkit-print-color-adjust: exact;
		print-color-adjust: exact;
	  }
	  * {
		-webkit-print-color-adjust: exact;
		print-color-adjust: exact;
	  }
	  .zone { page-break-inside: avoid; }
	  .layout { display: block; }

	  /* Print must contain only the board (and keep hamburger if present). */
	  #dark-mode-toggle,
	  .blur-overlay,
	  #drag-overlay,
	  #floating-preview,
	  #placement-zoom-lens,
	  #mobile-objective-banner,
	  #bottom-bar,
	  #card-choice-zone,
	  #bonus-zone,
	  #scoreboard,
	  #objective-zone,
	  #original-coins-zone,
	  #gold-zone,
	  #collected-coins,
	  #buy-placement-container,
	  #controls,
	  #round-modal-layer,
	  #shop-modal-layer,
	  #upgrade-modal-layer,
	  #deck-modal-layer,
	  #golden-unlock-layer,
	  #blackhole-modal-layer,
	  .objective-toast,
	  .zone-nav-arrow,
	  .zone-info-btn,
	  .zone-info-popover,
	  .zone-delete,
	  .trash-btn {
		display: none !important;
	  }

	  #board {
		display: flex !important;
		position: static !important;
		left: 0 !important;
		top: 0 !important;
		margin: 0 !important;
		transform: none !important;
	  }

	  /* Ensure print contains full grids, not only the visible part of scroll containers. */
	  #yellow-zone,
	  #green-zone,
	  #red-zone,
	  #purple-zone,
	  #blue-zone {
		overflow: visible !important;
		height: auto !important;
		max-height: none !important;
	  }
	  #yellow-grid,
	  #green-grid,
	  #purple-grid,
	  #blue-grid,
	  #red-zone .grid {
		overflow: visible !important;
		max-height: none !important;
	  }
	  .board {
		transform: none !important;
		max-height: none !important;
	  }
	  #board > .column:last-child {
		display: none !important;
	  }
	  #menu-toggle {
		display: inline-flex !important;
	  }
    }

	/*
		EN:
		- FIX: Some desktop "sub-breakpoint" rules are written as nested @media blocks inside
		  `@media (min-width: 651px) { ... }`. CSS nesting support varies by browser.
		- To make behavior consistent, we also include top-level versions of those @media queries here.
		- DUPLICATE: These mirror the nested blocks; keep them in sync if you edit one.
	*/
	@media (min-width: 651px) and (max-width: 1100px) {
		#card-choice-zone .card-label,
		#card-choice-zone .card-meta {
			display: none;
		}

		#card-choice-zone .card-option {
			min-width: 80px;
			min-height: 140px;
			padding: 8px 4px;
		}

		#card-choice-zone .card-option .card-cell {
			width: 18px;
			height: 18px;
		}

		#new-cards-btn,
		#rotate-card-btn {
			width: 44px;
			height: 44px;
			padding: 0;
			font-size: 0;
			justify-content: center;
		}

		#new-cards-btn::before,
		#rotate-card-btn::before {
			font-size: 1.8rem;
			position: absolute;
			top: 50%;
			left: 50%;
			transform: translate(-50%, -50%);
		}

		#rotate-card-btn {
			margin-top: 8px;
		}

		.deck-count {
			height: 44px;
			min-width: 44px;
			padding: 6px 8px;
			font-size: 0.95rem;
		}

		.deck-preview {
			padding: 6px 8px;
			min-height: 44px;
			width: auto;
			gap: 4px;
		}

		.deck-preview::after {
			display: none;
		}

		#turn-counter-inline {
			text-align: left;
			font-size: 0.9rem;
			padding-left: 8px;
		}

		#turn-counter-inline::before {
			content: '';
		}

		#objective-zone {
			width: 85%;
			max-width: 900px;
			padding: 8px 12px;
		}

		#desktop-bottom-left,
		#desktop-bottom-right {
			width: auto;
			min-width: 280px;
			max-width: 360px;
			flex-shrink: 1;
		}

		#desktop-wrapper {
			padding: 8px;
			gap: 12px;
		}
	}

	@media (min-width: 651px) and (max-width: 850px) {
		#objective-zone {
			width: 92%;
			max-width: 700px;
			padding: 8px 12px;
			font-size: 0.9rem;
		}

		#objective-zone h2 {
			font-size: 0.9rem;
		}

		#objective-current {
			font-size: 0.85rem;
		}

		#desktop-wrapper {
			padding: 8px;
			gap: 10px;
		}

		#desktop-bottom-left,
		#desktop-bottom-right {
			min-width: 240px;
			max-width: 320px;
		}

		#desktop-bottom {
			gap: 8px;
		}
	}

	@media (min-width: 651px) and (max-width: 900px) {
		body.desktop-portrait #desktop-bottom {
			gap: 8px;
			padding: 0 8px;
		}

		body.desktop-portrait #desktop-bottom-left {
			flex: 0 1 180px;
			min-width: 130px;
			max-width: 200px;
		}

		body.desktop-portrait #desktop-bottom-center {
			flex: 1 1 340px;
			min-width: 240px;
			max-width: 480px;
		}

		body.desktop-portrait #desktop-bottom-right {
			flex: 0 1 160px;
			min-width: 120px;
			max-width: 200px;
		}

		body.desktop-portrait #scoreboard {
			max-width: 190px;
			padding: 4px 5px;
			font-size: 0.8rem;
		}

		body.desktop-portrait #scoreboard .score-row {
			padding: 1px 3px;
			font-size: 0.75rem;
		}

		body.desktop-portrait #scoreboard .score-total {
			padding: 3px 5px;
			font-size: 0.78rem;
		}

		body.desktop-portrait #gold-zone {
			padding: 2px 6px;
			font-size: 0.85rem;
		}

		body.desktop-portrait .bonus-badge {
			padding: 4px 6px;
			font-size: 0.68rem;
		}
	}

	/* === Mobile zoom: make zoomed zones uniform (user request) === */
	@media (max-width: 650px) {
		body.zoomed-in #yellow-zone.zoom-focus,
		body.zoomed-in #green-zone.zoom-focus,
		body.zoomed-in #blue-zone.zoom-focus,
		body.zoomed-in #purple-zone.zoom-focus,
		body.zoomed-in #red-zone.zoom-focus {
			position: fixed !important;
			left: 0 !important;
			right: 0 !important;
			width: 100vw !important;
			max-width: 100vw !important;
			min-height: var(--mobile-zoom-height, 57svh) !important;
			max-height: var(--mobile-zoom-height, 57svh) !important;
			min-width: 0 !important;
			margin: 0 !important;

			/* Center position matches existing yellow-ish placement; JS clamps to avoid objective/bottom-bar overlap. */
			top: var(--mobile-zoom-center, calc(25% + 30px)) !important;
			height: var(--mobile-zoom-height, 57svh) !important;
			transform: translateY(-50%) !important;
			z-index: var(--z-zoom) !important;
			box-shadow: 0 0 30px rgba(0, 0, 0, 0.5);
		}

		/* If there is extra vertical room in zoom, center the small square grids (like Purple in the screenshot). */
		body.zoomed-in #yellow-zone.zoom-focus,
		body.zoomed-in #purple-zone.zoom-focus {
			justify-content: center !important;
		}
		/* Green zoom: let JS handle scroll-centering to the start cell; don't use align-items which moves the grid. */
		body.zoomed-in #green-zone.zoom-focus {
			align-items: flex-start !important;
			justify-content: flex-start !important;
		}

		/* Red zone: center the 2Ã—2 subgrids vertically within the fixed zoom container. */
		body.zoomed-in #red-zone.zoom-focus.red-group {
			display: grid !important;
			grid-template-columns: repeat(2, max-content) !important;
			justify-content: center !important;
			gap: 18px !important;
			align-content: center !important;
		}

		/* Red zone: ignore legacy min-height so it matches other zoomed zones. */
		body.zoomed-in #red-zone.zoom-focus {
			min-height: 0 !important;
			max-width: 100vw !important;
		}

		/* Keep green/blue scrollable while zoomed. */
		body.zoomed-in #green-zone.zoom-focus,
		body.zoomed-in #blue-zone.zoom-focus {
			overflow: auto !important;
			-webkit-overflow-scrolling: touch;
		}

		/* Red can be bigger than the viewport; allow scrolling in the fixed-height zoom container. */
		body.zoomed-in #red-zone.zoom-focus {
			overflow: auto !important;
			-webkit-overflow-scrolling: touch;
		}
	}

  </style>
  <script>
    // Simple menu toggle: toggles .open on #controls and .active on #menu-toggle
    document.addEventListener('DOMContentLoaded', function() {
        const menuToggle = document.getElementById('menu-toggle');
        const controls = document.getElementById('controls');
		const classicToggle = document.getElementById('classic-mode-toggle');

        if (!menuToggle || !controls) return;

        // ensure initial state: closed
        menuToggle.classList.remove('active');
        controls.classList.remove('open');

        // click toggles open state
        menuToggle.addEventListener('click', function(e) {
            e.stopPropagation();
            const opened = menuToggle.classList.toggle('active');
            if (opened) controls.classList.add('open'); else controls.classList.remove('open');
        });

        // clicking outside closes the menu
        document.addEventListener('click', function(event) {
            if (!menuToggle.contains(event.target) && !controls.contains(event.target)) {
                menuToggle.classList.remove('active');
                controls.classList.remove('open');
            }
        });

		// Classic mode toggle (persisted)
		const CLASSIC_MODE_KEY = 'locusClassicMode';
		const applyClassicModeUi = (enabled) => {
			document.body.classList.toggle('classic-mode', !!enabled);
			if (classicToggle) {
				classicToggle.setAttribute('aria-pressed', enabled ? 'true' : 'false');
				classicToggle.textContent = enabled ? 'Klassieke versie: aan' : 'Klassieke versie: uit';
			}
			// Mobile classic mode should run in landscape when the browser allows it.
			try {
				if (enabled && window.innerWidth <= (typeof MOBILE_BREAKPOINT !== 'undefined' ? MOBILE_BREAKPOINT : 650)) {
					if (screen && screen.orientation && typeof screen.orientation.lock === 'function') {
						screen.orientation.lock('landscape');
					}
				} else if (!enabled) {
					if (screen && screen.orientation && typeof screen.orientation.unlock === 'function') {
						screen.orientation.unlock();
					}
				}
			} catch (e) {}
			if (typeof updateCoinCounter === 'function') {
				updateCoinCounter();
			}
			if (typeof initialiseCoins === 'function') {
				try { initialiseCoins(enabled ? 20 : 50); } catch {}
			}
			if (typeof moveGameElements === 'function') {
				setTimeout(() => {
					try { moveGameElements(); } catch {}
				}, 0);
			}
		};

		try {
			const saved = localStorage.getItem(CLASSIC_MODE_KEY);
			applyClassicModeUi(saved === '1');
		} catch (e) {
			applyClassicModeUi(false);
		}

		if (classicToggle) {
			classicToggle.addEventListener('click', function(e) {
				e.stopPropagation();
				const enabled = !document.body.classList.contains('classic-mode');
				applyClassicModeUi(enabled);
				try {
					localStorage.setItem(CLASSIC_MODE_KEY, enabled ? '1' : '0');
				} catch (err) {}
				// Keep the menu open so the user can immediately toggle back.
				menuToggle.classList.add('active');
				controls.classList.add('open');
			});
		}
    });
  </script>
</head>

<body>
<div class="blur-overlay"></div>
<div id="drag-overlay"></div>

<!-- Floating preview voor touch-vriendelijke plaatsing -->
<div id="floating-preview">
  <div id="floating-preview-pattern"></div>
  <button id="floating-preview-rotate" title="Draai blok (tap of R)">â†»</button>
  <button id="floating-preview-mirror" title="Spiegel blok (tap of M)">â‡„</button>
  <button id="floating-preview-cancel" title="Annuleer selectie">Ã—</button>
</div>

<!-- Zoom-lens voor plaatsing preview (linksboven touch punt) -->
<div id="placement-zoom-lens" style="display: none;">
  <div id="zoom-lens-content"></div>
</div>

  <button id="dark-mode-toggle" title="Schakel donker/licht thema">ðŸŒ™</button>
	<button id="menu-toggle" class="menu-toggle" title="Menu" aria-label="Menu">
    <span></span>
    <span></span>
    <span></span>
  </button>
	<div id="mobile-objective-banner"></div>

	<!-- Mobile Sidebar Layout Container (hidden by default, JS populates for mobile) -->
	<div id="mobile-landscape-wrapper" style="display: none;">
		<div id="ml-sidebar-left"></div>
		<div id="ml-board-center">
			<div id="ml-objective-top" style="display: none;"></div>
		</div>
		<div id="ml-sidebar-right"></div>
	</div>
  
	<div id="board" class="board">
		<!-- Column 1: purple and yellow zones -->
		<div class="column">
		<div class="zone" data-color="paars" id="purple-zone">
			<button class="zone-info-btn" type="button" aria-label="Info: Paars" aria-expanded="false">i</button>
			<div class="zone-info-popover" role="tooltip" aria-hidden="true"></div>
			<div id="purple-grid" class="grid"></div>
		</div>
		<div class="zone" data-color="geel" id="yellow-zone">
			<button class="zone-info-btn" type="button" aria-label="Info: Geel" aria-expanded="false">i</button>
			<div class="zone-info-popover" role="tooltip" aria-hidden="true"></div>
		  <div id="yellow-grid" class="grid"></div>
		</div>
	  </div>
		  <!-- Column 2: green zone on top, red zone below -->
	  <div class="column">
		<div class="zone" data-color="groen" id="green-zone" >
			<button class="zone-info-btn" type="button" aria-label="Info: Groen" aria-expanded="false">i</button>
			<div class="zone-info-popover" role="tooltip" aria-hidden="true"></div>
			<div id="green-grid" class="grid"></div>
		</div>
		<div id="red-zone"  class="zone red-group" data-color="rood">
			<button class="zone-info-btn" type="button" aria-label="Info: Rood" aria-expanded="false">i</button>
			<div class="zone-info-popover" role="tooltip" aria-hidden="true"></div>
		  <div id="red-grid1" data-color="rood" data-zone="red-grid1" class="zone" data-subgrid="1"></div>
		  <div id="red-grid2" data-color="rood" data-zone="red-grid2" class="zone" data-subgrid="2"></div>
		  <div id="red-grid3" data-color="rood" data-zone="red-grid3" class="zone" data-subgrid="3"></div>
		  <div id="red-grid4" data-color="rood" data-zone="red-grid4" class="zone" data-subgrid="4"></div>
		</div>
		<div id="original-card-zone">
		<div class="zone" id="card-choice-zone">
	    <h2 id="kiesKaartTitel">Kies een kaart</h2>
		<br>
		    <div id="card-controls">
		      <div id="card-options"></div>
			  <button id="hand-scroll-left" class="hand-scroll-btn" type="button" aria-label="Scroll kaarten naar links" title="Vorige kaarten">â€¹</button>
			  <button id="hand-scroll-right" class="hand-scroll-btn" type="button" aria-label="Scroll kaarten naar rechts" title="Volgende kaarten">â€º</button>
			  <div id="turn-counter-inline" aria-live="polite">Beurt 1</div>
				<div id="card-action-buttons">
				<button id="new-cards-btn" class="card-action-btn" type="button" data-icon="âžœ" data-label="Volgende hand" aria-label="Volgende hand"></button>
				<button id="rotate-card-btn" class="card-action-btn" type="button" data-icon="âŸ³" data-label="Draai kaart" aria-label="Draai kaart"></button>
				<button id="mirror-card-btn" class="card-action-btn" type="button" data-icon="â‡„" data-label="Spiegel kaart" aria-label="Spiegel kaart"></button>
				<button id="bonus-shop-btn" class="card-action-btn" type="button" data-icon="ðŸª" data-label="Bonuswinkel" aria-label="Open bonuswinkel" style="display: none;"></button>
				<div id="deck-preview" class="deck-preview" role="button" tabindex="0" aria-haspopup="dialog" aria-controls="deck-modal" aria-label="Bekijk het volledige deck" data-label="Deck">
		        <div class="deck-count" data-deck-count="0">0</div>
		        </div>
		      </div>
		    </div>
		</div>
		</div>
	  </div>
	  <!-- Column 3: blue zone (long strip) -->
	  <div class="column">
		  <div class="zone" data-color="blauw" id="blue-zone">
			<button class="zone-info-btn" type="button" aria-label="Info: Blauw" aria-expanded="false">i</button>
			<div class="zone-info-popover" role="tooltip" aria-hidden="true"></div>
			<div id="blue-grid" class="grid"></div>
		  </div>
	  </div>
	   <!-- Column 4: coins, scoreboard, controls -->
	   <div class="column">
			<div id="original-coins-zone">
			<div class="zone" id="gold-zone">
			<h2 id="muntenTitel">Munten</h2>
			<div id="collected-coins"></div>
			<div id="buy-placement-container">
				<button id="buy-placement-btn" class="buy-placement-btn" type="button" title="Koop bonusblok (2 munten)">
					<span class="buy-placement-cost"><span class="coin-icon"></span><span class="coin-icon"></span></span>
					<span class="buy-placement-arrow" aria-hidden="true">â†’</span>
					<span class="buy-placement-rainbow-cell" aria-hidden="true"></span>
				</button>
				<div id="purchased-block-preview" class="purchased-block-preview" style="display: none;">
					<div class="purchased-block-cell"></div>
					<span class="purchased-block-label">Sleep me!</span>
				</div>
			</div>
		  </div>
			</div>
		<div id="original-score-zone">
		<div id="scoreboard" class="zone">
		  <h2>Score</h2>
		  <div class="score-total">
			<span class="label">Totaal</span>
			<span class="total-score" id="total-score">0</span>
		  </div>
		  <hr>
		  <div class="score-row yellow">
			<span class="color-box"></span>
			<span class="label">Geel</span>
			<span class="score" id="yellow-score">0</span>
		  </div>
		  <div class="score-row red">
			<span class="color-box"></span>
			<span class="label">Rood</span>
			<span class="score" id="red-score">0</span>
		  </div>
		  <div class="score-row green">
			<span class="color-box"></span>
			<span class="label">Groen</span>
			<span class="score" id="green-score">0</span>
		  </div>
		  <div class="score-row purple">
			<span class="color-box"></span>
			<span class="label">Paars</span>
			<span class="score" id="purple-score">0</span>
		  </div>
		  <div class="score-row blue">
			<span class="color-box"></span>
			<span class="label">Blauw</span>
			<span class="score" id="blue-score">0</span>
		  </div>
		  <div class="score-row bonus">
			<span class="color-box"></span>
			<span class="label">Bonus</span>
			<span class="score" id="bonus-score">0</span>
		  </div>
		</div>
		</div>
		<div id="original-objective-zone">
		  <div id="objective-zone" class="zone">
			<h2>Doel</h2>
			<div id="objective-current" class="objective-current objective-empty-state">Doelen worden geladenâ€¦</div>
			<ul id="objective-history" class="objective-history"></ul>
		  </div>
		</div>
		<div id="original-bonus-zone">
		  <div class="zone" id="bonus-zone">
			<h2>Bonussen</h2>
			<div id="bonus-inventory" class="bonus-inventory"></div>
			<p class="bonus-hint">Klik op een kleur om een gratis 1Ã—2 blok te plaatsen.</p>
		  </div>
		</div>
		<div class="zone" id="controls">
			<button onclick="undo()">Undo</button>
			<button id="new-game-btn" type="button">Nieuw Spel</button>
			<button id="classic-mode-toggle" type="button" aria-pressed="false">Klassieke versie: uit</button>
			<button id="debug-mode-toggle" type="button" aria-pressed="false">Debug modus: uit</button>
			<button id="print-btn" type="button">Print</button>
			<button id="menu-editor-btn" type="button">ðŸ› ï¸ Editor</button>
			<button id="menu-open-levels-btn" type="button" onclick="showSavedLevelsModal()">Open level</button>
			<button id="mobile-dark-mode-toggle" type="button">ðŸŒ™ Nacht</button>
			<button id="menu-rules-btn" onclick="showRulesModal()">ðŸ“– Spelregels</button>
			<button id="menu-highscore-btn" onclick="showHighScoreModal()">ðŸ† High Score</button>
		</div>
		<div id="original-controls-zone">
		  <div id="original-controls-zone-inner"></div>
		</div>
		<div class="tetris-block" data-shape='[[1,1],[1,1]]' data-color="#f00"></div>
	  </div> 
	</div>
		<!-- Mobile HUD: bottom bar injected via moveGameElements() for <=650px -->
		<div id="bottom-bar">
			<div id="bottom-bar-cards"></div>
			<div class="bottom-bar-footer">
				<div id="bottom-bar-left">
					<div id="bottom-bar-bonus"></div>
					<div id="bottom-bar-score-coins">
						<div id="bottom-bar-score"></div>
						<div id="bottom-bar-coins"></div>
					</div>
				</div>
			</div>
		</div>

		<div id="game-modal-layer" class="modal-overlay">
			<div id="round-modal" class="game-modal" role="dialog" aria-modal="true" aria-labelledby="round-modal-title">
				<h2 id="round-modal-title">Ronde voltooid</h2>
				<p id="round-modal-message">Goed gespeeld! Kies een optie om verder te gaan.</p>
				<div id="round-modal-summary" class="modal-score-summary"></div>
				<div class="modal-actions">
					<button id="round-modal-next">Volgende level</button>
					<button id="round-modal-restart">Opnieuw spelen</button>
				</div>
			</div>
		</div>

		<div id="shop-modal-layer" class="modal-overlay">
			<div id="shop-modal" class="game-modal" role="dialog" aria-modal="true" aria-labelledby="shop-modal-title">
				<div class="shop-modal-header">
					<h2 id="shop-modal-title">Kaarten &amp; Upgrades</h2>
					<button class="modal-close-btn" id="shop-modal-close" aria-label="Sluit winkel">&times;</button>
					<div class="shop-coin-display" id="shop-coin-display">
						<span class="shop-coin-label">Munten</span>
						<span class="shop-coin-balance" id="shop-coin-balance" aria-live="polite" aria-atomic="true">0</span>
					</div>
				</div>
				<p id="shop-modal-message">Besteed je munten aan kaarten, upgrades of bonussen.</p>
				<div class="shop-content-grid">
					<div class="shop-section shop-cards-section">
						<h3 class="shop-section-title">ðŸƒ Kaarten</h3>
						<div id="shop-card-options" class="shop-card-list"></div>
					</div>
					<div class="shop-lower-grid">
						<div class="shop-section shop-upgrades-section">
							<h3 class="shop-section-title">âš™ï¸ Upgrades</h3>
							<div id="shop-upgrade-container" class="shop-upgrade-container"></div>
						</div>
						<div class="shop-section shop-bonus-section">
							<h3 class="shop-section-title">âœ¨ Bonussen</h3>
							<div id="shop-bonus-container" class="shop-bonus-container"></div>
						</div>
						<div class="shop-section shop-freeplace-section">
							<h3 class="shop-section-title">ðŸŽ Extra Plaatsing</h3>
							<div id="shop-freeplace-container" class="shop-freeplace-container"></div>
						</div>
					</div>
				</div>
				<div class="modal-actions">
					<button id="shop-modal-skip">Naar volgend level</button>
				</div>
			</div>
		</div>

		<div id="print-settings-layer" class="modal-overlay" aria-hidden="true">
			<div id="print-settings-modal" class="game-modal" role="dialog" aria-modal="true" aria-labelledby="print-settings-title">
				<div class="shop-modal-header">
					<h2 id="print-settings-title">Print instellingen</h2>
					<button class="modal-close-btn" id="print-settings-close" aria-label="Sluit print instellingen">&times;</button>
				</div>
				<p id="print-settings-hint" style="margin-top: 6px;">Printvriendelijk (geen screenshot): alleen het speelveld, met zo min mogelijk inkt.</p>
				<div class="shop-content-grid" style="grid-template-columns: 1fr; gap: 10px;">
					<div class="shop-section" style="min-width: 0;">
						<h3 class="shop-section-title">Speelveld</h3>
						<label style="display:flex; gap:8px; align-items:center; margin: 6px 0;">
							<input type="radio" name="print-board-source" value="current" checked>
							<span>Huidig speelveld</span>
						</label>
						<label style="display:flex; gap:8px; align-items:center; margin: 6px 0;">
							<input type="radio" name="print-board-source" value="world1">
							<span>Genereer Wereld 1</span>
						</label>
						<label style="display:flex; gap:8px; align-items:center; margin: 6px 0;">
							<input type="radio" name="print-board-source" value="world2">
							<span>Genereer Wereld 2</span>
						</label>
					</div>
					<div class="shop-section" style="min-width: 0;">
						<h3 class="shop-section-title">Opties</h3>
						<label style="display:flex; gap:8px; align-items:center; margin: 6px 0;">
							<input id="print-opt-light" type="checkbox" checked>
							<span>Lichte modus</span>
						</label>
						<label style="display:flex; gap:8px; align-items:center; margin: 6px 0;">
							<input id="print-opt-no-bonuses" type="checkbox" checked>
							<span>Zonder bonussen/symbolen (minder inkt)</span>
						</label>
					</div>
				</div>
				<div class="modal-actions" style="justify-content: flex-end;">
					<button id="print-settings-cancel" type="button">Annuleer</button>
					<button id="print-settings-preview" type="button">Preview</button>
					<button id="print-settings-print" type="button">Print</button>
				</div>
			</div>
		</div>

		<!-- Unlock Modal -->
		<div id="unlock-modal-layer" class="modal-overlay">
			<div id="unlock-modal" class="game-modal unlock-modal" role="dialog" aria-modal="true">
				<div class="unlock-modal-content">
					<div class="unlock-icon" id="unlock-icon">ðŸŽ‰</div>
					<h2 id="unlock-title" class="unlock-title">Nieuwe Content!</h2>
					<div id="unlock-items" class="unlock-items-container"></div>
					<button id="unlock-modal-continue" class="modal-button">Doorgaan</button>
				</div>
			</div>
		</div>

		<div id="rules-modal-layer" class="modal-overlay">
			<div id="rules-modal" class="game-modal" role="dialog" aria-modal="true" aria-labelledby="rules-modal-title">
				<h2 id="rules-modal-title">ðŸ“– Spelregels</h2>
				
				<div class="rules-section">
					<h3>Hoe te spelen</h3>
					<p><strong>Doel:</strong> Voltooi het actieve level-objectief voordat je kaarten op zijn.</p>
				</div>

				<div class="rules-section">
					<h3>ðŸŽ´ Kaarten plaatsen</h3>
					<ul>
						<li>Kies een kaart uit je hand (3-4 kaarten)</li>
						<li>Klik op een kaart om te selecteren, klik opnieuw om te deselecteren</li>
						<li>Gebruik de draaiknop (â†») om de kaart te roteren</li>
						<li>Sleep de kaart naar een zone en plaats de blokken</li>
						<li>Kaarten verdwijnen na plaatsing</li>
					</ul>
				</div>

				<div class="rules-section">
					<h3>ðŸŽ¯ Zones & Scoring</h3>
					<ul>
						<li><strong>ðŸŸ¡ Geel:</strong> Vul hele kolommen voor punten (start: 10pt/kolom, groeit per level)</li>
						<li><strong>ðŸŸ¢ Groen:</strong> +10pt per takje dat je voltooit</li>
						<li><strong>ðŸŸ£ Paars:</strong> +1pt per blok voor elke aangrenzende verbinding</li>
						<li><strong>ðŸ”´ Rood:</strong> Vul alle 4 subgrids voor 10pt elk</li>
						<li><strong>ðŸ”µ Blauw:</strong> Vul rijen voor punten (elke 4e rij = vetgedrukt)</li>
						<li><strong>âœ¨ Gouden kaarten:</strong> Kunnen op elke zone geplaatst worden (unlock via upgrade)</li>
					</ul>
				</div>

				<div class="rules-section">
					<h3><span class="coin-symbol">ðŸª™</span> Munten & Upgrades</h3>
					<ul>
						<li>Verzamel munten door gouden cellen te activeren</li>
						<li>Gebruik munten in de winkel voor nieuwe kaarten of upgrades</li>
						<li>Upgrades: grotere hand, gouden kaarten, bonus boost, lucky draw, etc.</li>
					</ul>
				</div>

				<div class="rules-section">
					<h3>âš¡ Bonussen</h3>
					<ul>
						<li>Vul rijen met symbolen om bonusblokken te verdienen</li>
						<li>Klik op een bonus om een gratis 1Ã—2 blok te plaatsen</li>
						<li>Elke 3 bonuspunten = +1 munt</li>
					</ul>
				</div>

				<div class="rules-section">
					<h3>ðŸ“± Mobiele Bediening</h3>
					<ul>
						<li>Tik op een zone om in te zoomen</li>
						<li>Gebruik â—€â–¶ pijlen om tussen zones te navigeren</li>
						<li>Tik buiten de zone om uit te zoomen</li>
					</ul>
				</div>

				<div class="modal-actions">
					<button id="rules-modal-close">Sluiten</button>
				</div>
			</div>
		</div>

		<div id="upgrade-modal-layer" class="modal-overlay">
			<div id="upgrade-modal" class="game-modal" role="dialog" aria-modal="true" aria-labelledby="upgrade-modal-title">
				<h2 id="upgrade-modal-title">Upgrades (binnenkort)</h2>
				<p id="upgrade-modal-message">Dit scherm is gereserveerd voor toekomstige kaart-upgrades. Suggesties zijn welkom!</p>
				<div class="modal-actions">
					<button id="upgrade-modal-close">Sluiten</button>
				</div>
			</div>
		</div>

		<div id="confirm-complete-layer" class="modal-overlay">
			<div id="confirm-complete-modal" class="game-modal" role="dialog" aria-modal="true" aria-labelledby="confirm-complete-title">
				<h2 id="confirm-complete-title">Ronde voltooien?</h2>
				<p id="confirm-complete-message">Weet je zeker dat je de ronde wil voltooien?</p>
				<p id="confirm-complete-details" class="modal-subtext"></p>
				<div class="modal-actions">
					<button id="confirm-complete-yes">Ja</button>
					<button id="confirm-complete-no">Nee</button>
				</div>
			</div>
		</div>
		
		<div id="confirm-new-game-layer" class="modal-overlay">
			<div id="confirm-new-game-modal" class="game-modal" role="dialog" aria-modal="true" aria-labelledby="confirm-new-game-title">
				<h2 id="confirm-new-game-title">âš ï¸ Nieuw Spel Starten</h2>
				<p id="confirm-new-game-message">Weet je zeker dat je een nieuw spel wil starten?</p>
				<p id="confirm-new-game-details" class="modal-subtext">Je huidige voortgang (level, kaarten, upgrades) wordt permanent verwijderd.</p>
				<div class="modal-actions">
					<button id="confirm-new-game-yes" style="background: #d32f2f;">Ja, nieuw spel</button>
					<button id="confirm-new-game-no">Annuleren</button>
				</div>
			</div>
		</div>
		
		<div id="golden-unlock-layer" class="modal-overlay" aria-hidden="true">
			<div id="golden-unlock-modal" class="game-modal" role="dialog" aria-modal="true" aria-labelledby="golden-unlock-title" tabindex="-1">
				<h2 id="golden-unlock-title">âœ¨ Kies je eerste gouden kaart</h2>
				<p id="golden-unlock-subtext" class="modal-subtext">Je hebt <strong>Gouden Kaarten</strong> ontgrendeld. Kies er 1 uit 3.</p>
				<div id="golden-unlock-content" class="deck-modal-grid" role="list"></div>
			</div>
		</div>
		
		<div id="deck-modal-layer" class="modal-overlay" aria-hidden="true">
			<div id="deck-modal" class="game-modal" role="dialog" aria-modal="true" aria-labelledby="deck-modal-title">
				<h2 id="deck-modal-title">Deckoverzicht</h2>
				<p id="deck-modal-subtext" class="modal-subtext"></p>
				<div id="deck-modal-content" class="deck-modal-grid" role="list"></div>
				<div class="modal-actions">
					<button id="deck-modal-close" type="button">Sluiten</button>
				</div>
			</div>
		</div>
		<div id="blackhole-modal-layer" class="modal-overlay" aria-hidden="true">
			<div id="blackhole-modal" class="game-modal blackhole-modal" role="dialog" aria-modal="true" aria-labelledby="blackhole-modal-title" tabindex="-1">
				<h2 id="blackhole-modal-title">Zwart Gat Challenge</h2>
				<p id="blackhole-modal-subtext" class="modal-subtext"></p>
				<div class="blackhole-stats">
					<span>Kaarten gekozen: <strong id="blackhole-selection-count">0</strong>/<span id="blackhole-selection-limit">0</span></span>
					<span>PotentiÃ«le bonus: <strong id="blackhole-reward">0</strong></span>
					<span class="blackhole-stake">Inzet: <strong id="blackhole-stake-value">0</strong><span class="coin-symbol">ðŸª™</span> (x<strong id="blackhole-stake-mult">1</strong>)
						<input id="blackhole-stake" type="range" min="0" max="10" value="0" step="1" aria-label="Inzet munten" />
					</span>
				</div>
				<div id="blackhole-feedback" class="blackhole-feedback" aria-live="polite"></div>
				<div id="blackhole-card-grid" class="deck-modal-grid blackhole-card-grid" role="list"></div>
				<div class="modal-actions blackhole-actions">
					<button id="blackhole-claim-btn" type="button" disabled>Claim bonus</button>
					<button id="blackhole-forfeit-btn" type="button">Stop (âˆ’5)</button>
				</div>
			</div>
		</div>
		

  <script>
	// ---------- Utilities ----------
	
	// Helper functie om coin symbool te wrappen met correcte font
	// Zorgt voor consistente weergave in Edge en andere browsers
	function coinIcon(count = 1) {
		const coins = 'ðŸª™'.repeat(count);
		return `<span class="coin-symbol">${coins}</span>`;
	}
	
	const historyStack = [];
	const MAX_COINS = Infinity; // Geen limiet meer
	const MOBILE_BREAKPOINT = 650;
	const DESKTOP_LOW_HEIGHT_BREAKPOINT = 1080;
	const TRAP_PENALTY = 5;

	function isCoarsePointer() {
		try {
			return !!(window.matchMedia && window.matchMedia('(pointer: coarse)').matches);
		} catch {
			return false;
		}
	}

	function isMobileViewport() {
		// Mobile = small width OR (phone-landscape style: short height on coarse pointer).
		return window.innerWidth <= MOBILE_BREAKPOINT || (isCoarsePointer() && window.innerHeight <= 600);
	}
	// User request: black holes should be rarer.
	const BLACK_HOLE_DEFAULT_CHANCE = 0.12;
	const BLACK_HOLE_CARD_COUNT = 25; // 5x5 grid
	const BLACK_HOLE_MAX_SELECTION = 25;
	const BLACK_HOLE_POINT_MULTIPLIER = 2;
	const BLACK_HOLE_CARD_COLOR = {
	  name: 'zwart gat',
	  code: 'linear-gradient(135deg, #5f5a93 0%, #3b3662 55%, #191532 100%)'
	};

  function shuffleArray(a){
    for(let i=a.length-1;i>0;i--){
      const j = Math.floor(Math.random()*(i+1));
      [a[i],a[j]] = [a[j],a[i]];
    }
    return a;
  }
  
	let isDragging = false;
	let totalScoreFlashToken = 0;

	let yellow=0, green=0, purple=0, blue=0, red=0, bonus=0;
	let blackHoleBonus = 0;
	let totalBonusesCollected = 0;
	let latestScoreSnapshot = null;
	window.lastPlacementFailure = null;
	let blackHoleState = {
	  trap: null,
	  cards: [],
	  selected: new Set(),
	  reward: 0,
	  stake: 0,
	  feedbackTimeout: null
	};

	const GOLDEN_COLOR = { name: 'gouden', code: '#f5d76e', isGolden: true };
	const GOLDEN_FILL = 'linear-gradient(135deg, #fff4bf, #f5d76e, #d49f32)';
	const GOLDEN_CARD_SHAPES = [
		{ name: 'Gouden Vierkant', matrix: [[1,1],[1,1]], category: 'golden' },
		{ name: 'Gouden L', matrix: [[1,0],[1,0],[1,1]], category: 'golden' },
		{ name: 'Gouden Zuil', matrix: [[1],[1],[1]], category: 'golden' }
	];

	// ========== UPGRADE SYSTEEM ==========
	const UPGRADES = {
		wildcardCards: {
			id: 'wildcardCards',
			name: 'Multikleur Kaarten',
			description: 'Ontgrendel multikleur kaarten die op elk grid geplaatst kunnen worden.',
			cost: 13,
			icon: 'ðŸŒˆ',
			purchased: false,
			shopChance: 0.35,
			onPurchase: () => {
				showObjectiveToast('ðŸŒˆ Multikleur kaarten ontgrendeld! Kies meteen 1 multikleur kaart.');
				setTimeout(() => {
					openMulticolorRewardPicker();
				}, 80);
			}
		},
		miniPack34: {
			id: 'miniPack34',
			name: 'Compact Deck',
			description: 'Koop 3 mini-kaarten (max. 3 blokjes): kies 1 uit 3, drie keer.',
			cost: 8,
			icon: 'ðŸ“¦',
			purchased: false,
			onPurchase: () => {
				showObjectiveToast('ðŸ“¦ Compact Deck gekocht! Kies je 3 kaarten.');
				setTimeout(() => {
					startMini34RewardSequence();
				}, 80);
			}
		},
		goldenCards: {
			id: 'goldenCards',
			name: 'Gouden Kaarten',
			description: 'Ontgrendel gouden kaarten die op elk grid geplaatst kunnen worden.',
			cost: 15,
			icon: 'âœ¨',
			purchased: false,
			onPurchase: () => {
				showObjectiveToast('âœ¨ Gouden kaarten ontgrendeld! Kies meteen 1 gouden kaart.');
				// Immediate reward: let the player pick 1 of 3 golden cards.
				setTimeout(() => {
					openGoldenUnlockModal();
				}, 80);
			}
		},
		extraHandSize: {
			id: 'extraHandSize',
			name: 'Grotere Hand',
			description: 'Toon 1 extra kaart als kopie uit je deck (deck raakt niet sneller op).',
			cost: 17,
			icon: 'ðŸƒ',
			purchased: false,
			onPurchase: () => {
				// Logica staat in drawNextHand - toont kopie uit deck
			}
		},
		bonusBoost: {
			id: 'bonusBoost',
			name: 'Bonus Boost',
			description: 'Krijg 2 bonusblokken per kleur in plaats van 1.',
			cost: 15,
			icon: 'âš¡',
			purchased: false,
			onPurchase: () => {
				// Deze upgrade wijzigt toggleCell bonus logic
			}
		},
		multicolorBoost: {
			id: 'multicolorBoost',
			name: 'Multikleur Boost',
			description: '100% meer kans op multikleur tetris blokken (ook bij random shop).',
			cost: 10,
			icon: 'ðŸŒˆ',
			purchased: false,
			onPurchase: () => {
				showObjectiveToast('ðŸŒˆ Multikleur Boost actief! Dubbele kans op rainbow blokken.');
			}
		},
		luckyDraw: {
			id: 'luckyDraw',
			name: 'Lucky Draw',
			description: '25% kans op een bonuskopie van een kaart die nog in het deck zit.',
			cost: 8,
			icon: 'ðŸ€',
			purchased: false,
			onPurchase: () => {
				// Deze upgrade wijzigt drawNextHand
			}
		},
		coinMaster: {
			id: 'coinMaster',
			name: 'Muntmeester',
			description: 'Krijg 2 extra munten aan het begin van elk level.',
			cost: 6,
			icon: 'ðŸª™',
			purchased: false,
			onPurchase: () => {
				// Geef direct 2 munten
				const goldZone = document.getElementById('collected-coins');
				if (goldZone) {
					const coins = goldZone.querySelectorAll('.coin');
					let added = 0;
					coins.forEach(coin => {
						if (!coin.classList.contains('active') && added < 2) {
							coin.classList.add('active');
							added++;
						}
					});
					updateCoinCounter();
				}
			}
		},
		blackHoleAccess: {
			id: 'blackHoleAccess',
			name: 'Zwart Gat Pas',
			description: 'Ontgrendel het zwart gat bonuslevel wanneer je op een zwart gat landt.',
			cost: 21,
			icon: 'ðŸŒ€',
			purchased: false,
			onPurchase: () => {
				rebuildGameBoards();
				showObjectiveToast('ðŸŒ€ Zwart Gat Pas geactiveerd! Zwarte gaten zijn nu zichtbaar.');
			}
		},
		portals: {
			id: 'portals',
			name: 'Portals',
			description: 'Plaats tegelijkertijd op twee zones met portal verbinding.',
			cost: 20,
			icon: 'ðŸŒ',
			purchased: false,
			onPurchase: () => {
				activatePortals();
				showObjectiveToast('ðŸŒ Portals geactiveerd! Een portal is verschenen op het bord.');
			}
		},
		betterCards: {
			id: 'betterCards',
			name: 'Betere Kaarten',
			description: 'Ontgrendel een extra premium kaart in de shop (grotere vormen, meer kans op goud/multikleur).',
			cost: 25,
			icon: 'â™¦',
			purchased: false,
			onPurchase: () => {
				showObjectiveToast('â™¦ Premium shopkaart ontgrendeld!');
			}
		},
		xlBlocks: {
			id: 'xlBlocks',
			name: 'XL Blokken',
			description: 'Ontgrendel XL tetris vormen (6 blokjes) in de shop.',
			cost: 20,
			icon: 'ðŸ§±',
			purchased: false,
			onPurchase: () => {
				showObjectiveToast('ðŸ§± XL blokken ontgrendeld!');
			}
		},
		extraLargeBlocks: {
			id: 'extraLargeBlocks',
			name: 'XXL Blokken',
			description: 'Ontgrendel XXL tetris vormen (7+ blokjes) in de shop.',
			cost: 25,
			icon: 'ðŸ§±',
			purchased: false,
			onPurchase: () => {
				showObjectiveToast('ðŸ§± XXL blokken ontgrendeld!');
			}
		}
	};

	// Unlock systeem - bepaalt welke content beschikbaar is per level
	const UNLOCK_PROGRESSION = {
		// Kaart categorieÃ«n unlocks
		cardCategories: {
			mini: { unlockedAtLevel: 1, name: 'Mini Kaarten', icon: 'ðŸ“¦', description: 'Compacte kaarten van 2-3 blokjes' },
			standard: { unlockedAtLevel: 1, name: 'Standaard Kaarten', icon: 'ðŸŽ´', description: 'Klassieke Tetris vormen' },
			large: { unlockedAtLevel: 3, name: 'Grote Kaarten', icon: 'ðŸ“', description: 'Uitgebreide vormen met 5+ blokjes' }
		},
		// Speciale features
		features: {
			bonusShop: { unlockedAtWorld: 2, name: 'Bonus Shop', icon: 'ðŸª', description: 'Upgrade je bonussen permanent in de shop!' }
		},
		// Upgrade unlocks (level waarop ze in de shop verschijnen)
		upgrades: {
			miniPack34: { unlockedAtLevel: 5, announcement: 'nieuwe upgrade' },
			wildcardCards: { unlockedAtLevel: 7, announcement: 'nieuwe upgrade' },
			coinMaster: { unlockedAtLevel: 5, announcement: 'nieuwe upgrade' },
			goldenCards: { unlockedAtLevel: 7, announcement: 'nieuwe upgrade' },
			luckyDraw: { unlockedAtLevel: 5, announcement: 'nieuwe upgrade' },
			extraHandSize: { unlockedAtWorld: 2, unlockedAtLevel: 11, announcement: 'nieuwe upgrade' },
			multicolorBoost: { unlockedAtLevel: 11, announcement: 'nieuwe upgrade' },
			bonusBoost: { unlockedAtWorld: 2, unlockedAtLevel: 5, announcement: 'nieuwe upgrade' },
			blackHoleAccess: { unlockedAtLevel: 11, announcement: 'nieuwe uitdaging' },
			portals: { unlockedAtLevel: 11, announcement: 'nieuwe upgrade' },
			betterCards: { unlockedAtLevel: 11, announcement: 'nieuwe upgrade' },
			xlBlocks: { unlockedAtLevel: 7, announcement: 'nieuwe upgrade' },
			extraLargeBlocks: { unlockedAtLevel: 14, announcement: 'nieuwe upgrade' }
		},
		// Elk level track welke content unlocked is
		getLevelUnlocks: function(level, world = 1) {
			const unlocks = {
				cardCategories: [],
				upgrades: [],
				features: [],
				shopType: level % 2 === 0 ? 'full' : 'cards-only' // Elke 2 levels volledige shop (met upgrades)
			};
			
			// Check card categories
			Object.entries(this.cardCategories).forEach(([key, data]) => {
				if (data.unlockedAtLevel === level) {
					unlocks.cardCategories.push({ key, ...data });
				}
			});
			
			// Check features
			Object.entries(this.features || {}).forEach(([key, data]) => {
				if (data.unlockedAtLevel === level) {
					unlocks.features.push({ key, ...data });
				}
			});
			
			// Check upgrades
			Object.entries(this.upgrades).forEach(([key, data]) => {
				if (data.unlockedAtLevel === level && (!data.unlockedAtWorld || world >= data.unlockedAtWorld)) {
					unlocks.upgrades.push({ 
						key, 
						...data, 
						upgradeData: UPGRADES[key] 
					});
				}
			});
			
			return unlocks;
		},
		isUpgradeUnlocked: function(upgradeId, currentLevel, world = 1) {
			const u = this.upgrades[upgradeId];
			if (!u) return false;
			if (u.unlockedAtWorld && world < u.unlockedAtWorld) return false;
			return u.unlockedAtLevel <= currentLevel;
		},
		isCategoryUnlocked: function(category, currentLevel) {
			return this.cardCategories[category] && this.cardCategories[category].unlockedAtLevel <= currentLevel;
		},
		isFeatureUnlocked: function(featureId, level, world = 1) {
			if (!this.features || !this.features[featureId]) return false;
			const feature = this.features[featureId];
			if (feature.unlockedAtWorld) return world >= feature.unlockedAtWorld;
			if (feature.unlockedAtLevel) return level >= feature.unlockedAtLevel;
			return false;
		}
	};

	// Helper functie om upgrade status te checken
	function hasUpgrade(upgradeId) {
		// Back-compat: old saves used 'compactCards'. It now maps to miniPack34.
		if (upgradeId === 'miniPack34') return !!(UPGRADES.miniPack34?.purchased || UPGRADES.compactCards?.purchased);
		if (upgradeId === 'compactCards') return !!(UPGRADES.compactCards?.purchased || UPGRADES.miniPack34?.purchased);
		return UPGRADES[upgradeId]?.purchased || false;
	}

	function isWorld2Upgrade(upgradeId) {
		const meta = UNLOCK_PROGRESSION?.upgrades?.[upgradeId];
		if (!meta) return false;
		if (meta.unlockedAtWorld) return Number(meta.unlockedAtWorld) >= 2;
		const lvl = Number(meta.unlockedAtLevel) || 1;
		const info = (typeof getWorldAndSubLevel === 'function') ? getWorldAndSubLevel(lvl) : { world: 1 };
		return Number(info?.world || 1) >= 2;
	}

	function getEffectiveUpgradeCost(upgradeId) {
		const base = Number(UPGRADES?.[upgradeId]?.cost) || 0;
		if (Number(currentWorld || 1) >= 2 && isWorld2Upgrade(upgradeId)) return base * 2;
		return base;
	}

	// Unlock Modal Functies
	let pendingUnlockCallback = null;
	
	function showUnlockModal(levelUnlocks, callback) {
		const unlockModalLayer = document.getElementById('unlock-modal-layer');
		const unlockIcon = document.getElementById('unlock-icon');
		const unlockTitle = document.getElementById('unlock-title');
		const unlockItems = document.getElementById('unlock-items');
		
		if (!unlockModalLayer || !unlockItems) return;
		
		// Sla de callback op
		pendingUnlockCallback = callback;
		
		// Bepaal de icon en titel op basis van wat er is unlocked
		const hasChallenge = levelUnlocks.upgrades.some(u => u.announcement === 'nieuwe uitdaging');
		
		if (hasChallenge) {
			unlockIcon.textContent = 'âš ï¸';
			unlockTitle.textContent = 'Pas Op!';
		} else {
			unlockIcon.textContent = 'ðŸŽ‰';
			unlockTitle.textContent = 'Nieuwe Content Ontgrendeld!';
		}
		
		// Bouw unlock items
		unlockItems.innerHTML = '';
		
		// Voeg card categories toe
		levelUnlocks.cardCategories.forEach(cat => {
			const item = document.createElement('div');
			item.className = 'unlock-item';
			item.innerHTML = `
				<div class="unlock-item-icon">${cat.icon}</div>
				<div class="unlock-item-content">
					<div class="unlock-item-name">${cat.name}</div>
					<p class="unlock-item-description">${cat.description}</p>
				</div>
			`;
			unlockItems.appendChild(item);
		});
		
		// Voeg features toe (zoals Mega Bonus)
		if (levelUnlocks.features) {
			levelUnlocks.features.forEach(feature => {
				const item = document.createElement('div');
				item.className = 'unlock-item unlock-item--feature';
				item.innerHTML = `
					<div class="unlock-item-icon">${feature.icon}</div>
					<div class="unlock-item-content">
						<div class="unlock-item-name">${feature.name}</div>
						<p class="unlock-item-description">${feature.description}</p>
					</div>
				`;
				unlockItems.appendChild(item);
			});
		}
		
		// Voeg upgrades toe
		levelUnlocks.upgrades.forEach(upgrade => {
			const item = document.createElement('div');
			const isChallenge = upgrade.announcement === 'nieuwe uitdaging';
			item.className = isChallenge ? 'unlock-item unlock-item--challenge' : 'unlock-item';
			item.innerHTML = `
				<div class="unlock-item-icon">${upgrade.upgradeData.icon}</div>
				<div class="unlock-item-content">
					<div class="unlock-item-name">${upgrade.upgradeData.name}</div>
					<p class="unlock-item-description">${upgrade.upgradeData.description}</p>
				</div>
			`;
			unlockItems.appendChild(item);
		});
		
		unlockModalLayer.classList.add('show');
		console.log('ðŸŽ‰ Unlock modal shown');
	}

	function hideUnlockModal() {
		console.log('ðŸŽ‰ hideUnlockModal called');
		const unlockModalLayer = document.getElementById('unlock-modal-layer');
		if (unlockModalLayer) {
			unlockModalLayer.classList.remove('show');
		}
		// Roep de callback aan als die er is
		if (typeof pendingUnlockCallback === 'function') {
			console.log('ðŸŽ‰ Calling unlock callback');
			const cb = pendingUnlockCallback;
			pendingUnlockCallback = null;
			cb();
		} else {
			console.log('ðŸŽ‰ No unlock callback to call');
		}
	}

	// Portal systeem - twee vaste portals per level (Ã©Ã©n in geel, Ã©Ã©n in groen)
	let portalsActive = false;
	let portalCellYellow = null; // De portal cel in yellow-grid
	let portalCellGreen = null;  // De portal cel in green-grid

	function activatePortals() {
		portalsActive = true;
		placePortalsForLevel();
	}

	function placePortalsForLevel() {
		// Verwijder oude portals
		clearPortals();

		// Plaats portal in yellow-grid
		const yellowZone = document.getElementById('yellow-grid');
		if (yellowZone) {
			const yellowCells = Array.from(yellowZone.querySelectorAll('.cell:not(.void-cell):not(.active)'));
			if (yellowCells.length > 0) {
				const randomYellowCell = yellowCells[Math.floor(Math.random() * yellowCells.length)];
				setupPortalCell(randomYellowCell, 'yellow-grid');
				portalCellYellow = randomYellowCell;
			}
		}

		// Plaats portal in green-grid
		const greenZone = document.getElementById('green-grid');
		if (greenZone) {
			const greenCells = Array.from(greenZone.querySelectorAll('.cell:not(.void-cell):not(.active)'));
			if (greenCells.length > 0) {
				const randomGreenCell = greenCells[Math.floor(Math.random() * greenCells.length)];
				setupPortalCell(randomGreenCell, 'green-grid');
				portalCellGreen = randomGreenCell;
			}
		}

		console.log('ðŸŒ Portals placed for this level - Yellow:', !!portalCellYellow, 'Green:', !!portalCellGreen);
	}
	
	function clearPortals() {
		// Verwijder portal in yellow
		if (portalCellYellow) {
			portalCellYellow.classList.remove('portal-cell');
			portalCellYellow.classList.remove('bold-cell');
			const oldSymbol = portalCellYellow.querySelector('.portal-symbol');
			if (oldSymbol) oldSymbol.remove();
			portalCellYellow = null;
		}
		
		// Verwijder portal in green
		if (portalCellGreen) {
			portalCellGreen.classList.remove('portal-cell');
			portalCellGreen.classList.remove('bold-cell');
			const oldSymbol = portalCellGreen.querySelector('.portal-symbol');
			if (oldSymbol) oldSymbol.remove();
			portalCellGreen = null;
		}
	}
	
	function setupPortalCell(cell, zoneId) {
		cell.classList.add('portal-cell');
		cell.classList.add('bold-cell'); // Maak het een bold-cell zodat je vanaf hier kunt plaatsen!
		
		// Voeg portal symbool toe
		const portalSymbol = document.createElement('div');
		portalSymbol.classList.add('portal-symbol');
		portalSymbol.textContent = 'ðŸŒ';
		cell.appendChild(portalSymbol);
		
		console.log('ðŸŒ Portal placed in', zoneId);
	}

	// Mega Bonus systeem - random spawning vanaf level 4
	let megaBonusActive = false;
	let megaBonusCell = null;
	
	// Unified Shop systeem - no longer cell-based, always accessible from level 5
	// (Removed old cell-based shop placement logic)

	// Removed placeMegaBonus - merged into unified shop system

	function openBonusShopModal(specificColor = null) {
		// Toon de bonus sectie als modal
		showObjectiveToast('â™¦ Mega Bonus Shop geopend!');
		// We hergebruiken de bestaande shop modal maar tonen alleen bonussen
		const shopModalLayer = document.getElementById('shop-modal-layer');
		const shopModalTitle = document.getElementById('shop-modal-title');
		const shopModalMessage = document.getElementById('shop-modal-message');
		const shopCardOptions = document.getElementById('shop-card-options');
		const upgradesSection = document.querySelector('.shop-upgrades-section');
		const bonusSection = document.querySelector('.shop-bonus-section');
		const shopBonusContainer = document.getElementById('shop-bonus-container');
		
		if (!shopModalLayer || !shopBonusContainer) return;
		
		// Verberg kaarten en upgrades volledig in bonus shop
		if (shopCardOptions) shopCardOptions.closest('.shop-cards-section').style.display = 'none';
		if (upgradesSection) upgradesSection.style.display = 'none';
		
		// Toon alleen bonussen - zet parent grid om naar single column
		const shopContentGrid = document.querySelector('.shop-content-grid');
		if (shopContentGrid) {
			shopContentGrid.style.gridTemplateColumns = '1fr';
		}
		if (bonusSection) {
			bonusSection.style.display = '';
			const shopLowerGrid = bonusSection.closest('.shop-lower-grid');
			if (shopLowerGrid) shopLowerGrid.style.display = 'none';
			const parent = bonusSection.parentElement;
			if (parent && parent.classList.contains('shop-lower-grid')) {
				shopContentGrid.appendChild(bonusSection);
			}
		}
		
		// Update bonus UI om bonussen te tonen
		updateShopBonusUI();
		updateShopCoinDisplay();
		if (shopModalTitle) shopModalTitle.innerHTML = '<span class="diamond-glyph">â™¦</span> Mega Bonus Shop';
		if (shopModalMessage) {
			const coins = getSpendableCoinCount();
			shopModalMessage.textContent = coins >= 5
				? `Koop een bonus upgrade voor 5 munten!`
				: 'Je hebt niet genoeg munten (5 ðŸª™ nodig).';
		}
		
		// Filter bonus container om alleen de specifieke kleur te tonen als opgegeven
		if (specificColor) {
			shopBonusContainer.innerHTML = '';
			const meta = getBonusMeta(specificColor);
			if (!meta) return;
			
			const coins = getSpendableCoinCount();
			const bonusCard = document.createElement('div');
			bonusCard.classList.add('shop-bonus-card');
			
			const bonusHeader = document.createElement('div');
			bonusHeader.classList.add('shop-bonus-header');
			bonusHeader.innerHTML = `<span class="bonus-icon" style="background-color: ${meta.bgColor}">${meta.icon}</span><span class="bonus-name">${meta.name}</span>`;
			
			const bonusDesc = document.createElement('p');
			bonusDesc.classList.add('shop-bonus-desc');
			bonusDesc.textContent = `Krijg 1 bonus ${meta.name.toLowerCase()} blok.`;
			
			const bonusActions = document.createElement('div');
			bonusActions.classList.add('shop-bonus-actions');
			
			const buyBtn = document.createElement('button');
			const megaBonusCost = 5;
			buyBtn.innerHTML = `Kopen (${megaBonusCost} ${coinIcon()})`;
			buyBtn.disabled = coins < megaBonusCost;
			buyBtn.title = coins < megaBonusCost ? 'Onvoldoende munten' : `Koop ${meta.name} bonus`;
			buyBtn.addEventListener('click', () => {
				if (spendCoins(megaBonusCost)) {
					grantBonusCharge(specificColor);
					shopModalMessage.textContent = `${meta.icon} ${meta.name} bonus gekocht!`;
					updateShopCoinDisplay();
					buyBtn.disabled = true;
					setTimeout(() => {
						shopModalLayer.classList.remove('show');
						// Herstel visibility
						if (shopCardOptions) shopCardOptions.closest('.shop-cards-section').style.display = '';
						if (shopModalTitle) shopModalTitle.textContent = 'Kaarten & Upgrades';
					}, 1000);
				}
			});
			
			bonusActions.appendChild(buyBtn);
			bonusCard.append(bonusHeader, bonusDesc, bonusActions);
			shopBonusContainer.appendChild(bonusCard);
		} else {
			updateShopBonusUI();
		}
		
		updateShopCoinDisplay();
		shopModalLayer.classList.add('show');
		
		// Herstel normale shop bij sluiten
		const shopSkipBtn = document.getElementById('shop-modal-skip');
		if (shopSkipBtn) {
			const originalText = shopSkipBtn.textContent;
			shopSkipBtn.textContent = 'Sluiten';
			const handleClose = () => {
				shopModalLayer.classList.remove('show');
				shopSkipBtn.textContent = originalText;
				// Herstel visibility
				if (shopCardOptions) shopCardOptions.closest('.shop-cards-section').style.display = '';
				if (shopModalTitle) shopModalTitle.textContent = 'Kaarten & Upgrades';
				shopSkipBtn.removeEventListener('click', handleClose);
			};
			shopSkipBtn.addEventListener('click', handleClose, { once: true });
		}
	}

	// Objective templates - each level has 5 random candidates
	const OBJECTIVE_TEMPLATES = {
		1: [ // Level 1: Simple totals and single colors
			{
				id: 'level-1-total-10',
				description: 'Haal 10 punten totaal.',
				short: 'Level 1 - 10 punten totaal',
				check: scores => scores.total >= 10
			},
			{
				id: 'level-1-blue-8',
				description: 'Scoor 8 punten in blauw.',
				short: 'Level 1 - 8 punten blauw',
				check: scores => scores.blue >= 8
			},
			{
				id: 'level-1-yellow-6',
				description: 'Voltooi 1 kolom in geel.',
				short: 'Level 1 - 1 kolom geel',
				check: () => checkYellowFullRows(1)
			},
			{
				id: 'level-1-green-8',
				description: 'Scoor 8 punten in groen.',
				short: 'Level 1 - 8 punten groen',
				check: scores => scores.green >= 8
			},
			{
				id: 'level-1-purple-6',
				description: 'Scoor 6 punten in paars.',
				short: 'Level 1 - 8 punten paars',
				check: scores => scores.purple >= 8
			}
		],
		2: [ // Level 2: Higher totals and two-color combinations
			{
				id: 'level-2-total-20',
				description: 'Haal 20 punten totaal.',
				short: 'Level 2 - 20 punten totaal',
				check: scores => scores.total >= 20
			},
			{
				id: 'level-2-blue-yellow',
				description: 'Scoor 12 punten in geel en 6 in blauw.',
				short: 'Level 2 - 6 blauw + 12 geel',
				check: scores => scores.blue >= 6 && scores.yellow >= 12
			},
			{
				id: 'level-2-green-purple',
				description: 'Scoor 8 punten in groen Ã©n in paars.',
				short: 'Level 2 - 8 groen + 8 paars',
				check: scores => scores.green >= 8 && scores.purple >= 8
			},
			{
				id: 'level-2-bonus-collect-6',
				description: 'Verzamel 6 bonussen.',
				short: 'Level 2 - 6 bonussen',
				check: scores => (scores?.bonusesCollected || 0) >= 6,
				progress: scores => {
					const collected = Math.max(0, Math.min(6, (scores?.bonusesCollected || 0)));
					return `${collected}/6`;
				}
			}
		],
		3: [ // Level 3: Three colors and specific patterns
			{
				id: 'level-3-tricolor',
				description: 'Level 3: Scoor 8 punten in paars, blauw Ã©n geel.',
				short: 'Level 3 - 8 in paars/blauw/geel',
				check: scores => scores.purple >= 8 && scores.blue >= 8 && scores.yellow >= 8
			},
			{
				id: 'level-3-total-30',
				description: 'Level 3: Haal 30 punten totaal.',
				short: 'Level 3 - 30 punten totaal',
				check: scores => scores.total >= 30
			},
			{
				id: 'level-3-yellow-rows-2',
				description: 'Level 3: Voltooi 2 gele kolommen.',
				short: 'Level 3 - 2 gele kolommen',
				check: () => checkYellowFullRows(2),
				progress: () => {
					const yellowConfig = window.yellowGridConfig || {};
					const set = yellowConfig.scoreMode === 'diagonal'
						? (window.scoredYellowSegments || window.scoredYellowDiagonals)
						: window.scoredYellowColumns;
					const current = (set instanceof Set) ? set.size : 0;
					const capped = Math.max(0, Math.min(2, current));
					return `${capped}/2`;
				}
			},
			{
				id: 'level-3-green-red',
				description: 'Level 3: Scoor 8 in rood.',
				short: 'Level 3 - 8 in rood',
				check: scores => scores.red >= 8
			},
			{
				id: 'level-3-blue-14',
				description: 'Level 3: Scoor 20 punten in blauw',
				short: 'Level 3 - 20 punten blauw',
				check: scores => scores.blue >= 20
			}
		],
		4: [ // Level 4: Higher targets and complexity
			{
				id: 'level-4-green-16',
				description: 'Level 4: Bereik 16 punten in groen.',
				short: 'Level 4 - 16 punten groen',
				check: scores => scores.green >= 16
			},
			{
				id: 'level-4-total-40',
				description: 'Level 4: Haal 35 punten totaal.',
				short: 'Level 4 - 35 punten totaal',
				check: scores => scores.total >= 35
			},
			{
				id: 'level-4-all-colors-6',
				description: 'Level 4: Scoor minstens 6 punten in de kleuren geel, groen, paars en blauw.',
				short: 'Level 4 - 6+ in elke kleur',
				check: scores => scores.yellow >= 6 && scores.green >= 6 && scores.purple >= 6 && scores.blue >= 6,
				progress: scores => {
					const parts = [
						(scores.yellow >= 6 ? 'âœ”geel' : 'geel'),
						(scores.green >= 6 ? 'âœ”groen' : 'groen'),
						(scores.purple >= 6 ? 'âœ”paars' : 'paars'),
						(scores.blue >= 6 ? 'âœ”blauw' : 'blauw')
					];
					return parts.join(', ');
				}
			},
			{
				id: 'level-4-bonus-12',
			description: 'Level 4: Verzamel 12 bonussen.',
				short: 'Level4 - 12 bonussen',
				check: scores => (scores?.bonusesCollected || 0) >= 12,
				progress: scores => {
					const collected = Math.max(0, Math.min(12, (scores?.bonusesCollected || 0)));
					return `${collected}/12`;
				}
			},
			{
				id: 'level-4-purple-yellow',
				description: 'Level 4: Scoor 8 in paars en 12 in geel.',
				short: 'Level 4 - 8 paars + 12 geel',
				check: scores => scores.purple >= 8 && scores.yellow >= 12
			}
		],
		5: [ // Level 5: Pattern-based challenges
			{
				id: 'level-5-total-50',
				description: 'Level 5: Haal 40 punten totaal.',
				short: 'Level 5 - 40 punten totaal',
				check: scores => scores.total >= 40
			},
			{
				id: 'level-5-yellow-rows-3',
				description: 'Level 5: Scoor 16 punten in geel.',
				short: 'Level 5 - 16 punten geel',
				check: scores => scores.yellow >= 16
			},
			{
				id: 'level-5-blue-18',
				description: 'Level 5: Scoor 30 punten in blauw.',
				short: 'Level 5 - 30 punten blauw',
				check: scores => scores.blue >= 30
			},
			{
				id: 'level-5-red-12',
				description: 'Level 5: Scoor 12 punten in rood.',
				short: 'Level 5 - 12 punten rood',
				check: scores => scores.red >= 12
			}
		],
		6: [ // Level 6: Complex combinations
			{
				id: 'level-6-total-60',
				description: 'Level 6: Haal 50 punten totaal.',
				short: 'Level 6 - 50 punten totaal',
				check: scores => scores.total >= 50
			},
			{
				id: 'level-6-green-20',
				description: 'Level 6: Scoor 24 punten in groen.',
				short: 'Level 6 - 24 punten groen',
				check: scores => scores.green >= 24
			},
			{
				id: 'level-6-tricolor-advanced',
				description: 'Level 6: Scoor 12+ in paars, blauw Ã©n geel.',
				short: 'Level 6 - 12+ in paars/blauw/geel',
				check: scores => scores.purple >= 12 && scores.blue >= 12 && scores.yellow >= 12
			},
			{
				id: 'level-6-bonus-18',
				description: 'Level 6: Verzamel 18 bonussen.',
				short: 'Level 6 - 18 bonussen',
				check: scores => (scores?.bonusesCollected || 0) >= 18,
				progress: scores => {
					const collected = Math.max(0, Math.min(18, (scores?.bonusesCollected || 0)));
					return `${collected}/18`;
				}
			},
			{
				id: 'level-6-purple-18',
				description: 'Level 6: Scoor 18 punten in paars.',
				short: 'Level 6 - 18 punten paars',
				check: scores => scores.purple >= 18
			},
		],
		7: [ // Level 7: Advanced patterns
			{
				id: 'level-7-total-70',
				description: 'Level 7: Haal 60 punten totaal.',
				short: 'Level 7 - 60 punten totaal',
				check: scores => scores.total >= 60
			},
			{
				id: 'level-7-yellow-rows-5',
				description: 'Level 7: Voltooi 3 gele kolommen.',
				short: 'Level 7 - 3 gele kolommen',
				check: () => checkYellowFullRows(3),
				progress: () => {
					const yellowConfig = window.yellowGridConfig || {};
					const set = yellowConfig.scoreMode === 'diagonal'
						? (window.scoredYellowSegments || window.scoredYellowDiagonals)
						: window.scoredYellowColumns;
					const current = (set instanceof Set) ? set.size : 0;
					const capped = Math.max(0, Math.min(3, current));
					return `${capped}/3`;
				}
			},
			{
				id: 'level-7-all-colors-10',
				description: 'Level 7: Scoor minstens 10 in elke kleur.',
				short: 'Level 7 - 10+ in elke kleur',
				check: scores => scores.yellow >= 10 && scores.red >= 10 && scores.green >= 10 && scores.purple >= 10 && scores.blue >= 10,
				progress: scores => {
					const parts = [
						(scores.yellow >= 10 ? 'âœ”geel' : 'geel'),
						(scores.red >= 10 ? 'âœ”rood' : 'rood'),
						(scores.green >= 10 ? 'âœ”groen' : 'groen'),
						(scores.purple >= 10 ? 'âœ”paars' : 'paars'),
						(scores.blue >= 10 ? 'âœ”blauw' : 'blauw')
					];
					return parts.join(', ');
				}
			},
			{
				id: 'level-7-blue-purple',
				description: 'Level 7: Scoor 50 punten in blauw',
				short: 'Level 7 - 50 punten blauw',
				check: scores => scores.blue >= 50
			},
			{
				id: 'level-7-red-15',
				description: 'Level 7: Scoor 15 punten in rood.',
				short: 'Level 7 - 15 punten rood',
				check: scores => scores.red >= 15
			}
		],
		8: [ // Level 8: Very challenging
			{
				id: 'level-8-total-85',
				description: 'Level 8: Haal 85 punten totaal.',
				short: 'Level 8 - 85 punten totaal',
				check: scores => scores.total >= 85
			},
			{
				id: 'level-8-yellow-rows-6',
				description: 'Level 8: Voltooi 4 gele kolommen.',
				short: 'Level 8 - 4 gele kolommen',
				check: () => checkYellowFullRows(4),
				progress: () => {
					const yellowConfig = window.yellowGridConfig || {};
					const set = yellowConfig.scoreMode === 'diagonal'
						? (window.scoredYellowSegments || window.scoredYellowDiagonals)
						: window.scoredYellowColumns;
					const current = (set instanceof Set) ? set.size : 0;
					const capped = Math.max(0, Math.min(4, current));
					return `${capped}/4`;
				}
			},
			{
				id: 'level-8-green-purple-ring',
				description: 'Level 8: Scoor 24 punten in paars.',
				short: 'Level 8 - 24 punten paars',
				check: scores => scores.purple >= 24
			},
			{
				id: 'level-8-bonus-24',
				description: 'Level 8: Verzamel 24 bonussen.',
				short: 'Level 8 - 24 bonussen',
				check: scores => (scores?.bonusesCollected || 0) >= 24,
				progress: scores => {
					const collected = Math.max(0, Math.min(24, (scores?.bonusesCollected || 0)));
					return `${collected}/24`;
				}
			},
			{
				id: 'level-8-quad-color',
				description: 'Level 8: Scoor 14+ in geel, groen, paars Ã©n blauw.',
				short: 'Level 8 - 14+ in 4 kleuren',
				check: scores => scores.yellow >= 14 && scores.green >= 14 && scores.purple >= 14 && scores.blue >= 14,
				progress: scores => {
					const parts = [
						(scores.yellow >= 14 ? 'âœ”geel' : 'geel'),
						(scores.green >= 14 ? 'âœ”groen' : 'groen'),
						(scores.purple >= 14 ? 'âœ”paars' : 'paars'),
						(scores.blue >= 14 ? 'âœ”blauw' : 'blauw')
					];
					return parts.join(', ');
				}
			}
		],
		9: [ // Level 9: Expert level
			{
				id: 'level-9-total-100',
				description: 'Level 9: Haal 100 punten totaal.',
				short: 'Level 9 - 100 punten totaal',
				check: scores => scores.total >= 100
			},
			{
				id: 'level-9-yellow-rows-7',
				description: 'Level 9: Voltooi 5 gele kolommen.',
				short: 'Level 9 - 5 gele kolommen',
				check: () => checkYellowFullRows(5),
				progress: () => {
					const yellowConfig = window.yellowGridConfig || {};
					const set = yellowConfig.scoreMode === 'diagonal'
						? (window.scoredYellowSegments || window.scoredYellowDiagonals)
						: window.scoredYellowColumns;
					const current = (set instanceof Set) ? set.size : 0;
					const capped = Math.max(0, Math.min(5, current));
					return `${capped}/5`;
				}
			},
			{
				id: 'level-9-all-colors-15',
				description: 'Level 9: Scoor minstens 15 in elke kleur.',
				short: 'Level 9 - 15+ in elke kleur',
				check: scores => scores.yellow >= 15 && scores.red >= 15 && scores.green >= 15 && scores.purple >= 15 && scores.blue >= 15,
				progress: scores => {
					const parts = [
						(scores.yellow >= 15 ? 'âœ”geel' : 'geel'),
						(scores.red >= 15 ? 'âœ”rood' : 'rood'),
						(scores.green >= 15 ? 'âœ”groen' : 'groen'),
						(scores.purple >= 15 ? 'âœ”paars' : 'paars'),
						(scores.blue >= 15 ? 'âœ”blauw' : 'blauw')
					];
					return parts.join(', ');
				}
			},
			{
				id: 'level-9-blue-25',
				description: 'Level 9: Scoor 75 punten in blauw.',
				short: 'Level 9 - 75 punten blauw',
				check: scores => scores.blue >= 75
			},
			{
				id: 'level-9-combo-master',
				description: 'Level 9: Scoor 18 in rood, 2 gele kolommen Ã©n 24 bonus.',
				short: 'Level 9 - Combo master',
				check: scores => scores.red >= 18 && checkYellowFullRows(2) && ((scores?.bonusesCollected || 0) >= 24),
				progress: scores => {
					const yellowConfig = window.yellowGridConfig || {};
					const set = yellowConfig.scoreMode === 'diagonal'
						? (window.scoredYellowSegments || window.scoredYellowDiagonals)
						: window.scoredYellowColumns;
					const rowsDone = (set instanceof Set) ? set.size : 0;
					const rowsCapped = Math.max(0, Math.min(2, rowsDone));
					const bonusesDone = Math.max(0, (scores?.bonusesCollected || 0));
					const bonusesCapped = Math.max(0, Math.min(24, bonusesDone));
					return `gele kolommen: ${rowsCapped}/2 â€¢ bonussen: ${bonusesCapped}/24`;
				}
			}
		],
		10: [ // Level 10: Ultimate challenge
			{
				id: 'level-10-total-120',
				description: 'Level 10: Haal 120 punten totaal.',
				short: 'Level 10 - 120 punten totaal',
				check: scores => scores.total >= 120
			},
			{
				id: 'level-10-yellow-rows-8',
				description: 'Level 10: Voltooi 4 gele kolommen.',
				short: 'Level 10 - 4 gele kolommen',
				check: () => checkYellowFullRows(4),
				progress: () => {
					const yellowConfig = window.yellowGridConfig || {};
					const set = yellowConfig.scoreMode === 'diagonal'
						? (window.scoredYellowSegments || window.scoredYellowDiagonals)
						: window.scoredYellowColumns;
					const current = (set instanceof Set) ? set.size : 0;
					const capped = Math.max(0, Math.min(4, current));
					return `${capped}/4`;
				}
			},
			{
				id: 'level-10-perfect-balance',
				description: 'Level 10: Scoor 18+ in alle 5 kleuren.',
				short: 'Level 10 - Perfecte balans',
				check: scores => scores.yellow >= 18 && scores.red >= 18 && scores.green >= 18 && scores.purple >= 18 && scores.blue >= 18
			},
			{
				id: 'level-10-green-master',
				description: 'Level 10: Scoor 32 punten in groen.',
				short: 'Level 10 - Groen meester',
				check: scores => scores.green >= 32
			},
			{
				id: 'level-10-purple-ring',
				description: 'Level 10: Vul de volledige buitenrand van het paarse veld.',
				short: 'Level 10 - Paarse rand vol',
				check: () => checkPurpleOuterRingComplete()
			}
		],
		
		// WORLD 2 OBJECTIVES (Levels 11-20) - Complexere uitdagingen!
		11: [
			{
				id: 'level-11-world2-intro',
				description: 'Level 11: Welkom in Wereld 2! Scoor 40 punten totaal.',
				short: 'Level 11 - Wereld 2 intro',
				check: scores => ((scores.yellow + scores.red + scores.green + scores.purple + scores.blue) + (scores?.bonus || 0)) >= 40
			},
			{
				id: 'level-11-shape-master',
				description: 'Level 11: Voltooi 1 diagonale lijn van minstens 5 cellen in geel.',
				short: 'Level 11 - Diagonaal meester',
				check: () => {
					// Check of er een diagonaal van 5+ cellen volledig actief is
					const yellowZone = document.getElementById('yellow-zone');
					if (!yellowZone) return false;
					const grid = yellowZone.querySelector('.grid');
					if (!grid) return false;
					const cells = Array.from(grid.querySelectorAll('.cell:not(.void-cell)'));
					// Group cells by diagonal index
					const diagGroups = {};
					cells.forEach(cell => {
						const diag = cell.dataset.diag;
						if (diag !== undefined) {
							if (!diagGroups[diag]) diagGroups[diag] = [];
							diagGroups[diag].push(cell);
						}
					});
					// Check if any diagonal has 5+ cells all active
					for (const diag of Object.keys(diagGroups)) {
						const diagCells = diagGroups[diag];
						if (diagCells.length >= 5) {
							const allActive = diagCells.every(c => c.classList.contains('active'));
							if (allActive) return true;
						}
					}
					return false;
				}
			},
			{
				id: 'level-11-long-path',
				description: 'Level 11: Scoor 24 punten in blauw.',
				short: 'Level 11 - Lange reis',
				check: scores => scores.blue >= 24
			},
			{
				id: 'level-11-purple-expansion',
				description: 'Level 11: Scoor 24 punten in paars.',
				short: 'Level 11 - Paarse expansie',
				check: scores => scores.purple >= 24
			},
		],
		12: [
			{
				id: 'level-12-deep-roots',
				description: 'Level 12: Scoor 40 punten in groen (diepe wortels).',
				short: 'Level 12 - Diepe wortels',
				check: scores => scores.green >= 40
			},
			{
				id: 'level-12-red-connection',
				description: 'Level 12: Scoor 32 punten in rood (meerdere grids).',
				short: 'Level 12 - Rode verbinding',
				check: scores => scores.red >= 32
			},
			{
				id: 'level-12-yellow-precision',
				description: 'Level 12: Activeer alle boldcells in geel.',
				short: 'Level 12 - Gele precisie',
				check: () => {
					const yellowZone = document.getElementById('yellow-zone');
					if (!yellowZone) return false;
					const boldCells = yellowZone.querySelectorAll('.cell.bold-cell');
					const activeBoldCells = yellowZone.querySelectorAll('.cell.bold-cell.active');
					return boldCells.length > 0 && boldCells.length === activeBoldCells.length;
				}
			},
			{
				id: 'level-12-bonus-rush',
				description: 'Level 12: Verzamel 20 bonussen.',
				short: 'Level 12 - Bonus rush',
				check: scores => (scores?.bonusesCollected || 0) >= 20,
				progress: scores => {
					const collected = Math.max(0, Math.min(20, (scores?.bonusesCollected || 0)));
					return `${collected}/20`;
				}
			},
			{
				id: 'level-12-rainbow',
				description: 'Level 12: Scoor 18 punten elke kleur.',
				short: 'Level 12 - Regenboog',
				check: scores => scores.yellow >= 18 && scores.red >= 18 && scores.green >= 18 && scores.purple >= 18 && scores.blue >= 18
			}
		],
		13: [
			{
				id: 'level-13-mega-blue',
				description: 'Level 13: Scoor 40 punten in blauw.',
				short: 'Level 13 - Mega blauw',
				check: scores => scores.blue >= 40
			},
			{
				id: 'level-13-purple-perfect',
				description: 'Level 13: Scoor 40 punten in paars.',
				short: 'Level 13 - Paars 40 punten',
				check: scores => scores.purple >= 40
			},
			{
				id: 'level-13-green-giant',
				description: 'Level 13: Scoor 48 punten in groen.',
				short: 'Level 13 - Groene reus',
				check: scores => scores.green >= 48
			},
			{
				id: 'level-13-red-master',
				description: 'Level 13: Scoor 40 punten in rood.',
				short: 'Level 13 - Rood 40 punten',
				check: scores => scores.red >= 40
			},
			{
				id: 'level-13-yellow-artisan',
				description: 'Level 13: Voltooi 2 diagonale lijnen van minimaal 5 cellen in geel.',
				short: 'Level 13 - Gele artiest',
				check: () => {
					const yellowZone = document.getElementById('yellow-zone');
					if (!yellowZone) return false;
					const grid = yellowZone.querySelector('.grid');
					if (!grid) return false;
					const cells = Array.from(grid.querySelectorAll('.cell:not(.void-cell)'));
					// Group cells by diagonal index
					const diagGroups = {};
					cells.forEach(cell => {
						const diag = cell.dataset.diag;
						if (diag !== undefined) {
							if (!diagGroups[diag]) diagGroups[diag] = [];
							diagGroups[diag].push(cell);
						}
					});
					// Count how many diagonals have 6+ cells all active
					let completedDiagonals = 0;
					for (const diag of Object.keys(diagGroups)) {
						const diagCells = diagGroups[diag];
						if (diagCells.length >= 5) {
							const allActive = diagCells.every(c => c.classList.contains('active'));
							if (allActive) completedDiagonals++;
						}
					}
					return completedDiagonals >= 2;
				}
			}
		],
		14: [
			{
				id: 'level-14-total-score',
				description: 'Level 14: Scoor 160 punten totaal.',
				short: 'Level 14 - Totale score',
				check: scores => ((scores.yellow + scores.red + scores.green + scores.purple + scores.blue) + (scores?.bonus || 0)) >= 160
			},
			{
				id: 'level-14-balanced-power',
				description: 'Level 14: Scoor 30 punten in 4 verschillende kleuren.',
				short: 'Level 14 - Gebalanceerde kracht',
				check: scores => {
					const colorScores = [scores.yellow, scores.red, scores.green, scores.purple, scores.blue];
					return colorScores.filter(s => s >= 30).length >= 4;
				}
			},
			/* REMOVED BONUS OBJECTIVE AS REQUESTED */
			/*
			{
				id: 'level-14-bonus-master',
				description: 'Level 14: Verzamel 40+ bonuspunten.',
				short: 'Level 14 - Bonus meester',
				check: scores => scores.bonus >= 40,
				progress: scores => (scores.bonus >= 40 ? 'â­âœ”' : `â­${Math.max(0, scores.bonus)}/40`)
			},
			*/
			{
				id: 'level-14-blue-marathon',
				description: 'Level 14: Scoor 50 punten in blauw.',
				short: 'Level 14 - Blauwe marathon',
				check: scores => scores.blue >= 50
			},
			{
				id: 'level-14-multi-color-focus',
				description: 'Level 14: Scoor 42 punten in groen en paars.',
				short: 'Level 14 - Multi-kleur focus',
				check: scores => scores.green >= 42 && scores.purple >= 42
			}
		],
		15: [
			{
				id: 'level-15-trap-master',
				description: 'Level 15: Scoor 48 punten in groen en paars.',
				short: 'Level 15 - Val meester',
				check: scores => scores.purple >= 48 && scores.green >= 48
			},
			{
				id: 'level-15-green-legend',
				description: 'Level 15: Scoor 58 punten in groen.',
				short: 'Level 15 - Groene legende',
				check: scores => scores.green >= 58
			},
			{
				id: 'level-15-red-network',
				description: 'Level 15: Scoor 50 punten in rood.',
				short: 'Level 15 - Rood netwerk',
				check: scores => scores.red >= 50
			},
			{
				id: 'level-15-yellow-perfect',
				description: 'Level 15: Scoor 60 punten in geel.',
				short: 'Level 15 - Gele perfectie',
				check: scores => scores.yellow >= 60
			},
			{
				id: 'level-15-ultimate-balance',
				description: 'Level 15: Scoor 32 punten in elke kleur.',
				short: 'Level 15 - Ultieme balans',
				check: scores => scores.yellow >= 32 && scores.red >= 32 && scores.green >= 32 && scores.purple >= 32 && scores.blue >= 32
			}
		],
		16: [
			{
				id: 'level-16-total-domination',
				description: 'Level 16: Scoor 180 punten totaal.',
				short: 'Level 16 - Totale dominantie',
				check: scores => ((scores.yellow + scores.red + scores.green + scores.purple + scores.blue) + (scores?.bonus || 0)) >= 180
			},
			{
				id: 'level-16-blue-epic',
				description: 'Level 16: Scoor 60 punten in blauw.',
				short: 'Level 16 - Blauwe epic',
				check: scores => scores.blue >= 60
			},
			{
				id: 'level-16-purple-titan',
				description: 'Level 16: Scoor 60 punten in paars.',
				short: 'Level 16 - Paarse titaan',
				check: scores => scores.purple >= 60
			},
			{
				id: 'level-16-green-depths',
				description: 'Level 16: Scoor 65 punten in groen.',
				short: 'Level 16 - Groene dieptes',
				check: scores => scores.green >= 65
			},
			{
				id: 'level-16-bonus-legend',
				description: 'Level 16: Verzamel 25 bonuspunten.',
				short: 'Level 16 - Bonus legende',
				check: scores => scores.bonus >= 25,
				progress: scores => (scores.bonus >= 25 ? 'â­âœ”' : `â­${Math.max(0, scores.bonus)}/25`)
			}
		],
		17: [
			{
				id: 'level-17-red-empire',
				description: 'Level 17: Scoor 60 punten in rood.',
				short: 'Level 17 - Rood rijk',
				check: scores => scores.red >= 60
			},
			{
				id: 'level-17-four-pillars',
				description: 'Level 17: Scoor 48 punten in 4 verschillende kleuren.',
				short: 'Level 17 - Vier pilaren',
				check: scores => {
					const colorScores = [scores.yellow, scores.red, scores.green, scores.purple, scores.blue];
					return colorScores.filter(s => s >= 48).length >= 4;
				}
			},
			{
				id: 'level-17-yellow-architect',
				description: 'Level 17: Scoor 80 punten in geel.',
				short: 'Level 17 - Gele architect',
				check: scores => scores.yellow >= 80
			},
			{
				id: 'level-17-blue-odyssey',
				description: 'Level 17: Scoor 70 punten in blauw.',
				short: 'Level 17 - Blauwe odyssee',
				check: scores => scores.blue >= 70
			},
			{
				id: 'level-17-complete-mastery',
				description: 'Level 17: Scoor 48 punten elke kleur.',
				short: 'Level 17 - Complete meesterschap',
				check: scores => scores.yellow >= 48 && scores.red >= 48 && scores.green >= 48 && scores.purple >= 48 && scores.blue >= 48
			}
		],
		18: [
			{
				id: 'level-18-mega-score',
				description: 'Level 18: Scoor 200 punten totaal.',
				short: 'Level 18 - Mega score',
				check: scores => ((scores.yellow + scores.red + scores.green + scores.purple + scores.blue) + (scores?.bonus || 0)) >= 200
			},
			{
				id: 'level-18-green-abyss',
				description: 'Level 18: Scoor 70 punten in groen.',
				short: 'Level 18 - Groene afgrond',
				check: scores => scores.green >= 70
			},
			{
				id: 'level-18-purple-overlord',
				description: 'Level 18: Scoor 60 punten in paars.',
				short: 'Level 18 - Paarse overlord',
				check: scores => scores.purple >= 60
			},
			{
				id: 'level-18-red-megagrid',
				description: 'Level 18: Voltooi minstens 3 van de 4 rode grids.',
				short: 'Level 18 - Rood megagrid (3/4)',
				check: () => {
					const redZones = ['red-grid1-zone', 'red-grid2-zone', 'red-grid3-zone', 'red-grid4-zone'];
					let complete = 0;
					for (const id of redZones) {
						const zone = document.getElementById(id);
						if (!zone) continue;
						const cells = zone.querySelectorAll('.cell');
						const active = zone.querySelectorAll('.cell.active');
						if (cells.length > 0 && cells.length === active.length) complete += 1;
					}
					return complete >= 3;
				}
			},
			{
				id: 'level-18-bonus-titan',
				description: 'Level 18: Verzamel 30 bonuspunten.',
				short: 'Level 18 - Bonus titaan',
				check: scores => scores.bonus >= 30,
				progress: scores => (scores.bonus >= 30 ? 'â­âœ”' : `â­${Math.max(0, scores.bonus)}/30`)
			}
		],
		19: [
			{
				id: 'level-19-blue-legend',
				description: 'Level 19: Scoor 70 punten in blauw.',
				short: 'Level 19 - Blauwe legende',
				check: scores => scores.blue >= 70
			},
			{
				id: 'level-19-all-pillars',
				description: 'Level 19: Scoor 50 punten elke kleur.',
				short: 'Level 19 - Alle pilaren',
				check: scores => scores.yellow >= 50 && scores.red >= 50 && scores.green >= 50 && scores.purple >= 50 && scores.blue >= 50
			},
			{
				id: 'level-19-green-infinite',
				description: 'Level 19: Scoor 80 punten in groen.',
				short: 'Level 19 - Groene oneindigheid',
				check: scores => scores.green >= 80
			},
			{
				id: 'level-19-red-completion',
				description: 'Level 19: Scoor 60 punten in rood.',
				short: 'Level 19 - Rode voltooiing',
				check: scores => scores.red >= 60
			},
			{
				id: 'level-19-perfect-world',
				description: 'Level 19: Voltooi Ã©Ã©n zone perfect (alle cellen actief).',
				short: 'Level 19 - 1 perfecte zone',
				check: () => {
					const zoneIds = ['yellow-zone', 'purple-zone', 'blue-zone', 'green-zone'];
					return zoneIds.some(id => {
						const zone = document.getElementById(id);
						if (!zone) return false;
						const cells = zone.querySelectorAll('.cell');
						const active = zone.querySelectorAll('.cell.active');
						return cells.length > 0 && cells.length === active.length;
					});
				}
			}
		],
		20: [
			{
				id: 'level-20-ultimate',
				description: 'Level 20: Scoor 250 punten totaal (ultieme uitdaging).',
				short: 'Level 20 - Ultiem',
				check: scores => ((scores.yellow + scores.red + scores.green + scores.purple + scores.blue) + (scores?.bonus || 0)) >= 250
			},
			{
				id: 'level-20-perfect-balance',
				description: 'Level 20: Scoor 55 punten in elke kleur.',
				short: 'Level 20 - Perfecte balans',
				check: scores => scores.yellow >= 55 && scores.red >= 55 && scores.green >= 55 && scores.purple >= 55 && scores.blue >= 55,
				progress: scores => {
					const parts = [
						(scores.yellow >= 55 ? 'âœ”geel' : 'geel'),
						(scores.red >= 55 ? 'âœ”rood' : 'rood'),
						(scores.green >= 55 ? 'âœ”groen' : 'groen'),
						(scores.purple >= 55 ? 'âœ”paars' : 'paars'),
						(scores.blue >= 55 ? 'âœ”blauw' : 'blauw')
					];
					return parts.join(', ');
				}
			},
			{
				id: 'level-20-bonus-god',
				description: 'Level 20: Verzamel 30 bonuspunten.',
				short: 'Level 20 - Bonus god',
				check: scores => scores.bonus >= 30,
				progress: scores => (scores.bonus >= 30 ? 'â­âœ”' : `â­${Math.max(0, scores.bonus)}/30`)
			},
			{
				id: 'level-20-complete-all',
				description: 'Level 20: Voltooi minstens 2 zones volledig (alle cellen actief).',
				short: 'Level 20 - 2 volledige zones',
				check: () => {
					const colorZones = ['yellow-zone', 'purple-zone', 'blue-zone', 'green-zone'];
					const redZones = ['red-grid1-zone', 'red-grid2-zone', 'red-grid3-zone', 'red-grid4-zone'];
					let complete = 0;
					const isComplete = (zone) => {
						if (!zone) return false;
						const cells = zone.querySelectorAll('.cell');
						const active = zone.querySelectorAll('.cell.active');
						return cells.length > 0 && cells.length === active.length;
					};
					for (const id of colorZones) {
						const zone = document.getElementById(id);
						if (isComplete(zone)) complete += 1;
					}
					const redComplete = redZones.every(id => isComplete(document.getElementById(id)));
					if (redComplete) complete += 1;
					return complete >= 2;
				}
			},
			{
				id: 'level-20-world2-master',
				description: 'Level 20: Meester van Wereld 2 - Scoor 50 punten in elke kleur en haal 25+ bonus.',
				short: 'Level 20 - Wereld 2 meester',
				check: scores => {
					const colorScores = [scores.yellow, scores.red, scores.green, scores.purple, scores.blue];
					return colorScores.filter(s => s >= 50).length === 5 && scores.bonus >= 25;
				},
				progress: scores => {
					const parts = [
						(scores.yellow >= 50 ? 'âœ”geel' : 'geel'),
						(scores.red >= 50 ? 'âœ”rood' : 'rood'),
						(scores.green >= 50 ? 'âœ”groen' : 'groen'),
						(scores.purple >= 50 ? 'âœ”paars' : 'paars'),
						(scores.blue >= 50 ? 'âœ”blauw' : 'blauw'),
						(scores.bonus >= 25 ? 'â­âœ”' : 'â­' + scores.bonus)
					];
					return parts.join(', ');
				}
			}
		],
		// ========== WORLD 3: ULTIMATE CHALLENGE (Levels 21-30) ==========
		21: [
			{
				id: 'level-21-world3-intro',
				description: 'Level 21: Welkom in Wereld 3! Scoor 100 punten totaal.',
				short: 'Level 21 - Wereld 3 intro',
				check: scores => ((scores.yellow + scores.red + scores.green + scores.purple + scores.blue) + (scores?.bonus || 0)) >= 100
			},
			{
				id: 'level-21-blue-marathon',
				description: 'Level 21: Scoor 24 punten in blauw.',
				short: 'Level 21 - Blauwe marathon',
				check: scores => scores.blue >= 24
			},
			{
				id: 'level-21-green-explorer',
				description: 'Level 21: Scoor 30 punten in groen.',
				short: 'Level 21 - Groene verkenner',
				check: scores => scores.green >= 30
			},
			{
				id: 'level-21-balanced-champion',
				description: 'Level 21: Scoor 16 punten elke kleur.',
				short: 'Level 21 - Gebalanceerde kampioen',
				check: scores => scores.yellow >= 16 && scores.red >= 16 && scores.green >= 16 && scores.purple >= 16 && scores.blue >= 16,
				progress: scores => {
					const parts = [
						(scores.yellow >= 16 ? 'âœ”geel' : 'geel'),
						(scores.red >= 16 ? 'âœ”rood' : 'rood'),
						(scores.green >= 16 ? 'âœ”groen' : 'groen'),
						(scores.purple >= 16 ? 'âœ”paars' : 'paars'),
						(scores.blue >= 16 ? 'âœ”blauw' : 'blauw')
					];
					return parts.join(', ');
				}
			},
			{
				id: 'level-21-bonus-hunter',
				description: 'Level 21: Verzamel 24+ bonuspunten.',
				short: 'Level 21 - Bonus jager',
				check: scores => scores.bonus >= 24,
				progress: scores => (scores.bonus >= 24 ? 'âœ”' : `${Math.max(0, scores.bonus)}/24`)
			}
		],
		22: [
			{
				id: 'level-22-purple-domination',
				description: 'Level 22: Scoor 50 punten in paars.',
				short: 'Level 22 - Paarse dominantie',
				check: scores => scores.purple >= 50
			},
			{
				id: 'level-22-red-network',
				description: 'Level 22: Scoor 45 punten in rood.',
				short: 'Level 22 - Rood netwerk',
				check: scores => scores.red >= 45
			},
			{
				id: 'level-22-yellow-diamond',
				description: 'Level 22: Scoor 55 punten in geel.',
				short: 'Level 22 - Gele diamant',
				check: scores => scores.yellow >= 55
			},
			{
				id: 'level-22-coin-master',
				description: 'Level 22: Verzamel 15+ munten in dit level.',
				short: 'Level 22 - Munt meester',
				check: scores => getCollectedCoinCount(scores) >= 15,
				progress: scores => {
					const collected = Math.max(0, Math.min(15, getCollectedCoinCount(scores)));
					return `${collected}/15`;
				}
			},
			{
				id: 'level-22-dual-focus',
				description: 'Level 22: Scoor 40 punten in groen en blauw.',
				short: 'Level 22 - Dubbele focus',
				check: scores => scores.green >= 40 && scores.blue >= 40
			}
		],
		23: [
			{
				id: 'level-23-total-power',
				description: 'Level 23: Scoor 160 punten totaal.',
				short: 'Level 23 - Totale kracht',
				check: scores => ((scores.yellow + scores.red + scores.green + scores.purple + scores.blue) + (scores?.bonus || 0)) >= 160
			},
			{
				id: 'level-23-blue-split-master',
				description: 'Level 23: Scoor 60 punten in blauw.',
				short: 'Level 23 - Split meester',
				check: scores => scores.blue >= 60
			},
			{
				id: 'level-23-green-depth',
				description: 'Level 23: Scoor 80 punten in groen.',
				short: 'Level 23 - Groene diepte',
				check: scores => scores.green >= 80
			},
			{
				id: 'level-23-triple-threat',
				description: 'Level 23: Scoor 35 punten in 3 kleuren.',
				short: 'Level 23 - Drievoudige dreiging',
				check: scores => {
					const colorScores = [scores.yellow, scores.red, scores.green, scores.purple, scores.blue];
					return colorScores.filter(s => s >= 35).length >= 3;
				}
			},
			{
				id: 'level-23-purple-ring',
				description: 'Level 23: Voltooi de buitenste ring van paars.',
				short: 'Level 23 - Paarse ring',
				check: scores => scores.purple >= 45 && checkPurpleOuterRingComplete()
			}
		],
		24: [
			{
				id: 'level-24-extreme-balance',
				description: 'Level 24: Scoor 35 punten in elke kleur',
				short: 'Level 24 - Extreme balans',
				check: scores => scores.yellow >= 35 && scores.red >= 35 && scores.green >= 35 && scores.purple >= 35 && scores.blue >= 35,
				progress: scores => {
					const parts = [
						(scores.yellow >= 35 ? 'âœ”geel' : 'geel'),
						(scores.red >= 35 ? 'âœ”rood' : 'rood'),
						(scores.green >= 35 ? 'âœ”groen' : 'groen'),
						(scores.purple >= 35 ? 'âœ”paars' : 'paars'),
						(scores.blue >= 35 ? 'âœ”blauw' : 'blauw')
					];
					return parts.join(', ');
				}
			},
			{
				id: 'level-24-yellow-mastery',
				description: 'Level 24: Scoor 70 punten in geel.',
				short: 'Level 24 - Gele meesterschap',
				check: scores => scores.yellow >= 70
			},
			{
				id: 'level-24-red-empire',
				description: 'Level 24: Voltooi 3 van de 4 rode grids volledig.',
				short: 'Level 24 - Rood imperium',
				check: () => {
					const redZones = ['red-grid1-zone', 'red-grid2-zone', 'red-grid3-zone', 'red-grid4-zone'];
					let complete = 0;
					redZones.forEach(id => {
						const zone = document.getElementById(id);
						if (!zone) return;
						const cells = zone.querySelectorAll('.cell');
						const active = zone.querySelectorAll('.cell.active');
						if (cells.length > 0 && cells.length === active.length) complete++;
					});
					return complete >= 3;
				}
			},
			{
				id: 'level-24-bonus-rush',
				description: 'Level 24: Verzamel 30 bonussen.',
				short: 'Level 24 - Bonus rush',
				check: scores => (scores?.bonusesCollected || 0) >= 30,
				progress: scores => {
					const collected = Math.max(0, Math.min(30, (scores?.bonusesCollected || 0)));
					return `${collected}/30`;
				}
			},
			{
				id: 'level-24-blue-depths',
				description: 'Level 24: Scoor 75 punten in blauw.',
				short: 'Level 24 - Blauwe dieptes',
				check: scores => scores.blue >= 75
			}
		],
		25: [
			{
				id: 'level-25-halfway-champion',
				description: 'Level 25: Scoor 250 punten totaal.',
				short: 'Level 25 - Halverwege kampioen',
				check: scores => ((scores.yellow + scores.red + scores.green + scores.purple + scores.blue) + (scores?.bonus || 0)) >= 250
			},
			{
				id: 'level-25-quad-master',
				description: 'Level 25: Scoor 50 punten in 4 kleuren.',
				short: 'Level 25 - Viervoudige meester',
				check: scores => {
					const colorScores = [scores.yellow, scores.red, scores.green, scores.purple, scores.blue];
					return colorScores.filter(s => s >= 50).length >= 4;
				}
			},
			{
				id: 'level-25-green-legend',
				description: 'Level 25: Scoor 100 punten in groen.',
				short: 'Level 25 - Groene legende',
				check: scores => scores.green >= 100
			},
			{
				id: 'level-25-purple-complete',
				description: 'Level 25: Verbind de vier buitenste bold-cells in de paarse zone met actieve cellen.',
				short: 'Level 25 - Paars verbonden',
				check: () => {
					const purpleZone = document.getElementById('purple-zone');
					if (!purpleZone) return false;
					// Find bold corner cells by extremes of bold-cell coordinates
					const boldCells = Array.from(purpleZone.querySelectorAll('.cell.bold-cell:not(.void-cell)'));
					if (boldCells.length === 0) return false;
					const coords = boldCells.map(c => ({ x: Number(c.dataset.x), y: Number(c.dataset.y), el: c }));
					const xs = coords.map(c => c.x);
					const ys = coords.map(c => c.y);
					const minX = Math.min(...xs);
					const maxX = Math.max(...xs);
					const minY = Math.min(...ys);
					const maxY = Math.max(...ys);
					const cornerCoords = [[minX, minY], [minX, maxY], [maxX, minY], [maxX, maxY]];
					const cornerCells = cornerCoords.map(([x, y]) => purpleZone.querySelector(`.cell[data-x="${x}"][data-y="${y}"]`)).filter(Boolean);
					if (cornerCells.length !== 4) return false;
					// Require corner bold-cells to be active
					for (const c of cornerCells) if (!c.classList.contains('active')) return false;
					// Build set of active cell coordinates for BFS
					const activeSet = new Set(Array.from(purpleZone.querySelectorAll('.cell.active:not(.void-cell)')).map(c => `${c.dataset.x},${c.dataset.y}`));
					if (activeSet.size === 0) return false;
					const start = cornerCells[0];
					const startKey = `${start.dataset.x},${start.dataset.y}`;
					const queue = [startKey];
					const visited = new Set([startKey]);
					const neigh = [[1,0],[-1,0],[0,1],[0,-1]];
					while (queue.length) {
						const cur = queue.shift();
						const [cx, cy] = cur.split(',').map(Number);
						for (const [dx, dy] of neigh) {
							const nx = cx + dx;
							const ny = cy + dy;
							const key = `${nx},${ny}`;
							if (visited.has(key)) continue;
							if (!activeSet.has(key)) continue;
							visited.add(key);
							queue.push(key);
						}
					}
					// Ensure all other corner cells are reachable
					for (let i = 1; i < cornerCells.length; i++) {
						const k = `${cornerCells[i].dataset.x},${cornerCells[i].dataset.y}`;
						if (!visited.has(k)) return false;
					}
					return true;
				}
			},
			{
				id: 'level-25-coin-hoarder',
				description: 'Level 25: Verzamel 20+ munten.',
				short: 'Level 25 - Munt verzamelaar',
				check: scores => getCollectedCoinCount(scores) >= 20,
				progress: scores => {
					const collected = Math.max(0, Math.min(20, getCollectedCoinCount(scores)));
					return `${collected}/20`;
				}
			}
		],
		26: [
			{
				id: 'level-26-blue-infinity',
				description: 'Level 26: Scoor 100 punten in blauw.',
				short: 'Level 26 - Blauwe oneindigheid',
				check: scores => scores.blue >= 100
			},
			{
				id: 'level-26-all-reds',
				description: 'Level 26: Voltooi alle 4 rode grids volledig.',
				short: 'Level 26 - Alle roden',
				check: () => {
					const redZones = ['red-grid1-zone', 'red-grid2-zone', 'red-grid3-zone', 'red-grid4-zone'];
					return redZones.every(id => {
						const zone = document.getElementById(id);
						if (!zone) return false;
						const cells = zone.querySelectorAll('.cell');
						const active = zone.querySelectorAll('.cell.active');
						return cells.length > 0 && cells.length === active.length;
					});
				}
			},
			{
				id: 'level-26-extreme-yellow',
				description: 'Level 26: Scoor 85 punten in geel.',
				short: 'Level 26 - Extreem geel',
				check: scores => scores.yellow >= 85
			},
			{
				id: 'level-26-purple-titan',
				description: 'Level 26: Scoor 64 punten in paars.',
				short: 'Level 26 - Paarse titaan',
				check: scores => scores.purple >= 65
			},
			{
				id: 'level-26-five-colors',
				description: 'Level 26: Scoor 40 punten in elke kleur.',
				short: 'Level 26 - Vijf kleuren',
				check: scores => scores.yellow >= 40 && scores.red >= 40 && scores.green >= 40 && scores.purple >= 40 && scores.blue >= 40,
				progress: scores => {
					const parts = [
						(scores.yellow >= 40 ? 'âœ”geel' : 'geel'),
						(scores.red >= 40 ? 'âœ”rood' : 'rood'),
						(scores.green >= 40 ? 'âœ”groen' : 'groen'),
						(scores.purple >= 40 ? 'âœ”paars' : 'paars'),
						(scores.blue >= 40 ? 'âœ”blauw' : 'blauw')
					];
					return parts.join(', ');
				}
			}
		],
		27: [
			{
				id: 'level-27-mega-total',
				description: 'Level 27: Scoor 300 punten totaal.',
				short: 'Level 27 - Mega totaal',
				check: scores => ((scores.yellow + scores.red + scores.green + scores.purple + scores.blue) + (scores?.bonus || 0)) >= 300
			},
			{
				id: 'level-27-green-infinity',
				description: 'Level 27: Scoor 100 punten in groen.',
				short: 'Level 27 - Groene oneindigheid',
				check: scores => scores.green >= 100
			},
			{
				id: 'level-27-dual-domination',
				description: 'Level 27: Scoor 60 punten in geel en paars.',
				short: 'Level 27 - Dubbele dominantie',
				check: scores => scores.yellow >= 60 && scores.purple >= 60
			},
			{
				id: 'level-27-bonus-god',
				description: 'Level 27: Verzamel 30+ bonuspunten.',
				short: 'Level 27 - Bonus god',
				check: scores => scores.bonus >= 30,
				progress: scores => (scores.bonus >= 30 ? 'â­âœ”' : `â­${Math.max(0, scores.bonus)}/30`)
			},
			{
				id: 'level-27-red-perfection',
				description: 'Level 27: Scoor 60 punten in rood.',
				short: 'Level 27 - Rode perfectie',
				check: scores => scores.red >= 60
			}
		],
		28: [
			{
				id: 'level-28-ultimate-balance',
				description: 'Level 28: Scoor 50 punten in elke kleur',
				short: 'Level 28 - Ultieme balans',
				check: scores => scores.yellow >= 50 && scores.red >= 50 && scores.green >= 50 && scores.purple >= 50 && scores.blue >= 50,
				progress: scores => {
					const parts = [
						(scores.yellow >= 50 ? 'âœ”geel' : 'geel'),
						(scores.red >= 50 ? 'âœ”rood' : 'rood'),
						(scores.green >= 50 ? 'âœ”groen' : 'groen'),
						(scores.purple >= 50 ? 'âœ”paars' : 'paars'),
						(scores.blue >= 50 ? 'âœ”blauw' : 'blauw')
					];
					return parts.join(', ');
				}
			},
			{
				id: 'level-28-blue-master',
				description: 'Level 28: Scoor 120 punten in blauw.',
				short: 'Level 28 - Blauwe meester',
				check: scores => scores.blue >= 120
			},
			{
				id: 'level-28-yellow-emperor',
				description: 'Level 28: Scoor 100 punten in geel.',
				short: 'Level 28 - Gele keizer',
				check: scores => scores.yellow >= 100
			},
			{
				id: 'level-28-zone-complete',
				description: 'Level 28: Voltooi 2 zones volledig (alle cellen in geel, paars of groen).',
				short: 'Level 28 - Zone meester',
				check: () => {
					const zones = ['yellow-zone', 'purple-zone', 'green-zone'];
					let complete = 0;
					zones.forEach(id => {
						const zone = document.getElementById(id);
						if (!zone) return;
						const cells = zone.querySelectorAll('.cell');
						const active = zone.querySelectorAll('.cell.active');
						if (cells.length > 0 && cells.length === active.length) complete++;
					});
					return complete >= 2;
				}
			},
			{
				id: 'level-28-coin-emperor',
				description: 'Level 28: Verzamel 35+ munten.',
				short: 'Level 28 - Munt keizer',
				check: scores => getCollectedCoinCount(scores) >= 35,
				progress: scores => {
					const collected = Math.max(0, Math.min(35, getCollectedCoinCount(scores)));
					return `${collected}/35`;
				}
			}
		],
		29: [
			{
				id: 'level-29-penultimate',
				description: 'Level 29: Op naar de finale! Scoor 350+ punten totaal.',
				short: 'Level 29 - Bijna daar',
				check: scores => ((scores.yellow + scores.red + scores.green + scores.purple + scores.blue) + (scores?.bonus || 0)) >= 350
			},
			{
				id: 'level-29-green-god',
				description: 'Level 29: Scoor 150 punten in groen.',
				short: 'Level 29 - Groene god',
				check: scores => scores.green >= 150
			},
			{
				id: 'level-29-triple-60',
				description: 'Level 29: Scoor 90 punten in 3 kleuren naar keuze.',
				short: 'Level 29 - Triple 90',
				check: scores => {
					const colorScores = [scores.yellow, scores.red, scores.green, scores.purple, scores.blue];
					return colorScores.filter(s => s >= 90).length >= 3;
				}
			},
			{
				id: 'level-29-all-zones-active',
				description: 'Level 29: Activeer minstens 75% van alle zones.',
				short: 'Level 29 - Activatie expert',
				check: () => {
					const zones = ['yellow-zone', 'purple-zone', 'blue-zone', 'green-zone', 
								   'red-grid1-zone', 'red-grid2-zone', 'red-grid3-zone', 'red-grid4-zone', 'red-grid5-zone', 'red-grid6-zone'];
					let totalCells = 0;
					let activeCells = 0;
					zones.forEach(id => {
						const zone = document.getElementById(id);
						if (!zone) return;
						const cells = zone.querySelectorAll('.cell');
						const active = zone.querySelectorAll('.cell.active');
						totalCells += cells.length;
						activeCells += active.length;
					});
					return totalCells > 0 && (activeCells / totalCells) >= 0.75;
				}
			},
			{
				id: 'level-29-bonus-master',
				description: 'Level 29: Verzamel 40+ bonuspunten.',
				short: 'Level 29 - Bonus meester',
				check: scores => scores.bonus >= 40,
				progress: scores => (scores.bonus >= 40 ? 'â­âœ”' : `â­${Math.max(0, scores.bonus)}/40`)
			}
		],
		30: [
			{
				id: 'level-30-ultimate-champion',
				description: 'Level 30: FINALE! Scoor 400+ punten totaal.',
				short: 'Level 30 - Ultieme kampioen',
				check: scores => ((scores.yellow + scores.red + scores.green + scores.purple + scores.blue) + (scores?.bonus || 0)) >= 400
			}
		]
	};

	// Generate objectives array with random selection per level
	const OBJECTIVES = [];
	for (let level = 1; level <= 30; level++) { // Uitgebreid naar level 30 voor World 3
		const templates = OBJECTIVE_TEMPLATES[level] || [];
		if (templates.length > 0) {
			// Pick a random objective from the 5 available for this level
			const randomIndex = Math.floor(Math.random() * templates.length);
			const selected = templates[randomIndex];
			OBJECTIVES.push({
				...selected,
				level: level
			});
		}
	}

	let currentObjectiveId = null;
	const completedObjectives = [];
	const completedObjectiveIds = new Set();

	/* ============================================
	   DOELEN (OBJECTIVES) FUNCTIES
	   ============================================
	   Houdt bij welke doelen actief/voltooid zijn
	   Doelen geven extra uitdaging en structuur aan het spel
	*/
	function getObjectiveById(id) {
		if (!id) return null;
		return OBJECTIVES.find(obj => obj.id === id) || null;
	}

	// Parse a Dutch free-text objective (e.g. "Haal 50 punten bij geel" or "Haal 10 punten bij alle kleuren")
	// and return an objective-like object with a `.check(scores)` function.
	function parseObjectiveTextToObjective(text) {
		const raw = (text == null) ? '' : String(text || '').trim();
		const s = raw.toLowerCase();
		// detect numeric target
		const numMatch = s.match(/(\d{1,5})/);
		const target = numMatch ? parseInt(numMatch[1], 10) : null;
		const colorMap = { 'geel':'yellow', 'rood':'red', 'groen':'green', 'paars':'purple', 'blauw':'blue' };
		// find mentioned colors
		const colors = [];
		if (/alle kleuren|bij alle kleuren|alle kleur/.test(s)) {
			Object.keys(colorMap).forEach(k => colors.push(colorMap[k]));
		} else {
			Object.keys(colorMap).forEach(dutch => { if (s.indexOf(dutch) !== -1) colors.push(colorMap[dutch]); });
		}
		// determine if this is a total-target (in totaal) or per-color
		const wantsTotal = /totaal|in totaal|samen|alles samen/.test(s) && !!target;

		const id = `custom:${Date.now().toString(36)}:${Math.random().toString(36).slice(2,8)}`;
		const description = raw || '';
		const short = raw.length > 40 ? raw.slice(0,40) + '...' : raw;

		// Helper: produce a live snapshot of scores from provided object or from the DOM if omitted
		function getCurrentScores(provided) {
			const dutchToKey = { 'geel':'yellow', 'rood':'red', 'groen':'green', 'paars':'purple', 'blauw':'blue' };
			const snapshot = { yellow:0, red:0, green:0, purple:0, blue:0, bonus: (typeof bonus === 'number' ? bonus : 0), bonusesCollected: (typeof totalBonusesCollected === 'number' ? totalBonusesCollected : 0) };
			// If caller provided explicit snapshot, merge it over defaults
			if (provided && typeof provided === 'object') {
				Object.keys(snapshot).forEach(k => { if (provided[k] != null) snapshot[k] = provided[k]; });
				if (provided.total != null) snapshot.total = provided.total;
				return snapshot;
			}
			// Fallback to global numeric variables if present (these are updated during score calc)
			try {
				if (typeof yellow === 'number') snapshot.yellow = yellow;
				if (typeof red === 'number') snapshot.red = red;
				if (typeof green === 'number') snapshot.green = green;
				if (typeof purple === 'number') snapshot.purple = purple;
				if (typeof blue === 'number') snapshot.blue = blue;
			} catch (e) {}
			// If globals are zero-ish, try DOM counts (useful in some edge cases)
			try {
				Object.keys(dutchToKey).forEach(dutch => {
					const key = dutchToKey[dutch];
					if (snapshot[key] && snapshot[key] > 0) return;
					let count = 0;
					const nodes = document.querySelectorAll(`.zone[data-color="${dutch}"] .cell.active`);
					if (nodes && nodes.length) count = nodes.length;
					if (!count) {
						const alt = document.querySelectorAll(`#${key}-grid .cell.active`);
						if (alt && alt.length) count = alt.length;
					}
					if (count) snapshot[key] = count;
				});
			} catch (e) {}
			snapshot.total = (typeof snapshot.total === 'number') ? snapshot.total : (snapshot.yellow + snapshot.red + snapshot.green + snapshot.purple + snapshot.blue + (snapshot.bonus || 0));
			return snapshot;
		}

		function computeTotalFromScores(scores) {
			const s = getCurrentScores(scores);
			return (typeof s.total === 'number') ? s.total : 0;
		}

		// build check function
		let check;
		if (!target) {
			check = () => false;
		} else if (wantsTotal || colors.length === 0) {
			check = (scores) => {
				const total = computeTotalFromScores(scores);
				return total >= target;
			};
		} else {
			// per-color: ensure all mentioned colors meet the target
			const uniqColors = Array.from(new Set(colors));
			check = (scores) => {
				const s = getCurrentScores(scores);
				return uniqColors.every(c => (s[c] || 0) >= target);
			};
		}

		// progress helper returns a short progress string
		function progress(scores) {
			if (!target) return '';
			const s = getCurrentScores(scores);
			if (wantsTotal || colors.length === 0) {
				const total = computeTotalFromScores(s);
				return `${Math.min(total, target)}/${target}`;
			}
			const cols = Array.from(new Set(colors));
			const vals = cols.map(c => (s[c] || 0));
			const minv = Math.min.apply(null, vals.concat([0]));
			return `${Math.min(minv, target)}/${target}`;
		}

		return {
			id,
			description,
			short,
			check,
			progress
		};
	}

	function getObjectiveForLevel(level) {
		return OBJECTIVES.find(obj => obj.level === level) || null;
	}

	function isObjectiveCompleted(id) {
		return !!(id && completedObjectiveIds.has(id));
	}

	function isCurrentObjectiveCompleted() {
		const objective = getObjectiveById(currentObjectiveId);
		if (!objective) return true;
		const snapshot = latestScoreSnapshot || {
			yellow,
			red,
			green,
			purple,
			blue,
			bonus,
			bonusesCollected: totalBonusesCollected,
			total: yellow + red + green + purple + blue + bonus
		};
		try {
			return !!objective.check(snapshot);
		} catch (error) {
			console.warn('Objective check failed', objective.id, error);
			return false;
		}
	}

	function setCurrentObjectiveForLevel(level) {
		const objective = getObjectiveForLevel(level);
		currentObjectiveId = objective ? objective.id : null;
		renderObjectivePanel();
	}
	let objectiveToastTimeout = null;

	/* ============================================
	   DRAG & DROP VARIABELEN
	   ============================================
	   Globale state voor het slepen van kaarten/bonussen
	*/
	let draggedBlock = null;
	let draggedShape = null;
	let draggedColor = null;
	let isPointerDragging = false;
	let dragPointerId = null;
	let dragStartClientX = 0;
	let dragStartClientY = 0;
	let dragHasMoved = false;
	let rotateButton = null;
	let mirrorButton = null;
	let startX = 0;
	let startY = 0;
	let offsetX = 0; 
	let offsetY = 0;
	let lastZone = null;
	let lastBaseX = null;
	let lastBaseY = null;
	let skipNextZoneClick = false;
	let bonusCoinMilestones = 0;
	let activeTraps = [];
	let trapIdCounter = 0;
	let lastTrapHighlightId = null;

	function getBoardCellMetrics() {
		// Measure the *rendered* board cell size (accounts for transforms / scaling).
		let cellSizePx = 26;
		try {
			const sampleCell = document.querySelector('#board .grid .cell:not(.void-cell)');
			if (sampleCell) {
				const rect = sampleCell.getBoundingClientRect();
				cellSizePx = Math.min(rect.width, rect.height) || cellSizePx;
			} else {
				cellSizePx = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--cell-size')) || cellSizePx;
			}
		} catch {
			// keep default
		}

		let gapPx = 0;
		try {
			gapPx = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--board-grid-gap')) || 0;
		} catch {
			gapPx = 0;
		}

		return {
			cellSize: cellSizePx,
			gap: gapPx,
			step: cellSizePx + gapPx
		};
	}

	function computeShapeCenterOffsets(shape, cellSize = null) {
			try {
				if (!shape || !shape.length || !shape[0] || !shape[0].length) {
					return { offsetX: 0, offsetY: 0 };
				}
				const metrics = getBoardCellMetrics();
				// If a specific cellSize was passed, use it (gap assumed 0). Otherwise
				// when zoomed-in measure the actual cell size from the active zoom
				// zone so offsets align with the rendered draggable.
				const measuredRoot = (document.body.classList.contains('zoomed-in') && typeof activeZoomZone !== 'undefined' && activeZoomZone) ? activeZoomZone : null;
				const resolvedCellSize = Number.isFinite(cellSize) ? Number(cellSize) : getActualCellSize(measuredRoot) || metrics.cellSize;
				const resolvedGap = Number.isFinite(cellSize) ? 0 : metrics.gap;
				const resolvedStep = resolvedCellSize + resolvedGap;

			const shapeHeight = shape.length;
			const shapeWidth = shape[0].length;
			let minX = shapeWidth, maxX = -1, minY = shapeHeight, maxY = -1;
			for (let y = 0; y < shapeHeight; y++) {
				for (let x = 0; x < shapeWidth; x++) {
					if (shape[y][x]) {
						minX = Math.min(minX, x);
						maxX = Math.max(maxX, x);
						minY = Math.min(minY, y);
						maxY = Math.max(maxY, y);
					}
				}
			}
			if (maxX < 0 || maxY < 0) {
				return { offsetX: (shapeWidth * resolvedStep) / 2, offsetY: (shapeHeight * resolvedStep) / 2 };
			}
			const filledWidth = (maxX - minX + 1);
			const filledHeight = (maxY - minY + 1);
			// Center between first/last filled cell centers, accounting for grid gap.
			const centerCol = minX + (filledWidth - 1) / 2;
			const centerRow = minY + (filledHeight - 1) / 2;
			return {
				offsetX: (centerCol * resolvedStep) + (resolvedCellSize / 2),
				offsetY: (centerRow * resolvedStep) + (resolvedCellSize / 2)
			};
		} catch {
			return { offsetX: 0, offsetY: 0 };
		}
	}

	function beginPointerDrag({ clientX = 0, clientY = 0, pointerId = null } = {}) {
		isPointerDragging = true;
		dragPointerId = (pointerId !== undefined && pointerId !== null) ? pointerId : null;
		dragStartClientX = Number(clientX) || 0;
		dragStartClientY = Number(clientY) || 0;
		dragHasMoved = false;
		// Clear any stale hover/placement state so pointerup can't place immediately.
		lastZone = null;
		lastBaseX = lastBaseY = null;
	}

	function endPointerDragTracking() {
		isPointerDragging = false;
		dragPointerId = null;
		dragHasMoved = false;
	}

	/* ============================================
	   BONUS SYSTEEM
	   ============================================
	   Bonussen zijn speciale power-ups per kleur
	   Elk 10 punten op een kleur = 1 bonus
	   Bonussen kunnen gebruikt worden voor extra plaatsingen
	*/
	const BONUS_ORDER = ['yellow', 'red', 'green', 'purple', 'blue'];
	const BONUS_COLOR_CONFIG = {
		yellow: { label: 'Geel', colorName: 'geel', colorCode: '#cfba51' },
		red: { label: 'Rood', colorName: 'rood', colorCode: '#b56069' },
		green: { label: 'Groen', colorName: 'groen', colorCode: '#92c28c' },
		purple: { label: 'Paars', colorName: 'paars', colorCode: '#8f76b8' },
		blue: { label: 'Blauw', colorName: 'blauw', colorCode: '#5689b0' }
	};
	const BONUS_UPGRADE_COSTS = {
		yellow: 6,
		red: 6,
		green: 6,
		purple: 6,
		blue: 6
	};
	const bonusInventory = BONUS_ORDER.reduce((acc, key) => {
		acc[key] = 0;
		return acc;
	}, {});
	const bonusMasteryState = BONUS_ORDER.reduce((acc, key) => {
		acc[key] = false;
		return acc;
	}, {});
	const BONUS_SHAPES = {
		default: [[1], [1]],
		red: [[1]]
	};
	let activeBonusPlacement = null;
	
	// Free placement system
	let freePlacementsRemaining = 0;

	function isBonusUpgraded(colorKey) {
		return !!bonusMasteryState[colorKey];
	}

	function setBonusUpgraded(colorKey, upgraded = true) {
		if (!BONUS_COLOR_CONFIG[colorKey]) return;
		bonusMasteryState[colorKey] = !!upgraded;
	}

	function getBonusMeta(colorKey) {
		return BONUS_COLOR_CONFIG[colorKey] || null;
	}

	function getBonusShape(colorKey) {
		const upgraded = isBonusUpgraded(colorKey);
		if (colorKey && BONUS_SHAPES[colorKey]) {
			const base = cloneShape(BONUS_SHAPES[colorKey]);
			if (upgraded) {
				base.push([2]);
			}
			return base;
		}
		const base = cloneShape(BONUS_SHAPES.default);
		if (upgraded) {
			base.push([2]);
		}
		return base;
	}

	function checkPurpleOuterRingComplete() {
			const grid = document.getElementById('purple-grid');
			if (!grid) return false;
			const cells = Array.from(grid.querySelectorAll('.cell'));
			if (!cells.length) return false;
			const cols = parseInt(grid.dataset.cols || '0', 10) || (() => {
				const computed = getComputedStyle(grid).gridTemplateColumns;
				return computed ? computed.split(/\s+/).length : Math.round(Math.sqrt(cells.length)) || 1;
			})();
			const rows = parseInt(grid.dataset.rows || '0', 10) || Math.ceil(cells.length / cols);
			if (!cols || !rows) return false;
			for (let index = 0; index < cells.length; index += 1) {
				const row = Math.floor(index / cols);
				const col = index % cols;
				if (row === 0 || col === 0 || row === rows - 1 || col === cols - 1) {
					if (!cells[index].classList.contains('active')) {
						return false;
					}
				}
			}
			return true;
		}

		function checkYellowFullRows(targetColumns = 1) {
			const yellowConfig = window.yellowGridConfig || {};
			if (yellowConfig.scoreMode === 'diagonal') {
				const scoredSegments = window.scoredYellowSegments || window.scoredYellowDiagonals;
				return scoredSegments instanceof Set && scoredSegments.size >= targetColumns;
			}
			const scoredColumns = window.scoredYellowColumns;
			return scoredColumns instanceof Set && scoredColumns.size >= targetColumns;
		}

		function showObjectiveToast(message) {
			if (!message) return;
			let toast = document.querySelector('.objective-toast');
			if (!toast) {
				toast = document.createElement('div');
				toast.className = 'objective-toast';
				document.body.appendChild(toast);
			}
			// Render diamond glyph with special styling when present
			try {
				const safe = String(message).replace(/â™¦/g, '<span class="diamond-glyph">â™¦</span>');
				toast.innerHTML = safe;
			} catch (e) {
				toast.textContent = message;
			}
			toast.classList.add('show');
			if (objectiveToastTimeout) clearTimeout(objectiveToastTimeout);
			objectiveToastTimeout = setTimeout(() => {
				toast.classList.remove('show');
			}, 2400);
		}

		function stripObjectiveSymbols(text) {
			if (text == null) return '';
			let t = String(text);
			// Remove common emoji/symbol ranges + variation selectors.
			try {
				t = t.replace(/[\uFE0E\uFE0F]/g, '');
				t = t.replace(/[\u200D]/g, '');
				t = t.replace(/[\u2600-\u27BF]/g, '');
				t = t.replace(/[\u{1F000}-\u{1FAFF}]/gu, '');
			} catch {
				t = t.replace(/[\uFE0E\uFE0F\u200D\u2600-\u27BF]/g, '');
			}
			return t.replace(/\s{2,}/g, ' ').trim();
		}

		function normalizeObjectiveProgress(progressText) {
			let p = stripObjectiveSymbols(progressText);
			if (!p) return '';
			// If progress starts with "n/m ...", keep only "n/m".
			const m = p.match(/^\s*(\d+)\s*\/\s*(\d+)(?:\s+.*)?$/);
			if (m) return `${m[1]}/${m[2]}`;
			return p;
		}

		function renderObjectivePanel(snapshot = latestScoreSnapshot) {
			// If a custom board with metadata was loaded, show a compiled objective and its progress
			if (window && window.loadedCustomLevelMeta && (window.loadedCustomLevelMeta.name || window.loadedCustomLevelMeta.objective)) {
				const titleEl = document.querySelector('#objective-zone h2');
				const currentEl = document.getElementById('objective-current');
				if (titleEl && window.loadedCustomLevelMeta.name) titleEl.textContent = window.loadedCustomLevelMeta.name;
				const objText = (window.loadedCustomLevelMeta.objective || '').trim() || 'Haal 100 punten';
				const compiled = window.loadedCustomObjectiveCompiled || parseObjectiveTextToObjective(objText);
				const progressSource = snapshot || {
					yellow,
					red,
					green,
					purple,
					blue,
					bonus,
					bonusesCollected: totalBonusesCollected,
					total: yellow + red + green + purple + blue + bonus
				};
				let done = false;
				try { done = !!compiled.check(progressSource); } catch (e) { done = false; }
				if (currentEl) {
					currentEl.classList.toggle('objective-empty-state', false);
					if (done) {
						currentEl.innerHTML = `<strong>Doel:</strong> ${stripObjectiveSymbols(compiled.description)} <span style="opacity: 0.85;">(voltooid)</span>`;
					} else {
						let desc = stripObjectiveSymbols(compiled.description);
						if (typeof compiled.progress === 'function') {
							try {
								const p = normalizeObjectiveProgress(compiled.progress(progressSource));
								if (p) desc = `${desc} (${p})`;
							} catch (err) { /* ignore */ }
						}
						currentEl.innerHTML = `<strong>Doel:</strong> ${desc}`;
					}
				}
				return;
			}
			const currentEl = document.getElementById('objective-current');
			const historyEl = document.getElementById('objective-history');
			const titleEl = document.querySelector('#objective-zone h2');
			if (!currentEl || !historyEl) return;
			
			// Update titel met level nummer EN world indicator
			if (titleEl) {
				const { world, subLevel } = getWorldAndSubLevel(currentLevel);
				if (world === 1) {
					titleEl.textContent = `Level ${currentLevel}`;
					titleEl.style.background = '';
					titleEl.style.webkitBackgroundClip = '';
					titleEl.style.webkitTextFillColor = '';
				} else if (world === 2) {
					titleEl.textContent = `Wereld ${world} - Level ${world}.${subLevel}`;
					titleEl.style.background = 'linear-gradient(135deg, #5689b0, #8f76b8)';
					titleEl.style.webkitBackgroundClip = 'text';
					titleEl.style.webkitTextFillColor = 'transparent';
				} else if (world === 3) {
					titleEl.textContent = `Wereld ${world} - Level ${world}.${subLevel}`;
					titleEl.style.background = 'linear-gradient(135deg, #ff6b35, #f7931e, #ffcc02)';
					titleEl.style.webkitBackgroundClip = 'text';
					titleEl.style.webkitTextFillColor = 'transparent';
				} else {
					titleEl.textContent = `Wereld ${world} - Level ${world}.${subLevel}`;
					titleEl.style.background = 'linear-gradient(135deg, #5689b0, #8f76b8)';
					titleEl.style.webkitBackgroundClip = 'text';
					titleEl.style.webkitTextFillColor = 'transparent';
				}
			}

			historyEl.innerHTML = '';
			const objective = getObjectiveById(currentObjectiveId);
			if (!objective) {
				currentEl.classList.add('objective-empty-state');
				currentEl.textContent = 'Geen actief doel voor dit level.';
			} else {
				const progressSource = snapshot || {
					yellow,
					red,
					green,
					purple,
					blue,
					bonus,
					bonusesCollected: totalBonusesCollected,
					total: yellow + red + green + purple + blue + bonus
				};
				let isDone = false;
				try {
					isDone = !!objective.check(progressSource);
				} catch (error) {
					console.warn('Objective check failed', objective.id, error);
					isDone = false;
				}
				currentEl.classList.toggle('objective-empty-state', false);
				if (isDone) {
					// Voeg vinkje toe voor voltooide doelen, verwijder "Level X:" uit description
					let desc = objective.description.replace(/^Level\s+\d+:\s*/i, '');
					desc = stripObjectiveSymbols(desc);
					currentEl.innerHTML = `<strong>Doel:</strong> ${desc} <span style="opacity: 0.85;">(voltooid)</span>`;
				} else {
					let description = objective.description.replace(/^Level\s+\d+:\s*/i, '');
					description = stripObjectiveSymbols(description);
					if (typeof objective.progress === 'function') {
						try {
							const progressText = normalizeObjectiveProgress(objective.progress(progressSource));
							if (progressText) description = `${description} (${progressText})`;
						} catch (error) {
							console.warn('Objective progress failed', objective.id, error);
						}
					}
					currentEl.innerHTML = `<strong>Doel:</strong> ${description}`;
				}
			}

			// Verberg "nog geen doelen voltooid" op desktop
			if (completedObjectives.length === 0) {
				// Laat leeg op desktop
				historyEl.innerHTML = '';
			} else {
				completedObjectives.forEach(obj => {
					const item = document.createElement('li');
					const raw = obj.short || obj.description;
					item.textContent = stripObjectiveSymbols(String(raw || '').replace(/^Level\s+\d+:\s*/i, ''));
					historyEl.appendChild(item);
				});
			}
		}

		function resetObjectives() {
			currentObjectiveId = null;
			completedObjectives.length = 0;
			completedObjectiveIds.clear();
			latestScoreSnapshot = null;
			if (objectiveToastTimeout) {
				clearTimeout(objectiveToastTimeout);
				objectiveToastTimeout = null;
			}
			const toast = document.querySelector('.objective-toast');
			if (toast) toast.classList.remove('show');
			// Reset UI visueel
			const checkmark = document.querySelector('#objective-status');
			if (checkmark) checkmark.textContent = '';
			// Reset objective highlights
			clearObjectiveHighlights();
			renderObjectivePanel();
		}

		function updateObjectives(scores) {
			// If a custom board was loaded with a free-text objective, evaluate that first
			if (window && window.loadedCustomLevelMeta && window.loadedCustomLevelMeta.objective) {
				const compiled = window.loadedCustomObjectiveCompiled || parseObjectiveTextToObjective(window.loadedCustomLevelMeta.objective || '');
				const snapshotCustom = scores || latestScoreSnapshot || {
					yellow,
					red,
					green,
					purple,
					blue,
					bonus,
					bonusesCollected: totalBonusesCollected,
					total: yellow + red + green + purple + blue + bonus
				};
				latestScoreSnapshot = snapshotCustom;
				let achievedCustom = false;
				try { achievedCustom = !!compiled.check(snapshotCustom); } catch (e) { achievedCustom = false; }
				if (achievedCustom) {
					if (!window.loadedCustomLevelMetaCompleted) {
						window.loadedCustomLevelMetaCompleted = true;
						showObjectiveToast(`Doel behaald: ${compiled.short || compiled.description}`);
					}
				} else if (window.loadedCustomLevelMetaCompleted) {
					window.loadedCustomLevelMetaCompleted = false;
				}
				renderObjectivePanel(snapshotCustom);
				return;
			}
			const objective = getObjectiveById(currentObjectiveId);
			if (!objective) {
				renderObjectivePanel();
				return;
			}
			if (objective.level && objective.level !== currentLevel) {
				renderObjectivePanel();
				return;
			}
			const snapshot = scores || latestScoreSnapshot || {
				yellow,
				red,
				green,
				purple,
				blue,
				bonus,
				bonusesCollected: totalBonusesCollected,
				total: yellow + red + green + purple + blue + bonus
			};
			latestScoreSnapshot = snapshot;
			let achieved = false;
			try {
				achieved = !!objective.check(snapshot);
			} catch (error) {
				console.warn('Objective check failed', objective.id, error);
				return;
			}
			if (achieved) {
				if (!completedObjectiveIds.has(objective.id)) {
					completedObjectiveIds.add(objective.id);
					completedObjectives.push(objective);
					showObjectiveToast(`Doel behaald: ${objective.short || objective.description}`);
				}
			} else if (completedObjectiveIds.has(objective.id)) {
				// Objective can become un-achieved (e.g. undo). Keep UI/state in sync.
				completedObjectiveIds.delete(objective.id);
				const idx = completedObjectives.findIndex(obj => obj && obj.id === objective.id);
				if (idx >= 0) completedObjectives.splice(idx, 1);
			}
			renderObjectivePanel(snapshot);
		}

	function highlightAchievedObjectiveScores(scores) {
		// If a custom loaded objective exists, use that description for highlighting
		let objectiveDesc = null;
		let objectiveId = null;
		if (window && window.loadedCustomLevelMeta && window.loadedCustomLevelMeta.objective) {
			objectiveDesc = window.loadedCustomLevelMeta.objective || '';
			objectiveId = window.loadedCustomLevelMeta.name || 'custom';
		} else {
			const objective = getObjectiveById(currentObjectiveId);
			if (!objective) { clearObjectiveHighlights(); return; }
			objectiveDesc = objective.description || '';
			objectiveId = objective.id || '';
		}
		
		// Eerst alle highlights verwijderen
		clearObjectiveHighlights();
		
		// Controleer welke scores voldoen aan de objective eisen
		// Parse de objective beschrijving om score eisen te vinden
		// Check voor totaal score eisen (meer varianten ondersteunen)
		const extractMinTotal = (desc) => {
			if (!desc) return null;
			const s = String(desc);
			let m;
			m = s.match(/(\d+)\s*(?:punten|pt)\s*(?:totaal|in\s*totaal)/i);
			if (m) return parseInt(m[1], 10);
			m = s.match(/(?:totaal|in\s*totaal|totale\s*score|score\s*totaal|totaalscore)\s*(?:van\s*)?(\d+)/i);
			if (m) return parseInt(m[1], 10);
			return null;
		};
		const minTotal = extractMinTotal(objectiveDesc);
		if (Number.isFinite(minTotal) && scores.total >= minTotal) {
			const totalEl = document.querySelector('#scoreboard .score-total');
			if (totalEl) totalEl.classList.add('objective-achieved');
		}
		
		// Check voor kleur specifieke eisen (ondersteunt ook: "paarse zone", "gele" etc)
		const pickNumber = (m) => {
			if (!m) return null;
			const raw = (m[1] != null ? m[1] : null) || (m[2] != null ? m[2] : null);
			const n = raw != null ? parseInt(raw, 10) : NaN;
			return Number.isFinite(n) ? n : null;
		};
		const colorPatterns = [
			{ name: 'yellow', regex: /(?:in\s*(?:de\s*)?(?:gele|geel)(?:\s*zone)?\s*(?:minstens\s*)?(\d+)\s*(?:punten|pt)?)|(\d+)\s*(?:punten|pt)?\s*(?:in\s*)?(?:de\s*)?(?:gele|geel)(?:\s*zone)?/i },
			{ name: 'red', regex: /(?:in\s*(?:de\s*)?(?:rode|rood)(?:\s*zone)?\s*(?:minstens\s*)?(\d+)\s*(?:punten|pt)?)|(\d+)\s*(?:punten|pt)?\s*(?:in\s*)?(?:de\s*)?(?:rode|rood)(?:\s*zone)?/i },
			{ name: 'green', regex: /(?:in\s*(?:de\s*)?(?:groene|groen)(?:\s*zone)?\s*(?:minstens\s*)?(\d+)\s*(?:punten|pt)?)|(\d+)\s*(?:punten|pt)?\s*(?:in\s*)?(?:de\s*)?(?:groene|groen)(?:\s*zone)?/i },
			{ name: 'purple', regex: /(?:in\s*(?:de\s*)?(?:paarse|paars)(?:\s*zone)?\s*(?:minstens\s*)?(\d+)\s*(?:punten|pt)?)|(\d+)\s*(?:punten|pt)?\s*(?:in\s*)?(?:de\s*)?(?:paarse|paars)(?:\s*zone)?/i },
			{ name: 'blue', regex: /(?:in\s*(?:de\s*)?(?:blauwe|blauw)(?:\s*zone)?\s*(?:minstens\s*)?(\d+)\s*(?:punten|pt)?)|(\d+)\s*(?:punten|pt)?\s*(?:in\s*)?(?:de\s*)?(?:blauwe|blauw)(?:\s*zone)?/i }
		];
		
		colorPatterns.forEach(({ name, regex }) => {
			const match = objectiveDesc.match(regex);
			const minScore = pickNumber(match);
			if (Number.isFinite(minScore) && scores[name] >= minScore) {
				const row = document.querySelector(`.score-row.${name}`);
				if (row) row.classList.add('objective-achieved');
			}
		});
		
		// Check voor "minstens X in elke kleur" patronen
		const allColorsMatch = objectiveDesc.match(/minstens\s*(\d+)\s*(?:punten|pt)?\s*(?:in\s*)?(?:de\s*kleuren|elke\s*kleur)/i);
		if (allColorsMatch) {
			const minScore = parseInt(allColorsMatch[1], 10);
			['yellow', 'red', 'green', 'purple', 'blue'].forEach(color => {
				if (scores[color] >= minScore) {
					const row = document.querySelector(`.score-row.${color}`);
					if (row) row.classList.add('objective-achieved');
				}
			});
		}
		
		// Check voor specifieke patronen zoals "8 punten in paars Ã©n 6 in geel"
		// Ook ondersteund: "8 punten in groen Ã©n in paars" (zelfde drempel voor meerdere kleuren)
		const sharedThresholdMultiColorPattern = /(\d+)\s*(?:punten|pt)?\s*(?:in\s*)?(?:de\s*)?(gele|geel|rode|rood|groene|groen|paarse|paars|blauwe|blauw)\s*(?:zone)?\s*(?:Ã©n|en)\s*(?:in\s*)?(?:de\s*)?(gele|geel|rode|rood|groene|groen|paarse|paars|blauwe|blauw)/gi;
		let sharedMatch;
		while ((sharedMatch = sharedThresholdMultiColorPattern.exec(objectiveDesc)) !== null) {
			const minScore = parseInt(sharedMatch[1], 10);
			const color1Name = sharedMatch[2];
			const color2Name = sharedMatch[3];
			const colorMap = { 'geel': 'yellow', 'gele': 'yellow', 'rood': 'red', 'rode': 'red', 'groen': 'green', 'groene': 'green', 'paars': 'purple', 'paarse': 'purple', 'blauw': 'blue', 'blauwe': 'blue' };
			const color1 = colorMap[color1Name];
			const color2 = colorMap[color2Name];
			if (color1 && scores[color1] >= minScore) {
				const row = document.querySelector(`.score-row.${color1}`);
				if (row) row.classList.add('objective-achieved');
			}
			if (color2 && scores[color2] >= minScore) {
				const row = document.querySelector(`.score-row.${color2}`);
				if (row) row.classList.add('objective-achieved');
			}
		}

		const multiColorPattern = /(\d+)\s*(?:punten|pt)?\s*(?:in\s*)?(?:de\s*)?(gele|geel|rode|rood|groene|groen|paarse|paars|blauwe|blauw)\s*(?:zone)?\s*(?:Ã©n|en)\s*(\d+)\s*(?:punten|pt)?\s*(?:in\s*)?(?:de\s*)?(gele|geel|rode|rood|groene|groen|paarse|paars|blauwe|blauw)\s*(?:zone)?/gi;
		let multiMatch;
		while ((multiMatch = multiColorPattern.exec(objectiveDesc)) !== null) {
			const score1 = parseInt(multiMatch[1], 10);
			const color1Name = multiMatch[2];
			const score2 = parseInt(multiMatch[3], 10);
			const color2Name = multiMatch[4];
			
			const colorMap = { 'geel': 'yellow', 'gele': 'yellow', 'rood': 'red', 'rode': 'red', 'groen': 'green', 'groene': 'green', 'paars': 'purple', 'paarse': 'purple', 'blauw': 'blue', 'blauwe': 'blue' };
			const color1 = colorMap[color1Name];
			const color2 = colorMap[color2Name];
			
			if (color1 && scores[color1] >= score1) {
				const row = document.querySelector(`.score-row.${color1}`);
				if (row) row.classList.add('objective-achieved');
			}
			if (color2 && scores[color2] >= score2) {
				const row = document.querySelector(`.score-row.${color2}`);
				if (row) row.classList.add('objective-achieved');
			}
		}
	}
	
	function clearObjectiveHighlights() {
		// Verwijder alle objective-achieved classes
		document.querySelectorAll('.score-row.objective-achieved').forEach(el => {
			el.classList.remove('objective-achieved');
		});
		const totalEl = document.querySelector('#scoreboard .score-total.objective-achieved');
		if (totalEl) totalEl.classList.remove('objective-achieved');
	}

	function updateBonusInventoryUI() {
		const container = document.getElementById('bonus-inventory');
		if (!container) return;
		container.innerHTML = '';
		
		// Voeg gratis plaatsingen toe (als er zijn)
		if (freePlacementsRemaining > 0) {
			const freePlaceButton = document.createElement('button');
			freePlaceButton.type = 'button';
			freePlaceButton.classList.add('bonus-badge', 'free-placement-badge');
			freePlaceButton.title = `Gratis plaatsing (${freePlacementsRemaining})`;
			freePlaceButton.setAttribute('aria-label', `Gratis plaatsing (${freePlacementsRemaining})`);
			freePlaceButton.dataset.bonusKey = 'free';
			freePlaceButton.style.background = 'linear-gradient(135deg, #FFD700, #FFA500)';
			
			const swatch = document.createElement('div');
			swatch.classList.add('bonus-swatch');
			swatch.textContent = 'ðŸŽ';
			swatch.style.fontSize = '1.2rem';
			
			const label = document.createElement('div');
			label.classList.add('bonus-label');
			label.textContent = 'Gratis';
			
			const countElem = document.createElement('div');
			countElem.classList.add('bonus-count');
			countElem.textContent = String(freePlacementsRemaining);
			
			freePlaceButton.append(swatch, label, countElem);
			freePlaceButton.addEventListener('pointerdown', onBonusPointerDown);
			container.appendChild(freePlaceButton);
		}
		
		BONUS_ORDER.forEach(colorKey => {
			const meta = getBonusMeta(colorKey);
			if (!meta) return;
			const count = bonusInventory[colorKey] || 0;
			const button = document.createElement('button');
			button.type = 'button';
			button.classList.add('bonus-badge');
			button.title = `${meta.label} (${count})`;
			button.setAttribute('aria-label', `${meta.label} (${count})`);
			const upgraded = isBonusUpgraded(colorKey);
			button.classList.toggle('bonus-mastered', upgraded);
			button.dataset.bonusMastered = upgraded ? 'true' : 'false';
			if (count <= 0) {
				button.classList.add('disabled');
				button.disabled = true;
				button.setAttribute('aria-disabled', 'true');
			} else {
				button.disabled = false;
				button.removeAttribute('aria-disabled');
			}
			button.classList.toggle('active', !!(activeBonusPlacement && activeBonusPlacement.colorKey === colorKey));
			if (activeBonusPlacement && activeBonusPlacement.colorKey === colorKey) button.classList.add('active');
			button.dataset.bonusKey = colorKey;
			button.dataset.bonusColor = meta.colorName;
			const swatch = document.createElement('span');
			swatch.classList.add('bonus-swatch');
			swatch.style.background = meta.colorCode;
			const label = document.createElement('span');
			label.classList.add('bonus-label');
			label.textContent = meta.label;
			const countEl = document.createElement('span');
			countEl.classList.add('bonus-count');
			countEl.textContent = String(count);
			button.append(swatch, label, countEl);
			container.appendChild(button);
		});
	}

	function getBonusChargeAmount(colorKey) {
		if (!BONUS_COLOR_CONFIG[colorKey]) return 0;
		let amount = 1;
		if (hasUpgrade('bonusBoost')) amount += 1;
		return amount;
	}	function markActiveBonusButton(colorKey) {
		const container = document.getElementById('bonus-inventory');
		if (!container) return;
		container.querySelectorAll('.bonus-badge').forEach(btn => {
			const key = btn.dataset.bonusKey;
			btn.classList.toggle('active', !!colorKey && key === colorKey);
		});
	}

	function addBonusCharge(colorKey, amount = 1, options = {}) {
		if (!BONUS_COLOR_CONFIG[colorKey]) return 0;
		const count = Math.max(0, Number(amount) || 0);
		if (count === 0) return 0;
		bonusInventory[colorKey] = (bonusInventory[colorKey] || 0) + count;
		if (options.trackCollection !== false) {
			totalBonusesCollected += count;
		}
		updateBonusInventoryUI();
		return count;
	}

	function grantBonusCharge(colorKey) {
		if (!BONUS_COLOR_CONFIG[colorKey]) return 0;
		const chargeAmount = getBonusChargeAmount(colorKey) || 1;
		return addBonusCharge(colorKey, chargeAmount, { trackCollection: true });
	}

	function spendBonusCharge(colorKey) {
		// Handle gratis plaatsing
		if (colorKey === 'free') {
			if (freePlacementsRemaining <= 0) return false;
			freePlacementsRemaining -= 1;
			updateBonusInventoryUI();
			return true;
		}
		
		// Handle gekochte plaatsing (munten al betaald)
		if (colorKey === 'purchased') {
			return true; // Munten zijn al afgeschreven bij aankoop
		}
		
		if (!BONUS_COLOR_CONFIG[colorKey]) return false;
		if ((bonusInventory[colorKey] || 0) <= 0) return false;
		bonusInventory[colorKey] -= 1;
		updateBonusInventoryUI();
		return true;
	}

	function restoreBonusCharge(colorKey) {
		// Handle gratis plaatsing
		if (colorKey === 'free') {
			freePlacementsRemaining += 1;
			updateBonusInventoryUI();
			return;
		}
		// Handle gekochte plaatsing - geef munten terug
		if (colorKey === 'purchased') {
			// Geef de 2 munten terug
			addCoin();
			addCoin();
			updateBuyPlacementButton();
			return;
		}
		if (!BONUS_COLOR_CONFIG[colorKey]) return;
		bonusInventory[colorKey] = (bonusInventory[colorKey] || 0) + 1;
		updateBonusInventoryUI();
	}

	function getBonusKeyFromSymbol(symbolEl) {
		if (!symbolEl) return null;
		return BONUS_ORDER.find(key => symbolEl.classList.contains(key)) || null;
	}

	function createBonusClaim(cell, symbolEl, colorKey, amount = 1) {
		return {
			colorKey,
			cell,
			symbol: symbolEl,
			amount: amount
		};
	}

	function revokeBonusClaim(claim) {
		if (!claim || !claim.colorKey) return;
		const amount = claim.amount || 1;
		totalBonusesCollected = Math.max(0, totalBonusesCollected - amount);
		if (bonusInventory[claim.colorKey] > 0) {
			bonusInventory[claim.colorKey] = Math.max(0, bonusInventory[claim.colorKey] - amount);
		}
		if (claim.cell) {
			delete claim.cell.dataset.bonusConsumed;
		}
		if (claim.symbol && claim.symbol.classList) {
			claim.symbol.classList.remove('bonus-used');
		}
		updateBonusInventoryUI();
	}

	function resetBonusState() {
		cancelActiveBonusPlacement({ updateInventory: false });
		BONUS_ORDER.forEach(key => {
			bonusInventory[key] = 0;
		});
		document.querySelectorAll('.cell[data-bonus-consumed]').forEach(cell => {
			delete cell.dataset.bonusConsumed;
		});
		document.querySelectorAll('.symbol.bonus-used').forEach(symbol => {
			symbol.classList.remove('bonus-used');
		});
		// reset collected counter as well
		totalBonusesCollected = 0;
		updateBonusInventoryUI();
	}

	function grantRandomBonusUpgrade({ silent = false } = {}) {
		const available = BONUS_ORDER
			.filter(key => BONUS_COLOR_CONFIG[key])
			.filter(key => !isBonusUpgraded(key));
		if (!available.length) {
			if (!silent) showObjectiveToast('âœ¨ Alle bonus upgrades zijn al actief.');
			return null;
		}
		const key = available[Math.floor(Math.random() * available.length)];
		setBonusUpgraded(key, true);
		updateBonusInventoryUI();
		if (!silent) {
			const meta = BONUS_COLOR_CONFIG[key];
			showObjectiveToast(`ðŸª Gratis bonus upgrade: ${meta?.colorName || key}!`);
		}
		return key;
	}

	function openRandomFreeBonusUpgradeModal() {
		const available = BONUS_ORDER
			.filter(key => BONUS_COLOR_CONFIG[key])
			.filter(key => !isBonusUpgraded(key));
		if (!available.length) {
			showObjectiveToast('âœ¨ Alle bonus upgrades zijn al actief.');
			return null;
		}
		const colorKey = available[Math.floor(Math.random() * available.length)];
		const meta = getBonusMeta(colorKey);
		if (!meta) {
			// Fallback: behave like the old field event.
			return grantRandomBonusUpgrade();
		}

		const shopModalLayer = document.getElementById('shop-modal-layer');
		const shopModalTitle = document.getElementById('shop-modal-title');
		const shopModalMessage = document.getElementById('shop-modal-message');
		const shopCardOptions = document.getElementById('shop-card-options');
		const upgradesSection = document.querySelector('.shop-upgrades-section');
		const bonusSection = document.querySelector('.shop-bonus-section');
		const freePlaceSection = document.querySelector('.shop-freeplace-section');
		const shopBonusContainer = document.getElementById('shop-bonus-container');
		const shopContentGrid = document.querySelector('.shop-content-grid');
		const shopLowerGrid = document.querySelector('.shop-lower-grid');

		if (!shopModalLayer || !shopBonusContainer || !bonusSection) {
			return grantRandomBonusUpgrade();
		}

		// Snapshot current layout so we can restore on close.
		const cardsSection = shopCardOptions ? shopCardOptions.closest('.shop-cards-section') : null;
		const original = {
			gridTemplateColumns: shopContentGrid ? shopContentGrid.style.gridTemplateColumns : '',
			cardsDisplay: cardsSection ? cardsSection.style.display : '',
			upgradesDisplay: upgradesSection ? upgradesSection.style.display : '',
			bonusDisplay: bonusSection ? bonusSection.style.display : '',
			freePlaceDisplay: freePlaceSection ? freePlaceSection.style.display : '',
			lowerGridDisplay: shopLowerGrid ? shopLowerGrid.style.display : '',
			bonusParent: bonusSection.parentElement,
			bonusNext: bonusSection.nextSibling
		};

		const restoreLayout = () => {
			if (shopContentGrid) shopContentGrid.style.gridTemplateColumns = original.gridTemplateColumns;
			if (cardsSection) cardsSection.style.display = original.cardsDisplay;
			if (upgradesSection) upgradesSection.style.display = original.upgradesDisplay;
			if (bonusSection) bonusSection.style.display = original.bonusDisplay;
			if (freePlaceSection) freePlaceSection.style.display = original.freePlaceDisplay;
			if (shopLowerGrid) shopLowerGrid.style.display = original.lowerGridDisplay;
			try {
				if (original.bonusParent && bonusSection.parentElement !== original.bonusParent) {
					original.bonusParent.insertBefore(bonusSection, original.bonusNext || null);
				}
			} catch {}
		};

		// Show ONLY bonus upgrades with one free offer.
		if (cardsSection) cardsSection.style.display = 'none';
		if (upgradesSection) upgradesSection.style.display = 'none';
		if (freePlaceSection) freePlaceSection.style.display = 'none';
		if (shopLowerGrid) shopLowerGrid.style.display = 'none';
		if (shopContentGrid) shopContentGrid.style.gridTemplateColumns = '1fr';
		if (bonusSection) bonusSection.style.display = '';
		if (shopContentGrid && bonusSection.parentElement !== shopContentGrid) {
			shopContentGrid.appendChild(bonusSection);
		}

		shopBonusContainer.innerHTML = '';
		const card = document.createElement('div');
		card.classList.add('shop-bonus-card');
		const info = document.createElement('div');
		info.classList.add('shop-bonus-info');
		const swatch = document.createElement('span');
		swatch.classList.add('shop-bonus-swatch');
		swatch.style.background = meta.colorCode;
		const label = document.createElement('span');
		label.textContent = meta.label;
		info.append(swatch, label);

		const actions = document.createElement('div');
		actions.classList.add('shop-bonus-actions');
		const claimBtn = document.createElement('button');
		claimBtn.type = 'button';
		claimBtn.classList.add('shop-bonus-upgrade-btn');
		claimBtn.textContent = 'Gratis claimen';
		claimBtn.addEventListener('click', () => {
			if (isBonusUpgraded(colorKey)) return;
			setBonusUpgraded(colorKey, true);
			updateBonusInventoryUI();
			try { updateShopBonusUI(); } catch {}
			try { updateShopCoinDisplay(); } catch {}
			showObjectiveToast(`ðŸª Bonus upgrade geclaimd: ${meta.colorName}!`);
			claimBtn.disabled = true;
			setTimeout(() => {
				// Do NOT trigger the global close handler (it calls skipShop()).
				// We close + restore layout directly to prevent the old shop flashing.
				try { close(); } catch {
					shopModalLayer.classList.remove('show');
					restoreLayout();
				}
			}, 250);
		});
		actions.appendChild(claimBtn);
		card.append(info, actions);
		shopBonusContainer.appendChild(card);

		if (shopModalTitle) shopModalTitle.textContent = 'ðŸª Bonus upgrade';
		if (shopModalMessage) shopModalMessage.textContent = 'Je hebt 1 gratis bonus-upgrade gevonden!';
		try { updateShopCoinDisplay(); } catch {}
		shopModalLayer.classList.add('show');

		const shopSkipBtn = document.getElementById('shop-modal-skip');
		const shopCloseBtn = document.getElementById('shop-modal-close');
		let skipOriginalText = null;
		const close = () => {
			if (shopSkipBtn && skipOriginalText !== null) {
				shopSkipBtn.textContent = skipOriginalText;
			}
			shopModalLayer.classList.remove('show');
			restoreLayout();
		};
		if (shopSkipBtn) {
			skipOriginalText = shopSkipBtn.textContent;
			shopSkipBtn.textContent = 'Sluiten';
			shopSkipBtn.addEventListener('click', () => {
				close();
			}, { once: true });
		}
		if (shopCloseBtn) {
			// Capture phase + stopImmediatePropagation so the global handler (skipShop) won't run.
			shopCloseBtn.addEventListener('click', (e) => {
				e.preventDefault();
				e.stopImmediatePropagation();
				close();
			}, { once: true, capture: true });
			shopCloseBtn.addEventListener('touchend', (e) => {
				e.preventDefault();
				e.stopImmediatePropagation();
				close();
			}, { once: true, capture: true });
		}

		return colorKey;
	}

	function placeBonusUpgradeFieldEvent_World2() {
		const worldInfo = (typeof getWorldAndSubLevel === 'function')
			? getWorldAndSubLevel(currentLevel)
			: { world: Number(currentWorld || 1) || 1 };
		const world = Number(worldInfo?.world || 1) || 1;
		if (world < 2) return false;

		// Prefer blue/green; small chance yellow.
		const zoneRoll = Math.random();
		const preferred = zoneRoll < 0.45 ? 'blue' : (zoneRoll < 0.90 ? 'green' : 'yellow');
		const zoneOrder = preferred === 'yellow'
			? ['yellow', 'blue', 'green']
			: (preferred === 'blue'
				? ['blue', 'green', 'yellow']
				: ['green', 'blue', 'yellow']);

		const pickCandidateCell = (gridId) => {
			const grid = document.getElementById(gridId);
			if (!grid) return null;
			const candidates = Array.from(grid.querySelectorAll('.cell:not(.void-cell)'))
				.filter(cell => cell.dataset.disabled !== 'true')
				.filter(cell => !cell.classList.contains('active'))
				.filter(cell => !cell.classList.contains('bold-cell'))
				.filter(cell => !cell.classList.contains('gold-cell'))
				.filter(cell => !cell.classList.contains('trap-cell'))
				.filter(cell => !cell.querySelector('.symbol'));
			if (!candidates.length) return null;
			return candidates[Math.floor(Math.random() * candidates.length)];
		};

		const zoneToGridId = {
			blue: 'blue-grid',
			green: 'green-grid',
			yellow: 'yellow-grid'
		};

		let target = null;
		let chosenZone = null;
		for (const z of zoneOrder) {
			target = pickCandidateCell(zoneToGridId[z]);
			if (target) {
				chosenZone = z;
				break;
			}
		}
		if (!target) return false;

		target.dataset.bonusUpgradeEvent = 'true';
		const sym = document.createElement('div');
		sym.classList.add('symbol', 'upgrade-shop-symbol');
		// Use the editor's diamond glyph for consistency
		sym.textContent = 'â™¦';
		sym.setAttribute('aria-label', 'Bonus upgrade');
		target.appendChild(sym);
		return true;
	}

	function onBonusPointerDown(event) {
		const badge = event.target.closest('.bonus-badge');
		if (!badge) return;
		const colorKey = badge.dataset.bonusKey;
		
		// Handle gratis plaatsing
		if (colorKey === 'free') {
			if (freePlacementsRemaining <= 0) return;
			if (event.button !== undefined && event.button !== 0) return;
			event.preventDefault();
			event.stopPropagation();
			
			if (activeBonusPlacement && activeBonusPlacement.colorKey === 'free') {
				cancelActiveBonusPlacement();
				return;
			}
			cancelActiveBonusPlacement({ updateInventory: false });
			
			// Gebruik 'multikleur' voor universele plaatsing
			const shape = [[1]]; // 1x1 blok
			const colorObj = { name: 'multikleur', code: 'rainbow' };
			
			const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
			if (isTouchDevice && window.innerWidth <= MOBILE_BREAKPOINT) {
				activeBonusPlacement = {
					colorKey: 'free',
					pointerId: event.pointerId || null,
					sticky: true,
					shape: cloneShape(shape)
				};
				selectedShape = shape;
				selectedColor = colorObj;
				if (rotateButton) rotateButton.disabled = false;
				// For touch-initiated bonus drags, delay showing the mirror control
				// until the block is placed/released to avoid accidental mirrors.
				if (mirrorButton) mirrorButton.disabled = true;
				markActiveBonusButton('free');
				
				badge.setPointerCapture(event.pointerId);
				const freeBlock = makeDraggable(shape, colorObj);
				freeBlock.classList.add('bonus-draggable');
				const overlay = document.getElementById('drag-overlay');
				if (overlay && !overlay.contains(freeBlock)) {
					overlay.appendChild(freeBlock);
					overlay.style.display = 'block';
				}
				draggedBlock = freeBlock;
				draggedShape = freeBlock._shape || shape;
				draggedColor = colorObj;
				beginPointerDrag({ clientX: event.clientX, clientY: event.clientY, pointerId: event.pointerId || null });
				startGlobalDragVisuals();
				({ offsetX, offsetY } = computeShapeCenterOffsets(shape));
				const touchOffsetY = 60;
				draggedBlock.style.left = `${event.clientX - offsetX}px`;
				draggedBlock.style.top = `${event.clientY - offsetY - touchOffsetY}px`;
				// Controls are delayed for touch bonus drags; they will appear on release.
				activeBonusPlacement.delayedControls = true;
			} else {
				activeBonusPlacement = {
					colorKey: 'free',
					pointerId: event.pointerId || null,
					sticky: false,
					shape: cloneShape(shape)
				};
				selectedShape = shape;
				selectedColor = colorObj;
				if (rotateButton) rotateButton.disabled = false;
				if (mirrorButton) mirrorButton.disabled = false;
				markActiveBonusButton('free');
				showFloatingPreview(shape, colorObj);
			}
			return;
		}
		
		if (!colorKey || !BONUS_COLOR_CONFIG[colorKey]) return;
		if ((bonusInventory[colorKey] || 0) <= 0 && (!activeBonusPlacement || activeBonusPlacement.colorKey !== colorKey)) {
			// Even when empty, selecting a bonus badge on mobile should open the zoomed zone.
			event.preventDefault();
			event.stopPropagation();
			if (window.innerWidth <= MOBILE_BREAKPOINT) {
				const meta = BONUS_COLOR_CONFIG[colorKey];
				if (meta) {
					autoZoomToColorZone({ name: meta.colorName, code: meta.colorCode });
				}
			}
			return;
		}
		if (event.button !== undefined && event.button !== 0) return;
		event.preventDefault();
		event.stopPropagation();
		if (activeBonusPlacement && activeBonusPlacement.colorKey === colorKey) {
			cancelActiveBonusPlacement();
			return;
		}
		cancelActiveBonusPlacement({ updateInventory: false });
		const meta = BONUS_COLOR_CONFIG[colorKey];
		const shape = getBonusShape(colorKey);
		const colorObj = { name: meta.colorName, code: meta.colorCode };

		// Auto-zoom naar de juiste zone op basis van kleur (altijd op mobiel)
		if (window.innerWidth <= MOBILE_BREAKPOINT) {
			autoZoomToColorZone(colorObj);
		}

	// Voor touch devices: direct draggable maken (geen floating preview)
	const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
	if (isTouchDevice && window.innerWidth <= MOBILE_BREAKPOINT) {
		// Zet bonus placement variabelen
		activeBonusPlacement = {
			colorKey,
			pointerId: event.pointerId || null,
			sticky: true,
			shape: cloneShape(shape)
		};
		selectedShape = shape;
		selectedColor = colorObj;
		if (rotateButton) rotateButton.disabled = false;
		// For touch-initiated bonus drags, delay showing the mirror control
		// until the block is placed/released to avoid accidental mirrors.
		if (mirrorButton) mirrorButton.disabled = true;
		markActiveBonusButton(colorKey);

		// Maak het blok direct draggable vanaf pointer positie (niet op de badge),
		// zodat het niet direct "op de badge" lijkt te staan en overlap/annuleer-gevoel voorkomt.
		const block = makeDraggable(shape, colorObj);
		block.classList.add('bonus-draggable');
		const shapeWidth = shape[0].length;
		const shapeHeight = shape.length;
		({ offsetX, offsetY } = computeShapeCenterOffsets(shape));
		const touchOffsetY = 60;
		block.style.left = `${event.clientX - offsetX}px`;
		block.style.top = `${event.clientY - offsetY - touchOffsetY}px`;

		// Ensure block immediately matches zoomed cell size if a zoom/lift occurred
		requestAnimationFrame(() => {
			try {
				renderBlock(block, block._shape || shape, colorObj);
				({ offsetX, offsetY } = computeShapeCenterOffsets(block._shape || shape));
				block.style.left = `${event.clientX - offsetX}px`;
				block.style.top = `${event.clientY - offsetY - touchOffsetY}px`;
			} catch (e) {}
		});
		const overlay = document.getElementById('drag-overlay');
		if (overlay && !overlay.contains(block)) {
			overlay.appendChild(block);
			overlay.style.display = 'block';
		}
		draggedBlock = block;
		draggedShape = block._shape || shape;
		draggedColor = colorObj;
		try { badge.setPointerCapture(event.pointerId); } catch {}
		beginPointerDrag({ clientX: event.clientX, clientY: event.clientY, pointerId: event.pointerId || null });
		startGlobalDragVisuals();
		// Delay transform buttons (mirror) for touch bonus drags; they'll appear on release
		activeBonusPlacement.delayedControls = true;

			// Ensure correct sizing after any zoom/lift finishes
			requestAnimationFrame(() => {
				try {
					renderBlock(block, block._shape || shape, colorObj);
					({ offsetX, offsetY } = computeShapeCenterOffsets(block._shape || shape));
					const touchOffsetY2 = 60;
					block.style.left = `${event.clientX - offsetX}px`;
					block.style.top = `${event.clientY - offsetY - touchOffsetY2}px`;
				} catch (e) {}
			});
		return;
	} else if (window.innerWidth <= MOBILE_BREAKPOINT) {
		// Niet-touch mobiel: maak blok direct draggable
		// Buttons worden getoond zodra het blok wordt opgepakt
		activeBonusPlacement = {
			colorKey,
			pointerId: event.pointerId || null,
			sticky: true,
			shape: cloneShape(shape)
		};
		selectedShape = shape;
		selectedColor = colorObj;
		if (rotateButton) rotateButton.disabled = false;
		if (mirrorButton) mirrorButton.disabled = false;
		markActiveBonusButton(colorKey);
		
		// Maak het blok direct draggable
		const block = makeDraggable(shape, colorObj);
		block.classList.add('bonus-draggable');
		const overlay = document.getElementById('drag-overlay');
		if (overlay && !overlay.contains(block)) overlay.appendChild(block);
		draggedBlock = block;
		draggedShape = block._shape || shape;
		draggedColor = colorObj;
		beginPointerDrag({ clientX: event.clientX, clientY: event.clientY, pointerId: event.pointerId || null });
		startGlobalDragVisuals();
		const shapeWidth = shape[0].length;
		const shapeHeight = shape.length;
		({ offsetX, offsetY } = computeShapeCenterOffsets(shape));
		block.style.left = `${event.clientX - offsetX}px`;
		block.style.top = `${event.clientY - offsetY}px`;
		// visuals handled by startGlobalDragVisuals()
		if (overlay) overlay.style.display = 'block';
			// After possible zoom/DOM-lift, re-render to pick up zoomed cell size
			requestAnimationFrame(() => {
				try {
					renderBlock(block, block._shape || shape, colorObj);
					({ offsetX, offsetY } = computeShapeCenterOffsets(block._shape || shape));
					block.style.left = `${event.clientX - offsetX}px`;
					block.style.top = `${event.clientY - offsetY}px`;
				} catch (e) {}
			});
			return;
	}
		// Desktop (mouse): click-to-pickup -> hover-follow -> click-to-drop
		const isMobileLayout = window.innerWidth <= MOBILE_BREAKPOINT;
		if (!isMobileLayout && !isTouchDevice) {
			activeBonusPlacement = {
				colorKey,
				pointerId: null,
				sticky: false,
				shape: cloneShape(shape),
				desktopHover: true
			};
			lastZone = null;
			lastBaseX = null;
			lastBaseY = null;
			selectedCardId = null;
			if (selectedCardElement) {
				selectedCardElement.classList.remove('selected');
			}
			selectedCardElement = null;
			selectedShape = shape;
			selectedColor = colorObj;
			if (rotateButton) rotateButton.disabled = false;
			if (mirrorButton) mirrorButton.disabled = false;
			markActiveBonusButton(colorKey);
			badge.blur();
			startDesktopHoverDragFromSelection(badge, shape, colorObj);
			return;
		}

		// Desktop (touch) fallback: keep original drag behavior
		const block = makeDraggable(shape, colorObj);
		block.classList.add('bonus-draggable');
		const overlay = document.getElementById('drag-overlay');
		if (overlay && !overlay.contains(block)) overlay.appendChild(block);
		draggedBlock = block;
		draggedShape = block._shape || shape;
		draggedColor = colorObj;
		beginPointerDrag({ clientX: event.clientX, clientY: event.clientY, pointerId: event.pointerId || null });
		startGlobalDragVisuals();

		// Compute offsets based on the *actual rendered* board cell size + gap.
		({ offsetX, offsetY } = computeShapeCenterOffsets(draggedShape));
		const localTouchDevice = ('ontouchstart' in window || navigator.maxTouchPoints > 0);
		const touchOffsetY = localTouchDevice ? 60 : 0;
		block.style.left = `${event.clientX - offsetX}px`;
		block.style.top = `${event.clientY - offsetY - touchOffsetY}px`;
		activeBonusPlacement = {
			colorKey,
			pointerId: event.pointerId || null,
			sticky: true,
			shape: cloneShape(shape)
		};
		lastZone = null;
		lastBaseX = null;
		lastBaseY = null;
		selectedCardId = null;
		selectedCardElement = null;
		selectedShape = null;
		selectedColor = null;
		if (rotateButton) rotateButton.disabled = false;
		// visuals handled by startGlobalDragVisuals()
		if (overlay) overlay.style.display = 'block';
		badge.blur();
		markActiveBonusButton(colorKey);
	}
	
	// --- Dark mode toggle ---
	document.addEventListener('DOMContentLoaded', () => {
	  const toggleBtn = document.getElementById('dark-mode-toggle');
	  const mobileToggleBtn = document.getElementById('mobile-dark-mode-toggle');
	  const root = document.documentElement;
	  const body = document.body;
	  if (!body) return;

	  /*
		EN:
		- STATE: source of truth for dark/light theme is localStorage key `theme` + the `dark-mode` class on <html>/<body>.
		- OVERRIDE: This handler runs on DOMContentLoaded and can overwrite earlier theme decisions (e.g. head preload script).
		- DUPLICATE: Theme is handled in two places (head preload + here). If you keep both, ensure they do the same thing.
	*/
	  const savedTheme = localStorage.getItem('theme');
	  const preferDark = (savedTheme ? (savedTheme === 'dark') : true) || root.classList.contains('dark-mode');

	  function applyTheme(isDark) {
		/*
			EN:
			- STATE: toggles classes, updates button labels, persists to localStorage.
			- OVERRIDE: button text here overrides any initial HTML labels.
		*/
		root.classList.toggle('dark-mode', isDark);
		body.classList.toggle('dark-mode', isDark);
		if (toggleBtn) toggleBtn.textContent = isDark ? 'â˜€ï¸' : 'ðŸŒ™';
		if (mobileToggleBtn) mobileToggleBtn.textContent = isDark ? 'â˜€ï¸ Dag' : 'ðŸŒ™ Nacht';
		localStorage.setItem('theme', isDark ? 'dark' : 'light');
	  }

	  applyTheme(preferDark);

	  function handleToggleClick(event) {
		if (event) event.preventDefault();
		const willBeDark = !body.classList.contains('dark-mode');
		applyTheme(willBeDark);
	  }

	  if (toggleBtn) toggleBtn.addEventListener('click', handleToggleClick);
	  if (mobileToggleBtn) mobileToggleBtn.addEventListener('click', handleToggleClick);
	});



	 // ---------- CREATE GRID (general) ----------
	function createGrid(containerId, rows, cols, options = {}) {
		options = Object.assign({
			boldBottom: false,
			goldCells: false,
			symbols: false,
			symbolChance: 0.3,
			minSymbols: 0,
			maxSymbols: 0,
			coinChance: 0.0,
			maxCoins: 0,
			trapChance: 0,
			maxTraps: 0,
			blackHoleChance: BLACK_HOLE_DEFAULT_CHANCE,
			rowLengths: null,
			rowOffsets: null,
			voidCells: null,
			boldRows: [],
			randomBoldCount: null,
			includeDefaultBlueBold: true,
			colorChances: null,
					pointsPerWidthMap: null,
					pointsPerColumn: null,
					avoidAdjacentBold: false,
					diagonalShading: false,
					diagonalLegend: false,
					fixedBoldCells: null,
					outerRingShade: false,
					trimLeft: false,
					trimRight: false,
					randomBoldMinEdgeDistance: 0
		}, options);

		const container = document.getElementById(containerId);
		if (!container) return;

		const normalizedRowLengths = [];
		const normalizedRowOffsets = [];
		const hasCustomRowLengths = Array.isArray(options.rowLengths) && options.rowLengths.length;
		const hasCustomRowOffsets = Array.isArray(options.rowOffsets) && options.rowOffsets.length;

		let usedMaxCols = 0;
		for (let i = 0; i < rows; i++) {
			const lengthSourceIndex = hasCustomRowLengths
				? (i < options.rowLengths.length ? i : options.rowLengths.length - 1)
				: -1;
			const offsetSourceIndex = hasCustomRowOffsets
				? (i < options.rowOffsets.length ? i : options.rowOffsets.length - 1)
				: -1;

			const rawLength = lengthSourceIndex >= 0 ? options.rowLengths[lengthSourceIndex] : cols;
			const normalizedLength = Math.max(0, Number(rawLength) || 0);
			normalizedRowLengths.push(normalizedLength);

			const rawOffset = offsetSourceIndex >= 0 ? options.rowOffsets[offsetSourceIndex] : 0;
			const normalizedOffset = Math.max(0, Number(rawOffset) || 0);
			normalizedRowOffsets.push(normalizedOffset);

			if (normalizedLength > 0) {
				usedMaxCols = Math.max(usedMaxCols, normalizedOffset + normalizedLength);
			}
		}

		let maxCols = Math.max(cols, usedMaxCols);

		// Optional: trim empty leading columns when using rowOffsets.
		// Useful for World 2 blue path, where generation starts at offset>0 (otherwise you get lots of empty space on the left).
		let workingVoidCells = options.voidCells;
		if (options.trimLeft && hasCustomRowOffsets) {
			let minOffset = Infinity;
			for (let r = 0; r < rows; r++) {
				if (normalizedRowLengths[r] > 0) {
					minOffset = Math.min(minOffset, normalizedRowOffsets[r]);
				}
			}
			if (Number.isFinite(minOffset) && minOffset > 0) {
				for (let r = 0; r < rows; r++) {
					normalizedRowOffsets[r] = Math.max(0, (normalizedRowOffsets[r] || 0) - minOffset);
				}
				maxCols = Math.max(1, maxCols - minOffset);
				if (workingVoidCells && workingVoidCells instanceof Set) {
					const shifted = new Set();
					for (const key of workingVoidCells) {
						const parts = String(key).split(',');
						if (parts.length < 2) continue;
						const x = Number(parts[0]);
						const y = parts[1];
						if (!Number.isFinite(x)) continue;
						shifted.add(`${Math.max(0, x - minOffset)},${y}`);
					}
					workingVoidCells = shifted;
				}
			}
		}

		// Optional: trim empty trailing columns (right side). Useful when `cols` is larger than what the active rows actually use.
		if (options.trimRight) {
			let usedRight = 0;
			for (let r = 0; r < rows; r++) {
				const rowLen = normalizedRowLengths[r];
				if (rowLen > 0) {
					usedRight = Math.max(usedRight, (normalizedRowOffsets[r] || 0) + rowLen);
				}
			}
			if (Number.isFinite(usedRight) && usedRight > 0 && usedRight < maxCols) {
				maxCols = usedRight;
				if (workingVoidCells && workingVoidCells instanceof Set) {
					const trimmed = new Set();
					for (const key of workingVoidCells) {
						const parts = String(key).split(',');
						if (parts.length < 2) continue;
						const x = Number(parts[0]);
						if (!Number.isFinite(x)) continue;
						if (x >= 0 && x < maxCols) trimmed.add(key);
					}
					workingVoidCells = trimmed;
				}
			}
		}

		if (!Number.isFinite(maxCols) || maxCols <= 0) maxCols = Math.max(cols, 1);

		container.innerHTML = '';
	container.dataset.rows = String(rows);
	container.dataset.cols = String(maxCols);
		container.dataset.rowLengths = normalizedRowLengths.join(',');
		container.dataset.rowOffsets = normalizedRowOffsets.join(',');
		container.style.gridTemplateColumns = `repeat(${maxCols}, var(--cell-size))`;
		container.style.gridAutoRows = `var(--cell-size)`;

		const activeIndexOffsets = [];
		let activeCellCount = 0;
		for (let r = 0; r < rows; r++) {
			activeIndexOffsets[r] = activeCellCount;
			activeCellCount += normalizedRowLengths[r];
		}
		container.dataset.activeCells = String(activeCellCount);

		const allIdx = Array.from({ length: activeCellCount }, (_, i) => i);

		const indexToCoord = (index) => {
			if (index < 0 || index >= activeCellCount) return null;
			for (let r = rows - 1; r >= 0; r--) {
				const start = activeIndexOffsets[r];
				const rowLen = normalizedRowLengths[r];
				if (rowLen <= 0) continue;
				if (index >= start) {
					const within = index - start;
					if (within < rowLen) {
						const c = normalizedRowOffsets[r] + within;
						return { row: r, col: c };
					}
				}
			}
			return null;
		};

		const boldIndices = new Set();
		const boldRowsSet = new Set(Array.isArray(options.boldRows) ? options.boldRows : []);
		const includeDefaultBlue = options.includeDefaultBlueBold !== false;
		const fixedBoldCells = Array.isArray(options.fixedBoldCells) ? options.fixedBoldCells : [];

		for (let r = 0; r < rows; r++) {
			const rowLen = normalizedRowLengths[r];
			if (rowLen <= 0) continue;
			if (options.boldBottom && r === rows - 1) {
				for (let c = 0; c < rowLen; c++) boldIndices.add(activeIndexOffsets[r] + c);
			}
			if (boldRowsSet.has(r)) {
				for (let c = 0; c < rowLen; c++) boldIndices.add(activeIndexOffsets[r] + c);
			}
			if (includeDefaultBlue && containerId === 'blue-grid' && r % 4 === 0) {
				for (let c = 0; c < rowLen; c++) boldIndices.add(activeIndexOffsets[r] + c);
			}
		}

		// Fixed bold cells (used for World 2 purple corners)
		for (const entry of fixedBoldCells) {
			if (!Array.isArray(entry) || entry.length < 2) continue;
			const r = Number(entry[0]);
			const c = Number(entry[1]);
			if (!Number.isFinite(r) || !Number.isFinite(c)) continue;
			if (r < 0 || r >= rows) continue;
			const rowLen = normalizedRowLengths[r];
			if (!rowLen) continue;
			const rowStart = normalizedRowOffsets[r] || 0;
			const rel = c - rowStart;
			if (rel < 0 || rel >= rowLen) continue;
			boldIndices.add(activeIndexOffsets[r] + rel);
		}

				if (options.boldLeft) {
					for (let r = 0; r < rows; r++) {
						const rowLen = normalizedRowLengths[r];
						if (rowLen <= 0) continue;
						boldIndices.add(activeIndexOffsets[r]);
					}
				}

				if (Array.isArray(options.boldColumns)) {
					const numericColumns = options.boldColumns
						.map(value => Number(value))
						.filter(value => Number.isFinite(value));
							numericColumns.forEach(columnIndex => {
								for (let r = 0; r < rows; r++) {
									const rowLen = normalizedRowLengths[r];
									if (rowLen <= 0) continue;
									const rowStart = normalizedRowOffsets[r];
									const relativeIndex = columnIndex - rowStart;
									if (relativeIndex < 0 || relativeIndex >= rowLen) continue;
									boldIndices.add(activeIndexOffsets[r] + relativeIndex);
								}
							});
				}

		let randomBoldTarget = null;
		if (typeof options.randomBoldCount === 'number' && options.randomBoldCount > 0) {
			randomBoldTarget = Math.min(options.randomBoldCount, activeCellCount);
		} else if (containerId === 'purple-grid' && typeof options.randomBoldCount !== 'number') {
			randomBoldTarget = Math.min(5, activeCellCount);
		}

		const currentBoldCoords = [];
		for (const idx of boldIndices) {
			const coord = indexToCoord(idx);
			if (coord) currentBoldCoords.push(coord);
		}

		if (randomBoldTarget !== null) {
			const shuffled = allIdx.slice();
			shuffleArray(shuffled);
			for (let i = 0; boldIndices.size < randomBoldTarget && i < shuffled.length; i++) {
				const candidate = shuffled[i];
				if (boldIndices.has(candidate)) continue;
				const coord = indexToCoord(candidate);
				if (!coord) continue;
				// World 2 purple request: do not generate random bold cells in the outer rings.
				if (options.randomBoldMinEdgeDistance && options.randomBoldMinEdgeDistance > 0) {
					const edgeDist = Math.min(coord.row, coord.col, (rows - 1 - coord.row), (maxCols - 1 - coord.col));
					if (edgeDist < options.randomBoldMinEdgeDistance) continue;
				}
				if (options.avoidAdjacentBold) {
					let tooClose = false;
					for (const existing of currentBoldCoords) {
						const distance = Math.max(Math.abs(existing.row - coord.row), Math.abs(existing.col - coord.col));
						if (distance < 2) {
							tooClose = true;
							break;
						}
					}
					if (tooClose) continue;
				}
				boldIndices.add(candidate);
				currentBoldCoords.push(coord);
			}
		}

		const minSymbols = Math.max(0, Math.min(options.minSymbols || 0, activeCellCount));
		const maxSymbols = Math.max(minSymbols, Math.min(options.maxSymbols || minSymbols, activeCellCount));
		const symbolCount = maxSymbols > minSymbols
			? Math.floor(Math.random() * (maxSymbols - minSymbols + 1)) + minSymbols
			: minSymbols;
		const shuffledIdx = allIdx.slice();
		shuffleArray(shuffledIdx);
		const symbolIndices = new Set(shuffledIdx.slice(0, symbolCount));

		const coinCandidates = shuffledIdx.filter(i => {
			if (options.maxCoins && options.maxCoins <= 0) return false;
			if (options.goldCells === false && options.coinChance === 0) return false;
			if (boldIndices.has(i)) return false;
			return true;
		});

		const coinIndices = new Set();
		const coinLimit = options.maxCoins > 0 ? options.maxCoins : Infinity;
		for (const idx of coinCandidates) {
			if (coinIndices.size >= coinLimit) break;
			if (Math.random() < (options.coinChance || 0)) {
				coinIndices.add(idx);
			}
		}

		const trapChance = Math.max(0, Math.min(1, Number(options.trapChance) || 0));
		const trapLimit = options.maxTraps > 0 ? options.maxTraps : 0;
		const trapIndices = new Set();
		if (trapChance > 0 && trapLimit !== 0) {
			const trapCandidates = shuffledIdx.filter(i => !symbolIndices.has(i) && !coinIndices.has(i) && !boldIndices.has(i));
			for (const idx of trapCandidates) {
				if (trapIndices.size >= trapLimit) break;
				if (Math.random() < trapChance) {
					trapIndices.add(idx);
				}
			}
		}
		trapIndices.forEach(idx => symbolIndices.delete(idx));

		const frag = document.createDocumentFragment();
			for (let r = 0; r < rows; r++) {
				const rowLen = normalizedRowLengths[r];
				const rowStart = normalizedRowOffsets[r];
				for (let c = 0; c < maxCols; c++) {
				const cell = document.createElement('div');
				cell.classList.add('cell');
			cell.dataset.x = String(c);
			cell.dataset.y = String(r);
			cell.dataset.zoneId = containerId;

					// Check of cell binnen row range valt
					const isOutsideRow = (c < rowStart) || (c >= rowStart + rowLen);
					
					// Check of cell expliciet als void gemarkeerd is (voor gaps in split)
					const cellKey = `${c},${r}`;
					const isMarkedVoid = workingVoidCells && workingVoidCells.has(cellKey);
					
					const isVoid = isOutsideRow || isMarkedVoid;
				if (isVoid) {
					cell.classList.add('void-cell');
					cell.dataset.disabled = 'true';
					frag.appendChild(cell);
					continue;
				}

				// World 2 purple UX: shade the outer 2 rings
				if (containerId === 'purple-grid' && options.outerRingShade) {
					const dist = Math.min(r, c, (rows - 1 - r), (maxCols - 1 - c));
					if (dist === 0) cell.classList.add('outer-ring-0');
					else if (dist === 1) cell.classList.add('outer-ring-1');
				}

					const idx = activeIndexOffsets[r] + (c - rowStart);

					// WORLD 2 (Yellow): tag cells by diagonal so we can style and score diagonals.
					if (containerId === 'yellow-grid' && options.diagonalShading) {
						const diagIndex = c - r; // NW-SE diagonals
						cell.dataset.diag = String(diagIndex);
						const parity = ((diagIndex % 2) + 2) % 2;
						if (parity === 1) cell.classList.add('diag-shade-odd');
						else cell.classList.add('diag-shade-even');
					}

				if (boldIndices.has(idx)) cell.classList.add('bold-cell');

				if (trapIndices.has(idx)) {
					decorateTrapCell(cell, { blackHoleChance: options.blackHoleChance });
				} else if (coinIndices.has(idx)) {
					cell.classList.add('gold-cell');
				} else if (symbolIndices.has(idx) && !boldIndices.has(idx)) {
					const sym = document.createElement('div');
		  sym.classList.add('symbol', 'gray');

					const colorChances = options.colorChances || [
						{ color: 'blue', weight: 1 },
						{ color: 'green', weight: 1 },
						{ color: 'red', weight: 1 },
						{ color: 'purple', weight: 1 },
						{ color: 'yellow', weight: 1 }
					];
					const totalWeight = colorChances.reduce((sum, entry) => sum + entry.weight, 0) || 1;
					let roll = Math.random() * totalWeight;
					for (const entry of colorChances) {
						if (roll < entry.weight) {
							sym.classList.add(entry.color);
							sym.style.setProperty('--symbol.color', entry.color);
							break;
						}
						roll -= entry.weight;
					}
					cell.appendChild(sym);
				}

				cell.addEventListener('pointerdown', (e) => {
					e.preventDefault();
					toggleCell(cell, containerId);
				});
				frag.appendChild(cell);
			}
		}
		container.appendChild(frag);

			if (containerId === 'yellow-grid') {
				const puntenEl = document.getElementById('yellow-punten');
				if (puntenEl) {
					if (options.diagonalLegend) {
						puntenEl.innerHTML = [
							'<strong>Wereld 2: Diagonalen</strong>',
								'Voltooi diagonale rijen (NWâ†’SE Ã©n NEâ†’SW).',
								'Punten per diagonaal (lengte â†’ punten): <strong>4â†’8, 6â†’16, 8â†’32</strong>.'
						].join('<br>');
					} else if (Array.isArray(options.pointsPerColumn) && options.pointsPerColumn.length) {
						const columnTexts = options.pointsPerColumn.map((value, idx) => {
							if (!Number.isFinite(value) || value <= 0) return `Kolom ${idx + 1}`;
							return `Kolom ${idx + 1}: ${value}`;
						});
						puntenEl.innerHTML = columnTexts.join('<br>');
					} else if (normalizedRowLengths.length) {
						const map = options.pointsPerWidthMap || {};
						const rowsTexts = normalizedRowLengths.map((len, idx) => {
							const pts = map[len];
							return pts ? `Rij ${idx + 1}: ${pts}` : `Rij ${idx + 1}`;
						});
						puntenEl.innerHTML = rowsTexts.join('<br>');
					}
				}
			}

		updateScore();
	}


	// --- Zoom helpers ---
		const placeholderSyncQueue = new Set();
		let placeholderSyncFrame = null;
		let activeZoomZone = null;
		let zoneNavLeft = null;
		let zoneNavRight = null;
		let mobileZoomResizeBound = false;

	function isMobileViewport() {
		return window.innerWidth <= 650;
	}

	function applyMobileZoomSizing(zone) {
		if (!zone) return;
		if (!isMobileViewport()) return;
		if (!['yellow-zone', 'green-zone', 'blue-zone', 'purple-zone', 'red-zone'].includes(zone.id)) return;

		const viewportH = Math.round((window.visualViewport && window.visualViewport.height) ? window.visualViewport.height : window.innerHeight);
		const isShortViewport = viewportH <= 650;
		const objectiveBanner = document.getElementById('mobile-objective-banner');
		const bottomBar = document.getElementById('bottom-bar');
		const objectiveBottom = objectiveBanner ? objectiveBanner.getBoundingClientRect().bottom : 0;
		const bottomTop = bottomBar ? bottomBar.getBoundingClientRect().top : viewportH;
		const margin = isShortViewport ? 4 : 10;
		const available = Math.max(120, Math.floor(bottomTop - objectiveBottom - margin * 2));
		// Short screens: slightly smaller zoom height so everything fits without overlapping controls.
		const desired = Math.floor(viewportH * (isShortViewport ? 0.54 : 0.57));
		const height = Math.max(120, Math.min(desired, available));

		const minCenter = objectiveBottom + margin + height / 2;
		const maxCenter = bottomTop - margin - height / 2;
		// Minimize the gap above the zoomed zone: pin as high as allowed (still clamps to avoid overlap).
		let center = Math.round(minCenter + (isShortViewport ? 0 : 2));
		center = Math.max(minCenter, Math.min(maxCenter, center));

		zone.style.setProperty('--mobile-zoom-height', `${Math.round(height)}px`);
		zone.style.setProperty('--mobile-zoom-center', `${Math.round(center)}px`);
	}

	function bindMobileZoomResizeHandler() {
		if (mobileZoomResizeBound) return;
		mobileZoomResizeBound = true;
		window.addEventListener('resize', () => {
			if (activeZoomZone) applyMobileZoomSizing(activeZoomZone);
		}, { passive: true });
		if (window.visualViewport) {
			window.visualViewport.addEventListener('resize', () => {
				if (activeZoomZone) applyMobileZoomSizing(activeZoomZone);
			}, { passive: true });
		}
	}

	function resetGreenZoomScroll(greenZone) {
		if (!greenZone) return;
		const grid = document.getElementById('green-grid');
		if (!grid) return;
		const sx = Number(grid.dataset.startX);
		const sy = Number(grid.dataset.startY);
		let startCell = null;
		if (Number.isFinite(sx) && Number.isFinite(sy)) {
			startCell = getCell(greenZone, sx, sy);
		}
		if (!startCell) {
			startCell = greenZone.querySelector('#green-grid .cell.bold-cell:not(.void-cell)') || null;
		}
		if (!startCell) return;
		// Offset-based centering is more stable across resizes/zoom.
		const maxLeft = Math.max(0, greenZone.scrollWidth - greenZone.clientWidth);
		const maxTop = Math.max(0, greenZone.scrollHeight - greenZone.clientHeight);
		const desiredLeft = (startCell.offsetLeft + startCell.offsetWidth / 2) - (greenZone.clientWidth / 2);
		const desiredTop = (startCell.offsetTop + startCell.offsetHeight / 2) - (greenZone.clientHeight / 2);
		greenZone.scrollLeft = Math.max(0, Math.min(maxLeft, desiredLeft));
		greenZone.scrollTop = Math.max(0, Math.min(maxTop, desiredTop));
	}

	function resetBlueZoomScroll(blueZone) {
		if (!blueZone) return;
		const blueGrid = document.getElementById('blue-grid');
		if (!blueGrid) return;

		// Start at the bottom.
		blueZone.getBoundingClientRect();
		blueZone.scrollTop = blueZone.scrollHeight;

		// Center on the bottom "start" group (prefer bold-cells) at the lowest row.
		let bestY = -Infinity;
		const allCells = Array.from(blueGrid.querySelectorAll('.cell:not(.void-cell)'));
		for (const cell of allCells) {
			const y = Number(cell.dataset.y);
			if (!Number.isFinite(y)) continue;
			if (y > bestY) bestY = y;
		}
		const bottomRowCells = allCells.filter(c => Number(c.dataset.y) === bestY);
		const bottomBold = bottomRowCells.filter(c => c.classList.contains('bold-cell'));
		const anchorCells = bottomBold.length ? bottomBold : bottomRowCells;

		let targetCenter = null;
		if (anchorCells.length) {
			const centers = anchorCells.map(c => c.offsetLeft + c.offsetWidth / 2);
			const minC = Math.min(...centers);
			const maxC = Math.max(...centers);
			targetCenter = (minC + maxC) / 2;
		}
		const maxLeft = Math.max(0, blueZone.scrollWidth - blueZone.clientWidth);
		if (targetCenter !== null) {
			const desiredLeft = targetCenter - (blueZone.clientWidth / 2);
			blueZone.scrollLeft = Math.max(0, Math.min(maxLeft, desiredLeft));
		} else {
			blueZone.scrollLeft = maxLeft > 0 ? Math.round(maxLeft / 2) : 0;
		}
	}

	// --- Per-zone scroll memory (normal vs zoom) ---
	const ZONE_SCROLL_MEMORY = window.__locusZoneScrollMemory || (window.__locusZoneScrollMemory = {});
	function getZoneScrollMemory(zoneId) {
		if (!ZONE_SCROLL_MEMORY[zoneId]) {
			ZONE_SCROLL_MEMORY[zoneId] = {
				normal: { left: 0, top: 0, initialized: false },
				zoom: { left: 0, top: 0, initialized: false }
			};
		}
		return ZONE_SCROLL_MEMORY[zoneId];
	}
	function getZoneScrollMode(zoneEl) {
		if (!zoneEl) return 'normal';
		return (document.body.classList.contains('zoomed-in') && zoneEl.classList.contains('zoom-focus')) ? 'zoom' : 'normal';
	}
	function clampZoneScroll(zoneEl) {
		if (!zoneEl) return;
		const maxLeft = Math.max(0, zoneEl.scrollWidth - zoneEl.clientWidth);
		const maxTop = Math.max(0, zoneEl.scrollHeight - zoneEl.clientHeight);
		zoneEl.scrollLeft = Math.max(0, Math.min(maxLeft, zoneEl.scrollLeft));
		zoneEl.scrollTop = Math.max(0, Math.min(maxTop, zoneEl.scrollTop));
	}
	function ensureZoneScrollTracking(zoneEl) {
		if (!zoneEl || zoneEl.__scrollTrackingBound) return;
		zoneEl.__scrollTrackingBound = true;
		zoneEl.addEventListener('scroll', () => {
			if (zoneEl.dataset.suppressScrollSave === 'true') return;
			const zoneId = zoneEl.id;
			const mode = getZoneScrollMode(zoneEl);
			const mem = getZoneScrollMemory(zoneId);
			mem[mode].left = zoneEl.scrollLeft;
			mem[mode].top = zoneEl.scrollTop;
			mem[mode].initialized = true;
		}, { passive: true });
	}
	function restoreOrAnchorZoneScroll(zoneEl, anchorFn) {
		if (!zoneEl) return;
		ensureZoneScrollTracking(zoneEl);
		const mem = getZoneScrollMemory(zoneEl.id);
		const mode = getZoneScrollMode(zoneEl);
		requestAnimationFrame(() => {
			zoneEl.dataset.suppressScrollSave = 'true';
			try {
				clampZoneScroll(zoneEl);
				if (mem[mode].initialized) {
					zoneEl.scrollLeft = mem[mode].left || 0;
					zoneEl.scrollTop = mem[mode].top || 0;
					clampZoneScroll(zoneEl);
				} else if (typeof anchorFn === 'function') {
					anchorFn(zoneEl);
					clampZoneScroll(zoneEl);
					mem[mode].left = zoneEl.scrollLeft;
					mem[mode].top = zoneEl.scrollTop;
					mem[mode].initialized = true;
				}
			} finally {
				setTimeout(() => { zoneEl.dataset.suppressScrollSave = 'false'; }, 0);
			}
		});
	}

	// Auto-zoom naar de juiste zone op basis van card kleur
	function autoZoomToColorZone(color) {
		if (!color) return;
		
		const colorName = typeof color === 'object' ? color.name : color;
		let targetZoneId = null;
		
		// Bepaal de juiste zone op basis van kleur
		switch(colorName) {
			case 'geel':
				targetZoneId = 'yellow-zone';
				break;
			case 'groen':
				targetZoneId = 'green-zone';
				break;
			case 'paars':
				targetZoneId = 'purple-zone';
				break;
			case 'blauw':
				targetZoneId = 'blue-zone';
				break;
			case 'rood':
				// Rood heeft 4 subgrids, zoom naar de parent red-zone
				targetZoneId = 'red-zone';
				break;
			case 'multikleur':
				// Voor multikleur: houd huidige zone open, spring niet automatisch naar rood
				// Speler kan zelf kiezen waar te plaatsen
				return;
		}
		
	
	if (targetZoneId) {
		const targetZone = document.getElementById(targetZoneId);
		if (targetZone) {
			// Open zoom ook als het dezelfde zone is (voor hernieuwde selectie)
			openZoom(targetZone);
		}
	}
}
	const ZONE_ORDER = ['purple-zone','yellow-zone','green-zone','red-zone','blue-zone'];	function renameIdsForClone(node, suffix) {
	  if (node.id) node.id = `${node.id}${suffix}`;
	  node.querySelectorAll('[id]').forEach(child => {
		child.id = `${child.id}${suffix}`;
	  });
	}

	function createZonePlaceholder(zone) {
	  const clone = zone.cloneNode(true);
	  renameIdsForClone(clone, '--placeholder');
	  clone.classList.remove('zoom-focus');
	  clone.removeAttribute('data-zoom-active');
	  clone.classList.add('zone-placeholder');
	  clone.setAttribute('aria-hidden', 'true');
	  clone.style.removeProperty('top');
	  clone.style.removeProperty('left');
	  clone.style.removeProperty('right');
	  clone.style.removeProperty('bottom');
	  clone.style.removeProperty('transform');
	  return clone;
	}

	function schedulePlaceholderSync(zone) {
	  if (!zone || !zone._placeholder) return;
	  placeholderSyncQueue.add(zone);
	  if (placeholderSyncFrame) return;
	  placeholderSyncFrame = requestAnimationFrame(() => {
		placeholderSyncQueue.forEach(z => {
		  const replacement = createZonePlaceholder(z);
		  z._placeholder.replaceWith(replacement);
		  z._placeholder = replacement;
		});
		placeholderSyncQueue.clear();
		placeholderSyncFrame = null;
	  });
	}

	function syncPlaceholderForCell(cell) {
	  if (!cell) return;
	  const zone = cell.closest('.zone.zoom-focus');
	  if (zone) {
		schedulePlaceholderSync(zone);
	  }
	}

	function liftToBody(el) {
	  if (el._placeholder) return;
	  const placeholder = createZonePlaceholder(el);
	  el._placeholder = placeholder;
	  if (el.parentNode) {
		el.parentNode.insertBefore(placeholder, el);
	  }
	  document.body.appendChild(el);
	}

	function restoreFromBody(el) {
	  const placeholder = el._placeholder;
	  if (placeholder && placeholder.parentNode) {
		placeholder.parentNode.insertBefore(el, placeholder);
		placeholder.remove();
	  }
	  delete el._placeholder;
	}

	function openZoom(zone) {
		// NOTE: Mobile zone zoom is enabled; only the placement zoom-lens is disabled elsewhere.
		if (!zone || excludedZones.includes(zone.id)) return;
		// iPad/tablet UX: zoomed-in zones are unnecessary and can break layout.
		if (window.matchMedia && window.matchMedia('(pointer: coarse)').matches) {
			const w = window.innerWidth;
			const h = window.innerHeight;
			if (Math.min(w, h) >= 700) return;
		}
		if (activeZoomZone === zone) return;
		closeZoom();
		liftToBody(zone);
		document.body.classList.add('zoomed-in');
		zone.classList.add('zoom-focus');
		zone.setAttribute('data-zoom-active', 'true');
		activeZoomZone = zone;
		addZoneNavArrows();
		bindMobileZoomResizeHandler();
		applyMobileZoomSizing(zone);
		if (zone.id === 'green-zone') {
			// Zoom: first time anchor to start; subsequent opens restore last zoom position.
			restoreOrAnchorZoneScroll(zone, (z) => resetGreenZoomScroll(z));
		}
		if (zone.id === 'blue-zone') {
			// Zoom: first time anchor to bottom start; subsequent opens restore last zoom position.
			restoreOrAnchorZoneScroll(zone, (z) => resetBlueZoomScroll(z));
		}
	}

	function closeZoom() {
		if (!activeZoomZone) return;
		const zone = activeZoomZone;
		// Scroll memory is handled via scroll listeners; no dataset storage.
		placeholderSyncQueue.delete(zone);
		zone.classList.remove('zoom-focus');
		zone.removeAttribute('data-zoom-active');
		restoreFromBody(zone);
		activeZoomZone = null;
		document.body.classList.remove('zoomed-in');
		removeZoneNavArrows();
	}

	function addZoneNavArrows() {
		removeZoneNavArrows();
		zoneNavLeft = document.createElement('div');
		zoneNavLeft.className = 'zone-nav-arrow zone-nav-arrow-left';
		zoneNavLeft.innerHTML = 'â—€';
		zoneNavLeft.addEventListener('click', e => { e.stopPropagation(); navigateToAdjacentZone(-1); });
		zoneNavRight = document.createElement('div');
		zoneNavRight.className = 'zone-nav-arrow zone-nav-arrow-right';
		zoneNavRight.innerHTML = 'â–¶';
		zoneNavRight.addEventListener('click', e => { e.stopPropagation(); navigateToAdjacentZone(1); });
		document.body.append(zoneNavLeft, zoneNavRight);
	}

	function removeZoneNavArrows() {
		if (zoneNavLeft && zoneNavLeft.parentNode) zoneNavLeft.parentNode.removeChild(zoneNavLeft);
		if (zoneNavRight && zoneNavRight.parentNode) zoneNavRight.parentNode.removeChild(zoneNavRight);
		zoneNavLeft = null; zoneNavRight = null;
	}

	function navigateToAdjacentZone(direction) {
		if (!activeZoomZone) return;
		const currentId = activeZoomZone.id;
		const idx = ZONE_ORDER.indexOf(currentId);
		if (idx === -1) return;
		let nextIdx = (idx + direction + ZONE_ORDER.length) % ZONE_ORDER.length;
		const nextId = ZONE_ORDER[nextIdx];
		const nextZone = document.getElementById(nextId);
		if (nextZone) {
			// close current and open next
			// slight delay to avoid immediate click propagation issues
			setTimeout(() => openZoom(nextZone), 50);
		}
	}
	
	const excludedZones = ['scoreboard', 'gold-zone', 'card-choice-zone', 'controls', 'bonus-zone', 'bottom-bar'];

	document.querySelectorAll('.zone').forEach(zone => {
	  if (zone.classList.contains('zone-placeholder')) return;
	  zone.addEventListener('click', e => {
		// Allow zoom in mobile portrait AND mobile landscape sidebar mode
		const isMobileSidebarMode = document.body.classList.contains('mobile-sidebar-layout');
		if (window.innerWidth > MOBILE_BREAKPOINT && !isMobileSidebarMode) return;
		if (skipNextZoneClick) {
		  skipNextZoneClick = false;
		  return;
		}
		if (draggedBlock || draggedShape) return;
		const mainZone = zone.closest('.red-group') || zone;
		if (excludedZones.includes(zone.id) || (mainZone.id && excludedZones.includes(mainZone.id))) return;
		if (e.pointerType === 'mouse' || e.pointerType === 'pen' || typeof e.pointerType === 'undefined') {
		  if (e.detail === 0 || e.detail > 1) return;
		}
		e.stopPropagation();
		openZoom(mainZone);
	  });
	});

	document.addEventListener('click', e => {
	  /*
		EN:
		- WHY: Clicking outside the focused zone closes the zoom view.
		- STATE: gated by `.zoomed-in` class on <body>.
		- OVERRIDE/DUPLICATE RISK: This is a global document click handler.
		  If other global click handlers exist (menu close, tap-to-place, etc.),
		  ordering + `stopPropagation()` decides which one â€œwinsâ€.
	*/
	  if (!document.body.classList.contains('zoomed-in')) return;
	  if (draggedBlock) return;
	  if (e.target.closest('.zone.zoom-focus')) return;
	  if (e.target.closest('.zone-placeholder')) return;
	  if (e.target.closest('#bottom-bar') || e.target.closest('#card-choice-zone') || e.target.closest('#controls') || e.target.closest('#gold-zone') || e.target.closest('#scoreboard') || e.target.closest('#menu-toggle')) return;
	  closeZoom();
	});

	document.addEventListener('keydown', e => {
	  /*
		EN:
		- WHY: Keyboard escape hatch for zoom mode.
		- DUPLICATE RISK: Escape is also handled in the drag/shape keydown handler below.
		  Make sure the combined behavior is intentional.
	*/
	  if (e.key === 'Escape') {
		closeZoom();
	  }
	  
	  // Ctrl+Z voor undo
	  if ((e.ctrlKey || e.metaKey) && e.key === 'z' && !e.shiftKey) {
		e.preventDefault();
		if (typeof undo === 'function') {
			undo();
		}
	  }
	});


  // ---------- GENERATE ROOTS (green + red variants) ----------
	function generateRoots(gridId, rows = 12, cols = 12, branchCount = 5, splitChance = 0.25, coinChance = 0.05, minSymbols = 3, maxSymbols = 6, maxCoins = 5, isRed = false, trapChance = 0, maxTraps = 0, blackHoleChance = BLACK_HOLE_DEFAULT_CHANCE) {
	  const container = document.getElementById(gridId);
	  
	  // Check of container bestaat
	  if (!container) {
		console.warn(`âš ï¸ Grid element with ID "${gridId}" not found, skipping generation`);
		return;
	  }
	  
	  container.innerHTML = '';
	container.dataset.rows = String(rows);
	container.dataset.cols = String(cols);
	  container.style.position = 'relative';
	  container.style.width = `calc(${cols} * var(--cell-size))`;
	  container.style.height = `calc(${rows} * var(--cell-size))`;
	
	  const toIndex = (r,c)=> r*cols + c;
	  const isInside = (r,c)=> r>=0 && r<rows && c>=0 && c<cols;

	  const clusterSet = new Set();
	  const clusterMap = {};
	  const dirs = [{r:-1,c:0},{r:1,c:0},{r:0,c:-1},{r:0,c:1}];

	  const colorChances = [
		{color:'blue', weight:1},
		{color:'green', weight:3},
		{color:'red', weight:1},
		{color:'purple', weight:1},
		{color:'yellow', weight:1}
	  ];
	  const totalWeight = colorChances.reduce((s,o)=>s+o.weight,0);

	  const centerR = Math.floor(rows/2);
	  const centerC = Math.floor(cols/2);
	  const centerIdx = toIndex(centerR, centerC);
	  container.dataset.startX = String(centerC);
	  container.dataset.startY = String(centerR);

	  // WORLD 2 green: special generator (mega root in center -> 4 arms with World 1-like branching).
	  const isWorld2Green = !isRed && gridId === 'green-grid' && (rows >= 24 || cols >= 24);

	  // Fallback for tall-green variants (older tuning): fewer, longer continuous branches.
	  const isTallGreen = !isWorld2Green && !isRed && gridId === 'green-grid' && rows >= 40;
	  let growthBudget = Math.max(0, Math.floor(branchCount));
	  const branchAttempts = isTallGreen ? Math.max(18, Math.floor(growthBudget / 10)) : Math.max(1, Math.floor(branchCount));
	  const minBranchLen = isTallGreen ? 8 : 2;
	  const maxBranchLen = isTallGreen ? 18 : 5;

		function makeCell(r,c,isCenter=false, isVoid=false){
		  const el = document.createElement('div');
		  el.classList.add('cell','root-cell');
		  if(isVoid) {
			el.classList.add('void-cell');
			el.style.opacity = '0';
			el.style.pointerEvents = 'none';
		  }
		  if(isCenter && !isRed && !isVoid) el.classList.add('bold-cell');
		  el.style.position = 'absolute';
		  el.style.left = `calc(${c} * var(--cell-size))`;
		  el.style.top  = `calc(${r} * var(--cell-size))`;
		  el.style.zIndex = isCenter ? 10 : 1;
		  // Sla r/c op als data-attributes â€” dit is cruciaal voor de edge-detectie
		  el.dataset.r = String(r);
		  el.dataset.c = String(c);
		  el.dataset.x = c; // kolomindex
		  el.dataset.y = r; // rijindex
		  el.dataset.zoneId = gridId;
	
		  if(!isVoid) {
			// World 2 green UX: allow dragging/panning the grid without accidentally toggling cells.
			// We toggle on pointerup and ignore it if the zone was drag-scrolled.
			if (gridId === 'green-grid' && (rows >= 24 || cols >= 24)) {
				el.addEventListener('pointerup', (e)=>{
					const zoneEl = container.closest('#green-zone');
					if (zoneEl && zoneEl.dataset.dragScrolling === 'true') return;
					e.preventDefault();
					toggleCell(el, gridId);
				});
			} else {
				el.addEventListener('pointerdown', (e)=>{ e.preventDefault(); toggleCell(el, gridId); });
			}
		  }
		  return el;
		}


	  // center
	  const centerCell = makeCell(centerR, centerC, true, false);
	  if (!isRed) centerCell.classList.add('bold-cell');
	  container.appendChild(centerCell);
	  clusterSet.add(centerIdx);
	  clusterMap[centerIdx] = centerCell;

	  // build branches first to determine which cells are active
	  // Verbeterde logica: creÃ«er bredere, speelbaardere gebieden
	  const endpoints = [{r:centerR,c:centerC}];
	  
	  // Helper functie om naburige cellen toe te voegen (voor breedte)
	  const addWidthCell = (r, c, dir) => {
		// Voeg een cel toe perpendiculair aan de richting voor breedte
		const perpendicular = [
		  {r: dir.c, c: -dir.r},  // 90 graden gedraaid
		  {r: -dir.c, c: dir.r}   // -90 graden gedraaid
		];
		const chosen = perpendicular[Math.floor(Math.random() * perpendicular.length)];
		const newR = r + chosen.r;
		const newC = c + chosen.c;
		if (isInside(newR, newC)) {
		  const idx = toIndex(newR, newC);
		  if (!clusterSet.has(idx)) {
			clusterSet.add(idx);
			if (isTallGreen && growthBudget > 0) growthBudget -= 1;
			return true;
		  }
		}
		return false;
	  };
	  
	  // Voor groen grid: zorg voor exact 8 eindpunten
	  const targetEndpoints = !isRed ? 8 : Math.max(1, Math.floor(branchCount * splitChance));
	  
	  if (isWorld2Green) {
		// 1) Build a thick center "mega root" (2-3 wide).
		const thickness = Math.random() < 0.6 ? 2 : 3;
		const halfA = Math.floor((thickness - 1) / 2);
		const halfB = thickness - 1 - halfA;
		const top = Math.max(0, centerR - halfA);
		const bottom = Math.min(rows - 1, centerR + halfB);
		const left = Math.max(0, centerC - halfA);
		const right = Math.min(cols - 1, centerC + halfB);
		for (let rr = top; rr <= bottom; rr++) {
			for (let cc = left; cc <= right; cc++) {
				clusterSet.add(toIndex(rr, cc));
			}
		}

		// 2) Create 4 arms that branch like World 1.
		const armStarts = [];
		if (isInside(top - 1, centerC)) armStarts.push({ r: top - 1, c: centerC, primary: { r: -1, c: 0 } });
		if (isInside(bottom + 1, centerC)) armStarts.push({ r: bottom + 1, c: centerC, primary: { r: 1, c: 0 } });
		if (isInside(centerR, left - 1)) armStarts.push({ r: centerR, c: left - 1, primary: { r: 0, c: -1 } });
		if (isInside(centerR, right + 1)) armStarts.push({ r: centerR, c: right + 1, primary: { r: 0, c: 1 } });
		armStarts.forEach(s => clusterSet.add(toIndex(s.r, s.c)));

		const armBranches = Math.max(10, Math.floor(branchCount / 8));
		const chooseDirForArm = (primaryDir) => {
			// Bias outward + sideways, avoid going back toward the center.
			const weighted = [];
			for (const d of dirs) {
				let w = 1;
				if (d.r === primaryDir.r && d.c === primaryDir.c) w = 5;
				else if (d.r === -primaryDir.r && d.c === -primaryDir.c) w = 0.5;
				else w = 2;
				weighted.push({ d, w });
			}
			const total = weighted.reduce((s, x) => s + x.w, 0);
			let roll = Math.random() * total;
			for (const item of weighted) {
				roll -= item.w;
				if (roll <= 0) return item.d;
			}
			return primaryDir;
		};

		for (const arm of armStarts) {
			const armEndpoints = [{ r: arm.r, c: arm.c }];
			for (let b = 0; b < armBranches; b++) {
				const len = 2 + Math.floor(Math.random() * 4);
				const start = armEndpoints[Math.floor(Math.random() * armEndpoints.length)];
				let r = start.r;
				let c = start.c;
				const dir = chooseDirForArm(arm.primary);
				const makeWide = Math.random() < 0.20;
				for (let i = 0; i < len; i++) {
					r += dir.r;
					c += dir.c;
					if (!isInside(r, c)) break;
					const idx = toIndex(r, c);
					if (clusterSet.has(idx)) continue;
					clusterSet.add(idx);
					if (makeWide || Math.random() < 0.12) addWidthCell(r, c, dir);
					if (armEndpoints.length < targetEndpoints && i > 0 && Math.random() < splitChance) {
						armEndpoints.push({ r, c });
					}
				}
			}
		}
	  } else {
		for(let b=0;b<branchAttempts;b++){
		  if (isTallGreen && growthBudget <= 0) break;
		  const len = minBranchLen + Math.floor(Math.random() * (maxBranchLen - minBranchLen + 1));
		  const start = endpoints[Math.floor(Math.random()*endpoints.length)];
		  let r = start.r, c = start.c;
		  const dir = dirs[Math.floor(Math.random()*dirs.length)];
		  
		  // 25% kans dat deze tak breed wordt (vooral voor groen grid)
		  const makeWide = !isRed && Math.random() < 0.25;

		  for(let i=0;i<len;i++){
			if (isTallGreen && growthBudget <= 0) break;
			r += dir.r; c += dir.c;
			if(!isInside(r,c)) break;
			const idx = toIndex(r,c);
			if(clusterSet.has(idx)) continue;

			clusterSet.add(idx); // Markeer deze cel als actief (niet void)
			if (isTallGreen && growthBudget > 0) growthBudget -= 1;
			
			// Maak de tak breder op deze positie
			if (makeWide || Math.random() < 0.1) {
			  addWidthCell(r, c, dir);
			}

			// Voeg eindpunt toe als we er nog niet genoeg hebben (voor groen grid)
			if (!isRed && endpoints.length < targetEndpoints && i > 0) {
			  if (Math.random() < splitChance) endpoints.push({r,c});
			} else if (isRed && Math.random() < splitChance) {
			  endpoints.push({r,c});
			}
		  }
		}
	  }
	  
	  // NU: Maak ALLE cellen aan - actieve EN void cellen
	  for(let r = 0; r < rows; r++) {
		for(let c = 0; c < cols; c++) {
		  const idx = toIndex(r, c);
		  const isActive = clusterSet.has(idx);
		  const isCenter = (idx === centerIdx);
		  
		  // Als de cel al bestaat (center), skip
		  if(clusterMap[idx]) continue;
		  
		  // Maak de cel - actief of void
		  const cell = makeCell(r, c, isCenter, !isActive);
		  container.appendChild(cell);
		  clusterMap[idx] = cell;
		}
	  }

	  // ---------- assign symbols & coins only to existing cells ----------
	  const clusterIndices = Array.from(clusterSet).filter(i => i !== centerIdx);
	  shuffleArray(clusterIndices);

	  // Voor groen grid: schaal symbolen en coins op basis van aantal actieve cellen
	  let finalMinSymbols = minSymbols;
	  let finalMaxSymbols = maxSymbols;
	  let finalMaxCoins = maxCoins;
	  let finalCoinChance = coinChance;
	  
	  if (!isRed) {
		const clusterSize = clusterIndices.length;
		// Bereken percentage van grid dat gevuld is (ongeveer 15-25% voor symbolen)
		const symbolPercentage = 0.20; // 20% van de cellen krijgen symbolen
		const coinPercentage = 0.08;   // 8% van de cellen krijgen coins
		
		// Voor kleine grids (<20 cellen): halveer de minimale EN maximale waardes
		const isSmallGrid = clusterSize < 20;
		const minSymbolBase = isSmallGrid ? 4 : 8;
		const maxSymbolBase = isSmallGrid ? 6 : 12;
		const maxCoinBase = isSmallGrid ? 2 : 3;
		
		finalMinSymbols = Math.max(minSymbolBase, Math.floor(clusterSize * (symbolPercentage - 0.05)));
		finalMaxSymbols = Math.max(maxSymbolBase, Math.floor(clusterSize * (symbolPercentage + 0.05)));
		finalMaxCoins = Math.max(maxCoinBase, Math.floor(clusterSize * coinPercentage));
		finalCoinChance = 0.15; // Hogere kans maar minder max coins
	  }

	  // SYMBOLS
	  const symCount = Math.min(clusterIndices.length, Math.floor(Math.random()*(finalMaxSymbols-finalMinSymbols+1))+finalMinSymbols);
	  const symbolIndices = new Set(clusterIndices.slice(0, symCount));

	  // COINS
	  const remainingForCoins = clusterIndices.filter(i => !symbolIndices.has(i));
	  shuffleArray(remainingForCoins);
	  const coinSet = new Set();
	  for(const cand of remainingForCoins){
		if(coinSet.size >= finalMaxCoins) break;
		if(Math.random() < finalCoinChance) coinSet.add(cand);
	  }

	  const trapSet = new Set();
	  const trapChanceClamped = Math.max(0, Math.min(1, trapChance || 0));
	  const trapLimit = maxTraps > 0 ? maxTraps : 0;
	  if (trapChanceClamped > 0 && trapLimit !== 0) {
		const trapCandidates = clusterIndices.filter(i => !symbolIndices.has(i) && !coinSet.has(i));
		shuffleArray(trapCandidates);
		for (const cand of trapCandidates) {
		  if (trapSet.size >= trapLimit) break;
		  if (Math.random() < trapChanceClamped) trapSet.add(cand);
		}
	  }
	  trapSet.forEach(idx => {
		symbolIndices.delete(idx);
		coinSet.delete(idx);
	  });

	  // apply symbols & coins
	  for(const idx of clusterSet){
		const cell = clusterMap[idx];
		if(!cell) continue;

		if(trapSet.has(idx)){
		  decorateTrapCell(cell, { blackHoleChance });
		}

		else if(symbolIndices.has(idx)){
		  const sym = document.createElement('div');
		  sym.classList.add('symbol', 'gray');
		  let rr = Math.random()*totalWeight;
		  for(const cc of colorChances){
			if(rr < cc.weight){ sym.classList.add(cc.color); break; }
			rr -= cc.weight;
		  }
		  cell.appendChild(sym);
		}

		else if(coinSet.has(idx)){
		  cell.classList.add('gold-cell');
		}
	  }

	  // ---------- mark endpoints ----------
	  if (!isRed) {
		const greenCfg = (gridId === 'green-grid' && typeof window !== 'undefined') ? (window.greenGridConfig || null) : null;
		const targetMinEndpoints = Math.max(0, Number(greenCfg?.minEndPoints ?? 8) || 8);
		const targetMinEndCells = Math.max(0, Number(greenCfg?.minEndCellPoints ?? targetMinEndpoints) || targetMinEndpoints);
		const targetMaxEndCells = Math.max(targetMinEndCells, Number(greenCfg?.maxEndCellPoints ?? 30) || 30);
		// We want enough candidates to pick from.
		const desiredEndpointPool = Math.max(targetMinEndpoints, targetMinEndCells);
		// End-cell count: clamp to available endpoints, but allow >8 in World 2.
		const desiredEndCellCount = Math.min(targetMaxEndCells, Math.max(targetMinEndCells, desiredEndpointPool));

		// Verzamel alle potentiÃ«le eindpunten (cellen met max 1 buur)
		const potentialEndpoints = [];
		for(const idx of clusterSet){
		  const r = Math.floor(idx/cols), c = idx % cols;
		  let neighbors=0;
		  for(const d of dirs){
			const nr=r+d.r, nc=c+d.c;
			if(isInside(nr,nc) && clusterSet.has(toIndex(nr,nc))) neighbors++;
		  }
		  if(neighbors <= 1 && idx !== centerIdx){
			potentialEndpoints.push(idx);
		  }
		}
		
		// Als we niet genoeg eindpunten hebben, voeg cellen met 2 buren toe
		if (potentialEndpoints.length < desiredEndpointPool) {
		  const additionalEndpoints = [];
		  for(const idx of clusterSet){
			if (potentialEndpoints.includes(idx) || idx === centerIdx) continue;
			const r = Math.floor(idx/cols), c = idx % cols;
			let neighbors=0;
			for(const d of dirs){
			  const nr=r+d.r, nc=c+d.c;
			  if(isInside(nr,nc) && clusterSet.has(toIndex(nr,nc))) neighbors++;
			}
			if(neighbors === 2){
			  additionalEndpoints.push(idx);
			}
		  }
		  shuffleArray(additionalEndpoints);
		  const needed = desiredEndpointPool - potentialEndpoints.length;
		  potentialEndpoints.push(...additionalEndpoints.slice(0, needed));
		}
		
		// Als nog steeds niet genoeg, neem cellen met 3 buren
		if (potentialEndpoints.length < desiredEndpointPool) {
		  const moreEndpoints = [];
		  for(const idx of clusterSet){
			if (potentialEndpoints.includes(idx) || idx === centerIdx) continue;
			const r = Math.floor(idx/cols), c = idx % cols;
			let neighbors=0;
			for(const d of dirs){
			  const nr=r+d.r, nc=c+d.c;
			  if(isInside(nr,nc) && clusterSet.has(toIndex(nr,nc))) neighbors++;
			}
			if(neighbors === 3){
			  moreEndpoints.push(idx);
			}
		  }
		  shuffleArray(moreEndpoints);
		  const needed = desiredEndpointPool - potentialEndpoints.length;
		  potentialEndpoints.push(...moreEndpoints.slice(0, needed));
		}
		
		// Shuffle en selecteer een groter aantal eindpunten (World 2: meer end-cells)
		shuffleArray(potentialEndpoints);
		const selectedEndpoints = potentialEndpoints.slice(0, Math.min(desiredEndCellCount, potentialEndpoints.length));
		
		// Markeer de geselecteerde eindpunten
		for(const idx of selectedEndpoints){
		  const cell = clusterMap[idx];
		  if(cell){
			cell.querySelectorAll('.symbol').forEach(s=>s.remove());
			cell.classList.remove('gold-cell');
			if (trapSet.has(idx)) {
			  cell.classList.remove('trap-cell');
			  delete cell.dataset.trap;
			  cell.querySelectorAll('.trap-symbol').forEach(s => s.remove());
			}
			cell.classList.add('end-cell');
			cell.style.zIndex = 5;
		  }
		}
	  }

	  updateScore();
	  return clusterSet;
	}

  // ---------- toggleCell / coins ----------
	function toggleCell(cell, zoneId, explicitColor = null, partOfShape = false){

	if(!cell) return;
	if(cell.classList.contains('void-cell') || cell.dataset.disabled === 'true') return;

	if (!partOfShape) {
		if (draggedBlock) return;
		const isClassicMode = document.body.classList.contains('classic-mode');
		// Classic mode: allow direct click/tap placement without debug mode and without requiring zoom.
		if (!debugMode && !isClassicMode) {
			if (window.innerWidth <= MOBILE_BREAKPOINT && !document.body.classList.contains('zoomed-in')) {
				return;
			}
			return;
		}
	}
	
    // bepaal of cel voorheen actief was
	  const was = cell.classList.contains('active');

	  // push history (zodat undo werkt)
	  if (!partOfShape) {
		const actionId = ++actionSequence;
		historyStack.push({cell:cell, wasActive: was, sequence: actionId});
	  }

	  // bepaal zone en zoneColor op een robuuste manier
	  let zone = null;
	  if (zoneId) zone = document.getElementById(zoneId);
	  if (!zone) zone = cell.closest('.zone');
	  
	  const zoneColor = explicitColor || zone?.dataset?.color || '';
			
	 if(was) {
		// --- DEACTIVEREN ---
		cell.classList.remove('active');
		cell.classList.remove('preview-allowed', 'preview-denied', 'edge-cell');

		// Cleanup dataset
		delete cell.dataset.clusterScore;
		delete cell.dataset.clusterPending;
		delete cell.dataset.activationSequence;
		delete cell.dataset.placementId;
	  } else {
		cell.classList.add('active');
		cellActivationSequence += 1;
		cell.dataset.activationSequence = String(cellActivationSequence);
		if (partOfShape && currentPlacementId) {
			cell.dataset.placementId = currentPlacementId;
		} else {
			delete cell.dataset.placementId;
		}
		
		// Clean up portal visual elements when portal cell becomes active
		if (cell.classList.contains('portal-cell')) {
			const portalSymbol = cell.querySelector('.portal-symbol');
			if (portalSymbol) portalSymbol.remove();
			cell.classList.remove('portal-cell');
			// Keep bold-cell class for scoring logic
		}
				// zorg dat achtergrond consistent wordt gezet: expliciete kleur (bv. van placeShape) of zoneColor
				try {
					const rainbowGradient = 'linear-gradient(45deg, #f06272, #fff25a, #4ed346, #5d90f0, #a35eff)';
					let appliedBg = '';
					if (explicitColor) appliedBg = (explicitColor === 'rainbow') ? rainbowGradient : explicitColor;
					else if (zoneColor) appliedBg = (zoneColor === 'rainbow') ? rainbowGradient : zoneColor;

					// If this is a designated start-cell in the green zone, force the lighter green (do NOT use dark end-cell color)
					if (cell.classList.contains('start-cell')) {
						const zcol = String(zone && zone.dataset ? (zone.dataset.color || '') : '').toLowerCase();
						if (zcol === 'groen' || zcol === 'green') {
							appliedBg = '#92c28c';
							try { cell.style.borderColor = '#c1ffa8'; } catch (e) {}
						}
					}

					cell.style.background = appliedBg;
				} catch (e) { /* ignore styling errors */ }
	  }
    // If this cell is a coin and is activated, add coin; if deactivated, remove coin
	if(cell.classList.contains('gold-cell')){
      if(cell.classList.contains('active')) { 
	  const rect = cell.getBoundingClientRect();
		const scrollX = window.scrollX || window.pageXOffset;
		const scrollY = window.scrollY || window.pageYOffset;
		sparkleEffect(rect.left + rect.width / 2 + scrollX, rect.top + scrollY);
	  addCoin(); 
	} else removeCoin();
    }
	
	let bonusClaim = null;
	hasSymbol = cell.querySelector('.symbol');
	if(hasSymbol && cell.classList.contains('active') && cell.dataset.bonusConsumed !== 'true'){
		// World 2 field event: bonus upgrade shop (grants 1 free random upgrade)
		if (hasSymbol.classList.contains('upgrade-shop-symbol') || cell.dataset.bonusUpgradeEvent === 'true') {
			cell.dataset.bonusConsumed = 'true';
			delete cell.dataset.bonusUpgradeEvent;
			hasSymbol.classList.add('bonus-used');
			try { hasSymbol.remove(); } catch {}
			openRandomFreeBonusUpgradeModal();
		} else if (hasSymbol.classList.contains('mega-bonus-symbol')) {
			const megaBonusColor = hasSymbol.dataset.megaBonusColor;
			cell.dataset.bonusConsumed = 'true';
			hasSymbol.classList.add('bonus-used');
			const rect = cell.getBoundingClientRect();
			const scrollX = window.scrollX || window.pageXOffset;
			const scrollY = window.scrollY || window.pageYOffset;
			const color = getComputedStyle(hasSymbol).backgroundColor;
			showScoreAnimation(rect.left + rect.width/2 + scrollX, rect.top + rect.height/2 + scrollY, "MEGA BONUS!", color);
			// Bonus shop is now a field event (no modal). Grant a free random upgrade.
			setTimeout(() => {
				grantRandomBonusUpgrade();
			}, 250);
		} else {
			// Normale bonus handling
			const bonusKey = getBonusKeyFromSymbol(hasSymbol);
			const grantedAmount = bonusKey ? grantBonusCharge(bonusKey) : 0;
			if (grantedAmount > 0) {
				cell.dataset.bonusConsumed = 'true';
				hasSymbol.classList.add('bonus-used');
				const rect = cell.getBoundingClientRect();
				const scrollX = window.scrollX || window.pageXOffset;
				const scrollY = window.scrollY || window.pageYOffset;
				const color = getComputedStyle(hasSymbol).backgroundColor;
				showScoreAnimation(rect.left + rect.width/2 + scrollX, rect.top + rect.height/2 + scrollY, "BONUS", color);
				bonusClaim = createBonusClaim(cell, hasSymbol, bonusKey, grantedAmount);
				if (!partOfShape) {
					const lastHistory = historyStack[historyStack.length - 1];
					if (lastHistory && lastHistory.cell === cell) {
						lastHistory.bonusClaims = lastHistory.bonusClaims || [];
						lastHistory.bonusClaims.push(bonusClaim);
					}
				}
			}
		}
	}

	ensureTrapState(cell, zone?.id || zoneId || '');

	updateScore(cell);
	syncPlaceholderForCell(cell);
	return bonusClaim ? { bonusClaim } : null;
	}

	function createCoinElement(index) {
		const coin = document.createElement('div');
		coin.classList.add('coin');
		coin.dataset.index = String(index);
		coin.addEventListener('pointerdown', (e) => {
			e.preventDefault();
			const isActive = coin.classList.contains('active');
			const isUsed = coin.classList.contains('used');
			if (!isActive && !isUsed) return;
			if (isUsed) {
				coin.classList.remove('used');
				coin.classList.add('active');
			} else {
				coin.classList.add('used');
				coin.classList.remove('active');
			}
			updateCoinCounter();
		});
		return coin;
	}

	function initialiseCoins(minCount = 50) {
		const container = document.getElementById('collected-coins');
		if (!container) return;
		const isClassicMode = document.body.classList.contains('classic-mode');
		const desired = isClassicMode ? 20 : Math.max(50, Number(minCount) || 0);
		const existing = container.children.length;
		if (existing >= desired) {
			updateCoinCounter();
			return;
		}
		for (let i = existing; i < desired; i++) {
			container.appendChild(createCoinElement(i));
		}
		updateCoinCounter();
	}

	function resetCoins() {
	  document.querySelectorAll('#collected-coins .coin').forEach(coin => {
		coin.classList.remove('active', 'used');
	  });
	  updateCoinCounter();
	}

	function resetScoreState() {
	  yellow = 0;
	  green = 0;
	  purple = 0;
	  blue = 0;
	  red = 0;
	  bonus = 0;
	  blackHoleBonus = 0;
	  totalBonusesCollected = 0;
	  latestScoreSnapshot = null;
	coinsAwardedFromScore = 0;
	cellActivationSequence = 0;
	placementSequence = 0;
	currentPlacementId = null;
	  resetBlackHoleState();
	  bonusCoinMilestones = 0;
	  window.scoredYellowColumns = new Set();
	  window.scoredYellowDiagonals = new Set();
	  window.scoredYellowSegments = new Set();
	window['blue-grid-scoredRows'] = new Map();
	window['blue-grid-scoredTargets'] = new Map();
	window['blue-grid-rowPlacements'] = new Map();
	window['blue-grid-placementScorings'] = new Map();
	  delete window.purpleConnections;
	  ['red-grid1', 'red-grid2', 'red-grid3', 'red-grid4'].forEach(id => {
		const grid = document.getElementById(id);
		if (grid) {
		  grid.dataset.completed = 'false';
		  grid.dataset.score = '0';
		}
	  });
	  const scoreIds = ['yellow-score','red-score','green-score','purple-score','blue-score','bonus-score'];
	  scoreIds.forEach(id => {
		const el = document.getElementById(id);
		if (el) el.textContent = '0';
	  });
	  const totalScoreEl = document.getElementById('total-score');
	  if (totalScoreEl) {
		totalScoreEl.textContent = '0';
		totalScoreEl.classList.remove('flash');
	  }
	  resetTrapState();
	  resetBonusState();
	}

	function addCoin(){
		const container = document.getElementById('collected-coins');
		if (!container) return;
		const coins = Array.from(container.querySelectorAll('.coin'));
		let next = coins.find(coin => !coin.classList.contains('active') && !coin.classList.contains('used'));
		if (!next) {
			next = createCoinElement(coins.length);
			container.appendChild(next);
		}
		next.classList.add('active');
		next.classList.remove('used');
		updateCoinCounter();
	}

	function removeCoin(){
	  const coins = Array.from(document.querySelectorAll('#collected-coins .coin.active'));
	  const last = coins.pop();
	  if(last) last.classList.remove('active', 'used');
	  updateCoinCounter();
	}

	const TRAP_ZONE_LABELS = {
	  'yellow-grid': 'Geel',
	  'purple-grid': 'Paars',
	  'green-grid': 'Groen',
	  'blue-grid': 'Blauw',
	  'gold-zone': 'Munten',
	  'red-zone': 'Rood'
	};

	function normalizeZoneId(zoneId = '') {
	  return zoneId.replace(/--placeholder$/, '');
	}

	function nextTrapId() {
	  trapIdCounter += 1;
	  return `trap-${trapIdCounter}`;
	}

	function getTrapZoneLabel(zoneId = '') {
	  if (!zoneId) return 'Onbekend';
	  const normalized = normalizeZoneId(zoneId);
	  if (normalized.startsWith('red-grid')) return 'Rood';
	  return TRAP_ZONE_LABELS[normalized] || normalized;
	}

	function decorateTrapCell(cell, options = {}) {
	  if (!cell) return 'pit';
	  const { forceType = null, blackHoleChance = BLACK_HOLE_DEFAULT_CHANCE } = options;
	  let trapType = forceType;
	  if (!trapType) {
		const chance = Math.max(0, Math.min(1, Number(blackHoleChance) || 0));
		trapType = chance > 0 && Math.random() < chance ? 'blackHole' : 'pit';
	  }
	  cell.classList.add('trap-cell');
	  cell.dataset.trap = 'true';
	  cell.dataset.trapType = trapType;
	const shouldRevealTrap = trapType !== 'blackHole' || hasUpgrade('blackHoleAccess');
	if (shouldRevealTrap) {
		const symbol = document.createElement('div');
		symbol.classList.add('symbol', 'trap-symbol');
		if (trapType === 'blackHole') symbol.classList.add('trap-symbol--black-hole');
		else symbol.classList.add('trap-symbol--pit');
		cell.appendChild(symbol);
	}
	  return trapType;
	}

	function resetBlackHoleState() {
	  blackHoleState.trap = null;
	  blackHoleState.cards = [];
	  blackHoleState.selected = new Set();
	  blackHoleState.reward = 0;
	  blackHoleState.coins = 0;
	  blackHoleState.stake = 0;
	  blackHoleState.gameOver = false;
	  if (blackHoleState.feedbackTimeout) {
		clearTimeout(blackHoleState.feedbackTimeout);
		blackHoleState.feedbackTimeout = null;
	  }
	}

	function getTotalTrapPenalty() {
	  return activeTraps.reduce((sum, trap) => {
		const penalty = Number(trap.penalty) || 0;
		return penalty > 0 ? sum + penalty : sum;
	  }, 0);
	}

	function renderTrapSummary(options = {}) {
	  const { highlightId = null } = options;
	  const preview = document.getElementById('scoreboard-trap-preview');
	  const countEl = document.getElementById('trap-count-label');
	  
	  // Als trap-summary niet bestaat (verwijderd uit HTML), stop functie
	  if (!preview || !countEl) return;
	  
	const blackHoleUnlocked = hasUpgrade('blackHoleAccess');
	const visibleTraps = activeTraps.filter(trap => trap.type !== 'blackHole' || blackHoleUnlocked);
	const trapCount = visibleTraps.length;
	
	// Set data attribute op body voor CSS styling (voor toekomstig gebruik)
	if (currentLevel >= 5) {
		document.body.setAttribute('data-traps-active', 'true');
	} else {
		document.body.removeAttribute('data-traps-active');
	}
	
	const totalPenalty = visibleTraps.reduce((sum, trap) => {
		const penalty = Number(trap.penalty) || 0;
		return penalty > 0 ? sum + penalty : sum;
	}, 0);
	const specialCount = blackHoleUnlocked ? visibleTraps.filter(trap => trap.type === 'blackHole').length : 0;
	const penaltyCount = visibleTraps.filter(trap => trap.type !== 'blackHole').length;
	const scoreboardEl = document.getElementById('scoreboard');
	const isScoreboardInBottomBar = !!(scoreboardEl && scoreboardEl.closest('#bottom-bar'));
	const isMobileView = isScoreboardInBottomBar || window.innerWidth <= MOBILE_BREAKPOINT;
	preview.classList.toggle('trap-preview--compact', isMobileView);
	preview.innerHTML = '';
	if (trapCount === 0) {
		countEl.textContent = '0 actief';
		return;
	}
	const summaryParts = [`${trapCount} actief`];
	if (totalPenalty > 0) summaryParts.push(`âˆ’${totalPenalty}`);
	if (specialCount > 0) summaryParts.push(`${specialCount} zwart gat`);
	if (isMobileView) {
		const segments = [];
		if (penaltyCount > 0) segments.push(`âš ï¸ ${penaltyCount}`);
		if (specialCount > 0) segments.push(`ðŸŒ€ ${specialCount}`);
		countEl.textContent = segments.length ? segments.join(' Â· ') : `${trapCount}`;
		if (penaltyCount > 0) {
		  const chip = document.createElement('span');
		  chip.classList.add('trap-compact-chip');
		  chip.dataset.symbol = 'âš ï¸';
		  chip.innerHTML = `<span>${penaltyCount}</span>`;
		  const penaltyLabel = totalPenalty > 0 ? `, -${totalPenalty} punten` : '';
		  const label = `${penaltyCount} valkuil${penaltyCount === 1 ? '' : 'en'} actief${penaltyLabel}`;
		  chip.setAttribute('aria-label', label);
		  chip.title = label;
		  preview.appendChild(chip);
		}
		if (specialCount > 0) {
		  const chip = document.createElement('span');
		  chip.classList.add('trap-compact-chip', 'trap-compact-chip--black-hole');
		  chip.dataset.symbol = 'ðŸŒ€';
		  chip.innerHTML = `<span>${specialCount}</span>`;
		  const label = `${specialCount} zwart gat${specialCount === 1 ? '' : 'en'} actief`;
		  chip.setAttribute('aria-label', label);
		  chip.title = label;
		  preview.appendChild(chip);
		}
		return;
	}
	countEl.textContent = summaryParts.join(' Â· ');
	const sortedTraps = [...visibleTraps].sort((a, b) => a.triggeredAt - b.triggeredAt);
	  sortedTraps.forEach(trap => {
		const icon = document.createElement('div');
		icon.classList.add('trap-icon');
		const isBlackHole = trap.type === 'blackHole';
		icon.classList.toggle('trap-icon--black-hole', isBlackHole);
		icon.classList.toggle('trap-icon--penalty', !isBlackHole || (trap.penalty ?? 0) > 0);
		icon.dataset.trapId = trap.id;
		icon.setAttribute('role', 'listitem');
		const penaltyValue = Number(trap.penalty) || 0;
		const labelBits = [isBlackHole ? 'Zwart gat' : 'Valkuil', 'in', getTrapZoneLabel(trap.zoneId)];
		if (penaltyValue > 0) labelBits.push(`geeft -${penaltyValue} punten`);
		else if (isBlackHole) labelBits.push('bonus beschikbaar');
		icon.setAttribute('aria-label', labelBits.join(' '));
		const symbol = isBlackHole ? 'ðŸŒ€' : 'âš ï¸';
		let markup = `<span>${symbol}</span>`;
		if (penaltyValue > 0) {
		  markup += `<span class="penalty-chip">-${penaltyValue}</span>`;
		} else if (isBlackHole) {
		  markup += `<span class="penalty-chip">bonus</span>`;
		}
		icon.innerHTML = markup;
		preview.appendChild(icon);
	  });
	const highlightTarget = highlightId && visibleTraps.some(trap => trap.id === highlightId) ? highlightId : null;
	if (highlightTarget) {
		requestAnimationFrame(() => {
			const highlightEl = preview.querySelector(`[data-trap-id="${highlightTarget}"]`);
		  if (highlightEl) {
			highlightEl.classList.add('highlight');
			setTimeout(() => {
			  highlightEl.classList.remove('highlight');
			}, 1600);
		  }
		});
	  }
	}

	function handleBlackHoleTrapTrigger(trapRecord, options = {}) {
	  const { upgradeUnlocked = false, silent = false } = options;
	  if (!trapRecord || silent) return;
	  if (upgradeUnlocked) {
		openBlackHoleChallenge(trapRecord);
	  } else {
		showObjectiveToast('ðŸŒ€ Koop de Zwart Gat Pas in de shop om dit speciale level te spelen.');
	  }
	}

	function registerTrapTrigger(cell, zoneId = '', { silent = false } = {}) {
	  if (!cell || cell.dataset.trapTriggered === 'true') return;
	  const trapId = nextTrapId();
	  const normalizedZone = normalizeZoneId(zoneId || cell.dataset.zoneId || cell.closest('.grid')?.id || '');
	const trapType = cell.dataset.trapType || 'pit';
	const isBlackHole = trapType === 'blackHole';
	const blackHoleUnlocked = isBlackHole && hasUpgrade('blackHoleAccess');
	const penaltyValue = isBlackHole ? 0 : TRAP_PENALTY;
	  const trapRecord = {
		id: trapId,
		cell,
		zoneId: normalizedZone,
		penalty: penaltyValue,
		triggeredAt: Date.now(),
		type: trapType
	  };
	  cell.dataset.trapTriggered = 'true';
	  cell.dataset.trapInstanceId = trapId;
	  cell.classList.add('trap-triggered');
	  activeTraps.push(trapRecord);
	  lastTrapHighlightId = trapId;
	  if (!silent && penaltyValue > 0) {
		const rect = cell.getBoundingClientRect();
		const scrollX = window.scrollX || window.pageXOffset;
		const scrollY = window.scrollY || window.pageYOffset;
		showScoreAnimation(
		  rect.left + rect.width / 2 + scrollX,
		  rect.top + rect.height / 2 + scrollY,
		  `-${penaltyValue}`,
		  'rgba(196,56,56,0.9)'
		);
	  }
	const trapVisible = !isBlackHole || blackHoleUnlocked;
	if (silent) renderTrapSummary();
	else if (trapVisible) renderTrapSummary({ highlightId: trapId });
	else renderTrapSummary();
	if (trapType === 'blackHole') {
		handleBlackHoleTrapTrigger(trapRecord, { upgradeUnlocked: blackHoleUnlocked, silent });
	  }
	}

	function releaseTrap(cell) {
	  if (!cell || cell.dataset.trapTriggered !== 'true') return;
	  const trapId = cell.dataset.trapInstanceId;
	  cell.classList.remove('trap-triggered');
	  delete cell.dataset.trapTriggered;
	  delete cell.dataset.trapInstanceId;
	  if (trapId) {
		activeTraps = activeTraps.filter(trap => trap.id !== trapId);
	  }
	  renderTrapSummary();
	}

	function resolveTrapById(trapId) {
	  if (!trapId) return;
	  const trap = activeTraps.find(entry => entry.id === trapId);
	  if (!trap) return;
	  if (trap.cell) {
		releaseTrap(trap.cell);
	  } else {
		activeTraps = activeTraps.filter(entry => entry.id !== trapId);
		renderTrapSummary();
	  }
	}

	function ensureTrapState(cell, zoneId = '', options = {}) {
	  if (!cell || cell.dataset.trap !== 'true') return;
	  const normalizedZone = normalizeZoneId(zoneId || cell.dataset.zoneId || cell.closest('.grid')?.id || '');
	  const isActive = cell.classList.contains('active');
	  const triggered = cell.dataset.trapTriggered === 'true';
	  const { silent = false } = options;
	  if (isActive && !triggered) {
		registerTrapTrigger(cell, normalizedZone, { silent });
	  } else if (!isActive && triggered) {
		releaseTrap(cell);
	  }
	}

	function resetTrapState() {
	  activeTraps = [];
	  lastTrapHighlightId = null;
	  document.querySelectorAll('.cell.trap-triggered, .cell[data-trap-triggered="true"]').forEach(cell => {
		cell.classList.remove('trap-triggered');
		delete cell.dataset.trapTriggered;
		delete cell.dataset.trapInstanceId;
	  });
	  renderTrapSummary();
	}

  /* ============================================
     BONUS MUNT BELONINGEN
     ============================================
     World 1: Elke 10 punten bonus geeft 1 gratis munt
     World 2+: Elke 20 punten bonus geeft 1 gratis munt (50% minder)
     Houdt bij hoeveel milestones al bereikt zijn
  */
  function trackBonusCoinRewards(currentBonus) {
	if (typeof currentBonus !== 'number' || currentBonus <= 0) return;
	const worldInfo = (typeof getWorldAndSubLevel === 'function') ? getWorldAndSubLevel(currentLevel) : { world: 1 };
	const isWorld2Plus = Number(worldInfo?.world || 1) >= 2;
	const bonusPerCoin = isWorld2Plus ? 20 : 10; // World 2+: 50% minder coins
	const milestonesReached = Math.floor(currentBonus / bonusPerCoin);
	if (milestonesReached <= bonusCoinMilestones) return;
	const coinsToGrant = milestonesReached - bonusCoinMilestones;
	for (let i = 0; i < coinsToGrant; i += 1) addCoin();
	bonusCoinMilestones = milestonesReached;
  }

	/* Bereken hoeveel coins je krijgt voor een bepaalde score
	   World 1: 1 coin per 10 punten
	   World 2+: Getrapte schaal:
	     - 0-50 punten: 1 coin per 10 punten (max 5)
	     - 50-150 punten: 1 coin per 25 punten (max 4 extra = 9 totaal)
	     - 150+ punten: 1 coin per 50 punten
	*/
	function calculateCoinsForScore(score, isWorld2Plus = false) {
	  if (!isWorld2Plus) {
		return Math.floor(score / 10);
	  }
	  // World 2+ tiered system
	  let coins = 0;
	  if (score <= 50) {
		coins = Math.floor(score / 10);
	  } else if (score <= 150) {
		coins = 5 + Math.floor((score - 50) / 25);
	  } else {
		coins = 5 + 4 + Math.floor((score - 150) / 50);
	  }
	  return coins;
	}

	function grantRoundScoreCoins(finalScore) {
	  if (!Number.isFinite(finalScore) || finalScore <= 0) return;
	  const worldInfo = (typeof getWorldAndSubLevel === 'function') ? getWorldAndSubLevel(currentLevel) : { world: 1 };
	  const isWorld2Plus = Number(worldInfo?.world || 1) >= 2;
	  const targetCoins = calculateCoinsForScore(finalScore, isWorld2Plus);
	  if (targetCoins <= coinsAwardedFromScore) return;
	  const coinsToGrant = targetCoins - coinsAwardedFromScore;
	  for (let i = 0; i < coinsToGrant; i += 1) addCoin();
	  coinsAwardedFromScore = targetCoins;
	  if (coinsToGrant > 0) {
		const label = coinsToGrant === 1 ? 'munt' : 'munten';
		showObjectiveToast(`ðŸ’° +${coinsToGrant} ${label} voor je score!`);
	  }
	}

  /* ============================================
     SCORE BEREKENING - HOOFDFUNCTIE
     ============================================
     Berekent de totale score voor alle kleuren:
     - GROEN: 8 punten per ingevulde eindcel
     - BLAUW: Punten voor kolommen (4/8/12 voor 2/3/4 cellen)
     - ROOD: 2 punten per cel in volledig gevulde grids
     - GEEL: Punten per volledig gevulde rij (10 + upgrades)
     - PAARS: Punten voor patronen (2x2, 3x3, lijn van 4+, enz)
     
     Toont ook animaties bij score veranderingen
  */
  function updateScore(cell){

		try { console.debug('updateScore:called', { cellId: cell ? (cell.id || null) : null, time: Date.now() }); } catch(e) {}

    /* === GROEN SCORE === 
       Elke ingevulde eindcel = 8 punten */
	(() => {
		const greenGrid = document.getElementById('green-grid');
		const worldInfo = (typeof getWorldAndSubLevel === 'function') ? getWorldAndSubLevel(currentLevel) : { world: currentWorld };
		const isWorld2 = Number(worldInfo?.world || currentWorld || 1) >= 2;
		const activeEndCells = Array.from(document.querySelectorAll('#green-grid .cell.end-cell.active'));
		if (!isWorld2 || !greenGrid) {
			green = activeEndCells.length * 8;
			if (cell != null && cell.classList.contains('end-cell') && cell.classList.contains('active')) {
				const rect = cell.getBoundingClientRect();
				const scrollX = window.scrollX || window.pageXOffset;
				const scrollY = window.scrollY || window.pageYOffset;
				showScoreAnimation(rect.left + rect.width / 2 + scrollX, rect.top + rect.height / 2 + scrollY, "+ 8", "green");
			}
			return;
		}

		const greenCfg = window.greenGridConfig || {};
		const minPts = Math.max(0, Number(greenCfg.minEndCellPoints) || 8);
		const maxPts = Math.max(minPts, Number(greenCfg.maxEndCellPoints) || 30);
		const rows = Number(greenGrid.dataset.rows) || 0;
		const cols = Number(greenGrid.dataset.cols) || 0;
		const startX = Number(greenGrid.dataset.startX);
		const startY = Number(greenGrid.dataset.startY);
		const safeStartX = Number.isFinite(startX) ? startX : Math.floor(cols / 2);
		const safeStartY = Number.isFinite(startY) ? startY : Math.floor(rows / 2);
		const cornerDists = [
			Math.abs(0 - safeStartX) + Math.abs(0 - safeStartY),
			Math.abs((cols - 1) - safeStartX) + Math.abs(0 - safeStartY),
			Math.abs(0 - safeStartX) + Math.abs((rows - 1) - safeStartY),
			Math.abs((cols - 1) - safeStartX) + Math.abs((rows - 1) - safeStartY)
		];
		const maxDist = Math.max(1, ...cornerDists.filter(Number.isFinite));
		const pointsFor = (endCell) => {
			const x = Number(endCell.dataset.x ?? endCell.dataset.c);
			const y = Number(endCell.dataset.y ?? endCell.dataset.r);
			if (!Number.isFinite(x) || !Number.isFinite(y)) return minPts;
			const dist = Math.abs(x - safeStartX) + Math.abs(y - safeStartY);
			const t = Math.max(0, Math.min(1, dist / maxDist));
			return Math.round(minPts + t * (maxPts - minPts));
		};
		green = activeEndCells.reduce((sum, c) => sum + pointsFor(c), 0);

		if (cell != null && cell.classList.contains('end-cell') && cell.classList.contains('active')) {
			const rect = cell.getBoundingClientRect();
			const scrollX = window.scrollX || window.pageXOffset;
			const scrollY = window.scrollY || window.pageYOffset;
			const pts = pointsFor(cell);
			showScoreAnimation(rect.left + rect.width / 2 + scrollX, rect.top + rect.height / 2 + scrollY, `+ ${pts}`, "green");
		}
	})();

	/* === BLAUW SCORE ===
	   Per rij met â‰¥1 actieve bold-cel: 1e rij â†’ 6, 2e â†’ 8, 3e â†’ 10, enz. */
	blue = calculateBlueScore('blue-grid', 3, 4, 8, cell);	/* === ROOD SCORE ===
   Elk volledig gevuld grid = 2 punten per cel
   Score verdwijnt als grid weer leeg gemaakt wordt */
['red-grid1', 'red-grid2', 'red-grid3', 'red-grid4'].forEach(id => {
  const grid = document.getElementById(id);
  if (!grid) return;

  const allCells = grid.querySelectorAll('.cell:not(.void-cell)');
  const activeCells = grid.querySelectorAll('.cell.active');

  const isFull = allCells.length > 0 && allCells.length === activeCells.length;
  const wasFull = grid.dataset.completed === "true";
  const gained = allCells.length * 2;	  // ðŸŸ¥ Grid wordt net VOLTOOID
	  if (isFull && !wasFull) {
	  	highlightEdgeCells(grid);
		grid.dataset.completed = "true";
		grid.dataset.score = gained; // sla eigen score op


		red += gained;

		const middleIndex = Math.floor(allCells.length / 2);
		const cell = allCells[middleIndex];
		const rect = cell.getBoundingClientRect();
		const scrollX = window.scrollX || window.pageXOffset;
		const scrollY = window.scrollY || window.pageYOffset;

		showScoreAnimation(
		  rect.left + rect.width / 2 + scrollX,
		  rect.top + rect.height / 2 + scrollY,
		  "+" + gained,
		  "red"
		);
	  }

	  // ðŸ”» Grid wordt net ONTVOLLEDIGD (van vol â†’ niet vol)
	  if (!isFull && wasFull) {
		grid.dataset.completed = "false";
		const lost = parseInt(grid.dataset.score || gained);
		red -= lost;
		grid.dataset.score = 0;

		const middleIndex = Math.floor(allCells.length / 2);
		const cell = allCells[middleIndex];
	  }
	});


    /* === GEEL SCORE ===
       Volle rijen geven punten: basis 10 + 4 per upgrade level
       Bijv level 3 = 10 + 2*4 = 18 punten per rij */
	const yellowContainer = document.getElementById('yellow-grid');
	const yellowConfig = window.yellowGridConfig || {};
	const fallbackRowCount = Number(yellowContainer?.dataset?.rows || yellowConfig.rows || 0);
	const parsedRowLengths = (() => {
	  if (Array.isArray(yellowConfig.rowLengths)) return yellowConfig.rowLengths;
	  const raw = yellowContainer?.dataset?.rowLengths;
	  if (!raw) return [];
	  return raw.split(',').map(val => Number(val) || 0);
	})();
	const rowLengths = parsedRowLengths.length ? parsedRowLengths : Array.from({ length: fallbackRowCount }, () => Number(yellowContainer?.dataset?.cols || yellowConfig.cols || 0));
	const parsedRowOffsets = (() => {
	  if (Array.isArray(yellowConfig.rowOffsets)) return yellowConfig.rowOffsets;
	  const rawOffsets = yellowContainer?.dataset?.rowOffsets;
	  if (!rawOffsets) return Array.from({ length: rowLengths.length }, () => 0);
	  return rawOffsets.split(',').map(val => Number(val) || 0);
	})();
	const yellowCols = Number(yellowConfig.cols) || Number(yellowContainer?.dataset?.cols || 0) || 0;
	const columnPoints = Array.isArray(yellowConfig.pointsByColumn) ? yellowConfig.pointsByColumn : [];
	const fallbackColumnPoints = yellowConfig.pointsPerColumn || yellowConfig.pointsPerRow || 0;
	const playableYellowCells = yellowContainer ? Array.from(yellowContainer.querySelectorAll('.cell:not(.void-cell)')) : [];
	if (yellowConfig.scoreMode === 'diagonal') {
	  // World 2: score *segments* on diagonals (irregular shapes can have gaps)
	  // Points scale as requested: 4â†’8, 6â†’16, 8â†’32 (doubling every +2 length)
	  const minLen = Math.max(1, Number(yellowConfig.minDiagonalLength) || 4);
	  const computeSegmentPoints = (len) => {
		if (!Number.isFinite(len) || len < minLen) return 0;
		const halfSteps = Math.floor(len / 2) + 1;
		return Math.pow(2, halfSteps);
	  };
	  window.scoredYellowSegments = window.scoredYellowSegments || new Set();
	  // Back-compat: keep old set in sync so objectives/checks don't regress.
	  window.scoredYellowDiagonals = window.scoredYellowDiagonals || new Set();
	  const cellByCoord = new Map();
	  for (const c of playableYellowCells) {
		const x = Number(c.dataset.x);
		const y = Number(c.dataset.y);
		if (!Number.isFinite(x) || !Number.isFinite(y)) continue;
		cellByCoord.set(`${x},${y}`, c);
	  }

	  const tryGet = (x, y) => cellByCoord.get(`${x},${y}`) || null;
	  const collectSegments = (dx, dy, prefix) => {
		const segments = [];
		for (const startCell of cellByCoord.values()) {
			const x0 = Number(startCell.dataset.x);
			const y0 = Number(startCell.dataset.y);
			if (!Number.isFinite(x0) || !Number.isFinite(y0)) continue;
			// Segment start if previous neighbor in this diagonal direction doesn't exist
			if (tryGet(x0 - dx, y0 - dy)) continue;
			const segmentCells = [];
			let x = x0;
			let y = y0;
			while (true) {
				const cellHere = tryGet(x, y);
				if (!cellHere) break;
				segmentCells.push(cellHere);
				x += dx;
				y += dy;
			}
			if (segmentCells.length) {
				segments.push({
					key: `${prefix}:${x0},${y0}`,
					cells: segmentCells,
					points: computeSegmentPoints(segmentCells.length)
				});
			}
		}
		return segments;
	  };

	  // World 2 request: score BOTH diagonal directions.
	  const segments = [
		...collectSegments(1, 1, 'segNWSE'),
		...collectSegments(1, -1, 'segNESW')
	  ];

	  for (const seg of segments) {
		if (!seg.points) {
		  window.scoredYellowSegments.delete(seg.key);
		  continue;
		}
		const full = seg.cells.every(c => c.classList.contains('active'));
		const wasFull = window.scoredYellowSegments.has(seg.key);
		if (full && !wasFull) {
		  yellow += seg.points;
		  window.scoredYellowSegments.add(seg.key);
		  window.scoredYellowDiagonals.add(seg.key);
		  const anchorCell = seg.cells[0];
		  if (anchorCell) {
			const rect = anchorCell.getBoundingClientRect();
			const scrollX = window.scrollX || window.pageXOffset;
			const scrollY = window.scrollY || window.pageYOffset;
			showScoreAnimation(
			  rect.left + rect.width / 2 + scrollX,
			  rect.top + rect.height / 2 + scrollY,
			  `+${seg.points}`,
			  "yellow"
			);
		  }
		} else if (!full && wasFull) {
		  yellow -= seg.points;
		  window.scoredYellowSegments.delete(seg.key);
		  window.scoredYellowDiagonals.delete(seg.key);
		  const anchorCell = seg.cells[0];
		  if (anchorCell) {
			const rect = anchorCell.getBoundingClientRect();
			const scrollX = window.scrollX || window.pageXOffset;
			const scrollY = window.scrollY || window.pageYOffset;
			showScoreAnimation(
			  rect.left + rect.width / 2 + scrollX,
			  rect.top + rect.height / 2 + scrollY,
			  `âˆ’${seg.points}`,
			  "yellow"
			);
		  }
		}
	  }
	} else {
	  const columnCellMap = new Map();
	  playableYellowCells.forEach(cell => {
		const colIndex = Number(cell.dataset.x);
		if (!Number.isFinite(colIndex)) return;
		if (!columnCellMap.has(colIndex)) columnCellMap.set(colIndex, []);
		columnCellMap.get(colIndex).push(cell);
	  });

	  let maxColumnIndex = -1;
	  columnCellMap.forEach((_, key) => { if (key > maxColumnIndex) maxColumnIndex = key; });
	  const effectiveColumnCount = Math.max(yellowCols, columnPoints.length, maxColumnIndex + 1);
	  const columnHeights = (() => {
		if (Array.isArray(yellowConfig.columnHeights) && yellowConfig.columnHeights.length >= effectiveColumnCount) {
		  return yellowConfig.columnHeights;
		}
		const heights = Array.from({ length: effectiveColumnCount }, () => 0);
		for (let row = 0; row < rowLengths.length; row++) {
		  const rowLen = rowLengths[row];
		  if (rowLen <= 0) continue;
		  const rowStart = parsedRowOffsets[row] || 0;
		  for (let col = rowStart; col < rowStart + rowLen; col++) {
			if (col >= heights.length) break;
			heights[col] += 1;
		  }
		}
		return heights;
	  })();

	  window.scoredYellowColumns = window.scoredYellowColumns || new Set();

	  for (let col = 0; col < effectiveColumnCount; col++) {
		const expectedHeight = columnHeights[col] || 0;
		if (expectedHeight <= 0) {
		  window.scoredYellowColumns.delete(col);
		  continue;
		}

		const colCells = (columnCellMap.get(col) || []).slice().sort((a, b) => Number(a.dataset.y) - Number(b.dataset.y));
		const full = colCells.length === expectedHeight && colCells.every(cell => cell.classList.contains('active'));
		const wasFull = window.scoredYellowColumns.has(col);
		// Yellow request: every 2 columns share the same bonus.
		// e.g. columns 1-2 => 12 each, 3-4 => 18 each, 5-6 => 24 each, ...
		const columnPairIndex = Math.floor(col / 2);
		const columnPointsValue = 12 + (columnPairIndex * 6);
		if (!columnPointsValue || columnPointsValue <= 0) {
		  if (wasFull) window.scoredYellowColumns.delete(col);
		  continue;
		}

		if (full && !wasFull) {
		  yellow += columnPointsValue;
		  window.scoredYellowColumns.add(col);

		  const anchorCell = colCells[0];
		  if (anchorCell) {
			const rect = anchorCell.getBoundingClientRect();
			const scrollX = window.scrollX || window.pageXOffset;
			const scrollY = window.scrollY || window.pageYOffset;
			showScoreAnimation(
			  rect.left + rect.width / 2 + scrollX,
			  rect.top + rect.height / 2 + scrollY,
			  `+${columnPointsValue}`,
			  "yellow"
			);
		  }

		} else if (!full && wasFull) {
		  yellow -= columnPointsValue;
		  window.scoredYellowColumns.delete(col);

		  const anchorCell = colCells[0];
		  if (anchorCell) {
			const rect = anchorCell.getBoundingClientRect();
			const scrollX = window.scrollX || window.pageXOffset;
			const scrollY = window.scrollY || window.pageYOffset;
			showScoreAnimation(
			  rect.left + rect.width / 2 + scrollX,
			  rect.top + rect.height / 2 + scrollY,
			  `âˆ’${columnPointsValue}`,
			  "yellow"
			);
		  }
		}
	  }
	}

	// ---------- Purple clusters (floodfill BFS on active cells) ----------
	const purpleContainer = document.getElementById('purple-grid');
	if (purpleContainer) {
	  // Bind 1 delegated click handler (instead of rebinding onclick for every cell on every score tick)
	  if (!purpleContainer._clusterClickBound) {
		purpleContainer.addEventListener('click', (ev) => {
			const cell = ev.target && ev.target.closest ? ev.target.closest('.cell.bold-cell.active') : null;
			if (!cell || !purpleContainer.contains(cell)) return;
			const storedScore = Number(cell.dataset.clusterScore || '0');
			if (cell.dataset.clusterPending === "true" && storedScore > 0) {
				const rect = cell.getBoundingClientRect();
				const scrollX = window.scrollX || window.pageXOffset;
				const scrollY = window.scrollY || window.pageYOffset;
				showScoreAnimation(
					rect.left + rect.width / 2 + scrollX,
					rect.top + rect.height / 2 + scrollY,
					`+${storedScore}`,
					"purple"
				);
				cell.dataset.clusterPending = "false";
			}
		}, { passive: true });
		purpleContainer._clusterClickBound = true;
	  }

	  const purpleCells = Array.from(purpleContainer.querySelectorAll('.cell'));
	  const totalPurple = purpleCells.length;
	  let purpleCols = Number(purpleContainer.dataset.cols) || 0;
	  const styleCols = purpleContainer.style.gridTemplateColumns;
	  const repeatMatch = styleCols && styleCols.match(/repeat\(\s*(\d+)\s*,/i);
	  if (!purpleCols && repeatMatch) purpleCols = parseInt(repeatMatch[1], 10);
	  else if (!purpleCols) {
		const computed = getComputedStyle(purpleContainer).gridTemplateColumns;
		purpleCols = computed ? computed.split(/\s+/).length : Math.round(Math.sqrt(totalPurple)) || 1;
	  }
	  const purpleRows = Math.ceil(totalPurple / purpleCols);
	  const visited = new Array(totalPurple).fill(false);
	  const connections = [];
	  const purpleConfig = window.purpleGridConfig || {};
	  const isWorld2Purple = purpleConfig.world2 === true;

	  for (let i = 0; i < totalPurple; i++) {
		if (visited[i]) continue;
		if (!purpleCells[i].classList.contains('active')) { visited[i] = true; continue; }

		const stack = [i];
		visited[i] = true;
		const cluster = [];

		while (stack.length) {
		  const cur = stack.pop();
		  cluster.push(cur);
		  const r = Math.floor(cur / purpleCols), c = cur % purpleCols;
		  const neigh = [];
		  if (r > 0) neigh.push((r - 1) * purpleCols + c);
		  if (r < purpleRows - 1) neigh.push((r + 1) * purpleCols + c);
		  if (c > 0) neigh.push(r * purpleCols + (c - 1));
		  if (c < purpleCols - 1) neigh.push(r * purpleCols + (c + 1));
		  for (const n of neigh) {
			if (n < 0 || n >= totalPurple) continue;
			if (!visited[n] && purpleCells[n].classList.contains('active')) {
			  visited[n] = true;
			  stack.push(n);
			} else if (!visited[n] && !purpleCells[n].classList.contains('active')) visited[n] = true;
		  }
		}

		const boldCount = cluster.reduce(
		  (acc, idx) => acc + (purpleCells[idx].classList.contains('bold-cell') ? 1 : 0),
		  0
		);

		let clusterScore = 0;
		if (isWorld2Purple) {
		  // World 2 request:
		  // - Outer ring connections: 20 points per new connection (only the outer ring)
		  // - Inner bold connections: 8 points per new connection (starting at 8)
		  const perOuterConn = Number(purpleConfig.outerRingBonusPerBold) || 20;
		  const perInnerConn = Number(purpleConfig.innerBoldConnectionPoints) || 8;
		  const outerBoldCount = cluster.reduce((acc, idx) => {
			const cell = purpleCells[idx];
			if (!cell.classList.contains('bold-cell') || !cell.classList.contains('active')) return acc;
			const isOuter = cell.classList.contains('outer-ring-0') || cell.classList.contains('outer-ring-1');
			return acc + (isOuter ? 1 : 0);
		  }, 0);
		  const innerBoldCount = Math.max(0, boldCount - outerBoldCount);
		  if (outerBoldCount >= 2) clusterScore += (outerBoldCount - 1) * perOuterConn;
		  if (innerBoldCount >= 2) clusterScore += (innerBoldCount - 1) * perInnerConn;
		} else {
		  if (boldCount >= 2) clusterScore = (boldCount - 1) * 8;
		}
		const hasClusterScore = clusterScore > 0;

		// Sla cluster info op bij elke bold & actieve cell
		cluster.forEach(idx => {
		  const cell = purpleCells[idx];
		  if (cell.classList.contains('bold-cell') && cell.classList.contains('active')) {
			cell.dataset.clusterScore = String(clusterScore);
			cell.dataset.clusterPending = hasClusterScore ? "true" : "false";
		  }
		});

		connections.push({ indices: cluster, boldCount, score: clusterScore });
	  }

	  purple = connections.reduce((s, c) => s + c.score, 0);
	  window.purpleConnections = connections;
	}
	
	const waarden = [yellow, green, purple, blue, red];
	// Additional scoring: any active end-cell outside the green grid grants 8 points to its zone's color
	try {
		const extraEndCells = Array.from(document.querySelectorAll('.cell.end-cell.active'));
		extraEndCells.forEach(c => {
			// skip green because green scoring already handles variable points
			if (c.closest && c.closest('#green-grid')) return;
			let zone = c.closest && c.closest('.zone') ? c.closest('.zone') : null;
			let colorKey = zone && zone.dataset ? String(zone.dataset.color || '').toLowerCase() : '';
			if (!colorKey) {
				const g = c.closest && c.closest('.grid') ? c.closest('.grid') : null;
				if (g && g.id) {
					if (g.id.indexOf('yellow') !== -1) colorKey = 'geel';
					else if (g.id.indexOf('purple') !== -1 || g.id.indexOf('paars') !== -1) colorKey = 'paars';
					else if (g.id.indexOf('blue') !== -1) colorKey = 'blauw';
					else if (g.id.indexOf('red') !== -1) colorKey = 'rood';
				}
			}
			if (colorKey === 'geel' || colorKey === 'yellow') yellow += 8;
			else if (colorKey === 'paars' || colorKey === 'purple') purple += 8;
			else if (colorKey === 'blauw' || colorKey === 'blue') blue += 8;
			else if (colorKey === 'rood' || colorKey === 'red') red += 8;
		});
	} catch (e) {}
	const baseBonus = Math.min(...waarden);
	const totalBonusScore = baseBonus + Math.max(0, blackHoleBonus || 0);
	bonus = totalBonusScore;
	trackBonusCoinRewards(totalBonusScore);

	
    // update DOM
	const bonusEl = document.getElementById('bonus-score');
	if (bonusEl) {
	  bonusEl.textContent = totalBonusScore;
	  bonusEl.setAttribute('data-blackhole-extra', String(Math.max(0, blackHoleBonus || 0)));
	}
	document.getElementById('yellow-score').textContent = yellow;
	document.getElementById('green-score').textContent = green;
	document.getElementById('purple-score').textContent = purple;
	document.getElementById('blue-score').textContent = blue;
	document.getElementById('red-score').textContent = red;
	
	// element ophalen
	const totalScoreEl = document.getElementById('total-score');

	// bereken nieuwe total
	const newScore = (yellow + green + purple + blue + red + totalBonusScore);
	const trapPenalty = getTotalTrapPenalty();
	const displayScore = newScore - trapPenalty;

	// huidige getoonde waarde (als number, fallback 0)
	const currentScore = Number(totalScoreEl.textContent) || 0;

	if (currentScore !== displayScore) {
	  // update waarde in DOM
	  totalScoreEl.textContent = displayScore;

	  // Check for High Score
	  if (typeof updateHighScore === 'function') {
		updateHighScore(displayScore);
	  }

	  // ---- restart animatie op een nette manier ----
	  // 1) verwijder class als die er is
	  totalScoreEl.classList.remove('flash');

	  // 2) force reflow om de class-add echt te "resetten"
	  void totalScoreEl.offsetWidth;

	  // 3) voeg class toe zodat animatie opnieuw start
	  totalScoreEl.classList.add('flash');

	  // 4) verwijder class wanneer de animatie klaar is.
	  // Token voorkomt dat een eerder 'animationend' een nieuwere flash stopt.
	  const token = ++totalScoreFlashToken;
	  const onEnd = () => {
		if (token !== totalScoreFlashToken) return;
		totalScoreEl.classList.remove('flash');
		totalScoreEl.removeEventListener('animationend', onEnd);
	  };
	  totalScoreEl.addEventListener('animationend', onEnd);
	}

	const scoreSnapshot = {
	  yellow,
	  red,
	  green,
	  purple,
	  blue,
	  bonus: totalBonusScore,
	  blackHoleBonus,
	  baseBonus,
	  bonusesCollected: totalBonusesCollected,
	  total: displayScore,
	  trapPenalty,
	  baseTotal: newScore
	};
	latestScoreSnapshot = scoreSnapshot;
	updateObjectives(scoreSnapshot);
	highlightAchievedObjectiveScores(scoreSnapshot);
  }
	
	

	  // ---------- Blue score (per bold-row with >=1 active cell) ----------
	// FIX: Use dataset.y for proper visual row detection instead of index-based calculation
	function calculateBlueScore(gridId='blue-grid', cols=null, boldInterval=4, pointsPerBold=8) {
		try { console.debug('calculateBlueScore:called', { gridId, time: Date.now() }); } catch(e) {}
		const container = document.getElementById(gridId);
		if (!container) {
			try { console.debug('calculateBlueScore:no-container', { gridId }); } catch(e) {}
			return 0;
		}
		const cells = Array.from(container.querySelectorAll('.cell:not(.void-cell)'));
		if (cells.length === 0) return 0;

		// Determine number of columns used by the grid.
		// Prefer explicit `cols` param or `data-cols`, otherwise infer from data-x values
		// or fallback to a square-root heuristic.
		let deducedCols = 0;
		if (cols && Number.isFinite(Number(cols))) {
			deducedCols = Number(cols);
		} else if (container && container.dataset && container.dataset.cols) {
			deducedCols = Number(container.dataset.cols) || 0;
		}
		if (!deducedCols) {
			const xs = new Set();
			cells.forEach(c => {
				const vx = Number(c.dataset.x);
				if (Number.isFinite(vx)) xs.add(vx);
			});
			deducedCols = xs.size || Math.max(1, Math.round(Math.sqrt(cells.length)));
		}

		const scoredKey = `${gridId}-scoredRows`;
		let scoredRows = window[scoredKey];
		if (scoredRows instanceof Set) {
			const migrated = new Map();
			scoredRows.forEach(rowIdx => migrated.set(rowIdx, pointsPerBold));
			scoredRows = migrated;
		}
		if (!(scoredRows instanceof Map)) {
			scoredRows = new Map();
		}
		window[scoredKey] = scoredRows;

		// Build a map of visual rows (using dataset.y) to their bold cells
		const rowToBoldCells = new Map();
		const rowToActiveBoldCells = new Map();
		
		cells.forEach(cell => {
			if (!cell.classList.contains('bold-cell')) return;
			const visualRow = Number(cell.dataset.y);
			if (!Number.isFinite(visualRow)) return;
			
			if (!rowToBoldCells.has(visualRow)) {
				rowToBoldCells.set(visualRow, []);
				rowToActiveBoldCells.set(visualRow, []);
			}
			rowToBoldCells.get(visualRow).push(cell);
			if (cell.classList.contains('active')) {
				rowToActiveBoldCells.get(visualRow).push(cell);
			}
		});

		// Debug: report counts to help diagnose missing blue scoring
		try {
			console.debug('calculateBlueScore:start', {
				gridId,
				totalCells: cells.length,
				deducedCols,
				boldCells: Array.from(rowToBoldCells.entries()).reduce((sum, [, arr]) => sum + arr.length, 0),
				activeBoldCells: Array.from(rowToActiveBoldCells.entries()).reduce((sum, [, arr]) => sum + arr.length, 0)
			});
		} catch (e) {}
		
		// Get all unique visual rows sorted
		const allVisualRows = Array.from(rowToBoldCells.keys()).sort((a, b) => a - b);
		const rows = allVisualRows.length > 0 ? Math.max(...allVisualRows) + 1 : 0;

		// For the blue grid in normal levels, only the bottom-most bold row should
		// be eligible for placement/scoring. If this board was loaded from the
		// external editor (custom level metadata present) allow all bold rows.
		const isBlueGrid = String(gridId || '').toLowerCase().indexOf('blue') !== -1;
		// Treat a board as "editor-applied" only when explicitly marked by
		// the editor flow (window._locusEditorApplied) or the zone itself.
		// Do NOT assume a board is custom just because some global metadata
		// exists; that caused all bold rows to be treated as start anchors.
		const isCustomBoard = !!(window && window._locusEditorApplied);
		let visualRowsToProcess = allVisualRows;
		if (isBlueGrid && !isCustomBoard && allVisualRows.length > 0) {
			const bottom = Math.max(...allVisualRows);
			visualRowsToProcess = [bottom];
		}

		const targetKey = `${gridId}-scoredTargets`;
		let rowTargets = window[targetKey];
		if (!(rowTargets instanceof Map)) {
			rowTargets = new Map();
			window[targetKey] = rowTargets;
		}

		const rowPlacementKey = `${gridId}-rowPlacements`;
		let rowPlacements = window[rowPlacementKey];
		if (!(rowPlacements instanceof Map)) {
			rowPlacements = new Map();
			window[rowPlacementKey] = rowPlacements;
		}

		const showChangePopup = (cell, diff) => {
			if (!cell || diff === 0) return;
			const rect = cell.getBoundingClientRect();
			const scrollX = window.scrollX || window.pageXOffset;
			const scrollY = window.scrollY || window.pageYOffset;
			const amountText = diff > 0 ? `+${diff}` : `-${Math.abs(diff)}`;
			showScoreAnimation(
				rect.left + rect.width / 2 + scrollX,
				rect.top + rect.height / 2 + scrollY,
				amountText,
				"blue"
			);
		};

		const scoredRowIndices = [];
		let positivePopupShown = false;
		const currentPlacementId = window.currentPlacementId || '';

		// Track welke placements al punten hebben toegekend voor welke rijen
		const placementScoringKey = `${gridId}-placementScorings`;
		let placementScorings = window[placementScoringKey];
		if (!(placementScorings instanceof Map)) {
			placementScorings = new Map();
			window[placementScoringKey] = placementScorings;
		}

		// Iterate over the visual rows we've chosen to process
		for (const r of visualRowsToProcess) {
			const boldCells = rowToBoldCells.get(r) || [];
			const activeBoldCells = rowToActiveBoldCells.get(r) || [];

			const previousPoints = scoredRows.get(r) || 0;
			const wasScored = scoredRows.has(r);
			const previousPlacement = rowPlacements.get(r) || '';

			if (boldCells.length === 0) {
				const previousTarget = rowTargets.get(r) || null;
				if (previousTarget && previousPoints > 0) {
					showChangePopup(previousTarget, -previousPoints);
				}
				rowTargets.delete(r);
				rowPlacements.delete(r);
				scoredRows.delete(r);
				placementScorings.delete(r);
				continue;
			}

			const activeCount = activeBoldCells.length;
			if (activeCount === 0) {
				const previousTarget = rowTargets.get(r) || boldCells[0] || null;
				if (previousTarget && previousPoints > 0) {
					showChangePopup(previousTarget, -previousPoints);
				}
				rowTargets.delete(r);
				rowPlacements.delete(r);
				scoredRows.delete(r);
				placementScorings.delete(r);
				continue;
			}

			let targetBoldCell = null;
			const storedTarget = rowTargets.get(r);
			if (storedTarget && storedTarget.classList.contains('active')) {
				targetBoldCell = storedTarget;
			} else {
				let bestSequence = Number.POSITIVE_INFINITY;
				activeBoldCells.forEach(cell => {
					const sequenceValue = Number(cell.dataset.activationSequence);
					if (Number.isFinite(sequenceValue) && sequenceValue < bestSequence) {
						bestSequence = sequenceValue;
						targetBoldCell = cell;
					}
				});
				if (!targetBoldCell && activeBoldCells.length > 0) {
					targetBoldCell = activeBoldCells[0];
				}
			}
			if (!targetBoldCell) {
				rowTargets.delete(r);
				rowPlacements.delete(r);
				scoredRows.delete(r);
				placementScorings.delete(r);
				continue;
			}

		rowTargets.set(r, targetBoldCell);
		
		// Verzamel ALLE placementIds van alle actieve bold-cells in deze rij
		const placementIds = new Set();
		activeBoldCells.forEach(cell => {
			const pid = cell.dataset.placementId;
			if (pid) placementIds.add(pid);
		});
		
		// Check of deze placement al heeft gescoord voor deze rij
		const previousScoredPlacement = placementScorings.get(r) || '';
		const currentPlacementId = Array.from(placementIds)[0] || ''; // Neem eerste placementId
		const hasPlacementScored = currentPlacementId && previousScoredPlacement === currentPlacementId;
		
		// Een rij is "nieuw gescoord" alleen als:
		// 1. De rij nog nooit eerder punten had (wasScored = false)
		// 2. EN deze placement heeft nog NIET gescoord voor deze rij
		const isNewScoring = !wasScored && currentPlacementId && !hasPlacementScored;
		
		if (isNewScoring) {
			// Mark placement als scored voor deze rij METEEN
			placementScorings.set(r, currentPlacementId);
			scoredRows.set(r, 0);
			scoredRowIndices.push(r);
		}
		
		if (currentPlacementId) {
			rowPlacements.set(r, currentPlacementId);
		}
	}		scoredRowIndices.sort((a, b) => a - b);
		
		const allScoredRows = Array.from(scoredRows.keys()).sort((a, b) => a - b);
		let runningTotal = 0;
		
		allScoredRows.forEach((r, idx) => {
			const basePoints = idx === 0 ? 6 : 8 + (idx - 1) * 2;
			const previousPoints = scoredRows.get(r) || 0;
			const diff = basePoints - previousPoints;
			scoredRows.set(r, basePoints);
			runningTotal += basePoints;
			
			if (scoredRowIndices.includes(r)) {
				const target = rowTargets.get(r);
				if (target && !positivePopupShown) {
					showChangePopup(target, basePoints);
					positivePopupShown = true;
				}
			} else if (diff !== 0) {
				const target = rowTargets.get(r);
				if (target) {
					showChangePopup(target, diff);
				}
			}
		});

		const rowsToRemove = [];
		scoredRows.forEach((pts, r) => {
			if (!allScoredRows.includes(r)) {
				const boldCells = [];
				const activeBoldCells = [];
				for (let c = 0; c < deducedCols; c++) {
					const idx = r * deducedCols + c;
					const cell = cells[idx];
					if (!cell || cell.classList.contains('void-cell')) continue;
					if (cell.classList.contains('bold-cell')) {
						boldCells.push(cell);
						if (cell.classList.contains('active')) {
							activeBoldCells.push(cell);
						}
					}
				}
				if (activeBoldCells.length === 0) {
					const previousTarget = rowTargets.get(r) || boldCells[0] || null;
					if (previousTarget && pts > 0) {
						showChangePopup(previousTarget, -pts);
					}
					rowsToRemove.push(r);
				}
			}
		});
		rowsToRemove.forEach(r => {
			scoredRows.delete(r);
			rowTargets.delete(r);
			rowPlacements.delete(r);
		});

		return runningTotal;
	}
	
	// showScoreAnimation: positioneert tov viewport (fixed) zodat getBoundingClientRect() direct werkt
	function showScoreAnimation(x, y, text = "+1", color = "black") {
	  const el = document.createElement("div");
	  el.className = "score-popup";
	  el.style.left = `${x}px`;
	  el.style.top  = `${y}px`;
	  el.textContent = text;
	  document.body.appendChild(el);
	  setTimeout(() => el.remove(), 1000);
	}
	
	// Sparkle effect
	function sparkleEffect(x, y, count = 8) {
	  for (let i = 0; i < count; i++) {
		const s = document.createElement("div");
		s.className = "sparkle";
		const angle = Math.random() * 2 * Math.PI;
		const distance = 40 + Math.random() * 20;
		s.style.left = `${x}px`;
		s.style.top = `${y}px`;
		s.style.setProperty("--dx", `${Math.cos(angle) * distance}px`);
		s.style.setProperty("--dy", `${Math.sin(angle) * distance}px`);
		document.body.appendChild(s);
		setTimeout(() => s.remove(), 800);
	  }
	}
	
	
	function highlightEdgeCells(gridOrId) {
	const grid = typeof gridOrId === 'string' ? document.getElementById(gridOrId) : gridOrId;
	const gridLabel = typeof gridOrId === 'string' ? gridOrId : (gridOrId && gridOrId.id) || '(anonymous zone)';
	console.log("highlightEdgeCells called with:", gridLabel);
	    console.log("grid found?", !!grid);

	  if (!grid) return;
	  console.log('test2');

	  const cells = Array.from(grid.querySelectorAll('.cell'));
	  if (cells.length === 0) return;

	  // Haal gridafmetingen op uit dataset of bepaal automatisch
	  const rows = parseInt(grid.dataset.rows || '12', 10);
	  const cols = parseInt(grid.dataset.cols || '12', 10);

	  // Map opbouwen van "r,c" â†’ element
	  const map = new Map();
	  for (const cell of cells) {
		const r = parseInt(cell.dataset.r ?? "-1", 10);
		const c = parseInt(cell.dataset.c ?? "-1", 10);
		if (r >= 0 && c >= 0) map.set(`${r},${c}`, cell);
	  }

	  // Reset edge-styling
	  cells.forEach(c => c.classList.remove('edge-cell'));

	  const dirs = [
		{dr: -1, dc: 0},
		{dr: 1,  dc: 0},
		{dr: 0,  dc: -1},
		{dr: 0,  dc: 1},
	  ];

	  let edgeCount = 0;

	  for (const [key, cell] of map.entries()) {
		if (!cell.classList.contains('active')) continue;

		const [rStr, cStr] = key.split(',');
		const r = parseInt(rStr, 10);
		const c = parseInt(cStr, 10);

		let isEdge = false;

		for (const d of dirs) {
		  const nr = r + d.dr, nc = c + d.dc;
		  const neighbor = map.get(`${nr},${nc}`);
		  if (!neighbor || !neighbor.classList.contains('active')) {
			isEdge = true;
			break;
		  }
		}

		if (isEdge) {
		  cell.classList.add('edge-cell');
		  edgeCount++;
		}
	  }

	  // Debug info in console
	  console.log(`[${gridLabel}] edge-cells found:`, edgeCount);

		  const zoomZone = grid.closest('.zone.zoom-focus');
		  if (zoomZone) schedulePlaceholderSync(zoomZone);
	}

	let lastTap = 0;

	const board = document.querySelector('.board');

	board.addEventListener('touchend', function(e) {
	  const currentTime = new Date().getTime();
	  const tapLength = currentTime - lastTap;
	  if (tapLength < 300 && tapLength > 0) {
		e.preventDefault(); // voorkomt dubbel-tap zoom
	  }
	  lastTap = currentTime;
	});


  // ---------- Undo / Clear ----------
  function undo(){
	const lastPlacement = cardPlacementHistory.length ? cardPlacementHistory[cardPlacementHistory.length - 1] : null;
	const lastToggle = historyStack.length ? historyStack[historyStack.length - 1] : null;
	const placementSeq = lastPlacement?.sequence ?? -Infinity;
	const toggleSeq = lastToggle?.sequence ?? -Infinity;
	if (placementSeq === -Infinity && toggleSeq === -Infinity) return;

	if (placementSeq >= toggleSeq) {
	  const placement = cardPlacementHistory.pop();
	  if (!placement) return;
	  const { cells = [], coinSnapshotBefore = [], handIndex = 0, cardState, cardRef, bonuses = [], isBonusPlacement = false, bonusKey = null, bonusSpent = false } = placement;
	  cells.forEach(cell => {
		if (!cell) return;
		cell.classList.remove('active', 'preview-allowed', 'preview-denied', 'edge-cell');
		cell.style.removeProperty('background');
		delete cell.dataset.clusterScore;
		delete cell.dataset.clusterPending;
		syncPlaceholderForCell(cell);
	  });
	  restoreCoinState(coinSnapshotBefore);
	  if (Array.isArray(bonuses) && bonuses.length) {
		bonuses.forEach(revokeBonusClaim);
	  }
	  updateScore();
	  if (isBonusPlacement) {
		if (bonusSpent && bonusKey) restoreBonusCharge(bonusKey);
		selectedCardId = null;
		selectedCardElement = null;
		selectedShape = null;
		selectedColor = null;
		if (rotateButton) rotateButton.disabled = true;
		updateDrawButtonState();
		recomputeTurnCardFlags();
		applyTurnCardLocks();
		return;
	  }
	  const discardIdx = cardState ? discardPile.findIndex(card => card.id === cardState.id) : -1;
	  let restoredCard = null;
	  if (discardIdx !== -1) {
		restoredCard = discardPile.splice(discardIdx, 1)[0];
	  } else if (cardRef) {
		restoredCard = cardRef;
	  }
	  if (!restoredCard && cardState) {
		restoredCard = {
		  id: cardState.id,
		  blueprintId: cardState.blueprintId,
		  shapeName: cardState.shapeName,
		  matrix: cloneShape(cardState.matrix),
		  category: cardState.category,
		  color: cloneColor(cardState.color)
		};
	  } else if (restoredCard && cardState) {
		restoredCard.matrix = cloneShape(cardState.matrix);
		restoredCard.shapeName = cardState.shapeName;
		restoredCard.category = cardState.category;
		restoredCard.color = cloneColor(cardState.color);
	  }
	  if (restoredCard) {
		const insertIndex = Math.max(0, Math.min(handIndex, currentHand.length));
		currentHand.splice(insertIndex, 0, restoredCard);
	  }
	  cardsPlayedThisTurn = Math.max(0, cardsPlayedThisTurn - 1);
	  selectedCardId = null;
	  selectedCardElement = null;
	  selectedShape = null;
	  selectedColor = null;
	  if (rotateButton) rotateButton.disabled = true;
	  renderCurrentHand();
	  updateDrawButtonState();
	  recomputeTurnCardFlags();
	  applyTurnCardLocks();
	  return;
	}

	const last = historyStack.pop();
	if(!last) return;
	if(last.wasActive) last.cell.classList.add('active'); else last.cell.classList.remove('active');
	ensureTrapState(last.cell, last.cell.dataset.zoneId || last.cell.closest('.grid')?.id || '', { silent: true });
	if(last.cell.classList.contains('gold-cell')){
	  if(last.cell.classList.contains('active')) addCoin(); else removeCoin();
	}
	if (Array.isArray(last.bonusClaims) && last.bonusClaims.length) {
		last.bonusClaims.forEach(revokeBonusClaim);
	}
	updateScore(last.cell);
	syncPlaceholderForCell(last.cell);
	// Recompute per-turn flags after toggling a cell state which may have affected bonuses
	recomputeTurnCardFlags();
	applyTurnCardLocks();
  }
	function clearBoard(){
	  if (!debugMode) return;
	  document.querySelectorAll('.cell').forEach(c=>c.classList.remove('active'));
	  resetCoins();
	  addCoin();
	  historyStack.length = 0;
	  resetScoreState();
	  updateScore();
	if (activeZoomZone) schedulePlaceholderSync(activeZoomZone);
	}
	
  
  // bewaar originele inline cursor instellingen zodat we ze kunnen herstellen
	let _origCursorHtml = null;
	let _origCursorBody = null;

	// helper: start dragging visuals (hide cursor globally)
	function startGlobalDragVisuals() {
	  document.body.classList.add('dragging');

	  // Sla inline stijl op en zet inline cursor: none !important (overruled bijna alles)
	  const html = document.documentElement;
	  const body = document.body;

	  // bewaar oude inline waarde
	  _origCursorHtml = html.style.getPropertyValue('cursor') || null;
	  _origCursorBody = body.style.getPropertyValue('cursor') || null;

	  // zet inline style met priority 'important'
	  html.style.setProperty('cursor', 'none', 'important');
	  body.style.setProperty('cursor', 'none', 'important');
	}

	// helper: stop dragging visuals (restore cursor)
	function stopGlobalDragVisuals() {
	  document.body.classList.remove('dragging');

	  const html = document.documentElement;
	  const body = document.body;

	  if (_origCursorHtml !== null) html.style.setProperty('cursor', _origCursorHtml);
	  else html.style.removeProperty('cursor');

	  if (_origCursorBody !== null) body.style.setProperty('cursor', _origCursorBody);
	  else body.style.removeProperty('cursor');

	  _origCursorHtml = _origCursorBody = null;
	}
  
  
	// ========================
	// DRAG & DROP LOGICA (verfijnd)
	// ========================

	function makeDraggable(shape, color) {
	  const block = document.createElement('div');
	  block.classList.add('draggable');
	  block.style.position = 'fixed';
	  block.style.left = '0px';
      block.style.top = '0px';
	  block.style.zIndex = 1000;


	
	  const allowedZones =
		color.name === 'rood'
		  ? ['red-grid1', 'red-grid2', 'red-grid3', 'red-grid4']
		  : [color.name];
	  block.dataset.allowedZones = JSON.stringify(allowedZones);

	  let currentShape = JSON.parse(JSON.stringify(shape));
	  block._shape = currentShape;
	  
	  
	  renderBlock(block, currentShape, color);
	  document.body.appendChild(block);

	  // ================
	  // START DRAG
	  // ================
	  block.addEventListener('pointerdown', ev => {
        ev.preventDefault();
		// If the block has been rotated/mirrored via buttons, use the updated shape.
		currentShape = block._shape || currentShape;
		beginPointerDrag({ clientX: ev.clientX, clientY: ev.clientY, pointerId: ev.pointerId });

        draggedBlock = block;
        draggedColor = color;
		draggedShape = currentShape;
		
		// Offsets based on the current shape and actual board cell size.
		({ offsetX, offsetY } = computeShapeCenterOffsets(currentShape));

		// Voor touch devices: voeg extra upward offset toe zodat blok boven vinger verschijnt
		const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
		const touchOffsetY = isTouchDevice ? 60 : 0; // 60px boven vinger

		// Start drag direct: plaats blok op cursor positie met offset
		const overlay = document.getElementById('drag-overlay');
		if (overlay) {
			overlay.appendChild(block);
			overlay.style.display = 'block';
		}
		startGlobalDragVisuals();

		// Positioneer blok direct op de pointer positie
		block.style.left = (ev.clientX - offsetX) + 'px';
		block.style.top = (ev.clientY - offsetY - touchOffsetY) + 'px';

        block.setPointerCapture(ev.pointerId);
        block.style.transition = 'transform 0.1s ease';
        block.style.opacity = '0.3';
	  });

	  // ROTATIE VIA SCROLL
	  block.addEventListener('wheel', ev => {
		if (draggedBlock !== block) return;
		ev.preventDefault();
		currentShape = rotateShape(currentShape);
		block._shape = currentShape;
		draggedShape = currentShape;
		renderBlock(draggedBlock, currentShape, draggedColor);
		({ offsetX, offsetY } = computeShapeCenterOffsets(currentShape));
	  });
	  
  return block;
}

// ROTATIE VIA R en SPIEGEL VIA T
/*
	EN:
	- WHY: Keyboard shortcuts while a shape exists (dragging OR selected card).
	- STATE: reads/writes `draggedBlock`, `draggedShape`, `selectedShape`, `selectedColor`, `offsetX/offsetY`.
	- DUPLICATE: Rotation/mirror also exists via buttons (floating preview buttons) and mouse wheel rotate.
	- NOTE: Offsets are based on measured board cell size + `--board-grid-gap` for consistent scaling.
	- Escape: cancels current drag OR cancels bonus placement.
*/
document.addEventListener('keydown', ev => {
  // Check of we een shape hebben (draggedBlock of selectedShape)
  const hasShape = draggedBlock || (selectedShape && selectedColor);
  if (!hasShape) return;
  
  if (ev.key === 'Escape' && draggedBlock) {
	ev.preventDefault();
	if (activeBonusPlacement) {
		cancelActiveBonusPlacement();
	} else {
		cleanupDragState({ clearBonus: false });
	}
	return;
  }
  
	// Rotatie met 'r'
	if (ev.key.toLowerCase() === 'r') {
		ev.preventDefault();
		if (draggedBlock) {
			draggedShape = rotateShape(draggedShape);
			draggedBlock._shape = draggedShape;
			renderBlock(draggedBlock, draggedShape, draggedColor);
			({ offsetX, offsetY } = computeShapeCenterOffsets(draggedShape));
		} else if (selectedShape) {
			rotateSelectedCard();
		}
	}  // Spiegel met 't'
  if (ev.key.toLowerCase() === 't') {
	ev.preventDefault();
	if (draggedBlock) {
		draggedShape = mirrorShape(draggedShape);
		draggedBlock._shape = draggedShape;
		renderBlock(draggedBlock, draggedShape, draggedColor);
			({ offsetX, offsetY } = computeShapeCenterOffsets(draggedShape));
	} else if (selectedShape) {
		mirrorSelectedCard();
	}
  }
});

// =============
// SLEPEN (drag)
// =============
/*
	EN:
	- WHY: This is the core â€œdrag the placed shape over the boardâ€ loop.
	- STATE: moves `draggedBlock` into `#drag-overlay` so it renders above everything.
	- COORDINATES: Uses `elementFromPoint()` per filled cell in the shape to find underlying grid cells.
	  This is more robust than only using the cursor point, but it is heavier.
	- OVERRIDE: Preview rendering is currently disabled (showPreview/clearPreview calls are commented out).
	- FIX NOTE: `showZoomLens(...)` uses `cursorX`/`cursorY` from the pointer event for correct positioning.
*/

document.addEventListener('pointermove', ev => {
	if (!draggedBlock || !isPointerDragging) return;
	if (dragPointerId !== null && ev.pointerId !== dragPointerId) return;

	if (!dragHasMoved) {
		const isTouchDevice = ('ontouchstart' in window || navigator.maxTouchPoints > 0);
		const moveThreshold = isTouchDevice ? 10 : 5;
		const dx = Math.abs((Number(ev.clientX) || 0) - dragStartClientX);
		const dy = Math.abs((Number(ev.clientY) || 0) - dragStartClientY);
		if ((dx + dy) >= moveThreshold) {
			dragHasMoved = true;
		}
	}

	const overlay = document.getElementById('drag-overlay');		document.body.classList.add('dragging'); // optioneel, voor extra styling
		overlay.style.display = 'block';

		// Voeg draggedBlock als kind van overlay, zodat hij altijd boven alles zweeft
		overlay.appendChild(draggedBlock);

		// Verberg echte cursor
		document.body.style.cursor = 'none';
		document.documentElement.style.cursor = 'none';

	// Toon control buttons in mobiel zonder touch tijdens drag
	const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
	if (window.innerWidth <= MOBILE_BREAKPOINT && !isTouchDevice) {
		addCardControlButtons();
	}

	  // PREVIEW MEESLEPEN
	  const cursorX = ev.clientX;
	  const cursorY = ev.clientY;

	  // Voor touch devices: voeg extra upward offset toe
	  const touchOffsetY = isTouchDevice ? 60 : 0;

	  // ===== Verplaats visueel het draggable blok =====
	  draggedBlock.style.left = (cursorX - offsetX) + 'px';
	  draggedBlock.style.top  = (cursorY - offsetY - touchOffsetY) + 'px';

	// ===== Vind zones en cellen onder ALLE gevulde cellen van het blok =====
	const blockRect = draggedBlock.getBoundingClientRect();

	// Derive per-cell spacing from the rendered draggable block so
	// sampling points match what the user actually sees. This keeps
	// visual size unchanged while aligning elementFromPoint checks.
	const shapeHeight = draggedShape.length;
	const shapeWidth = draggedShape[0].length;
	const stepX = shapeWidth > 0 ? (blockRect.width / shapeWidth) : 0;
	const stepY = shapeHeight > 0 ? (blockRect.height / shapeHeight) : 0;

	// Verzamel alle hits van gevulde cellen
	const cellHits = [];
	  
	  // Schakel pointer events uit voor het gedraaide blok
	  const prevPointerEvents = draggedBlock.style.pointerEvents;
	  draggedBlock.style.pointerEvents = 'none';
	  
	  // Check elke gevulde cel in de shape
	  for (let row = 0; row < shapeHeight; row++) {
		for (let col = 0; col < shapeWidth; col++) {
		  // Optional (value 2) cells should NOT drive hit-testing / anchoring.
		  if (isSolidShapeCell(draggedShape[row][col])) {
			// Bereken de positie van deze cel in het visuele blok
			const cellX = blockRect.left + (col * stepX) + (stepX / 2);
			const cellY = blockRect.top + (row * stepY) + (stepY / 2);
			
			// Vind de grid cel onder dit punt
			const elem = document.elementFromPoint(cellX, cellY);
			const gridCell = elem ? elem.closest('.cell') : null;
			
			if (gridCell && gridCell.dataset.x !== undefined && gridCell.dataset.y !== undefined) {
			  const cellZone = gridCell.closest('.zone');
			  if (cellZone && !cellZone.classList.contains('zone-placeholder')) {
				cellHits.push({
				  gridCell: gridCell,
				  zone: cellZone,
				  shapeRow: row,
				  shapeCol: col,
				  gridX: parseInt(gridCell.dataset.x, 10),
				  gridY: parseInt(gridCell.dataset.y, 10)
				});
			  }
			}
		  }
		}
	  }
	  
	  // Herstel pointer events
	  draggedBlock.style.pointerEvents = prevPointerEvents || '';
	  
	  // Als we geen hits hebben, bail
	  if (cellHits.length === 0) {
		// Preview uitgeschakeld
		// if (lastZone) clearPreview(lastZone);
		lastZone = null;
		lastBaseX = lastBaseY = null;
		return;
	  }
	  
	  // Kies de meest voorkomende zone (of eerste hit)
	  const zoneCounts = {};
	  cellHits.forEach(hit => {
		const zoneId = hit.zone.id;
		zoneCounts[zoneId] = (zoneCounts[zoneId] || 0) + 1;
	  });
	  const bestZoneId = Object.keys(zoneCounts).reduce((a, b) => zoneCounts[a] > zoneCounts[b] ? a : b);
	  let zone = document.getElementById(bestZoneId);
	  
	  // Filter hits naar alleen deze zone
	  const zoneHits = cellHits.filter(hit => hit.zone.id === bestZoneId);
	  if (zoneHits.length === 0) {
		lastZone = null;
		lastBaseX = lastBaseY = null;
		return;
	  }
	  
	  // Bereken de baseX/baseY vanuit de eerste hit (of gemiddelde)
	  const firstHit = zoneHits[0];
	  let hoveredCell = firstHit.gridCell;
	  let baseX = firstHit.gridX - firstHit.shapeCol;
	  let baseY = firstHit.gridY - firstHit.shapeRow;

	const cellZone = hoveredCell.closest('.zone');
	if (cellZone && !cellZone.classList.contains('zone-placeholder')) {
	  zone = cellZone;
	}

	if (!zone) {
	  // Preview uitgeschakeld
	  // if (lastZone) clearPreview(lastZone);
	  lastZone = null;
	  lastBaseX = lastBaseY = null;
	  return;
	}

	if (zone !== lastZone) {
	  // Preview uitgeschakeld
	  // if (lastZone) clearPreview(lastZone);
	  lastZone = zone;
	  lastBaseX = lastBaseY = null;
	}

	// baseX en baseY zijn nu al berekend uit de cell hits
	// shapeWidth en shapeHeight zijn al gedeclareerd boven

	const metrics = getZoneMetrics(zone);
	if (!metrics || metrics.maxX < metrics.minX || metrics.maxY < metrics.minY) {
	  // Preview uitgeschakeld
	  // clearPreview(zone);
	  lastBaseX = lastBaseY = null;
	  return;
	}

	const solidBounds = getSolidShapeBounds(draggedShape);
	const minStartX = metrics.minX - solidBounds.minX;
	const minStartY = metrics.minY - solidBounds.minY;
	let maxStartX = metrics.maxX - solidBounds.maxX;
	let maxStartY = metrics.maxY - solidBounds.maxY;
	if (!Number.isFinite(maxStartX)) maxStartX = metrics.maxX;
	if (!Number.isFinite(maxStartY)) maxStartY = metrics.maxY;
	if (maxStartX < minStartX) maxStartX = minStartX;
	if (maxStartY < minStartY) maxStartY = minStartY;

	// Sla originele baseX/baseY op voordat speciale zone aanpassingen
	const originalBaseX = baseX;
	const originalBaseY = baseY;

	if (zone.id === 'yellow-zone') {
	  const yellowPlacement = getYellowPlacement(zone, baseX, baseY, draggedShape, metrics);
	  baseX = yellowPlacement.baseX;
	  baseY = yellowPlacement.baseY;
	} else if (zone.id === 'blue-zone') {
	  baseY = getStickyBaseY(zone, baseX, baseY, draggedShape);
	}

	// Check of het blok NA de speciale zone aanpassingen nog steeds binnen de grenzen is
	// Zo niet, dan is het niet plaatsbaar (geen forceren binnen grenzen)
	const wouldFitX = baseX >= minStartX && baseX <= maxStartX;
	const wouldFitY = baseY >= minStartY && baseY <= maxStartY;
	
	if (!wouldFitX || !wouldFitY) {
		// Blok valt buiten de grid na speciale zone logica - niet plaatsbaar
		if (draggedBlock) {
			draggedBlock.style.opacity = '0.3';
		}
		lastBaseX = baseX;
		lastBaseY = baseY;
		return;
	}

	  // ===== Toon preview alleen bij verandering =====
	  if (baseX !== lastBaseX || baseY !== lastBaseY) {
		lastBaseX = baseX;
		lastBaseY = baseY;

		const zoneColor =
		  zone.dataset.color ||
		  zone.closest('.zone')?.dataset.color ||
		  (zone.id.startsWith('red-grid') ? 'rood' : null);

		const colorOk =
		  zoneColor === draggedColor.name ||
		  draggedColor.name === 'multikleur' ||
		  (draggedColor.name === 'rood' && zoneColor === 'rood');

		const allowed = colorOk && canPlace(zone, baseX, baseY, draggedShape);
		
		// Update draggedBlock opacity gebaseerd op plaatsbaarheid
		if (draggedBlock) {
			if (allowed) {
				draggedBlock.style.opacity = '1';
			} else {
				draggedBlock.style.opacity = '0.3';
			}
		}
		
		// Preview uitgeschakeld
		// showPreview(zone, baseX, baseY, draggedShape, draggedColor, allowed);
		
		// Zoom-lens disabled (remove the extra in-zoom placement preview panel).
		hideZoomLens();
	  }
	});

	/*
		EN:
		- LEGACY/DUPLICATE: Older alternative drag algorithm kept as a block comment.
		  It uses different logic (zones under cursor rather than per-cell elementFromPoint).
		  Keeping both can confuse future edits; consider deleting once the new approach is stable.
	
	document.addEventListener('pointermove', ev => {
		if (!draggedBlock) return;

		const visualOffsetX = 40; // kleine offset zodat het blok onder de vinger zit
		const visualOffsetY = 20; // kleine offset zodat het blok onder de vinger zit

		// Gebruik clientX/Y in plaats van pageX/Y
		const x = ev.clientX;
		const y = ev.clientY;

		// ===== Verplaats visueel het draggable blok =====
		draggedBlock.style.left = (x - offsetX  - visualOffsetX) + 'px';
		draggedBlock.style.top  = (y - offsetY - visualOffsetY) + 'px';

			
		
		// Detecteer alle zones (inclusief subgrids)
		const zones = [...document.querySelectorAll('.zone')].filter(z => !z.classList.contains('zone-placeholder'));

		// Vind alle zones onder de cursor
		const hoveredZones = zones.filter(z => {
		  const r = z.getBoundingClientRect();
		  return x >= r.left && x <= r.right && y >= r.top && y <= r.bottom;
		});

		// Kies de meest specifieke zone:
		// - Als je boven een subgrid hangt, gebruik die
		// - Anders (bijv. voor blauw/geel) gebruik de gewone zone
		let zone = null;
		if (hoveredZones.length > 0) {
		  // Geef prioriteit aan subgrids binnen de rode zone
		  zone = hoveredZones.find(z => z.id.startsWith('red-grid')) || hoveredZones[0];
		}

		if (!zone) {
			if (lastZone) clearPreview(lastZone);
			lastZone = null;
			lastBaseX = lastBaseY = null;
			return;
		}

		lastZone = zone;
		
		
		  // ===== Bereken correcte positie binnen de zone =====
		  const zRect = zone.getBoundingClientRect();
		  
		  
		  // --- Bepaal aantal kolommen op betrouwbare manier ---
		  // Probeer eerst dataset of style, fallback op computed gridTemplateColumns of een cell
		  let cols = parseInt(zone.dataset.cols || '0', 10);
		  if (!cols) {
			const inline = zone.style.gridTemplateColumns;
			if (inline) {
			  const m = inline.match(/repeat\(\s*(\d+)/i);
			  cols = m ? parseInt(m[1],10) : 0;
			}
		  }
		  // fallback: bereken uit eerste rij van cells (meest robuust)
		  const cells = Array.from(zone.querySelectorAll('.cell'));
		  if (!cols && cells.length) {
			// probeer columns = aantal verschillende data-x waarden
			const xs = new Set(cells.map(c => c.dataset.x).filter(Boolean));
			cols = xs.size || Math.round(Math.sqrt(cells.length)) || 1;
		  }
		  cols = Math.max(1, cols);


		  const sampleCell = zone.querySelector('.cell');
	      const cellSize = sampleCell ? sampleCell.getBoundingClientRect().width : (zRect.width / cols);


	  // ===== Relatieve positie binnen de zone =====
	  const rect = draggedBlock.getBoundingClientRect();
	  const relX = rect.left + rect.width/2 - zRect.left;
	  const relY = rect.top  + rect.height/2 - zRect.top;
	  
	  // ===== Bereken grid positie direct vanaf cursor positie =====
	  // Gebruik de cursor positie zonder offset correctie voor exacte alignment
	  let baseX = Math.floor(relX / cellSize);
	  let baseY = Math.floor(relY / cellSize);
		// Alleen blauw/geel: laat het blok "vallen" naar beneden
		if (zone.id === 'blue-zone' || zone.id === 'yellow-zone') {
			if (zone.id === 'blue-zone' || zone.id === 'yellow-zone') {
				baseY = getStickyBaseY(zone, baseX, baseY, draggedShape);
				// clamp again in case sticky geeft buiten-range
				const rows = Math.max(1, Math.ceil(cells.length / cols));
				const shapeHeightCells = draggedShape.length;
		        baseY = Math.max(0, Math.min(rows - shapeHeightCells, baseY));
			}
		}

		if (baseX !== lastBaseX || baseY !== lastBaseY) {
			lastBaseX = baseX;
			lastBaseY = baseY;
			
			// ===== Toon de preview =====
			// Zorg dat we altijd de juiste kleur pakken
			const zoneColor =
			  zone.dataset.color ||
			  zone.closest('.zone')?.dataset.color ||
			  (zone.id.startsWith('red-grid') ? 'rood' : null);
			const colorOk = zoneColor === draggedColor.name || draggedColor.name === 'multikleur' || (draggedColor.name === 'rood' && zoneColor === 'rood');
			const allowed = colorOk && canPlace(zone, baseX, baseY, draggedShape);
			// Preview uitgeschakeld
			// showPreview(zone, baseX, baseY, draggedShape, draggedColor, allowed);
		}
	});
	
	*/

	// =============
	// LOSLATEN
	// =============
	document.addEventListener('pointerup', ev => {
			// If a pointer is captured (e.g. purchased preview in #gold-zone), ev.target can be misleading.
			// Use the real element under the pointer at release for drop logic.
			const releaseTarget = (typeof ev.clientX === 'number' && typeof ev.clientY === 'number')
				? (document.elementFromPoint(ev.clientX, ev.clientY) || ev.target)
				: ev.target;

		// Negeer als we op een control button klikken
			if (releaseTarget && releaseTarget.classList && releaseTarget.classList.contains('card-control-btn')) {
			return;
		}
		
		// Negeer clicks op gold-zone (buy button, coin display, etc.)
			if (releaseTarget && releaseTarget.closest && releaseTarget.closest('#gold-zone') && !draggedBlock) {
			return;
		}
		
		if (!draggedBlock) return;
		if (dragPointerId !== null && ev.pointerId !== dragPointerId) return;
		const bonusContext = activeBonusPlacement;
		const isMobileLayout = window.innerWidth <= MOBILE_BREAKPOINT;
		const isTouchDevice = ('ontouchstart' in window || navigator.maxTouchPoints > 0);
		// Desktop hover-drag: do not drop on pointerup (click-to-drop handles placement).
		if (desktopHoverDragActive && !isMobileLayout && !isTouchDevice && (!bonusContext || bonusContext.desktopHover)) {
			return;
		}
		// Mobile UX: a short tap should not instantly place a block.
		// Only allow placing on release if the user actually dragged (moved a bit).
		if (isMobileLayout && !dragHasMoved) {
			enterStickyDragPreview();
			return;
		}

		if (lastZone && lastBaseX !== null && lastBaseY !== null) {
			const zoneColor =
			  lastZone.dataset.color ||
			  lastZone.closest('.zone')?.dataset.color ||
			  (lastZone.id.startsWith('red-grid') ? 'rood' : null);
			const colorOk = zoneColor === draggedColor.name || draggedColor.name === 'multikleur' || (draggedColor.name === 'rood' && zoneColor === 'rood');
			const allowed = colorOk && canPlace(lastZone, lastBaseX, lastBaseY, draggedShape);

			clearPreview(lastZone);

			if (allowed) {
				const coinSnapshotBefore = getCoinStateSnapshot();
				const placementResult = placeShape(lastZone, lastBaseX, lastBaseY, draggedShape, draggedColor);
				if (bonusContext) {
					finalizeBonusPlacement(placementResult, coinSnapshotBefore, bonusContext);
					cleanupDragState({ clearBonus: true, updateInventory: false });
					hideFloatingPreview(); // Verberg na succesvolle plaatsing
					removeCardControlButtons(); // Verberg buttons na plaatsing
				} else {
					finalizeCardPlacement(placementResult, coinSnapshotBefore);
					cleanupDragState({ clearBonus: false });
					hideFloatingPreview(); // Verberg na succesvolle plaatsing
					removeCardControlButtons(); // Verberg buttons na plaatsing
				}
				return;
			}
		}

		if (bonusContext) {
			// Check of purchased placement buiten grid of op gold-zone is losgelaten
			if (bonusContext.colorKey === 'purchased') {
				const goldZone = document.getElementById('gold-zone');
				const previewDiv = document.getElementById('purchased-block-preview');
				const clickedOnGoldZone = goldZone && releaseTarget && goldZone.contains(releaseTarget);
				const clickedOnPreview = previewDiv && releaseTarget && previewDiv.contains(releaseTarget);
				
				// Als geklikt op gold-zone/preview, annuleer
				if (clickedOnGoldZone || clickedOnPreview) {
					cancelActiveBonusPlacement({ updateInventory: true });
					return;
				}
				
				// Als we GEEN lastZone hebben (echt buiten grid), annuleer
				if (!lastZone) {
					cancelActiveBonusPlacement({ updateInventory: true });
					return;
				}
				
				// We hebben een zone, probeer te plaatsen op laatste positie
				if (lastZone && lastBaseX !== null && lastBaseY !== null) {
					const zoneColor =
						lastZone.dataset.color ||
						lastZone.closest('.zone')?.dataset.color ||
						(lastZone.id.startsWith('red-grid') ? 'rood' : null);
					const colorOk = zoneColor === draggedColor.name || draggedColor.name === 'multikleur' || (draggedColor.name === 'rood' && zoneColor === 'rood');
					const allowed = colorOk && canPlace(lastZone, lastBaseX, lastBaseY, draggedShape);
					
					if (allowed) {
						const coinSnapshotBefore = getCoinStateSnapshot();
						const placementResult = placeShape(lastZone, lastBaseX, lastBaseY, draggedShape, draggedColor);
						finalizeBonusPlacement(placementResult, coinSnapshotBefore, bonusContext);
						cleanupDragState({ clearBonus: true, updateInventory: false });
						hideFloatingPreview();
						removeCardControlButtons();
						return;
					} else {
						// Plaatsing niet geldig, annuleer en geef munten terug
						cancelActiveBonusPlacement({ updateInventory: true });
						return;
					}
				}
				
				// Geen geldige positie gevonden, annuleer
				cancelActiveBonusPlacement({ updateInventory: true });
				return;
			}
			// Als sticky false is (touch mode) voor ANDERE bonussen, annuleer bij invalide plaatsing
			if (!bonusContext.sticky && bonusContext.colorKey !== 'purchased') {
				cancelActiveBonusPlacement({ updateInventory: true });
				return;
			}
			// Keep the bonus block visible so player can rotate/mirror or reposition after releasing.
			enterStickyDragPreview();
			return;
		}

		// Desktop: on invalid release, the piece disappears.
		if (!isMobileLayout) {
			const overlay = document.getElementById('drag-overlay');
			try { draggedBlock.remove(); } catch {}
			draggedBlock = null;
			draggedShape = null;
			draggedColor = null;
			lastZone = null;
			lastBaseX = lastBaseY = null;
			desktopHoverDragActive = false;
			suppressDesktopDropUntil = 0;
			endPointerDragTracking();
			if (overlay) overlay.style.display = 'none';
			document.body.classList.remove('dragging');
			document.body.style.cursor = '';
			document.documentElement.style.cursor = '';
			stopGlobalDragVisuals();
			removeCardControlButtons();
			return;
		}

		// Mobile: keep the card block on screen on invalid release.
		enterStickyDragPreview();
		// Floating preview blijft zichtbaar - alleen kruisje of succesvolle plaatsing verbergt het
	});

	// Desktop hover-drag: second click drops the piece.
	document.addEventListener('pointerdown', ev => {
		if (!desktopHoverDragActive) return;
		if (activeBonusPlacement && !activeBonusPlacement.desktopHover) return;
		if (ev.button !== 0) return;
		const isMobileLayout = window.innerWidth <= MOBILE_BREAKPOINT;
		const isTouchDevice = ('ontouchstart' in window || navigator.maxTouchPoints > 0);
		if (isMobileLayout || isTouchDevice) return;
		if (Date.now() < suppressDesktopDropUntil) return;

		// If the user clicks the hand/cards area while a sticky block is active, interpret that as
		// â€œlet goâ€ (otherwise it can feel like the block is stuck).
		// Allow clicks on cards to continue so the player can switch cards in one action.
		const clickedCard = ev.target.closest ? ev.target.closest('.card-option') : null;
		if (ev.target.closest && ev.target.closest('#card-choice-zone')) {
			if (clickedCard) {
				cleanupDragState({ clearBonus: false, hidePreview: true });
				return;
			}
			cleanupDragState({ clearBonus: false, hidePreview: true });
			ev.preventDefault();
			ev.stopPropagation();
			return;
		}

		// Ignore clicks on UI areas; drop should happen on the board.
		if (ev.target.closest('button') || ev.target.closest('#controls') || ev.target.closest('#floating-preview')) {
			return;
		}

		ev.preventDefault();
		ev.stopPropagation();

		if (lastZone && lastBaseX !== null && lastBaseY !== null) {
			const zoneColor =
				lastZone.dataset.color ||
				lastZone.closest('.zone')?.dataset.color ||
				(lastZone.id.startsWith('red-grid') ? 'rood' : null);
			const colorOk = zoneColor === draggedColor.name || draggedColor.name === 'multikleur' || (draggedColor.name === 'rood' && zoneColor === 'rood');
			const allowed = colorOk && canPlace(lastZone, lastBaseX, lastBaseY, draggedShape);
			clearPreview(lastZone);
			if (allowed) {
				const coinSnapshotBefore = getCoinStateSnapshot();
				const placementResult = placeShape(lastZone, lastBaseX, lastBaseY, draggedShape, draggedColor);
				if (activeBonusPlacement && activeBonusPlacement.desktopHover) {
					finalizeBonusPlacement(placementResult, coinSnapshotBefore, activeBonusPlacement);
					desktopHoverDragActive = false;
					suppressDesktopDropUntil = 0;
					cleanupDragState({ clearBonus: true, updateInventory: false });
					hideFloatingPreview();
					removeCardControlButtons();
					return;
				}
				finalizeCardPlacement(placementResult, coinSnapshotBefore);
				desktopHoverDragActive = false;
				suppressDesktopDropUntil = 0;
				cleanupDragState({ clearBonus: false });
				hideFloatingPreview();
				return;
			}
		}

		// Invalid drop: on desktop the piece disappears.
		cancelDesktopHoverDragKeepSelection({ showPreview: false });
	}, true);

	function enterStickyDragPreview() {
		if (!draggedBlock) return;
		// Pointer capture / touch can synthesize a click right after release.
		// Prevent that click from toggling card selection and calling cleanup.
		suppressCardSelectUntil = Date.now() + 650;
		endPointerDragTracking();
		lastZone = null;
		lastBaseX = lastBaseY = null;

		const overlay = document.getElementById('drag-overlay');
		if (overlay && overlay.contains(draggedBlock)) {
			document.body.appendChild(draggedBlock);
		}
		if (overlay) overlay.style.display = 'none';

		document.body.classList.remove('dragging');
		document.body.style.cursor = '';
		document.documentElement.style.cursor = '';
		stopGlobalDragVisuals();

		// Ensure the rotate/mirror controls are available.
		if (rotateButton) rotateButton.disabled = false;
		if (mirrorButton) {
			// Only enable mirror now if controls were not intentionally delayed
			if (!activeBonusPlacement || !activeBonusPlacement.delayedControls) {
				mirrorButton.disabled = false;
			}
		}
		addCardControlButtons();
		// If mirror was delayed for this bonus drag, reveal it now and re-position
		try {
			// Only reveal delayed mirror if this was NOT a bonus placement
			if (activeBonusPlacement && activeBonusPlacement.delayedControls && !(activeBonusPlacement && activeBonusPlacement.colorKey)) {
				const mb = document.querySelector('.card-control-mirror');
				if (mb) {
					mb.disabled = false;
					mb.classList.add('visible');
					mb.removeAttribute('data-delayed');
					// Re-position buttons using the centralized positioning logic
					try { addCardControlButtons(); } catch (e) {}
				}
				activeBonusPlacement.delayedControls = false;
			}
		} catch (e) {}
	}

	function findCellInZone(zone, clientX, clientY) {
		if (!zone) return null;
		const cells = zone.querySelectorAll('.cell');
		for (const cell of cells) {
			const rect = cell.getBoundingClientRect();
			if (clientX >= rect.left && clientX <= rect.right && clientY >= rect.top && clientY <= rect.bottom) {
				return cell;
			}
		}
		return null;
	}

	function cleanupDragState({ clearBonus = false, updateInventory = false, hidePreview = false } = {}) {
		const overlay = document.getElementById('drag-overlay');
		endPointerDragTracking();
		desktopHoverDragActive = false;
		suppressDesktopDropUntil = 0;
		if (draggedBlock) {
			draggedBlock.remove();
		}
		draggedBlock = null;
		draggedShape = null;
		draggedColor = null;
		lastZone = null;
		lastBaseX = lastBaseY = null;
		if (overlay) overlay.style.display = 'none';
		document.body.classList.remove('dragging');
		document.body.style.cursor = '';
		document.documentElement.style.cursor = '';
		
		// Verberg control buttons altijd als drag/selection wordt opgeruimd.
		removeCardControlButtons();
		
	// Verwijder kaart selectie
	if (selectedCardElement) {
		selectedCardElement.classList.remove('selected');
		selectedCardElement = null;
	}
	selectedCardId = null;
	selectedShape = null;
	selectedColor = null;
	
	// Reset card locks zodat andere kaarten weer klikbaar zijn
	applyTurnCardLocks();
	
	// Verberg zoom-lens altijd
	hideZoomLens();
	
	// Verberg floating preview alleen als expliciet gevraagd
		if (hidePreview) {
			hideFloatingPreview();
		}
		
		if (clearBonus && activeBonusPlacement) {
			// Geef gekochte plaatsing munten terug bij annuleren
			if (updateInventory && activeBonusPlacement.colorKey === 'purchased') {
				addCoin();
				addCoin();
				clearPurchasedPlacement();
			}
			activeBonusPlacement = null;
			markActiveBonusButton(null);
			if (updateInventory) updateBonusInventoryUI();
		}
		skipNextZoneClick = true;
		setTimeout(() => { skipNextZoneClick = false; }, 80);
		stopGlobalDragVisuals();
		if (!selectedCardElement && !activeBonusPlacement && rotateButton) {
		  rotateButton.disabled = true;
		}
	}

	function cancelActiveBonusPlacement(options = {}) {
		const { updateInventory = true, hidePreview = false } = options;
		if (!activeBonusPlacement && !draggedBlock) return;
		cleanupDragState({ clearBonus: true, updateInventory, hidePreview });
	}
	

	// ========================
	// HELPER FUNCTIES
	// ========================

	function getOptionalCells(shape) {
	  const coords = [];
	  if (!shape || !shape.length) return coords;
	  for (let y = 0; y < shape.length; y++) {
		const row = shape[y];
		for (let x = 0; x < row.length; x++) {
		  if (row[x] === 2) {
			coords.push({ x, y });
		  }
		}
	  }
	  return coords;
	}

	function isOptionalShapeCell(value) {
	  return value === 2;
	}

	function isSolidShapeCell(value) {
	  return value === 1;
	}

	function getSolidShapeBounds(shape) {
	  let minX = Infinity;
	  let maxX = -Infinity;
	  let minY = Infinity;
	  let maxY = -Infinity;
	  if (!Array.isArray(shape) || !shape.length) {
		return { minX: 0, maxX: -1, minY: 0, maxY: -1, width: 0, height: 0 };
	  }
	  for (let y = 0; y < shape.length; y++) {
		const row = shape[y];
		if (!Array.isArray(row)) continue;
		for (let x = 0; x < row.length; x++) {
		  if (!isSolidShapeCell(row[x])) continue;
		  if (x < minX) minX = x;
		  if (x > maxX) maxX = x;
		  if (y < minY) minY = y;
		  if (y > maxY) maxY = y;
		}
	  }
	  if (!Number.isFinite(minX) || !Number.isFinite(minY)) {
		return { minX: 0, maxX: -1, minY: 0, maxY: -1, width: 0, height: 0 };
	  }
	  return {
		minX,
		maxX,
		minY,
		maxY,
		width: (maxX - minX + 1),
		height: (maxY - minY + 1)
	  };
	}

	function hasOptionalCells(shape) {
	  return getOptionalCells(shape).length > 0;
	}

	function trimOptionalCells(shape) {
	  if (!shape || !shape.length) return shape;
	  const optionalCells = getOptionalCells(shape);
	  if (!optionalCells.length) return shape;
	  const trimmed = shape.map(row => row.slice());
	  optionalCells.forEach(({ x, y }) => {
		if (trimmed[y] && typeof trimmed[y][x] === 'number') {
		  trimmed[y][x] = 0;
		}
	  });
	  // Verwijder lege rijen
	  let filtered = trimmed.filter(row => row.some(value => value !== 0));
	  if (!filtered.length) {
		return trimmed;
	  }
	  const colCount = filtered[0].length;
	  const activeCols = [];
	  for (let col = 0; col < colCount; col++) {
		if (filtered.some(row => row[col] !== 0)) {
		  activeCols.push(col);
		}
	  }
	  if (!activeCols.length) {
		return trimmed;
	  }
	  filtered = filtered.map(row => activeCols.map(index => row[index] || 0));
	  return filtered;
	}

	function rotateShape(shape) {
	  const rows = shape.length;
	  const cols = shape[0].length;
	  return Array.from({ length: cols }, (_, x) =>
		Array.from({ length: rows }, (_, y) => shape[rows - 1 - y][x])
	  );
	}

	function mirrorShape(shape) {
	  // Spiegel het blok horizontaal (flip left-right)
	  return shape.map(row => [...row].reverse());
	}

	function cloneShape(shape) {
	  return shape.map(row => row.slice());
	}

	function updateCardPattern(card, shape, color) {
	  if (!card || !shape || !shape.length) return;
	  color = color || {};
	  const cssCellSizeRaw = (card.style && card.style.getPropertyValue('--preview-cell')) || '';
	  const computedCellSizeRaw = !cssCellSizeRaw ? (getComputedStyle(card).getPropertyValue('--preview-cell') || '') : '';
	  const overrideCellSize = parseFloat((cssCellSizeRaw || computedCellSizeRaw || '').trim());
	  const { cellSize: defaultCellSize } = getCardSizing();
	  const cellSize = Number.isFinite(overrideCellSize) && overrideCellSize > 0 ? overrideCellSize : defaultCellSize;
	  card.dataset.shapeCols = String(shape[0].length);
	  card.dataset.shapeRows = String(shape.length);
	  const pattern = card.querySelector('.card-pattern');
	  if (pattern) {
		pattern.innerHTML = '';
		pattern.style.gridTemplateColumns = `repeat(${shape[0].length}, ${cellSize}px)`;
		pattern.style.gridTemplateRows = `repeat(${shape.length}, ${cellSize}px)`;
		// Gap is controlled via CSS (`--preview-gap`) so all previews stay consistent.
		pattern.style.removeProperty('gap');
		shape.forEach(row => {
		  row.forEach(cell => {
			const div = document.createElement('div');
			div.classList.add('card-cell');
			div.style.width = `${cellSize}px`;
			div.style.height = `${cellSize}px`;
			// Border-radius: max 5px, minder rond voor kleine cells
			div.style.borderRadius = `${Math.min(5, cellSize / 5)}px`;
			if (cell) {
			  let background;
			  let shadow;
			  if (color.code === 'rainbow') {
				background = 'linear-gradient(45deg, #f06272, #fff25a, #4ed346, #5d90f0, #a35eff)';
				shadow = '0 0 6px rgba(0,0,0,0.3)';
			  } else {
				// Golden is a card modifier; do not paint blocks gold.
				background = (color.code || '#a0a0a0');
				const isGradient = typeof background === 'string' && background.includes('gradient');
				shadow = isGradient ? '0 0 4px rgba(90,80,160,0.4)' : `0 0 4px ${background}`;
			  }
			  div.style.background = background;
			  div.style.boxShadow = shadow;
			} else {
			  div.style.background = 'transparent';
			  div.style.boxShadow = 'none';
			}
			pattern.appendChild(div);
		  });
		});
	  }
	  const meta = card.querySelector('.card-meta');
	  if (meta) meta.textContent = `${shape.length}Ã—${shape[0].length}`;
	  card.cardShape = shape;
	}

	function getActualCellSize(root = null) {
		// Bereken de werkelijke cel-grootte op basis van een cel in het opgegeven root
		// (of het globale speelveld als geen root gegeven). Dit houdt rekening met
		// board/zone scaling and any DOM lifts performed during mobile zoom.
		try {
			// Mobile behaviour: always prefer the unscaled CSS cell size (the
			// "zoomed-in" visual size) for mobile layouts so previews match the
			// zoomed experience even before the zone is opened.
			if (window && typeof window.innerWidth === 'number' && window.innerWidth <= (typeof MOBILE_BREAKPOINT !== 'undefined' ? MOBILE_BREAKPOINT : 650)) {
				const cssSize = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--cell-size')) || 26;
				return cssSize;
			}

			let sampleCell = null;
			if (root instanceof Element) {
				sampleCell = root.querySelector('.grid .cell:not(.void-cell)');
			} else if (typeof root === 'string') {
				sampleCell = document.querySelector(root + ' .grid .cell:not(.void-cell)');
			} else {
				sampleCell = document.querySelector('#board .grid .cell:not(.void-cell)');
			}

			if (sampleCell) {
				const rect = sampleCell.getBoundingClientRect();
				return Math.min(rect.width, rect.height);
			}
		} catch (e) {
			// ignore and fallback
		}
		const cssSize = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--cell-size')) || 26;
		return cssSize;
	}

	function renderBlock(block, shape, color, useActualCellSize = true) {
	block.innerHTML = '';
	block.style.display = 'grid';
	// Ensure floating/draggable previews remain visible on top when rotated
	try {
		const isFloatingPreview = (block.id === 'floating-preview' || block.id === 'purchased-block-preview' || (block.classList && (block.classList.contains('draggable') || block.classList.contains('bonus-draggable'))));
		if (isFloatingPreview) {
			if (!block.style.position) block.style.position = 'fixed';
			block.style.zIndex = block.style.zIndex || '10000';
			const overlay = document.getElementById('drag-overlay') || document.body;
			if (overlay && !overlay.contains(block)) overlay.appendChild(block);
		}
	} catch (e) {}
	  
	  // Bepaal de cel-grootte: gebruik de werkelijke speelveld cel-grootte als niet ingezoomd
	  const isZoomed = document.body.classList.contains('zoomed-in');
	  let cellSize;
	  let cellSizeStr;
	  
	if (useActualCellSize) {
		// If a zoomed zone is active, measure cell size from that zone so
		// the draggable matches the zoomed-in cells exactly. Otherwise
		// measure from the default board.
		const measuredRoot = (document.body.classList.contains('zoomed-in') && typeof activeZoomZone !== 'undefined' && activeZoomZone) ? activeZoomZone : null;
		cellSize = getActualCellSize(measuredRoot);
		cellSizeStr = `${cellSize}px`;
	} else {
		// Fallback: use CSS variable when explicit actual sizing is not requested.
		cellSize = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--cell-size')) || 26;
		cellSizeStr = 'var(--cell-size)';
	}
	  
	  // Border-radius is altijd size / 4
	  const borderRadius = `${cellSize / 4}px`;
	  
	  block.style.gridTemplateColumns = `repeat(${shape[0].length}, ${cellSizeStr})`;
	  block.style.gridTemplateRows = `repeat(${shape.length}, ${cellSizeStr})`;
	  // Keep spacing consistent with the board grid.
	  block.style.gap = 'var(--board-grid-gap)';
	  block.style.opacity = '0.8';
	  const optionalSet = new Set(getOptionalCells(shape).map(({ x, y }) => `${x},${y}`));
	  
	  shape.forEach((row, rowIdx) => {
		row.forEach((cell, colIdx) => {
			const div = document.createElement('div');
			div.style.width = cellSizeStr;
			div.style.height = cellSizeStr;
			div.style.margin = '0px';
			// Border-radius consistent met speelveld: size / 4
			div.style.borderRadius = borderRadius;
			div.style.boxSizing = 'border-box';
			const key = `${colIdx},${rowIdx}`;
			const isOptional = optionalSet.has(key);
			if (cell && !isOptional) {
			  let background;
			  let shadow;
			  if (color.code === 'rainbow') {
				background = 'linear-gradient(45deg, #f06272, #fff25a, #4ed346, #5d90f0, #a35eff)';
				shadow = '0 0 6px rgba(0,0,0,0.3)';
			  } else {
				// Golden is a card modifier; do not paint blocks gold.
				background = (color.code || '#a0a0a0');
				const isGradient = typeof background === 'string' && background.includes('gradient');
				shadow = isGradient ? '0 0 4px rgba(90,80,160,0.4)' : `0 0 4px ${background}`;
			  }
			  div.style.background = background;
			  div.style.boxShadow = shadow;
			} else if (isOptional) {
			  let background;
			  if (color.code === 'rainbow') {
				background = 'linear-gradient(45deg, #f06272, #fff25a, #4ed346, #5d90f0, #a35eff)';
			  } else {
				background = color.code || '#a0a0a0';
			  }
			  div.style.background = background;
			  div.style.opacity = '0.6';
			  div.style.border = '2px dashed rgba(255,255,255,0.85)';
			  div.style.boxShadow = 'none';
			} else {
			  div.style.visibility = 'hidden';
			}
			block.appendChild(div);
		});
	  });
	}

	function hexToRGBA(hex, alpha = 1) {
	  if (!hex) return `rgba(0,0,0,${alpha})`;
	  let c = hex.replace('#','');
	  if (c.length === 3) c = c.split('').map(ch => ch+ch).join('');
	  const r = parseInt(c.substr(0,2),16);
	  const g = parseInt(c.substr(2,2),16);
	  const b = parseInt(c.substr(4,2),16);
	  return `rgba(${r},${g},${b},${alpha})`;
	}

	function clearPreview(zone) {
	  zone.querySelectorAll('.cell.preview-allowed, .cell.preview-denied').forEach(c=>{
		c.classList.remove('preview-allowed','preview-denied');
		if (!c.classList.contains('active')) c.style.background = '';
	  });
	}

	function getZoneMetrics(zone) {
	  const empty = {
		cols: 0,
		rows: 0,
		minX: 0,
		maxX: -1,
		minY: 0,
		maxY: -1
	  };
	  if (!zone) return empty;
	  const cells = zone.querySelectorAll('.cell');
	  if (!cells.length) return empty;
	  let minX = Infinity;
	  let maxX = -Infinity;
	  let minY = Infinity;
	  let maxY = -Infinity;
	  cells.forEach(cell => {
		if (cell.classList.contains('void-cell') || cell.dataset.disabled === 'true') return;
		const col = Number(cell.dataset.x);
		const row = Number(cell.dataset.y);
		if (!Number.isNaN(col)) {
		  if (col < minX) minX = col;
		  if (col > maxX) maxX = col;
		}
		if (!Number.isNaN(row)) {
		  if (row < minY) minY = row;
		  if (row > maxY) maxY = row;
		}
	  });
	  if (!Number.isFinite(minX) || !Number.isFinite(maxX)) return empty;
	  if (!Number.isFinite(minY) || !Number.isFinite(maxY)) return empty;
	  return {
		cols: maxX - minX + 1,
		rows: maxY - minY + 1,
		minX,
		maxX,
		minY,
		maxY
	  };
	}

	function getZonePriority(zone) {
	  if (!zone || zone.classList.contains('zone-placeholder')) return -Infinity;
	  if (zone.classList.contains('zoom-focus')) return 1000;
	  const style = window.getComputedStyle(zone);
	  const zIndex = parseInt(style.zIndex, 10);
	  return Number.isFinite(zIndex) ? zIndex : 0;
	}


	// Helper om de juiste cell in een zone te pakken
	function getCell(zone, x, y) {
	  if (!zone) return null;
	  const cell = zone.querySelector(`.cell[data-x="${x}"][data-y="${y}"]`);
	  if (!cell) return null;
	  if (cell.classList.contains('void-cell') || cell.dataset.disabled === 'true') return null;
	  return cell;
	}

	function collectPlacementCells(zone, baseX, baseY, shape) {
	  if (!zone || !Array.isArray(shape) || !shape.length) return null;
	  const pending = [];
	  window.lastPlacementFailure = null;
	  
	  // Gebruik gewoon de normale coÃ¶rdinaten-gebaseerde aanpak
	  // Nu werkt dit ook voor root-based grids omdat alle cellen bestaan!
	  for (let y = 0; y < shape.length; y++) {
		for (let x = 0; x < shape[y].length; x++) {
		  const cellVal = shape[y][x];
		  if (!cellVal) continue; // Skip lege posities in de shape
		  const isOptional = isOptionalShapeCell(cellVal);
		  const target = getCell(zone, baseX + x, baseY + y);
		  
		  if (!target) {
			if (isOptional) continue;
			window.lastPlacementFailure = {
			  zoneId: zone?.id || null,
			  reason: 'missing-cell',
			  x: baseX + x,
			  y: baseY + y
			};
			return null;
		  }
		  if (target.classList.contains('active')) {
			if (isOptional) continue;
			window.lastPlacementFailure = {
			  zoneId: zone?.id || null,
			  reason: 'occupied',
			  x: baseX + x,
			  y: baseY + y
			};
			return null;
		  }
		  
		  pending.push(target);
		}
	  }
	  
	  return pending;
	}
	
	// Speciaal voor root-based grids: zoek cellen op fysieke positie op het scherm
	function collectPlacementCellsForRootGrid(zone, baseX, baseY, shape) {
	  console.log('ðŸŒ³ Root grid - searching by SCREEN position');
	  
	  // Vind de eerste gevulde cel in de shape (anchor point)
	  let anchorShapeX = -1, anchorShapeY = -1;
	  for (let y = 0; y < shape.length && anchorShapeY === -1; y++) {
		for (let x = 0; x < shape[y].length; x++) {
		  if (shape[y][x]) {
			anchorShapeX = x;
			anchorShapeY = y;
			break;
		  }
		}
	  }
	  
	  // Probeer de anchor cell te vinden via coÃ¶rdinaten
	  const anchorX = baseX + anchorShapeX;
	  const anchorY = baseY + anchorShapeY;
	  const anchorCell = getCell(zone, anchorX, anchorY);
	  
	  if (!anchorCell || anchorCell.classList.contains('active')) {
		console.log('âŒ Anchor cell not available');
		return null;
	  }
	  
	  console.log('âœ… Anchor cell found, now searching by screen position...');
	  
	  // Get de fysieke positie van de anchor cell
	  const anchorRect = anchorCell.getBoundingClientRect();
	  const cellSize = anchorRect.width;
	  
	  // Get alle beschikbare cellen in deze zone
	  const allCells = Array.from(zone.querySelectorAll('.cell:not(.void-cell)'))
		.filter(c => !c.classList.contains('active') && c.dataset.disabled !== 'true');
	  
	  // Bouw een map: fysieke positie (in grid units) -> cel
	  const positionMap = new Map();
	  for (const cell of allCells) {
		const rect = cell.getBoundingClientRect();
		// Bereken grid positie relatief tot anchor (in hele cellen)
		const gridX = Math.round((rect.left - anchorRect.left) / cellSize);
		const gridY = Math.round((rect.top - anchorRect.top) / cellSize);
		const key = `${gridX},${gridY}`;
		positionMap.set(key, cell);
		
		console.log(`Cell at screen grid position (${gridX}, ${gridY}):`, cell.dataset.x, cell.dataset.y);
	  }
	  
	  // Nu loop door de shape en zoek elke cel op basis van FYSIEKE positie
	  const result = [];
	  for (let shapeY = 0; shapeY < shape.length; shapeY++) {
		for (let shapeX = 0; shapeX < shape[shapeY].length; shapeX++) {
		  if (!shape[shapeY][shapeX]) continue; // Skip lege posities
		  
		  // Bereken relatieve positie t.o.v. anchor
		  const relX = shapeX - anchorShapeX;
		  const relY = shapeY - anchorShapeY;
		  const key = `${relX},${relY}`;
		  
		  console.log(`Looking for shape position (${shapeX},${shapeY}) at relative grid (${relX},${relY})`);
		  
		  const cell = positionMap.get(key);
		  if (!cell) {
			console.log(`âŒ No cell found at relative position (${relX},${relY})`);
			return null;
		  }
		  
		  console.log(`âœ… Found cell at (${relX},${relY}):`, cell.dataset.x, cell.dataset.y);
		  result.push(cell);
		}
	  }
	  
	  console.log(`âœ… All ${result.length} cells found successfully!`);
	  return result;
	}
	
	// Bouw een grafiek van welke cellen fysiek aan elkaar grenzen
	function buildCellAdjacencyGraph(cells) {
	  const graph = new Map();
	  
	  for (const cell of cells) {
		const rect = cell.getBoundingClientRect();
		const centerX = rect.left + rect.width / 2;
		const centerY = rect.top + rect.height / 2;
		const cellSize = rect.width;
		
		const neighbors = [];
		
		for (const other of cells) {
		  if (cell === other) continue;
		  
		  const otherRect = other.getBoundingClientRect();
		  const otherCenterX = otherRect.left + otherRect.width / 2;
		  const otherCenterY = otherRect.top + otherRect.height / 2;
		  
		  const dx = Math.abs(centerX - otherCenterX);
		  const dy = Math.abs(centerY - otherCenterY);
		  
		  // Check of ze horizontaal of verticaal naast elkaar liggen
		  const isHorizontal = dx > cellSize * 0.8 && dx < cellSize * 1.2 && dy < cellSize * 0.3;
		  const isVertical = dy > cellSize * 0.8 && dy < cellSize * 1.2 && dx < cellSize * 0.3;
		  
		  if (isHorizontal || isVertical) {
			// Bepaal richting
			let direction = null;
			if (isHorizontal) {
			  direction = otherCenterX > centerX ? 'right' : 'left';
			} else {
			  direction = otherCenterY > centerY ? 'down' : 'up';
			}
			
			neighbors.push({ cell: other, direction });
		  }
		}
		
		graph.set(cell, neighbors);
	  }
	  
	  return graph;
	}
	
	// Vind cellen die de shape vorm volgen vanaf de anchor
	function findShapeCellsInGraph(anchorCell, shape, anchorShapeX, anchorShapeY, graph, allCells) {
	  const result = [];
	  const cellToShapePos = new Map();
	  
	  // Start met de anchor
	  cellToShapePos.set(anchorCell, { x: anchorShapeX, y: anchorShapeY });
	  result.push(anchorCell);
	  
	  // BFS om andere cellen te vinden
	  const queue = [anchorCell];
	  const visited = new Set([anchorCell]);
	  
	  while (queue.length > 0) {
		const current = queue.shift();
		const currentPos = cellToShapePos.get(current);
		
		const neighbors = graph.get(current) || [];
		
		for (const { cell: neighbor, direction } of neighbors) {
		  if (visited.has(neighbor)) continue;
		  
		  // Bereken waar deze neighbor zou zijn in de shape
		  let neighborShapeX = currentPos.x;
		  let neighborShapeY = currentPos.y;
		  
		  if (direction === 'right') neighborShapeX++;
		  else if (direction === 'left') neighborShapeX--;
		  else if (direction === 'down') neighborShapeY++;
		  else if (direction === 'up') neighborShapeY--;
		  
		  // Check of deze positie in de shape bestaat en gevuld is
		  if (neighborShapeY >= 0 && neighborShapeY < shape.length &&
			  neighborShapeX >= 0 && neighborShapeX < shape[neighborShapeY].length &&
			  shape[neighborShapeY][neighborShapeX]) {
			
			visited.add(neighbor);
			cellToShapePos.set(neighbor, { x: neighborShapeX, y: neighborShapeY });
			result.push(neighbor);
			queue.push(neighbor);
		  }
		}
	  }
	  
	  return result;
	}
	
	// Tel hoeveel cellen gevuld zijn in een shape
	function countFilledCells(shape) {
	  let count = 0;
	  for (let y = 0; y < shape.length; y++) {
		for (let x = 0; x < shape[y].length; x++) {
		  if (shape[y][x]) count++;
		}
	  }
	  return count;
	}
	
	// Check of cellen fysiek aangrenzend zijn volgens de shape structuur
	function areCellsPhysicallyConnected(cells, shape) {
	  if (cells.length <= 1) return true;
	  
	  // Bouw een map van x,y naar cel
	  const cellMap = new Map();
	  for (const cell of cells) {
		const x = parseInt(cell.dataset.x);
		const y = parseInt(cell.dataset.y);
		cellMap.set(`${x},${y}`, cell);
	  }
	  
	  // Start BFS vanaf de eerste cel
	  const visited = new Set();
	  const queue = [cells[0]];
	  visited.add(cells[0]);
	  
	  while (queue.length > 0) {
		const current = queue.shift();
		const cx = parseInt(current.dataset.x);
		const cy = parseInt(current.dataset.y);
		
		// Check alle 4 aangrenzende posities
		const neighbors = [
		  [cx - 1, cy],
		  [cx + 1, cy],
		  [cx, cy - 1],
		  [cx, cy + 1]
		];
		
		for (const [nx, ny] of neighbors) {
		  const key = `${nx},${ny}`;
		  const neighborCell = cellMap.get(key);
		  
		  if (neighborCell && !visited.has(neighborCell)) {
			// Check of deze neighbor ook aangrenzend is volgens de shape
			// (niet alleen in de grid, maar ook in de verwachte vorm)
			if (areCellsVisuallyAdjacent(current, neighborCell)) {
			  visited.add(neighborCell);
			  queue.push(neighborCell);
			}
		  }
		}
	  }
	  
	  return visited.size === cells.length;
	}
	
	// Check of twee cellen visueel aangrenzend zijn (binnen ~1 celgrootte afstand)
	function areCellsVisuallyAdjacent(cell1, cell2) {
	  const rect1 = cell1.getBoundingClientRect();
	  const rect2 = cell2.getBoundingClientRect();
	  
	  const center1X = rect1.left + rect1.width / 2;
	  const center1Y = rect1.top + rect1.height / 2;
	  const center2X = rect2.left + rect2.width / 2;
	  const center2Y = rect2.top + rect2.height / 2;
	  
	  const dx = Math.abs(center1X - center2X);
	  const dy = Math.abs(center1Y - center2Y);
	  
	  const cellSize = rect1.width; // Aanname: vierkante cellen
	  
	  // Cellen zijn aangrenzend als ze horizontaal OF verticaal naast elkaar liggen
	  // Tolerantie van 1.5x celgrootte voor kleine positioneringsverschillen
	  const isHorizontallyAdjacent = dx <= cellSize * 1.5 && dy <= cellSize * 0.5;
	  const isVerticallyAdjacent = dy <= cellSize * 1.5 && dx <= cellSize * 0.5;
	  
	  return isHorizontallyAdjacent || isVerticallyAdjacent;
	}
	
	// Check of alle cellen in een lijst met elkaar verbonden zijn (aangrenzend)
	function areCellsConnected(cells) {
	  if (cells.length <= 1) return true;
	  
	  const visited = new Set();
	  const queue = [cells[0]];
	  visited.add(cells[0]);
	  
	  while (queue.length > 0) {
		const current = queue.shift();
		const cx = parseInt(current.dataset.x);
		const cy = parseInt(current.dataset.y);
		
		// Check alle cellen in de lijst of ze aangrenzend zijn aan current
		for (const cell of cells) {
		  if (visited.has(cell)) continue;
		  
		  const x = parseInt(cell.dataset.x);
		  const y = parseInt(cell.dataset.y);
		  
		  // Check of deze cel aangrenzend is (Manhattan distance = 1)
		  if (Math.abs(x - cx) + Math.abs(y - cy) === 1) {
			visited.add(cell);
			queue.push(cell);
		  }
		}
	  }
	  
	  // Als alle cellen bezocht zijn, zijn ze verbonden
	  return visited.size === cells.length;
	}

	function cellsAreAdjacent(cellA, cellB) {
	  if (!cellA || !cellB) return false;
	  const ax = Number(cellA.dataset.x);
	  const ay = Number(cellA.dataset.y);
	  const bx = Number(cellB.dataset.x);
	  const by = Number(cellB.dataset.y);
	  if (!Number.isFinite(ax) || !Number.isFinite(ay) || !Number.isFinite(bx) || !Number.isFinite(by)) return false;
	  return Math.abs(ax - bx) + Math.abs(ay - by) === 1;
	}

	// ========================
	// CAN PLACE
	// ========================
	function canPlace(zone, baseX, baseY, shape) {
	  const pendingCells = collectPlacementCells(zone, baseX, baseY, shape);
	  return !!(pendingCells && pendingCells.length > 0 && passesPlacementRules(zone, pendingCells));
	}

	function passesPlacementRules(zone, pendingCells) {
	  if (!zone || !pendingCells.length) return false;
	  const zoneId = zone.id || '';
	if (zoneId === 'yellow-zone') return validateYellowPlacement(zone, pendingCells);
	if (zoneId === 'blue-zone') return validateBluePlacement(zone, pendingCells);
	if (zoneId === 'green-zone') return validateGreenPlacement(zone, pendingCells);
	if (zoneId.startsWith('red-grid')) return validateRedPlacement(zone, pendingCells);
	if (zoneId === 'purple-zone') return validatePurplePlacement(zone, pendingCells);
	  return true;
	}

	function zoneHasActiveCells(zone) {
	  return !!zone.querySelector('.cell.active');
	}

	function hasAdjacentActiveCell(zone, cell) {
	  if (!zone || !cell) return false;
	  const x = Number(cell.dataset.x);
	  const y = Number(cell.dataset.y);
	  if (!Number.isFinite(x) || !Number.isFinite(y)) return false;
	  const neighbors = [
		getCell(zone, x - 1, y),
		getCell(zone, x + 1, y),
		getCell(zone, x, y - 1),
		getCell(zone, x, y + 1)
	  ];
	  return neighbors.some(neighbor => neighbor && neighbor.classList.contains('active'));
	}

	function validateYellowPlacement(zone, pendingCells) {
	  const hasActive = zoneHasActiveCells(zone);
	  const touchesStartColumn = pendingCells.some(cell => cell.classList.contains('bold-cell'));
	  if (!hasActive) return touchesStartColumn;
	  if (touchesStartColumn) return true;
	  return pendingCells.some(cell => hasAdjacentActiveCell(zone, cell));
	}

	function validateBluePlacement(zone, pendingCells) {
	  const metrics = getZoneMetrics(zone);
	  const floorY = Number.isFinite(metrics.maxY) ? metrics.maxY : null;
	  const touchesFloor = floorY !== null && pendingCells.some(cell => Number(cell.dataset.y) === floorY);
	  // Determine whether pendingCells touch an allowed bold-cell start.
	  // Prefer a per-zone mark set during import (`data-editor-applied`) to detect
	  // editor-applied boards. Fall back to global flags for backward compat.
	const isEditorApplied = !!(
		(zone && zone.dataset && String(zone.dataset.editorApplied) === 'true') ||
		(window && window._locusEditorApplied)
	);

	const allBoldCells = Array.from(zone.querySelectorAll('.cell.bold-cell:not(.void-cell)'));
	let touchesBold = false;
	try {
		// Compute only finite numeric Y values to avoid NaN pollution
		const boldYs = allBoldCells.map(c => Number(c.dataset.y)).filter(v => Number.isFinite(v));
		if (isEditorApplied || boldYs.length === 0) {
			// Allow any bold-cell (or no explicit bold-cells exist)
			touchesBold = pendingCells.some(cell => cell.classList && cell.classList.contains('bold-cell'));
		} else {
			// Restrict to bold-cells on the bottom-most bold row only
			const maxBoldY = Math.max(...boldYs);
			touchesBold = pendingCells.some(cell => cell.classList && cell.classList.contains('bold-cell') && Number(cell.dataset.y) === maxBoldY);
		}
	} catch (e) {
		// Fallback conservative behavior: require explicit bottom-most check via dataset
		touchesBold = pendingCells.some(cell => cell.classList && cell.classList.contains('bold-cell'));
	}
	try { console.debug('validateBluePlacement', { zoneId: zone.id, isEditorApplied, allBoldCount: allBoldCells.length, boldYs: allBoldCells.map(c=>c.dataset.y), touchesBold }); } catch(e){}
	  const hasActive = zoneHasActiveCells(zone);
	  // If no active cells exist yet, allow placement when it touches floor OR a bold start cell
	  if (!hasActive) return touchesFloor || touchesBold;
	// If there are active cells, touching floor or bold-cell is acceptable
	if (touchesFloor || touchesBold) {
		// Extra safety: ensure any touched bold-cell is actually on the zone's bottom row
		// when this is NOT an editor-applied board. This prevents stray bold-cells
		// elsewhere in the DOM from being treated as valid starts.
		try {
			if (!isEditorApplied && touchesBold) {
				const zoneMetrics = getZoneMetrics(zone);
				if (zoneMetrics && Number.isFinite(zoneMetrics.maxY)) {
					const bottomY = zoneMetrics.maxY;
					const pendingTouchesBottom = pendingCells.some(cell => {
						return cell && cell.classList && cell.classList.contains('bold-cell') && Number(cell.dataset.y) === bottomY;
					});
					if (!pendingTouchesBottom) {
						// No touched bold-cell is on the true bottom row - disallow.
						return pendingCells.some(cell => hasAdjacentActiveCell(zone, cell));
					}
				}
			}
		} catch (e) {}
		return true;
	}
	  return pendingCells.some(cell => hasAdjacentActiveCell(zone, cell));
	}

	function validateGreenPlacement(zone, pendingCells) {
	  const hasActive = zoneHasActiveCells(zone);
	  // Allow ANY bold-cell in the green zone to serve as a start anchor (not just the first match)
	  const boldCells = Array.from(zone.querySelectorAll('.cell.bold-cell:not(.void-cell)'));
	  const touchesAnchor = boldCells.length ? boldCells.some(b => pendingCells.includes(b)) : false;
	  
	  // Als er nog geen actieve cellen zijn
	  if (!hasActive) {
		if (!boldCells.length) return true;
		return touchesAnchor;
	  }
	  
	  // Als er wel actieve cellen zijn, check:
	  // 1. Touch anchor directly
	  if (touchesAnchor) return true;
	  
	  // 2. Adjacent to any active cell (including the anchor if it's active)
	  return pendingCells.some(cell => hasAdjacentActiveCell(zone, cell));
	}

	function validateRedPlacement(zone, pendingCells) {
	  // Rood: altijd vrij plaatsen, geen adjacency check nodig
	  return true;
	}

	function validatePurplePlacement(zone, pendingCells) {
	  // World 2 paars: je mag niet starten op de buitenste 2 ringen
	  // tenzij je aangrenzend bent aan een actieve cel
	  const hasActive = zoneHasActiveCells(zone);
	  
	  // Als er nog geen actieve cellen zijn, moet je NIET op outer ring starten
	  if (!hasActive) {
		// Check of alle pending cells NIET op de buitenste 2 ringen zitten
		const allInner = pendingCells.every(cell => {
		  return !cell.classList.contains('outer-ring-0') && !cell.classList.contains('outer-ring-1');
		});
		return allInner;
	  }
	  
	  // Als er wel actieve cellen zijn, moet je aangrenzend zijn
	  return pendingCells.some(cell => hasAdjacentActiveCell(zone, cell));
	}

	// ========================
	// SHOW PREVIEW
	// ========================
	function showPreview(zone, baseX, baseY, shape, color, allowed) {
	  clearPreview(zone);
	  const optionalCells = getOptionalCells(shape);
	  const optionalSet = new Set(optionalCells.map(({ x, y }) => `${x},${y}`));
	  let effectiveShape = shape;
	  let trimmedMode = false;
	  const fullCells = collectPlacementCells(zone, baseX, baseY, shape);
	  const fullValid = fullCells && fullCells.length > 0 && passesPlacementRules(zone, fullCells);
	  if (!fullValid && optionalCells.length) {
		const trimmed = trimOptionalCells(shape);
		if (trimmed.length > 0 && trimmed[0].length > 0) {
		  const trimmedCells = collectPlacementCells(zone, baseX, baseY, trimmed);
		  if (trimmedCells && trimmedCells.length > 0 && passesPlacementRules(zone, trimmedCells)) {
			effectiveShape = trimmed;
			trimmedMode = true;
		  }
		}
	  }
	  const highlightSet = trimmedMode ? new Set() : optionalSet;
	  effectiveShape.forEach((row, y) => {
		row.forEach((cell, x) => {
		  if (!cell) return;
		  const target = getCell(zone, baseX + x, baseY + y);
		  if (target) {
			const key = `${x},${y}`;
			const isOptional = highlightSet.has(key);
			target.classList.add(allowed ? 'preview-allowed' : 'preview-denied');
			if (allowed) {
			  const baseColor = color.name === 'multikleur'
				  ? 'linear-gradient(45deg, #f06272, #fff25a, #4ed346, #5d90f0, #a35eff)'
				  : hexToRGBA(color.code, isOptional ? 0.25 : 0.5);
			  target.style.background = baseColor;
			  if (isOptional) {
				target.style.border = '2px dashed rgba(255,255,255,0.6)';
			  }
			}
		  }
		});
	  });
	}
	
	// kan het blijven plakken aan een ander blok
	function getStickyBaseY(zone, baseX, baseY, shape) {
		if (!zone || zone.id !== 'blue-zone') return baseY;
		
		const metrics = getZoneMetrics(zone);
		if (!metrics || metrics.maxY < metrics.minY) return baseY;
		
		// GEEN magnetisch effect meer - alleen checken of positie geldig is
		// Een positie is geldig als:
		// 1. Het blok raakt de bodem (boldBottom cells), OF
		// 2. Het blok grenst aan een al geplaatst blok (boven/onder/links/rechts)
		
		let touchesBottom = false;
		let touchesActiveBlock = false;
		
		for (let y = 0; y < shape.length; y++) {
			for (let x = 0; x < shape[0].length; x++) {
				if (!isSolidShapeCell(shape[y][x])) continue;
				
				const cellX = baseX + x;
				const cellY = baseY + y;
				const cell = getCell(zone, cellX, cellY);
				
				// Check of deze cel de bodem raakt (bold-cell onderaan)
				if (cell && cell.classList.contains('bold-cell')) {
					touchesBottom = true;
				}
				
				// Check of cel onder deze actief is (staat erop)
				const cellBelow = getCell(zone, cellX, cellY + 1);
				if (cellBelow && cellBelow.classList.contains('active')) {
					touchesActiveBlock = true;
				}
				
				// Check aangrenzende cellen (boven, links, rechts - niet onder want dat is hierboven)
				const adjacentPositions = [
					{ x: cellX - 1, y: cellY },     // links
					{ x: cellX + 1, y: cellY },     // rechts
					{ x: cellX, y: cellY - 1 }      // boven
				];
				
				for (const pos of adjacentPositions) {
					const adjacentCell = getCell(zone, pos.x, pos.y);
					if (adjacentCell && adjacentCell.classList.contains('active')) {
						touchesActiveBlock = true;
						break;
					}
				}
				
				if (touchesBottom || touchesActiveBlock) break;
			}
			if (touchesBottom || touchesActiveBlock) break;
		}
		
		// Als het blok noch de bodem noch een actief blok raakt, is de positie ongeldig
		if (!touchesBottom && !touchesActiveBlock) {
			return -9999; // Onmogelijke positie
		}
		
		// Positie is geldig, return origineel
		return baseY;
	}

	function getYellowPlacement(zone, baseX, baseY, shape, metrics) {
	  if (!zone || zone.id !== 'yellow-zone') return { baseX, baseY };
	  
	  // Check of deze gele zone bold-cells heeft (World 2 mechaniek)
	  const hasBoldCells = zone.querySelectorAll('.cell.bold-cell').length > 0;
	  
	  // Als er geen bold-cells zijn (World 1), gebruik oude gedrag: geen restricties
	  if (!hasBoldCells) {
		return { baseX, baseY };
	  }
	  
	  // WORLD 2: Voor gele zone met bold-cells: GEEN magnetisch effect
	  // Het blok moet exact op de juiste positie staan
	  // EN Ã©Ã©n van de cellen moet een bold-cell aanraken OF aangrenzen aan een actieve cel
	  
	  // Check of er een bold-cell wordt aangeraakt OF aangrenzen aan actieve cel
	  let touchesBoldCell = false;
	  let adjacentToActive = false;
	  
	  for (let row = 0; row < shape.length; row++) {
		for (let col = 0; col < shape[0].length; col++) {
		  if (isSolidShapeCell(shape[row][col])) {
			const cellX = baseX + col;
			const cellY = baseY + row;
			const cell = getCell(zone, cellX, cellY);
			
			// Check bold-cell
			if (cell && cell.classList.contains('bold-cell')) {
			  touchesBoldCell = true;
			  break;
			}
			
			// Check aangrenzende cellen (boven, onder, links, rechts)
			const adjacentPositions = [
			  { x: cellX - 1, y: cellY },     // links
			  { x: cellX + 1, y: cellY },     // rechts
			  { x: cellX, y: cellY - 1 },     // boven
			  { x: cellX, y: cellY + 1 }      // onder
			];
			
			for (const pos of adjacentPositions) {
			  const adjacentCell = getCell(zone, pos.x, pos.y);
			  if (adjacentCell && adjacentCell.classList.contains('active')) {
				adjacentToActive = true;
				break;
			  }
			}
			
			if (adjacentToActive) break;
		  }
		}
		if (touchesBoldCell || adjacentToActive) break;
	  }
	  
	  // Als geen bold-cell wordt aangeraakt EN niet aangrenzend aan actieve cel
	  // dan is dit geen geldige positie (alleen voor World 2)
	  if (!touchesBoldCell && !adjacentToActive) {
		return { baseX: -9999, baseY: -9999 };
	  }
	  
	  // Anders: retourneer de originele positie (geen aanpassing)
	  return { baseX, baseY };
	}
		
	// ========================
	// PLACE SHAPE
	// ========================
	function placeShape(zone, baseX, baseY, shape, color) {
	  if (!zone) return null;
	  const colorCode = typeof color === 'string'
		? color
		: (color?.code);
	  const effectiveShape = shape;
	  // Validate using the required cells only (optional cells are skipped by collectPlacementCells).
	  const pendingCells = collectPlacementCells(zone, baseX, baseY, effectiveShape);
	  if (!pendingCells || pendingCells.length <= 0 || !passesPlacementRules(zone, pendingCells)) {
		return null;
	  }
	  
	  const placements = [];
	  const bonuses = [];
	  const previousPlacementId = currentPlacementId;
	  placementSequence += 1;
	  currentPlacementId = `placement-${placementSequence}`;
	  
	effectiveShape.forEach((row, y) => {
		row.forEach((cellVal, x) => {
		  if (!cellVal) return;
		  const target = getCell(zone, baseX + x, baseY + y);
		  if (!target) return;
		  // Optional cells (value 2) are a bonus extension: place them only when they fit.
		  if (isOptionalShapeCell(cellVal) && target.classList.contains('active')) return;
		  if (!target.classList.contains('active')) {
			placements.push(target);
			const toggleInfo = toggleCell(target, zone.id, colorCode, true);
			if (toggleInfo && toggleInfo.bonusClaim) {
				bonuses.push(toggleInfo.bonusClaim);
			}
		  }
		});
	});
	
	// Portals blijven op hun plaats staan voor het hele level
	
	currentPlacementId = previousPlacementId;
	return {
		zoneId: zone.id,
		cells: placements,
		bonuses
	};
}	// ========== KAARTEN SYSTEEM ==========
	// Centraal systeem voor alle kaart blueprints
	const CARD_BLUEPRINTS = {
		// Mini kaarten (2-3 blokjes)
		mini: [
			{ name: 'Domino verticaal', matrix: [[1],[1]], weight: 1 },
			{ name: 'Domino horizontaal', matrix: [[1,1]], weight: 1 },
			{ name: 'Tri-bar horizontaal', matrix: [[1,1,1]], weight: 1 },
			{ name: 'Tri-bar verticaal', matrix: [[1],[1],[1]], weight: 1 },
			{ name: 'Mini L', matrix: [[1,0],[1,1]], weight: 1 },
			{ name: 'Mini J', matrix: [[0,1],[1,1]], weight: 1 }
		],
		// Standaard Tetris (4 blokjes)
		standard: [
			{ name: 'I verticaal', matrix: [[1],[1],[1],[1]], weight: 1 },
			{ name: 'I horizontaal', matrix: [[1,1,1,1]], weight: 1 },
			{ name: 'O', matrix: [[1,1],[1,1]], weight: 1 },
			{ name: 'T omhoog', matrix: [[1,0],[1,1],[1,0]], weight: 1 },
			{ name: 'T omlaag', matrix: [[0,1],[1,1],[0,1]], weight: 1 },
			{ name: 'L klassiek', matrix: [[1,0],[1,0],[1,1]], weight: 1 },
			{ name: 'J klassiek', matrix: [[0,1],[0,1],[1,1]], weight: 1 },
			{ name: 'S horizontaal', matrix: [[1,1,0],[0,1,1]], weight: 1 },
			{ name: 'S verticaal', matrix: [[0,1],[1,1],[1,0]], weight: 1 },
			{ name: 'Z horizontaal', matrix: [[0,1,1],[1,1,0]], weight: 1 },
			{ name: 'Z verticaal', matrix: [[1,0],[1,1],[0,1]], weight: 1 }
		],
		// Grote/creatieve vormen
		large: [
			{ name: 'Plus', matrix: [[0,1,0],[1,1,1],[0,1,0]], weight: 1 },
			{ name: 'U vorm', matrix: [[1,0,1],[1,1,1]], weight: 1 },
			{ name: 'L groot', matrix: [[1,0],[1,0],[1,0],[1,1]], weight: 1 },
			{ name: 'Trap', matrix: [[1,0,0],[1,1,0],[0,1,1]], weight: 1 },
			{ name: 'Hoefijzer', matrix: [[1,1,0],[1,0,0],[1,1,0]], weight: 1 },
			{ name: 'Pijl', matrix: [[0,0,1],[1,1,1],[0,1,0]], weight: 1 },
			{ name: 'Lang 5 horizontaal', matrix: [[1,1,1,1,1]], weight: 1 },
			{ name: 'Lang 5 verticaal', matrix: [[1],[1],[1],[1],[1]], weight: 1 },
			{ name: 'Hinge', matrix: [[1,1,0],[0,1,1],[0,0,1]], weight: 1 },
			{ name: 'Z dubbel', matrix: [[0,1],[1,0],[1,1]], weight: 1 },
			{ name: 'S dubbel rechts', matrix: [[1,0],[1,1],[0,1,1]], weight: 1 },
			{ name: 'Hoekspiegel', matrix: [[1,0,0],[1,1,1],[0,0,1]], weight: 1 }
		],
		// Gouden kaarten (speciale category)
		golden: [
			{ name: 'Gouden Vierkant', matrix: [[1,1],[1,1]], weight: 1 },
			{ name: 'Gouden L', matrix: [[1,0],[1,0],[1,1]], weight: 1 },
			{ name: 'Gouden Zuil', matrix: [[1],[1],[1]], weight: 1 }
		]
	};

	// Extra grote (7 blokjes) vormen: zeldzaam + pas na upgrade.
	const EXTRA_LARGE_7_SHAPES = [
		{ name: 'Extra Groot (7) - Randhoek', matrix: [[1,1,1],[1,0,0],[1,1,1]], weight: 0.08 },
		{ name: 'Extra Groot (7) - Dubbele balk', matrix: [[1,1,1],[0,1,0],[1,1,1]], weight: 0.08 }
	];

	// XL vormen (6 blokjes): pas na upgrade.
	const XL_6_SHAPES = [
		{ name: 'XL (6) - 2x3', matrix: [[1,1,1],[1,1,1]], weight: 1 },
		{ name: 'XL (6) - Lang 6 horizontaal', matrix: [[1,1,1,1,1,1]], weight: 1 },
		{ name: 'XL (6) - Lang 6 verticaal', matrix: [[1],[1],[1],[1],[1],[1]], weight: 1 }
	];

	const SHAPE_CATEGORY_WEIGHTS = {
		mini: 0.35,      
		standard: 1,     
		large: 0.35      
	};

	// Bouw shapePool dynamisch op basis van upgrades
	function buildShapePool() {
		const pool = [];
		const weights = { ...SHAPE_CATEGORY_WEIGHTS };
		
		// Pas weights aan op basis van upgrades
		if (hasUpgrade('miniPack34')) {
			weights.mini = 0.65;  // Meer mini kaarten
		}
		
		// Voeg alleen unlocked categories toe aan pool
		Object.entries(CARD_BLUEPRINTS).forEach(([category, cards]) => {
			if (category === 'golden') return; // Skip golden, die worden apart toegevoegd
			
			// Check of category unlocked is
			if (!UNLOCK_PROGRESSION.isCategoryUnlocked(category, currentLevel)) {
				return; // Skip niet-unlocked categorieÃ«n
			}
			
			cards.forEach(card => {
				const categoryWeight = weights[category] ?? 1;
				pool.push({
					name: card.name,
					category: category,
					weight: card.weight * categoryWeight,
					matrix: card.matrix
				});
			});
		});

		// Extra grote 7-blok vormen zijn upgrade-gated en zeldzaam.
		if (hasUpgrade('extraLargeBlocks')) {
			EXTRA_LARGE_7_SHAPES.forEach(card => {
				pool.push({
					name: card.name,
					category: 'large',
					weight: card.weight,
					matrix: card.matrix
				});
			});
		}

		// XL 6-blok vormen zijn upgrade-gated.
		if (hasUpgrade('xlBlocks')) {
			XL_6_SHAPES.forEach(card => {
				pool.push({
					name: card.name,
					category: 'large',
					weight: card.weight,
					matrix: card.matrix
				});
			});
		}
		
		return pool;
	}

	// shapePool wordt later geÃ¯nitialiseerd na currentLevel declaratie
	let shapePool = [];

	function getRandomShapeEntry() {
	  const totalWeight = shapePool.reduce((sum, entry) => {
		const categoryWeight = SHAPE_CATEGORY_WEIGHTS[entry.category] ?? 1;
		return sum + entry.weight * categoryWeight;
	  }, 0);
	  let target = Math.random() * totalWeight;
	  for (const entry of shapePool) {
		const categoryWeight = SHAPE_CATEGORY_WEIGHTS[entry.category] ?? 1;
		const adjustedWeight = entry.weight * categoryWeight;
		if (target < adjustedWeight) return entry;
		target -= adjustedWeight;
	  }
	  return shapePool[shapePool.length - 1];
	}

	// gewone kleuren + multikleur
	const colors = [
	  { name: 'rood',   code: '#b56069' },
	  { name: 'groen',  code: '#92c28c' },
	  { name: 'blauw',  code: '#5689b0' },
	  { name: 'geel',   code: '#cfba51' },
	  { name: 'paars',  code: '#8f76b8' },
	  { name: 'multikleur', code: 'rainbow' } // speciale wildcard
	];
	const NON_WILDCARD_COLORS = colors.filter(c => c.name !== 'multikleur').map(c => ({ ...c }));
	const EXTRA_HAND_BONUS = 1;
	const LUCKY_DRAW_COPY_CHANCE = 0.25;
	let goldenColorRotation = 0;

	// Variabelen die nodig zijn voor buildShapePool
	let currentLevel = 1;
	let currentWorld = 1; // Nieuwe variabele om bij te houden in welke wereld we zitten

	// Helper functie om world en subLevel te bepalen
	function getWorldAndSubLevel(level) {
		if (level <= 10) return { world: 1, subLevel: level };
		if (level <= 20) return { world: 2, subLevel: level - 10 };
		if (level <= 30) return { world: 3, subLevel: level - 20 };
		return { world: Math.floor((level - 1) / 10) + 1, subLevel: ((level - 1) % 10) + 1 };
	}

	function isAtLeastWorldAndSubLevel(targetWorld, targetSubLevel, level = currentLevel) {
		const info = getWorldAndSubLevel(Number(level) || 1);
		const world = Number(info?.world || 1);
		const subLevel = Number(info?.subLevel || 1);
		if (world > targetWorld) return true;
		if (world < targetWorld) return false;
		return subLevel >= targetSubLevel;
	}

	// Vanaf level 1.7 (en later) zijn multikleur + gouden modifiers beschikbaar.
	function isSpecialModifiersUnlocked(level = currentLevel) {
		return isAtLeastWorldAndSubLevel(1, 7, level);
	}

	let ownedDeckBlueprints = [];
	let drawPile = [];
	let discardPile = [];
	let currentHand = [];
	let pendingShopCallback = null;
	let lastRoundWasSuccess = false;
	let lastRoundFailureReason = null;
	let selectedCardId = null;
	let selectedCardElement = null;
	let cardPlacementHistory = [];
	let cardsPlayedThisTurn = 0;
	let goldenCardPlayedThisTurn = false;
	let nonGoldenCardPlayedThisTurn = false;
	let actionSequence = 0;
	let cellActivationSequence = 0;
	let placementSequence = 0;
	let currentPlacementId = null;
	let coinsAwardedFromScore = 0;
	let cardSelectionLocked = false;
	  // NOTE: Turn counter UI is handled via turnCount/updateTurnCounterDisplay().
	let debugMode = false;
	let isLoadingGame = false;
	let savedDeckState = null;

	// Initialiseer shapePool nu currentLevel beschikbaar is
	shapePool = buildShapePool();

	let cardBlueprintCounter = 0;
	let cardInstanceCounter = 0;

	function nextBlueprintId() {
	  cardBlueprintCounter += 1;
	  return `bp-${cardBlueprintCounter}`;
	}

	function nextCardInstanceId() {
	  cardInstanceCounter += 1;
	  return `card-${cardInstanceCounter}`;
	}

	function cloneColor(color) {
		if (!color) return { name: '', code: '#ffffff' };
		return { name: color.name, code: color.code, isGolden: !!color.isGolden };
	}

	function createCardBlueprint(shapeEntry, colorOverride, extras = {}) {
		return {
			blueprintId: nextBlueprintId(),
			shapeName: shapeEntry.name,
			matrix: cloneShape(shapeEntry.matrix),
			category: shapeEntry.category,
			color: cloneColor(colorOverride),
			...extras
		};
	}

	function instantiateBlueprint(blueprint) {
		const safeColor = cloneColor(blueprint.color);
		// Backward compatible: old saves might mark golden on the color object.
		// Golden is a card modifier, NOT a block color.
		const isGolden = !!(blueprint && (blueprint.isGolden || blueprint.color?.isGolden));
		if (isGolden) safeColor.isGolden = false;
		return {
			id: nextCardInstanceId(),
			blueprintId: blueprint.blueprintId,
			shapeName: blueprint.shapeName,
			matrix: cloneShape(blueprint.matrix),
			category: blueprint.category,
			color: safeColor,
			isGolden
		};
	}

	function buildStandardDeckBlueprint() {
	  const standardShapes = shapePool.filter(entry => entry.category === 'standard');
	  
	  // Als shapePool leeg is of geen standard shapes heeft, rebuild de pool
	  if (standardShapes.length === 0) {
		console.warn('âš ï¸ No standard shapes in pool, rebuilding shapePool');
		shapePool = buildShapePool();
		const retryStandardShapes = shapePool.filter(entry => entry.category === 'standard');
		if (retryStandardShapes.length === 0) {
		  console.error('âŒ Still no standard shapes after rebuild!');
		  // Fallback: gebruik alle shapes als laatste redmiddel
		  return shapePool.slice(0, 9).map((entry, idx) => {
			const color = NON_WILDCARD_COLORS[idx % NON_WILDCARD_COLORS.length];
			return createCardBlueprint(entry, color);
		  });
		}
	  }
	  
	  const shuffled = shuffleArray([...standardShapes]);
	  const picks = shuffled.slice(0, 9);
	  const baseColors = [...NON_WILDCARD_COLORS];
	  let colorIndex = 0;
	  return picks.map(entry => {
		const color = baseColors[colorIndex % baseColors.length];
		colorIndex += 1;
		return createCardBlueprint(entry, color);
	  });
	}

	function getRandomGoldenShape() {
		if (!GOLDEN_CARD_SHAPES.length) {
			return { name: 'Gouden Vierkant', matrix: [[1,1],[1,1]], category: 'golden' };
		}
		const index = Math.floor(Math.random() * GOLDEN_CARD_SHAPES.length);
		return GOLDEN_CARD_SHAPES[index];
	}

	function createGoldenCardBlueprint() {
		const shapeEntry = getRandomGoldenShape();
		const palette = [...NON_WILDCARD_COLORS];
		const baseColor = palette.length ? palette[goldenColorRotation % palette.length] : { name: 'multikleur', code: 'rainbow' };
		goldenColorRotation = palette.length ? (goldenColorRotation + 1) % palette.length : goldenColorRotation;
		// Golden card = golden frame; keep the block color the base color.
		return createCardBlueprint(shapeEntry, baseColor, { isGolden: true, category: 'golden' });
	}

	function addGoldenCardBlueprints(count = 1) {
		for (let i = 0; i < count; i += 1) {
			ownedDeckBlueprints.push(createGoldenCardBlueprint());
		}
	}

	function addMiniCardBlueprints(count = 1) {
		const miniShapes = CARD_BLUEPRINTS.mini || [];
		const palette = NON_WILDCARD_COLORS.length ? NON_WILDCARD_COLORS : [{ name: 'grijs', code: '#a0a0a0' }];
		if (!miniShapes.length || !palette.length) return;
		for (let i = 0; i < count; i += 1) {
			const shapeEntry = miniShapes[Math.floor(Math.random() * miniShapes.length)];
			const entryWithCategory = { ...shapeEntry, category: 'mini' };
			const baseColor = palette[Math.floor(Math.random() * palette.length)];
			const blueprint = createCardBlueprint(entryWithCategory, baseColor);
			ownedDeckBlueprints.push(blueprint);
		}
	}

	function getSpendableCoinCount() {
	  return document.querySelectorAll('#collected-coins .coin.active').length;
	}

// Return a coin count usable by objective checks/progress.
// Priority: explicit `scores.coins` or `scores.coinsCollected` if provided,
// then DOM `getSpendableCoinCount()`, then fallback to deriving from
// bonus points (1 coin per 3 bonus points) if available.
function getCollectedCoinCount(scores) {
	if (scores && typeof scores.coins === 'number') return scores.coins;
	if (scores && typeof scores.coinsCollected === 'number') return scores.coinsCollected;
	if (typeof getSpendableCoinCount === 'function') return getSpendableCoinCount();
	if (scores && typeof scores.bonusesCollected === 'number') return Math.floor(scores.bonusesCollected / 3);
	return 0;
}

	function updateShopCoinDisplay() {
		if (!window.updateShopCoinDisplayElement) {
			const balanceEl = document.getElementById('shop-coin-balance');
			const displayEl = document.getElementById('shop-coin-display');
			window.updateShopCoinDisplayElement = { balanceEl, displayEl };
		}
		const refs = window.updateShopCoinDisplayElement;
		if (!refs || !refs.balanceEl) return;
		const coins = getSpendableCoinCount();
		refs.balanceEl.textContent = String(coins);
		refs.balanceEl.setAttribute('data-coins', String(coins));
		if (refs.displayEl) {
			refs.displayEl.classList.toggle('is-empty', coins === 0);
		}
	}

	function updateCoinCounter() {
	  const goldZone = document.getElementById('gold-zone');
	  if (!goldZone) return;
	  const activeCoins = getSpendableCoinCount();
	  goldZone.setAttribute('data-coin-text', `${activeCoins}`);
	  updateShopCoinDisplay();
	  updateBuyPlacementButton();
	}

	function updateBuyPlacementButton() {
	  const btn = document.getElementById('buy-placement-btn');
	  const preview = document.getElementById('purchased-block-preview');
	  if (!btn) return;
	  
	  // Als er een gekochte plaatsing actief is, toon preview en verberg knop
	  if (window.hasPurchasedPlacement) {
		btn.style.display = 'none';
		if (preview) preview.style.display = 'flex';
		// Ensure preview cell matches zoomed cell size when zoomed
		try {
			if (document.body.classList.contains('zoomed-in')) {
				const cellSize = Math.round(getActualCellSize(typeof activeZoomZone !== 'undefined' && activeZoomZone ? activeZoomZone : null));
				const cellEl = preview.querySelector('.purchased-block-cell');
				if (cellEl && Number.isFinite(cellSize) && cellSize > 6) {
					cellEl.style.width = cellEl.style.height = `${cellSize}px`;
					cellEl.style.borderRadius = `${Math.min(8, Math.round(cellSize / 4))}px`;
				}
			} else {
				// restore default CSS sizing
				const cellEl = preview.querySelector('.purchased-block-cell');
				if (cellEl) {
					cellEl.style.removeProperty('width');
					cellEl.style.removeProperty('height');
					cellEl.style.removeProperty('border-radius');
				}
			}
		} catch (e) {}
		return;
	  }
	  
	  // Anders toon knop en verberg preview
	  btn.style.display = 'flex';
	  if (preview) preview.style.display = 'none';
	  
	  const coins = getSpendableCoinCount();
	  const cost = 2;
	  btn.disabled = coins < cost;
	  btn.title = coins < cost 
		? `Onvoldoende munten (${coins}/${cost})` 
		: 'Koop bonusblok (2 munten)';
	}

	function onBuyPlacementClick() {
	  const coins = getSpendableCoinCount();
	  const cost = 2;
	  if (coins < cost) {
		showObjectiveToast('âŒ Onvoldoende munten voor blokplaatsing');
		return;
	  }
	  
	  // Betaal de munten
	  if (!spendCoins(cost)) {
		showObjectiveToast('âŒ Kon munten niet afschrijven');
		return;
	  }
	  
	  // Markeer dat er een gekochte plaatsing klaar staat
	  window.hasPurchasedPlacement = true;
	  updateBuyPlacementButton();
	  
	  showObjectiveToast('ðŸŒˆ Blok gekocht! Sleep het icoon om te plaatsen.');
	}

	function onPurchasedBlockPreviewClick(event) {
	  if (!window.hasPurchasedPlacement) return;
	  const isMobileLayout = window.innerWidth <= MOBILE_BREAKPOINT;
	  const isTouchDevice = ('ontouchstart' in window || navigator.maxTouchPoints > 0);
	  const isPointerDown = !!(event && typeof event.type === 'string' && event.type.indexOf('pointer') === 0);
	  const preferDirectDrag = !!(event && event.type === 'pointerdown' && event.pointerType === 'mouse');
	  
	  // Als er al een purchased placement drag actief is, doe niets (voorkom toggle)
	  if (activeBonusPlacement && activeBonusPlacement.colorKey === 'purchased') {
		return;
	  }
	  
	  // Cancel eventuele actieve bonus plaatsing
	  cancelActiveBonusPlacement({ updateInventory: false });
	  
	  // Maak een 1x1 multikleur blok en start het slepen
	  const shape = [[1]];
	  const colorObj = { name: 'multikleur', code: 'rainbow' };
	  
	  // Stel de geselecteerde vorm in
	  selectedShape = shape;
	  selectedColor = colorObj;
	  
	  const previewEl = document.getElementById('purchased-block-preview');
	  // Touch devices and mobile: always use direct drag (no hover mode)
	  // Desktop mouse can also use direct drag for purchased blocks (simpler UX)
	  // Skip hover-follow mode for purchased placement entirely.

	  // Touch: direct drag behavior - blok volgt de vinger
	  const block = makeDraggable(shape, colorObj);
	  block.classList.add('bonus-draggable', 'purchased-placement');
	  const overlay = document.getElementById('drag-overlay');
	  if (overlay && !overlay.contains(block)) overlay.appendChild(block);
	  if (overlay) overlay.style.display = 'block';
	  
	  draggedBlock = block;
	  draggedShape = block._shape || shape;
	  draggedColor = colorObj;
	  
	  // Start de pointer drag tracking
	  beginPointerDrag({ clientX: event.clientX, clientY: event.clientY, pointerId: event.pointerId || null });
	  
	  // Positioneer het blok bij de pointer positie (met touch offset)
	  const startX = event.clientX || window.innerWidth / 2;
	  const startY = event.clientY || window.innerHeight / 2;
	  ({ offsetX, offsetY } = computeShapeCenterOffsets(draggedShape));
	  const touchOffsetY = isTouchDevice ? 60 : 0; // Offset zodat vinger het blok niet bedekt
	  draggedBlock.style.left = `${startX - offsetX}px`;
	  draggedBlock.style.top = `${startY - offsetY - touchOffsetY}px`;

	// Ensure the purchased draggable immediately measures zoomed cell size
	// (in case zoom/lift just occurred). Re-render on next frame.
	requestAnimationFrame(() => {
		try {
			renderBlock(block, block._shape || shape, colorObj);
			({ offsetX, offsetY } = computeShapeCenterOffsets(block._shape || shape));
			block.style.left = `${startX - offsetX}px`;
			block.style.top = `${startY - offsetY - touchOffsetY}px`;
		} catch (e) {}
	});
	  
	  activeBonusPlacement = {
		colorKey: 'purchased',
		pointerId: event.pointerId || null,
		sticky: false, // Direct plaatsen bij release
		shape: cloneShape(shape),
		purchasedPlacement: true
	  };
	  
	  startGlobalDragVisuals();
	  // Don't show rotate/mirror buttons for purchased placement (1x1 block doesn't need them)
	  // addCardControlButtons() is skipped for purchased placement
	}

	function clearPurchasedPlacement() {
	  window.hasPurchasedPlacement = false;
	  updateBuyPlacementButton();
	}

	function setDebugMode(enabled) {
		debugMode = !!enabled;
		document.body.classList.toggle('debug-mode', debugMode);
		const toggleBtn = document.getElementById('debug-mode-toggle');
		if (toggleBtn) {
			toggleBtn.classList.toggle('debug-active', debugMode);
			toggleBtn.setAttribute('aria-pressed', String(debugMode));
			toggleBtn.textContent = debugMode ? 'Debug modus: aan' : 'Debug modus: uit';
		}
		const clearBtn = document.getElementById('clear-board-btn');
		if (clearBtn) {
			clearBtn.disabled = !debugMode;
			if (debugMode) clearBtn.removeAttribute('aria-disabled');
			else clearBtn.setAttribute('aria-disabled', 'true');
			clearBtn.title = debugMode ? 'Leeg het bord en reset munten (debug)' : 'Debug modus vereist om het bord te legen';
		}
		localStorage.setItem('debugModeEnabled', debugMode ? 'true' : 'false');
	}

	function toggleDebugMode() {
		setDebugMode(!debugMode);
	}

	const deckModalLayer = document.getElementById('deck-modal-layer');
	const deckModalContent = document.getElementById('deck-modal-content');
	const deckModalSubtext = document.getElementById('deck-modal-subtext');
	const deckModalClose = document.getElementById('deck-modal-close');
	const deckPreviewEl = document.getElementById('deck-preview');
	const goldenUnlockLayer = document.getElementById('golden-unlock-layer');
	const goldenUnlockModal = document.getElementById('golden-unlock-modal');
	const goldenUnlockTitle = document.getElementById('golden-unlock-title');
	const goldenUnlockContent = document.getElementById('golden-unlock-content');
	const goldenUnlockSubtext = document.getElementById('golden-unlock-subtext');
	const GOLDEN_UNLOCK_DEFAULT_TITLE = goldenUnlockTitle ? goldenUnlockTitle.textContent : 'âœ¨ Kies je eerste gouden kaart';
	const GOLDEN_UNLOCK_DEFAULT_SUBTEXT = goldenUnlockSubtext ? goldenUnlockSubtext.innerHTML : 'Je hebt <strong>Gouden Kaarten</strong> ontgrendeld. Kies er 1 uit 3.';
	const blackHoleModalLayer = document.getElementById('blackhole-modal-layer');
	const blackHoleModal = document.getElementById('blackhole-modal');
	const blackHoleSubtext = document.getElementById('blackhole-modal-subtext');
	const blackHoleCardGrid = document.getElementById('blackhole-card-grid');
	const blackHoleSelectionCount = document.getElementById('blackhole-selection-count');
	const blackHoleSelectionLimit = document.getElementById('blackhole-selection-limit');
	const blackHoleRewardEl = document.getElementById('blackhole-reward');
	const blackHoleStakeInput = document.getElementById('blackhole-stake');
	const blackHoleStakeValueEl = document.getElementById('blackhole-stake-value');
	const blackHoleStakeMultEl = document.getElementById('blackhole-stake-mult');
	const blackHoleClaimBtn = document.getElementById('blackhole-claim-btn');
	const blackHoleForfeitBtn = document.getElementById('blackhole-forfeit-btn');
	const blackHoleFeedbackEl = document.getElementById('blackhole-feedback');

	if (blackHoleStakeInput) {
		blackHoleStakeInput.addEventListener('input', () => {
			const maxStake = Math.max(0, Number(blackHoleStakeInput.max) || 10);
			const raw = Number(blackHoleStakeInput.value) || 0;
			const minStake = maxStake > 0 ? 1 : 0;
			blackHoleState.stake = Math.max(minStake, Math.min(maxStake, raw));
			updateBlackHoleSelectionUI();
		});
	}

	function buildDeckModalCard(blueprint, index) {
	  if (!blueprint || !deckModalContent) return null;
	  const rows = Array.isArray(blueprint.matrix) ? blueprint.matrix.length : 0;
	  const cols = rows > 0 && Array.isArray(blueprint.matrix[0]) ? blueprint.matrix[0].length : 0;
		const card = document.createElement('div');
		card.classList.add('card', 'card-option', 'deck-modal-card');
		card.setAttribute('role', 'listitem');
		card.dataset.shapeCols = String(cols);
		card.dataset.shapeRows = String(rows);
		if (blueprint.blueprintId) card.dataset.blueprintId = blueprint.blueprintId;
		if (blueprint.shapeName) card.dataset.shapeName = blueprint.shapeName;
	  card.tabIndex = -1;
	  card.style.cursor = 'default';
	  card.style.pointerEvents = 'none';
	  const isGolden = !!(blueprint.isGolden || blueprint.color?.isGolden);
	  const colorObj = cloneColor(blueprint.color || { name: '', code: '#cccccc' });
	  // Golden is a card modifier; do not paint the blocks gold.
	  if (isGolden) colorObj.isGolden = false;
	  card.dataset.golden = isGolden ? 'true' : 'false';
		const baseLabel = blueprint.shapeName || (colorObj.name ? `${colorObj.name} kaart` : 'Kaart');
		card.dataset.cardLabel = baseLabel;
		card.setAttribute('aria-label', baseLabel);
	  if (isGolden) card.classList.add('card-golden');
	  const pattern = document.createElement('div');
	  pattern.classList.add('card-pattern');
	  card.appendChild(pattern);
	  updateCardPattern(card, blueprint.matrix, colorObj);
	  const label = document.createElement('div');
	  label.classList.add('card-label');
	  const swatch = document.createElement('span');
	  swatch.classList.add('card-label-dot');
	  // Golden is a modifier; keep the swatch showing the base color.
	  const fill = (colorObj.code === 'rainbow'
		? 'linear-gradient(135deg, #f06272, #fff25a, #4ed346, #5d90f0, #a35eff)'
		: (colorObj.code || '#a0a0a0'));
	  swatch.style.background = fill;
	  const labelText = document.createElement('span');
	  labelText.textContent = isGolden
		? 'GOUDEN'
		: (colorObj.name ? colorObj.name.toUpperCase() : 'KAART');
	  label.append(swatch, labelText);
	  const meta = document.createElement('div');
	  meta.classList.add('card-meta');
	  meta.textContent = rows && cols ? `${rows}Ã—${cols}` : '';
	  card.append(label, meta);
	  return card;
	}

	let handScrollControlsInitialized = false;

	function updateHandScrollControls() {
	  const container = document.getElementById('card-options');
	  const cardControls = document.getElementById('card-controls');
	  const leftBtn = document.getElementById('hand-scroll-left');
	  const rightBtn = document.getElementById('hand-scroll-right');
	  if (!container || !cardControls || !leftBtn || !rightBtn) return;

	  const isMobile = window.innerWidth <= MOBILE_BREAKPOINT;
	  if (!isMobile) {
		cardControls.classList.remove('hand-scroll-enabled');
		leftBtn.disabled = true;
		rightBtn.disabled = true;
		return;
	  }

	  // UX rule: only show arrows when there are 5+ cards in hand.
	  const cardCount = container.querySelectorAll('.card-option').length;
	  if (cardCount < 5) {
		cardControls.classList.remove('hand-scroll-enabled');
		leftBtn.disabled = true;
		rightBtn.disabled = true;
		return;
	  }

	  const canScroll = container.scrollWidth > (container.clientWidth + 4);
	  cardControls.classList.toggle('hand-scroll-enabled', canScroll);

	  if (!canScroll) {
		leftBtn.disabled = true;
		rightBtn.disabled = true;
		return;
	  }

	  const maxScrollLeft = Math.max(0, container.scrollWidth - container.clientWidth);
	  const current = container.scrollLeft;
	  leftBtn.disabled = current <= 1;
	  rightBtn.disabled = current >= (maxScrollLeft - 1);
	}

	function initHandScrollControls() {
	  if (handScrollControlsInitialized) return;
	  handScrollControlsInitialized = true;

	  const container = document.getElementById('card-options');
	  const leftBtn = document.getElementById('hand-scroll-left');
	  const rightBtn = document.getElementById('hand-scroll-right');
	  if (!container || !leftBtn || !rightBtn) return;

	  const getScrollDelta = () => {
		const firstCard = container.querySelector('.card-option');
		const cardWidth = firstCard ? firstCard.getBoundingClientRect().width : 110;
		const gapRaw = getComputedStyle(container).gap || '0px';
		const gap = parseFloat(gapRaw) || 0;
		return Math.max(48, Math.round(cardWidth + gap));
	  };

	  leftBtn.addEventListener('click', (e) => {
		e.preventDefault();
		if (leftBtn.disabled) return;
		container.scrollBy({ left: -getScrollDelta(), behavior: 'smooth' });
	  });

	  rightBtn.addEventListener('click', (e) => {
		e.preventDefault();
		if (rightBtn.disabled) return;
		container.scrollBy({ left: getScrollDelta(), behavior: 'smooth' });
	  });

	  container.addEventListener('scroll', () => {
		updateHandScrollControls();
	  }, { passive: true });

	  window.addEventListener('resize', () => {
		updateHandScrollControls();
	  }, { passive: true });
	}

	function populateDeckModalContent() {
	  if (!deckModalContent) return;
	  deckModalContent.innerHTML = '';
	  const total = ownedDeckBlueprints.length;
	  // Respect scenario restrictions when present.
	  const allowedColors = Array.isArray(window.scenarioAllowedColors) ? window.scenarioAllowedColors : null;
	  if (deckModalSubtext) {
		deckModalSubtext.textContent = total === 1
		  ? 'Je hebt 1 kaart in je deck'
		  : `Je hebt ${total} kaarten in je deck`;
	  }
	  if (total === 0) {
		const empty = document.createElement('div');
		empty.classList.add('deck-modal-empty');
		empty.textContent = 'Je deck is leeg. Koop of verdien nieuwe kaarten om ze hier te zien.';
		deckModalContent.appendChild(empty);
		return;
	  }
		const getDeckKeyFromMatrix = matrix => {
			try {
				return JSON.stringify(matrix || []);
			} catch {
				return '[]';
			}
		};
		const getDeckSignature = (category, matrix, color, isGolden) => {
			// IMPORTANT: Use a deterministic signature that survives refresh/save/load.
			// We intentionally do NOT include blueprintId, shapeName, or color.code here,
			// because those can change or be missing across sessions.
			const safeColor = color || {};
			const golden = !!(isGolden || safeColor.isGolden);
			return [
				category || '',
				getDeckKeyFromMatrix(matrix),
				safeColor.name || '',
				golden ? 'gold' : 'normal'
			].join('|');
		};
		const getBlueprintKey = blueprint => {
			if (!blueprint) return 'sig|';
			return `sig|${getDeckSignature(blueprint.category, blueprint.matrix, blueprint.color, blueprint.isGolden)}`;
		};
		const getCardKey = card => {
			if (!card) return 'sig|';
			return `sig|${getDeckSignature(card.category, card.matrix, card.color, card.isGolden)}`;
		};
		const buildCountMap = (arr, keyFn) => {
			const map = new Map();
			(arr || []).forEach(item => {
				const k = keyFn(item);
				map.set(k, (map.get(k) || 0) + 1);
			});
			return map;
		};
		const dec = (map, key) => {
			const cur = map.get(key) || 0;
			if (cur <= 1) map.delete(key);
			else map.set(key, cur - 1);
		};
		// Use a filtered draw pile for availability calculations so inactive colors
		// (restricted by scenarios) are treated as 'not in draw'.
		const filteredDrawPile = allowedColors
			? drawPile.filter(c => c && (allowedColors.includes((c.color && c.color.name) || '') || (c.color && c.color.name) === 'multikleur'))
			: drawPile;
		const remainingCounts = buildCountMap(filteredDrawPile, getCardKey);
		const handCounts = buildCountMap(currentHand, getCardKey);
		const discardCounts = buildCountMap(discardPile, getCardKey);
		const statusOrder = {
			'available': 0,
			'in-hand': 1,
			'used': 2,
			'discarded': 3,
			'inactive': 99
		};
		const orderedBlueprints = ownedDeckBlueprints
			.map((blueprint, index) => {
				const key = getBlueprintKey(blueprint);
				let status = 'available';
				// If scenario restrictions exist, mark blueprints whose base color is
				// not allowed as 'inactive' so they are shown but marked unusable.
				const bpColorName = (blueprint && blueprint.color && blueprint.color.name) || '';
				const isBpAllowed = !allowedColors || allowedColors.includes(bpColorName) || bpColorName === 'multikleur';
				if (!isBpAllowed) {
					status = 'inactive';
				}
				let isInHand = false;
				let isInDrawPile = false;
				let isDiscarded = false;

				// IMPORTANT: Use counts so duplicates don't all get flagged.
				if ((handCounts.get(key) || 0) > 0) {
					status = 'in-hand';
					isInHand = true;
					dec(handCounts, key);
				} else if ((remainingCounts.get(key) || 0) > 0) {
					status = 'available';
					isInDrawPile = true;
					dec(remainingCounts, key);
				} else if ((discardCounts.get(key) || 0) > 0) {
					status = 'discarded';
					isDiscarded = true;
					dec(discardCounts, key);
				} else {
					status = 'used';
				}

				const sortKey = statusOrder[status] ?? 99;
				return { blueprint, index, status, isInDrawPile, isInHand, isDiscarded, sortKey };
			})
			.sort((a, b) => {
				if (a.sortKey !== b.sortKey) return a.sortKey - b.sortKey;
				return a.index - b.index;
			});
		orderedBlueprints.forEach(entry => {
			const { blueprint, index, status } = entry;
			const card = buildDeckModalCard(blueprint, index);
			if (!card) return;
			const baseLabel = card.dataset.cardLabel || blueprint.shapeName || 'Kaart';
			let statusText = 'Nog in deck';
			switch (status) {
				case 'in-hand':
					card.classList.add('deck-modal-card--depleted', 'deck-modal-card--in-hand');
					statusText = 'Nu in je hand';
					break;
				case 'available':
					statusText = 'Nog in deck';
					break;
				case 'inactive':
					card.classList.add('deck-modal-card--inactive');
					statusText = 'Niet bruikbaar voor dit niveau!';
					// Add an explicit badge element so it displays reliably over the card preview.
					try {
						const badge = document.createElement('div');
						badge.className = 'deck-modal-inactive-badge';
						badge.textContent = '?';
						// Avoid adding badge on multikleur cards (they have their own mark)
						const label = (card.dataset.cardLabel || '').toLowerCase();
						if (!label.includes('multikleur') && !label.includes('rainbow')) card.appendChild(badge);
					} catch (e) {}
					break;
				case 'used':
					card.classList.add('deck-modal-card--depleted');
					statusText = 'Al getrokken';
					break;
				case 'discarded':
					card.classList.add('deck-modal-card--depleted');
					statusText = 'Al gespeeld';
					break;
			}
			card.dataset.cardStatus = status;
			card.setAttribute('aria-label', `${baseLabel} â€“ ${statusText}`);
			card.title = `${baseLabel} â€¢ ${statusText}`;
			deckModalContent.appendChild(card);
		});
	  applyCardSizing();
	  deckModalContent.scrollTop = 0;
	}

	function openDeckModal() {
	  if (!deckModalLayer) return;
	  populateDeckModalContent();
	  deckModalLayer.classList.add('show');
	  deckModalLayer.setAttribute('aria-hidden', 'false');
	}

	function closeDeckModal() {
	  if (deckModalLayer) {
		deckModalLayer.classList.remove('show');
		deckModalLayer.setAttribute('aria-hidden', 'true');
	  }
	  if (deckPreviewEl) deckPreviewEl.focus();
	}

	function buildGoldenUnlockChoices(count = 3) {
		const candidates = shapePool.filter(e => e && (e.category === 'mini' || e.category === 'standard'));
		const pool = candidates.length ? shuffleArray([...candidates]) : shuffleArray([...shapePool]);
		const picks = pool.slice(0, Math.max(1, count));
		const palette = NON_WILDCARD_COLORS.length ? NON_WILDCARD_COLORS : colors;
		return picks.map(entry => {
			const baseColor = palette[Math.floor(Math.random() * palette.length)];
			const color = cloneColor(baseColor);
			const blueprint = createCardBlueprint(entry, color, { isGolden: true });
			return { blueprint, card: instantiateBlueprint(blueprint) };
		});
	}

	function setGoldenUnlockModalCopy(titleText, subtextHtml) {
		if (goldenUnlockTitle && typeof titleText === 'string') goldenUnlockTitle.textContent = titleText;
		if (goldenUnlockSubtext && typeof subtextHtml === 'string') goldenUnlockSubtext.innerHTML = subtextHtml;
	}

	function restoreGoldenUnlockModalCopy() {
		setGoldenUnlockModalCopy(GOLDEN_UNLOCK_DEFAULT_TITLE, GOLDEN_UNLOCK_DEFAULT_SUBTEXT);
	}

	function buildRewardChoices({ count = 3, filterFn = null, color = null, blueprintOptions = null } = {}) {
		const fallbackColor = color || { name: 'grijs', code: '#a0a0a0' };
		const candidates = shapePool.filter(e => {
			if (!e || !e.matrix) return false;
			if (typeof filterFn === 'function' && !filterFn(e)) return false;
			return true;
		});
		const pool = candidates.length ? shuffleArray([...candidates]) : shuffleArray([...shapePool]);
		const picks = pool.slice(0, Math.max(1, count));
		return picks.map(entry => {
			const blueprint = createCardBlueprint(entry, fallbackColor, blueprintOptions || undefined);
			return { blueprint, card: instantiateBlueprint(blueprint) };
		});
	}

	function populateRewardPickerModal(choices, onPick) {
		if (!goldenUnlockContent) return;
		goldenUnlockContent.innerHTML = '';
		goldenUnlockContent.classList.remove('selection-disabled');
		(choices || []).forEach(({ blueprint, card }) => {
			const el = createCardElement(card, true, {
				onSelect: (pickedCard) => {
					if (goldenUnlockContent.classList.contains('selection-disabled')) return;
					goldenUnlockContent.classList.add('selection-disabled');
					try {
						if (typeof onPick === 'function') onPick({ blueprint, card: pickedCard });
					} catch (err) {
						console.error('Reward selection failed:', err);
						goldenUnlockContent.classList.remove('selection-disabled');
						showObjectiveToast('âš ï¸ Kon selectie niet verwerken. Probeer opnieuw.');
					}
				}
			});
			el.setAttribute('role', 'listitem');
			el.tabIndex = 0;
			goldenUnlockContent.appendChild(el);
		});
		applyCardSizing();
		goldenUnlockContent.scrollTop = 0;
	}

	function showRewardPickerModal({ titleText, subtextHtml, choices, onPick }) {
		if (!goldenUnlockLayer) return;
		setGoldenUnlockModalCopy(titleText, subtextHtml);
		populateRewardPickerModal(choices, onPick);
		goldenUnlockLayer.classList.add('show');
		goldenUnlockLayer.setAttribute('aria-hidden', 'false');
		if (goldenUnlockModal) goldenUnlockModal.focus();
	}

	function grantPickedBlueprintReward({ blueprint, card }) {
		ownedDeckBlueprints.push(blueprint);
		currentHand.push(card);
		updateDeckPreview();
		saveGameState();
		renderCurrentHand();
	}

	function openMulticolorRewardPicker() {
		const rainbowColor = { name: 'multikleur', code: 'rainbow' };
		const choices = buildRewardChoices({
			count: 3,
			filterFn: (e) => e && (e.category === 'mini' || e.category === 'standard' || e.category === 'large'),
			color: rainbowColor
		});
		showRewardPickerModal({
			titleText: 'ðŸŒˆ Kies je multikleur kaart',
			subtextHtml: 'Je hebt <strong>Multikleur Kaarten</strong> ontgrendeld. Kies er 1 uit 3.',
			choices,
			onPick: ({ blueprint, card }) => {
				grantPickedBlueprintReward({ blueprint, card });
				closeGoldenUnlockModal();
				restoreGoldenUnlockModalCopy();
			}
		});
	}

	function startMini34RewardSequence() {
		const steps = 3;
		let step = 1;
		const colorPalette = NON_WILDCARD_COLORS.length ? NON_WILDCARD_COLORS : colors;
		const pickColor = () => {
			const base = colorPalette[Math.floor(Math.random() * colorPalette.length)] || { name: 'grijs', code: '#a0a0a0' };
			return cloneColor(base);
		};
		const filterMini34 = (e) => {
			if (!e || !e.matrix) return false;
			const blocks = (typeof countShapeBlocks === 'function') ? countShapeBlocks(e.matrix) : null;
			if (!Number.isFinite(blocks)) return (e.category === 'mini' || e.category === 'standard');
			return blocks <= 3;
		};
		const showStep = () => {
			const choices = buildRewardChoices({
				count: 3,
				filterFn: filterMini34,
				color: pickColor()
			});
			showRewardPickerModal({
				titleText: `ðŸ§© Kies je mini-kaart (${step}/${steps})`,
				subtextHtml: 'Je koopt een <strong>mini pakket</strong> (max. 3 blokjes). Kies 3 kaarten (telkens 1 uit 3).',
				choices,
				onPick: ({ blueprint, card }) => {
					grantPickedBlueprintReward({ blueprint, card });
					step += 1;
					if (step > steps) {
						closeGoldenUnlockModal();
						restoreGoldenUnlockModalCopy();
						return;
					}
					setTimeout(showStep, 60);
				}
			});
		};
		showStep();
	}

	function populateGoldenUnlockModal() {
		if (!goldenUnlockContent) return;
		goldenUnlockContent.innerHTML = '';
		goldenUnlockContent.classList.remove('selection-disabled');
		const choices = buildGoldenUnlockChoices(3);
		choices.forEach(({ blueprint, card }) => {
			const el = createCardElement(card, true, {
				onSelect: (pickedCard) => {
					// Safety: prevent double selection (double-click / mobile tap quirks).
					if (goldenUnlockContent.classList.contains('selection-disabled')) return;
					goldenUnlockContent.classList.add('selection-disabled');
					// Permanent reward: add the picked golden card to your owned deck (and keep it in future saves).
					try {
						ownedDeckBlueprints.push(blueprint);
						// Immediate reward: also give an instantiated copy right now.
						currentHand.push(pickedCard);
						updateDeckPreview();
						saveGameState();
						renderCurrentHand();
						closeGoldenUnlockModal();
					} catch (err) {
						console.error('Golden card selection failed:', err);
						goldenUnlockContent.classList.remove('selection-disabled');
						showObjectiveToast('âš ï¸ Kon gouden kaart niet opslaan. Probeer opnieuw.');
					}
				}
			});
			el.setAttribute('role', 'listitem');
			el.tabIndex = 0;
			goldenUnlockContent.appendChild(el);
		});
		applyCardSizing();
		goldenUnlockContent.scrollTop = 0;
	}

	function openGoldenUnlockModal() {
		if (!goldenUnlockLayer) return;
		// Only meaningful if the upgrade is unlocked.
		if (!hasUpgrade('goldenCards')) return;
		restoreGoldenUnlockModalCopy();
		populateGoldenUnlockModal();
		goldenUnlockLayer.classList.add('show');
		goldenUnlockLayer.setAttribute('aria-hidden', 'false');
		if (goldenUnlockModal) {
			goldenUnlockModal.focus();
		}
	}

	function closeGoldenUnlockModal() {
		if (!goldenUnlockLayer) return;
		goldenUnlockLayer.classList.remove('show');
		goldenUnlockLayer.setAttribute('aria-hidden', 'true');
	}

	function showBlackHoleFeedback(message = '', tone = 'info', duration = 2000) {
	  if (!blackHoleFeedbackEl) return;
	  blackHoleFeedbackEl.textContent = message;
	  blackHoleFeedbackEl.dataset.tone = tone;
	  blackHoleFeedbackEl.classList.toggle('show', !!message);
	  if (blackHoleState.feedbackTimeout) {
		clearTimeout(blackHoleState.feedbackTimeout);
		blackHoleState.feedbackTimeout = null;
	  }
	  if (message && duration > 0) {
		blackHoleState.feedbackTimeout = setTimeout(() => {
		  blackHoleFeedbackEl.textContent = '';
		  blackHoleFeedbackEl.classList.remove('show');
		  blackHoleState.feedbackTimeout = null;
		}, duration);
	  }
	}

	function generateBlackHoleCards(count = BLACK_HOLE_CARD_COUNT) {
	  const cards = [];
	  const randInt = (min, max) => (min + Math.floor(Math.random() * (max - min + 1)));
	  // 1 Black Hole
	  cards.push({ type: 'blackhole', value: 0, label: 'âš«' });
	  
	  // 2 Multipliers
	  cards.push({ type: 'multiplier', value: 2, label: 'x2' });
	  cards.push({ type: 'multiplier', value: 2, label: 'x2' });
	  
	  // Remaining are small rewards: mostly 1-10 points, sometimes 1-3 coins.
	  const remaining = count - 3;
	  for (let i = 0; i < remaining; i++) {
		const roll = Math.random();
		if (roll < 0.18) {
			const coins = Math.random() < 0.65 ? 1 : (Math.random() < 0.85 ? 2 : 3);
			cards.push({ type: 'coins', value: coins, label: `<span class="coin-symbol">ðŸª™</span>+${coins}` });
		} else {
			const points = randInt(1, 10);
			cards.push({ type: 'points', value: points, label: `+${points}` });
		}
	  }
	  
	  return shuffleArray(cards);
	}

	function buildBlackHoleModalCard(cardData, index) {
	  if (!cardData) return null;
	  const card = document.createElement('div');
	  card.classList.add('card', 'blackhole-card');
	  card.dataset.cardIndex = String(index);
	  card.tabIndex = 0;
	  
	  // Initial state: Face down
	  card.textContent = '?';
	  card.style.aspectRatio = '1';
	  card.style.display = 'flex';
	  card.style.alignItems = 'center';
	  card.style.justifyContent = 'center';
	  card.style.fontSize = '24px';
	  card.style.fontWeight = 'bold';
	  card.style.background = 'linear-gradient(135deg, #444, #222)';
	  card.style.color = '#fff';
	  card.style.cursor = 'pointer';
	  
	  card.addEventListener('click', () => handleBlackHoleCardClick(index));
	  card.addEventListener('keydown', event => {
		if (event.key === 'Enter' || event.key === ' ') {
		  event.preventDefault();
		  handleBlackHoleCardClick(index);
		}
	  });
	  return card;
	}

	function revealCardVisuals(card, cardData) {
		card.innerHTML = cardData.label;
		card.style.background = '#fff';
		card.style.color = '#000';
		card.style.cursor = 'default';
		
		if (cardData.type === 'blackhole') {
			card.style.background = '#000';
			card.style.color = 'red';
			card.style.border = '2px solid red';
		} else if (cardData.type === 'multiplier') {
			card.style.background = '#ffd700'; // Gold
		} else if (cardData.type === 'coins') {
			card.style.background = '#e8fff0';
			card.style.border = '1px solid rgba(60, 170, 90, 0.55)';
		} else {
			card.style.background = '#e0e0e0';
		}
	}

	function renderBlackHoleCards() {
	  if (!blackHoleCardGrid) return;
	  blackHoleCardGrid.innerHTML = '';
	  blackHoleCardGrid.style.display = 'grid';
	  blackHoleCardGrid.style.gridTemplateColumns = 'repeat(5, 1fr)';
	  blackHoleCardGrid.style.gap = '8px';
	  
	  blackHoleState.cards.forEach((cardData, index) => {
		const card = buildBlackHoleModalCard(cardData, index);
		if (!card) return;
		if (blackHoleState.selected.has(index)) {
			revealCardVisuals(card, cardData);
		}
		blackHoleCardGrid.appendChild(card);
	  });
	}

	function updateBlackHoleSelectionStyles() {
		// No-op
	}

	function getBlackHoleStakeMultiplier(stake) {
		const s = Math.max(0, Math.min(10, Number(stake) || 0));
		// Map 0..10 stake -> 1..5 multiplier (0 means no stake).
		// 0-2 => x1, 3-4 => x2, 5-6 => x3, 7-8 => x4, 9-10 => x5
		if (s <= 2) return 1;
		return 1 + Math.floor((s - 1) / 2);
	}

	function syncBlackHoleStakeUI() {
		const stake = Math.max(0, Number(blackHoleState.stake) || 0);
		const mult = getBlackHoleStakeMultiplier(stake);
		if (blackHoleStakeInput) blackHoleStakeInput.value = String(stake);
		if (blackHoleStakeValueEl) blackHoleStakeValueEl.textContent = String(stake);
		if (blackHoleStakeMultEl) blackHoleStakeMultEl.textContent = String(mult);
	}

	function updateBlackHoleSelectionUI() {
	  const selectionSize = blackHoleState.selected.size;
	  const reward = Math.max(0, blackHoleState.reward || 0);
	  const coins = blackHoleState.coins || 0;
	  const stake = Math.max(0, Number(blackHoleState.stake) || 0);
	  const mult = getBlackHoleStakeMultiplier(stake);
	  const rewardWithStake = reward * mult;
	  
	  if (blackHoleSelectionCount) blackHoleSelectionCount.textContent = String(selectionSize);
	  if (blackHoleSelectionLimit) blackHoleSelectionLimit.textContent = String(BLACK_HOLE_CARD_COUNT);
	  if (blackHoleRewardEl) blackHoleRewardEl.textContent = String(rewardWithStake);
	  syncBlackHoleStakeUI();
	  
	  if (blackHoleClaimBtn) {
		blackHoleClaimBtn.disabled = selectionSize === 0 || blackHoleState.gameOver;
		blackHoleClaimBtn.textContent = blackHoleState.gameOver 
			? 'Game Over' 
			: (selectionSize === 0 ? 'Kies een kaart' : (coins > 0 ? `Claim +${rewardWithStake} (+${coins}ðŸª™)` : `Claim +${rewardWithStake}`));
	  }
	}

	function handleBlackHoleCardClick(index) {
	  if (blackHoleState.gameOver) return;
	  if (typeof index !== 'number' || !blackHoleState.cards[index]) return;
	  if (blackHoleState.selected.has(index)) return;

	  const cardData = blackHoleState.cards[index];
	  blackHoleState.selected.add(index);
	  
	  const cardEl = blackHoleCardGrid.children[index];
	  if (cardEl) revealCardVisuals(cardEl, cardData);

	  if (cardData.type === 'blackhole') {
		blackHoleState.reward = 0;
		blackHoleState.coins = 0;
		blackHoleState.gameOver = true;
		const penalty = Math.min(getSpendableCoinCount(), TRAP_PENALTY || 5);
		for (let i = 0; i < penalty; i++) removeCoin();
		showBlackHoleFeedback(penalty > 0 ? `âš« ZWART GAT! -${penalty}ðŸª™` : 'âš« ZWART GAT!', 'warn');
		
		// Reveal all
		blackHoleState.cards.forEach((c, i) => {
			if (!blackHoleState.selected.has(i)) {
				const el = blackHoleCardGrid.children[i];
				if (el) revealCardVisuals(el, c);
			}
		});
		
		const forfeitBtn = document.getElementById('blackhole-forfeit-btn');
		if (forfeitBtn) forfeitBtn.textContent = 'Sluiten';
		
	  } else if (cardData.type === 'multiplier') {
		blackHoleState.reward *= cardData.value;
		showBlackHoleFeedback(`Bonus x${cardData.value}!`, 'info');
	  } else if (cardData.type === 'coins') {
		blackHoleState.coins = (blackHoleState.coins || 0) + (Number(cardData.value) || 0);
		showBlackHoleFeedback(`+${cardData.value}ðŸª™`, 'info');
	  } else {
		blackHoleState.reward += cardData.value;
		showBlackHoleFeedback(`+${cardData.value} punten`, 'info');
	  }

	  updateBlackHoleSelectionUI();
	}

	function openBlackHoleChallenge(trapRecord) {
	  if (!blackHoleModalLayer || !blackHoleModal) return;
	  resetBlackHoleState();
	  blackHoleState.trap = trapRecord;
	  blackHoleState.cards = generateBlackHoleCards();
	  
	  if (blackHoleSubtext) {
		blackHoleSubtext.textContent = `Draai kaarten om voor punten. Pas op voor het Zwarte Gat! (Stoppen of zwart gat: âˆ’${TRAP_PENALTY}ðŸª™)`;
	  }

	  // Stake UI (optional): 0..10 coins, scaled multiplier x1..x5.
	  const coinsAvailable = getSpendableCoinCount();
	  const maxStake = Math.max(0, Math.min(10, coinsAvailable));
	  blackHoleState.stake = maxStake > 0 ? 1 : 0;
	  if (blackHoleStakeInput) {
		blackHoleStakeInput.max = String(maxStake);
		blackHoleStakeInput.min = maxStake > 0 ? '1' : '0';
		blackHoleStakeInput.disabled = maxStake <= 0;
	  }
	  syncBlackHoleStakeUI();
	  
	  const forfeitBtn = document.getElementById('blackhole-forfeit-btn');
	  if (forfeitBtn) forfeitBtn.textContent = 'Stop';
	  
	  renderBlackHoleCards();
	  updateBlackHoleSelectionUI();
	  showBlackHoleFeedback('ðŸŒ€ Tijd voor bonuspunten!');
	  blackHoleModalLayer.classList.add('show');
	  blackHoleModalLayer.setAttribute('aria-hidden', 'false');
	  if (blackHoleModal.focus) {
		setTimeout(() => blackHoleModal.focus(), 80);
	  }
	}

	function closeBlackHoleModal() {
	  if (!blackHoleModalLayer) return;
	  blackHoleModalLayer.classList.remove('show');
	  blackHoleModalLayer.setAttribute('aria-hidden', 'true');
	  showBlackHoleFeedback('');
	  resetBlackHoleState();
	}

	function claimBlackHoleReward() {
	  const baseReward = Math.max(0, blackHoleState.reward || 0);
	  const coinsReward = Math.max(0, blackHoleState.coins || 0);
	  const stake = Math.max(0, Number(blackHoleState.stake) || 0);
	  const mult = getBlackHoleStakeMultiplier(stake);
	  const reward = baseReward * mult;
	  const trapRecord = blackHoleState.trap;
	  if ((baseReward <= 0 && coinsReward <= 0) || !trapRecord) {
		showBlackHoleFeedback('Selecteer eerst kaarten', 'warn');
		return;
	  }
	  if (stake > 0) {
		const coinsAvailable = getSpendableCoinCount();
		if (coinsAvailable < stake) {
			showBlackHoleFeedback('Niet genoeg munten voor deze inzet.', 'warn');
			return;
		}
		if (!spendCoins(stake)) {
			showBlackHoleFeedback('Inzet kon niet worden afgeschreven.', 'warn');
			return;
		}
	  }
	  if (reward > 0) blackHoleBonus += reward;
	  if (coinsReward > 0) {
		for (let i = 0; i < coinsReward; i++) addCoin();
	  }
	  const stakeLabel = stake > 0 ? ` (inzet ${stake}ðŸª™ Ã—${mult})` : '';
	  showObjectiveToast(coinsReward > 0 ? `ðŸŒ€ Bonus +${reward} en +${coinsReward}ðŸª™!${stakeLabel}` : `ðŸŒ€ Bonus +${reward}!${stakeLabel}`);
	  resolveTrapById(trapRecord.id);
	  closeBlackHoleModal();
	  updateScore();
	}

	function forfeitBlackHoleChallenge() {
	  const trapRecord = blackHoleState.trap;
	  if (!blackHoleState.gameOver) {
		const penalty = Math.min(getSpendableCoinCount(), TRAP_PENALTY || 5);
		for (let i = 0; i < penalty; i++) removeCoin();
		if (penalty > 0) showObjectiveToast(`ðŸŒ€ Gestopt: -${penalty}ðŸª™`);
	  }
	  if (trapRecord) {
		if (activeTraps.some(trap => trap.id === trapRecord.id)) {
			showObjectiveToast('ðŸŒ€ Geen bonus deze keer.');
			resolveTrapById(trapRecord.id);
		}
	  }
	  closeBlackHoleModal();
	  updateScore();
	}

	function updateDeckPreview() {
	  const deckCount = document.querySelector('.deck-count');
	  const deckPreview = document.getElementById('deck-preview');
	  if (deckCount) {
		// UX request: show turns remaining instead of raw cards.
		// Assumption: a "turn" consumes 3 cards from the draw pile.
		const remainingCards = drawPile.length;
		const turnsRemaining = Math.ceil(remainingCards / 3);
		deckCount.textContent = 