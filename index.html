<!DOCTYPE html>
<html lang="nl">
<head>
	<meta charset="utf-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
	<meta title="LOCUS Digitaal">
	<link rel="stylesheet" href="print.css" media="print">
	<script>
		// Prevent pinch/double-touch zoom on phones; keep single-finger scrolling intact.
		(function disableTouchZoom() {
			try {
				const isCoarse = window.matchMedia && window.matchMedia('(pointer: coarse)').matches;
				if (!isCoarse) return;
				const blockPinch = (e) => {
					if (e.touches && e.touches.length > 1) {
						e.preventDefault();
					}
				};
				const canScroll = (el) => {
					if (!el || !el.closest) return false;
					if (el.closest('#green-zone, #blue-zone, #card-options, #preworld-pick-grid, #deck-modal-content, #blackhole-card-grid')) return true;
					let node = el;
					while (node && node !== document.body) {
						try {
							const style = window.getComputedStyle(node);
							const overflowY = style.overflowY;
							const overflowX = style.overflowX;
							const canScrollY = (overflowY === 'auto' || overflowY === 'scroll') && node.scrollHeight > node.clientHeight + 1;
							const canScrollX = (overflowX === 'auto' || overflowX === 'scroll') && node.scrollWidth > node.clientWidth + 1;
							if (canScrollY || canScrollX) return true;
						} catch (_) {}
						node = node.parentElement;
					}
					return false;
				};
				const blockPageScroll = (e) => {
					if (!canScroll(e.target)) e.preventDefault();
				};
				let touchMoveQueued = false;
				let lastTouchEvent = null;
				const throttledBlockPageScroll = (e) => {
					lastTouchEvent = e;
					if (touchMoveQueued) return;
					touchMoveQueued = true;
					requestAnimationFrame(() => {
						touchMoveQueued = false;
						if (lastTouchEvent) blockPageScroll(lastTouchEvent);
					});
				};
				window.addEventListener('touchmove', blockPinch, { passive: false });
				window.addEventListener('touchmove', throttledBlockPageScroll, { passive: false });
				window.addEventListener('gesturestart', e => e.preventDefault());
				window.addEventListener('gesturechange', e => e.preventDefault());
				window.addEventListener('gestureend', e => e.preventDefault());
			} catch (_) {}
		})();
	</script>
	<script>
		/*
			EN:
			- WHY: Apply the saved theme class as early as possible to avoid a flash of the wrong theme.
		*/
		(function preloadThemeClass() {
			try {
				// Dark mode is the base styling now (no class needed).
				// Inject a minimal inline style to ensure immediate dark background
				// and text color before external/embedded CSS parses fully.
				var _s = document.createElement('style');
				_s.setAttribute('data-locus-theme-preload','true');
				_s.textContent = 'html,body { background: #1e1f23; color: #e5e5e5; }\n'
					+ '#menu-toggle { background: var(--color-menu-bg, #2f3546); border-color: var(--shadow-light, rgba(255,255,255,0.12)); }\n'
					+ '#menu-toggle span { background: rgba(255,255,255,0.88); }\n'
					+ '#mobile-objective-banner, #ml-objective-top { background: transparent; }\n'
					+ '#objective-zone { background: rgba(34,37,43,0.95); color: var(--color-text-light, #e5e5e5); }\n'
					+ '.card { background: var(--color-dark-gray, #333); color: inherit; }';
				document.head.appendChild(_s);
			} catch (e) {
				// Ignore storage or DOM errors (private mode / blocked storage).
			}
		})();
	</script>
		<style>
			/*
				EN: Comment tags used throughout this file:
				- WHY: reason the code exists / design intent
				- STATE: what global state / DOM state is read or written
				- OVERRIDE: this block can be overwritten later (order-dependent)
				- DUPLICATE: a similar rule/handler exists elsewhere (risk of divergence)
				- LEGACY: kept for backwards compatibility / older UI paths
				
				Note: This is a single-file app with large CSS + JS blocks; ordering matters.
			*/

			/* === Shared defaults (desktop look from 22-10 + mobile HUD from 23-10-3) === */
			html {
				min-height: 100%;
				background: var(--color-dark-bg);
				overflow-y: hidden;
				overflow-x: hidden;
				overscroll-behavior: contain;
				/* Prevent browser back-navigation on horizontal swipe (iOS Safari, Chrome) */
				overscroll-behavior-x: none;
			}

			body {
				margin: 0;
				position: relative;
				padding: 10px;
				min-height: 100%;
				width: 100%;
				overflow: hidden;
				overflow-x: hidden;
				overflow-y: hidden;
				overscroll-behavior: none;
				background: var(--color-dark-bg);
				/*
					IMPORTANT (mobile/iOS): never put emoji fonts before system UI fonts.
					Otherwise digits can render in Apple Color Emoji, which looks "weird".
					Keep emoji fonts at the end so emoji still work when needed.
				*/
				font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", "Helvetica Neue", Arial, sans-serif, "Segoe UI Emoji", "Apple Color Emoji", "Noto Color Emoji";
				font-size: 16px;
				/*
					EN:
					- STATE: sets the page base typography + background.
				*/
				gap: 10px;
				grid-template-columns: auto;
				justify-content: center;
				align-items: start;
				color: var(--color-text-light);
				transition: background-color 0.3s, color 0.3s;
			}

			@media (max-width: 900px), (hover: none) and (pointer: coarse) {
				html, body {
					height: 100%;
					overflow: hidden;
					overscroll-behavior: none;
				}
			}

		:root {
			/* Base measurements */
			/* Fixed across all grids; the board itself is scaled to fit the screen. */
			--cell-size: 26px;
			--board-grid-gap: 2px;
			--preview-gap: 2px;
			--gap: 10px;
			--radius: 10px;
			--cell-radius: calc(var(--cell-size) / 4);
			--bottom-height: 70px;
			--side-panel-width: 120px;
			--card-size: 150px;
			--zoom-scale: 1.25;
			--zoom-top: 22%;

			/* Bottom bar sizing */
			--bottom-bar-gap: 0px;
			--bottom-bar-bottom-offset: 0px;
			--card-hand-lift: 12px;

			/* Z-index scale */
			--z-bottom: 450;      /* bottom bar */
			--z-controls: 1000;   /* controls panel */
			--z-menu: 1100;       /* menu / hamburger (must stay above other UI) */
			--z-ui: 250;          /* generic UI buttons */
			--z-blur: 400;        /* blur backdrop */
			--z-zoom: 500;        /* focused/zoomed zone */
			--z-drag: 600;        /* drag overlay (highest for dragged items) */
			--z-score: 1050;      /* transient score / sparkle popups â€” must be above zoom-focus (1000 on desktop) */
			--z-draggable: 600;   /* draggable block default */



			/* Colors - Dark mode (REFACTORED: Phase 2) */
			--main-bg-dark: #1a1a1a;
			--panel-bg-dark: #2d2d2d;
			--score-bg-dark: rgba(45,45,45,0.9);
			--card-bg-dark: #2d2d2d;
			
			/* Refactored colors - Phase 2 */
			--color-dark-bg: #1e1f23;
			--color-dark-panel: #2d2d2d;
			--color-text-light: #e5e5e5;
			--color-accent-blue: #3d75b5;
			--color-menu-bg: #2f3546;
			--color-dark-gray: #333;
			--color-border-dark: #2d2f36;
			
			/* Shadow utilities */
			--shadow-light: rgba(0,0,0,0.12);
			--shadow-medium: rgba(0,0,0,0.3);
			--shadow-dark: rgba(0,0,0,0.5);

			/* Zone background colors */
			--zone-yellow: #f0dc7d;
			--zone-green: #a8d5a2;
			--zone-purple: #a48dcc;
			--zone-blue: #6ba8d8;
			--zone-red: #de838c;
			--zone-gold: #fffbea;

			/* Cell colors per zone (bg, border, active, active-border) */
			--cell-yellow-bg: #fff3b0;
			--cell-yellow-color: #3e2f00;
			--cell-yellow-border: #fffba8;
			--cell-yellow-active: #cfba51;
			--cell-yellow-active-border: #f7dc54;

			--cell-red-bg: #ffd6d1;
			--cell-red-color: #4b0000;
			--cell-red-border: #ff7b73;
			--cell-red-active: #b56069;
			--cell-red-active-border: #ff7b73;

			--cell-purple-bg: #f3e8fa;
			--cell-purple-border: #e6a8ff;
			--cell-purple-active: #8f76b8;
			--cell-purple-active-color: #33004b;
			--cell-purple-active-border: #e6a8ff;

			--cell-green-bg: #d6f5d6;
			--cell-green-color: #003300;
			--cell-green-border: #c1ffa8;
			--cell-green-active: #92c28c;
			--cell-green-active-border: #c1ffa8;
			--cell-green-end: #7bba7b;
			--cell-green-end-border: #7bb57f;
			--cell-green-end-active: #5da35d;
			--cell-green-end-active-border: #518755;

			--cell-blue-bg: #d6eaff;
			--cell-blue-color: #001f3f;
			--cell-blue-border: #a8d8ff;
			--cell-blue-active: #5689b0;
			--cell-blue-active-border: #a8d8ff;

			/* Spacing scale */
			--space-xs: 2px;
			--space-sm: 4px;
			--space-md: 8px;
			--space-lg: 12px;
			--space-xl: 16px;
			--space-2xl: 24px;

			/* Border-radius scale */
			--radius-sm: 6px;
			--radius-md: 10px;
			--radius-lg: 16px;
			--radius-xl: 20px;
			--radius-pill: 999px;

			/* Typography scale */
			--text-xs: 0.65rem;
			--text-sm: 0.78rem;
			--text-base: 0.88rem;
			--text-md: 1rem;
			--text-lg: 1.25rem;
			--text-xl: 1.5rem;
			--text-2xl: 2rem;
		}

		* {
			box-sizing: border-box;
		}

		html, body {
			touch-action: manipulation;
		}

		#drag-overlay {
			position: fixed;
			top: 0;
			left: 0;
			width: 100vw;
			height: 100vh;
			pointer-events: none;
			cursor: none;
			z-index: var(--z-drag);
		}

	/* Floating preview voor touch-vriendelijke kaart plaatsing */
	#floating-preview {
		position: fixed;
		/* Positie wordt dynamisch ingesteld via JS */
		width: 138px;
		min-height: 180px;
		padding: 16px;
		display: none;
		flex-direction: column;
		align-items: center;
		justify-content: center;
		gap: 12px;
		border-radius: 16px;
		background: linear-gradient(165deg, #ffffff 0%, #eef2ff 45%, #dfe4ff 100%);
		border: 2px solid #4a90e2;
		box-shadow: 0 18px 26px rgba(10,12,20,0.3);
		z-index: calc(var(--z-zoom) + 50);
		touch-action: none;
		cursor: grab;
		transition: transform 0.2s ease, box-shadow 0.2s ease, opacity 0.2s ease;
		transform: scale(0.8);
		opacity: 0;
		overflow: visible;
	}		#floating-preview.dragging {
			cursor: grabbing;
			transform: scale(1.1);
			box-shadow: 0 12px 32px rgba(0,0,0,0.4);
		}

	#floating-preview {
		background: linear-gradient(165deg, #2d2d2d 0%, #1f2233 45%, #1a1d2e 100%);
		border-color: #5a9fd4;
	}	#floating-preview-pattern {
		width: 100%;
		flex: 1;
		display: flex;
		align-items: center;
		justify-content: center;
		pointer-events: none;
		position: relative;
		z-index: 1;
	}		#floating-preview-rotate {
			position: absolute;
			top: 6px;
			right: 6px;
			width: 36px;
			height: 36px;
			background: #4a90e2;
			border: 2px solid white;
			border-radius: 50%;
			display: flex;
			align-items: center;
			justify-content: center;
			font-size: 18px;
			color: white;
			cursor: pointer;
			touch-action: none;
			box-shadow: 0 4px 12px rgba(0,0,0,0.3);
			z-index: 1;
			user-select: none;
		}

		#floating-preview-rotate:active {
			transform: scale(0.95);
		}

		#floating-preview-rotate {
			background: #5a9fd4;
			border-color: #1e2128;
		}

		#floating-preview-mirror {
			position: absolute;
			bottom: 6px;
			right: 6px;
			width: 36px;
			height: 36px;
			background: #9b59b6;
			border: 2px solid white;
			border-radius: 50%;
			display: flex;
			align-items: center;
			justify-content: center;
			font-size: 18px;
			color: white;
			cursor: pointer;
			touch-action: none;
			box-shadow: 0 4px 12px rgba(0,0,0,0.3);
			z-index: 1;
			user-select: none;
		}

		#floating-preview-mirror:active {
			transform: scale(0.95);
		}

		#floating-preview-mirror {
			background: #8e44ad;
			border-color: #1e2128;
		}

		#floating-preview-cancel {
			position: absolute;
			top: 6px;
			left: 6px;
			width: 36px;
			height: 36px;
			background: #e74c3c;
			border: 2px solid white;
			border-radius: 50%;
			display: flex;
			align-items: center;
			justify-content: center;
			font-size: 20px;
			color: white;
			cursor: pointer;
			touch-action: none;
			box-shadow: 0 4px 12px rgba(0,0,0,0.3);
			z-index: calc(var(--z-zoom) + 51);
			user-select: none;
		}

		#floating-preview-cancel:active {
			transform: scale(0.95);
		}

		#floating-preview-cancel {
			background: #c0392b;
			border-color: #1e2128;
		}

		/* Zoom-lens voor plaatsing preview */
		#placement-zoom-lens {
			position: fixed;
			width: 160px;
			height: 160px;
			background: rgba(255, 255, 255, 0.98);
			border: 3px solid #4a90e2;
			border-radius: 16px;
			box-shadow: 0 12px 32px rgba(0,0,0,0.5), 0 0 0 2px rgba(74, 144, 226, 0.3);
			z-index: calc(var(--z-zoom) + 1);
			pointer-events: none;
			transition: opacity 0.15s ease;
		}

		#placement-zoom-lens {
			background: rgba(30, 33, 40, 0.98);
			border-color: #5a9fd4;
			box-shadow: 0 12px 32px rgba(0,0,0,0.7), 0 0 0 2px rgba(90, 159, 212, 0.3);
		}

		#zoom-lens-content {
			width: 100%;
			height: 100%;
			display: flex;
			align-items: center;
			justify-content: center;
			padding: 8px;
			overflow: hidden;
		}

		#zoom-lens-content .zoom-grid {
			display: grid;
			gap: var(--board-grid-gap, 2px);
			transform: scale(1.5);
			transform-origin: center;
		}

		#zoom-lens-content .zoom-cell {
			border-radius: 2px;
			border: 1px solid rgba(0,0,0,0.15);
		}

		#zoom-lens-content .zoom-cell {
			border-color: rgba(255,255,255,0.2);
		}

		#zoom-lens-content .zoom-cell.filled {
			box-shadow: 0 2px 4px rgba(0,0,0,0.2);
		}

		#zoom-lens-content .zoom-cell.preview {
			opacity: 0.7;
			border: 2px solid rgba(74, 144, 226, 0.8);
		}

		#zoom-lens-content .zoom-cell.preview.valid {
			border-color: rgba(76, 175, 80, 0.9);
			box-shadow: 0 0 8px rgba(76, 175, 80, 0.4);
		}

		#zoom-lens-content .zoom-cell.preview.invalid {
			border-color: rgba(244, 67, 54, 0.9);
			box-shadow: 0 0 8px rgba(244, 67, 54, 0.4);
		}


		body .blur-overlay {
			pointer-events: none;
		}

		/* ============================================
		   DARK MODE - BASIS STYLING
		   ============================================
		*/
		{
			background: var(--color-dark-bg);
			color: var(--color-text-light);
		}

		.board {
			display: flex;
			gap: 12px; /* ruimte tussen kolommen */
			margin: 0 auto;
			margin-top: 50px;
			touch-action: manipulation;
			position: relative;
			z-index: 1;
			transition: transform 0.25s ease, opacity 0.12s ease;
		}

		body.layout-reflow .board {
			opacity: 0;
			pointer-events: none;
		}

		body.board-loading .board {
			opacity: 0;
			pointer-events: none;
		}

		body.board-scaled {
			overflow-y: auto;
		}

		body.board-scaled .board {
			transform-origin: top center;
		}

	.column {
		display: flex;
		flex-direction: column;
		gap: 12px; /* ruimte tussen vakken in dezelfde kolom */
		flex: 1; /* kolommen gelijk breed op mobiel */
	}
	.zone {
		/* Geen background hier - wordt per zone ingesteld */
		position: relative;
		border-radius: 10px;
		border: 1px solid #e3e6ea;
		box-shadow: 0 2px 6px rgba(0,0,0,0.12);
		box-sizing: border-box;
		padding: 10px;
		margin: 10px;
		touch-action: manipulation;
		transition: transform 0.3s ease;
		z-index: 1;
	}

	body.debug-mode .zone .cell:not(.void-cell) {
		cursor: pointer;
	}

	.red-group {
		display: flex;
		flex-wrap: wrap;
		gap: 8px;
		justify-content: center;
	}

	.red-group.zoom-focus {
		width: auto;
		min-height: 400px; /* Minimum height, niet fixed */
		height: auto; /* Laat content de height bepalen */
	}


	.zone {
		border: 1px solid var(--color-border-dark);
		box-shadow: 0 4px 10px var(--shadow-dark);
	}.zone-placeholder {
			pointer-events: none;
			position: relative;
		}

		.blur-overlay {
			display: none;
			position: fixed;
			inset: 0;
			background: rgba(0, 0, 0, 0.4);
			backdrop-filter: blur(4px);
			-webkit-backdrop-filter: blur(4px);
			z-index: var(--z-blur);
		}

		body.zoomed-in .blur-overlay {
			display: block;
		}

		.zone.zoom-focus {
			position: fixed;
			top: var(--zoom-top, 22%);
			left: 50%;
			flex-direction: column;
			gap: 2px;
			flex: 0 0 auto;
			width: 58px;
			min-width: 50px;
			max-width: 70px;
			overflow-y: auto;
			overflow-x: hidden;
			scrollbar-width: none;
		}

		/* Landscape: slightly wider sidebars */
		@media (orientation: landscape) {
			body.mobile-sidebar-layout #ml-sidebar-left,
			body.mobile-sidebar-layout #ml-sidebar-right {
				width: 72px;
				min-width: 65px;
				max-width: 90px;
				gap: 3px;
			}
			
			body.mobile-sidebar-layout #mobile-landscape-wrapper {
				gap: 4px;
				padding: 4px;
			}
		}

		body.mobile-sidebar-layout #ml-sidebar-left::-webkit-scrollbar,
		body.mobile-sidebar-layout #ml-sidebar-right::-webkit-scrollbar {
			display: none;
		}

		body.mobile-sidebar-layout #ml-board-center {
			/* Don't expand to fill all remaining width: keep sidebars close to the board
			   (fixes "options too far to the sides" on phone landscape). */
			flex: 0 1 auto;
			display: flex;
			flex-direction: column;
			justify-content: flex-start;
			align-items: center;
			min-width: 0;
			overflow: hidden;
			gap: 2px;
		}

		/* Small-ish desktop landscape: slightly smaller cells so zones fit cleanly. */
		@media (min-width: 651px) and (orientation: landscape) and (max-height: 760px) {
			body.desktop-landscape {
				--cell-size: 26px;
			}
		}

		/* Mid-size desktop landscape (e.g. ~950px wide / ~925px tall):
		   reduce cell size so symbols don't look oversized and the board fits better. */
		@media (min-width: 801px) and (max-width: 1100px) and (orientation: landscape) and (max-height: 980px) {
			body.desktop-landscape {
				--cell-size: 26px;
			}
		}

		/* Compact objective banner in sidebar layout */
		body.mobile-sidebar-layout #ml-objective-top {
			display: flex !important;
			width: 100%;
			padding: 2px 6px;
			background: rgba(34, 37, 43, 0.95);
			color: var(--color-text-light);
			border-radius: 6px;
			font-size: 0.65rem;
			text-align: center;
			justify-content: center;
			align-items: center;
			flex-shrink: 0;
		}

		body.mobile-sidebar-layout #ml-objective-top #objective-zone {
			min-height: auto;
			padding: 2px 8px;
			font-size: 0.6rem;
		}

		body.mobile-sidebar-layout #ml-objective-top #objective-zone h2 {
			display: none;
		}

		body.mobile-sidebar-layout #ml-board-center #board {
			transform-origin: top center;
		}

		/* Zorg voor gelijke kolomhoogtes in mobiele sidebar layout */
		body.mobile-sidebar-layout #ml-board-center #board {
			display: grid;
			grid-template-columns: repeat(2, minmax(140px, 1fr));
			gap: 8px;
			margin: 0;
		}

		@media (orientation: landscape) {
			body.mobile-sidebar-layout #ml-board-center #board {
				grid-template-columns: repeat(3, minmax(130px, 1fr));
				align-items: start;
			}
		}

		body.mobile-sidebar-layout #ml-board-center #board .zone {
			margin: 0;
		}

		/* Mobile sidebar styling */
		body.mobile-sidebar-layout #ml-sidebar-left #scoreboard,
		body.mobile-sidebar-layout #ml-sidebar-left #gold-zone,
		body.mobile-sidebar-layout #ml-sidebar-right #bonus-zone {
			padding: 3px 4px;
			font-size: 0.6rem;
		}

		body.mobile-sidebar-layout #ml-sidebar-left #scoreboard h2,
		body.mobile-sidebar-layout #ml-sidebar-left #gold-zone h2,
		body.mobile-sidebar-layout #ml-sidebar-right #bonus-zone h2 {
			display: none;
		}

		/* Gold zone in left sidebar */
		body.mobile-sidebar-layout #ml-sidebar-left #gold-zone {
			display: flex;
			flex-direction: column;
			align-items: center;
			gap: 2px;
			padding: 4px;
			background: rgba(255, 215, 0, 0.15);
			border-radius: 6px;
		}

		body.mobile-sidebar-layout #ml-sidebar-left #gold-zone::after {
			content: attr(data-coin-text);
			display: block;
			font-size: 0.6rem;
			font-weight: 700;
			padding-left: 20px; /* ruimte voor het CSS-coin icoon */
			position: relative;
		}

		/* CSS-drawn coin voor compatibele weergave (fallback voor Emoji/Edge) */
		body.mobile-sidebar-layout #ml-sidebar-left #gold-zone::before {
			content: '';
			position: absolute;
			left: 0;
			top: 50%;
			transform: translateY(-50%);
			width: 14px;
			height: 14px;
			border-radius: 50%;
			background: radial-gradient(circle at 30% 30%, #fff6b5, #f7bb36 60%, #d49f20);
			box-shadow: inset 0 -1px 2px rgba(0,0,0,0.2);
			border: 1px solid #c9960a;
		}

body.mobile-sidebar-layout.mobile-sidebar-layout #ml-sidebar-left #gold-zone .buy-placement-btn {
			padding: 3px 5px;
			font-size: 0.45rem;
			display: block;
		}

body.mobile-sidebar-layout.mobile-sidebar-layout #ml-sidebar-left #gold-zone #collected-coins {
			display: none;
		}

		@media (orientation: landscape) {
			body.mobile-sidebar-layout #ml-sidebar-left #gold-zone::after {
				font-size: 0.6rem;
			}

			body.mobile-sidebar-layout #ml-sidebar-left #gold-zone .buy-placement-btn {
				padding: 3px 5px;
				font-size: 0.45rem;
			}
		}

		body.mobile-sidebar-layout #ml-sidebar-left #scoreboard .score-row {
			padding: 1px 2px;
			font-size: 0.55rem;
		}

		body.mobile-sidebar-layout #ml-sidebar-left #scoreboard .score-row .label {
			display: none;
		}

		body.mobile-sidebar-layout #ml-sidebar-left #scoreboard .score-row .color-box {
			width: 8px;
			height: 8px;
		}

		body.mobile-sidebar-layout #ml-sidebar-left #scoreboard .score-total {
			font-size: 0.7rem;
			padding: 2px;
		}

		body.mobile-sidebar-layout #ml-sidebar-left #scoreboard .score-total .label {
			display: none;
		}

		body.mobile-sidebar-layout .bonus-inventory {
			flex-direction: column;
			gap: 1px;
		}

		body.mobile-sidebar-layout .bonus-badge {
			padding: 2px 4px;
			font-size: 0.5rem;
		}

		body.mobile-sidebar-layout .bonus-count {
			font-size: 0.45rem;
			padding: 1px 3px;
		}

		body.mobile-sidebar-layout #ml-sidebar-right #card-choice-zone {
			padding: 3px;
			display: flex;
			flex-direction: column;
			gap: 4px;
		}

		body.mobile-sidebar-layout #ml-sidebar-right #card-choice-zone h2,
		body.mobile-sidebar-layout #ml-sidebar-right #kiesKaartTitel,
		body.mobile-sidebar-layout #ml-sidebar-right #card-choice-zone br {
			display: none;
		}

		body.mobile-sidebar-layout #ml-sidebar-right #card-options {
			flex-direction: column;
			gap: 3px;
			order: 1;
		}

		/* Action buttons below cards */
		body.mobile-sidebar-layout #ml-sidebar-right #card-action-buttons {
			order: 2;
			flex-direction: row;
			flex-wrap: wrap;
			justify-content: center;
			gap: 3px;
			margin-top: 4px;
			padding-top: 4px;
			border-top: 1px solid rgba(0,0,0,0.1);
		}

		/* Portrait: smaller cards */
		body.mobile-sidebar-layout #ml-sidebar-right .card-option {
			width: 44px;
			min-height: 50px;
			padding: 2px;
			--preview-cell: 6px;
		}

		body.mobile-sidebar-layout #ml-sidebar-right .card-option .card-cell {
			width: 6px;
			height: 6px;
		}

		body.mobile-sidebar-layout #ml-sidebar-right .card-label {
			font-size: 0.4rem;
			padding: 1px 2px;
		}

		/* Landscape: allow slightly larger cards */
		@media (orientation: landscape) {
			body.mobile-sidebar-layout #ml-sidebar-right .card-option {
				width: 58px;
				min-height: 70px;
				padding: 4px;
				--preview-cell: 10px;
			}

			body.mobile-sidebar-layout #ml-sidebar-right .card-option .card-cell {
				width: 9px;
				height: 9px;
			}

			body.mobile-sidebar-layout #ml-sidebar-right .card-label {
				font-size: 0.5rem;
				padding: 2px 4px;
			}
		}

		body.mobile-sidebar-layout #ml-sidebar-right .card-action-btn {
			width: 22px;
			height: 22px;
			min-width: 22px;
			padding: 2px;
		}

		body.mobile-sidebar-layout #ml-sidebar-right .card-action-btn::before {
			font-size: 0.65rem;
		}

		/* Landscape: larger action buttons */
		@media (orientation: landscape) {
			body.mobile-sidebar-layout #ml-sidebar-right .card-action-btn {
				width: 24px;
				height: 24px;
				min-width: 24px;
				padding: 3px;
			}

			body.mobile-sidebar-layout #ml-sidebar-right .card-action-btn::before {
				font-size: 0.7rem;
			}
		}
		
		.zone.portal-active {
			box-shadow: 0 0 16px 5px rgba(100, 200, 255, 0.7);
			/* Animation removed for performance - static glow */
		}

		/* Blue zone scroll - lang uitgezoomd, kort ingezoomd */


		#blue-zone.zoom-focus {
			/* Keep the zoomed blue zone ~2/3 of the viewport height. */
			max-height: 66vh;
			overflow-y: auto;
			overflow-x: hidden;
			/* Keep blue scrollable but hide the scrollbar visuals (no "scroll wheel"). */
			scrollbar-width: none; /* Firefox */
			-ms-overflow-style: none; /* IE/Edge legacy */
		}
		#blue-zone.zoom-focus::-webkit-scrollbar {
			width: 0;
			height: 0;
			display: none;
		}

		/*
		#red-zone {
			width: 430px;
		}
			*/

		#original-card-zone {
			width: 430px;
		}

		/* Zone navigation arrows */
		.zone-nav-arrow {
			position: fixed;
			top: 50%;
			transform: translateY(-50%);
			z-index: calc(var(--z-zoom) + 1);
			background: rgba(255, 255, 255, 0.9);
			border: 2px solid rgba(40, 55, 120, 0.3);
			border-radius: 50%;
			width: 48px;
			height: 48px;
			display: flex;
			align-items: center;
			justify-content: center;
			font-size: 24px;
			cursor: pointer;
			transition: all 0.2s ease;
			box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
			user-select: none;
		}

		/* Hide zone arrows while dragging to keep cells visible on mobile zoom */
		body.dragging .zone-nav-arrow {
			opacity: 0;
			pointer-events: none;
		}

		.zone-nav-arrow:hover {
			background: rgba(255, 255, 255, 1);
			transform: translateY(-50%) scale(1.1);
			box-shadow: 0 6px 16px rgba(0, 0, 0, 0.3);
		}

		.zone-nav-arrow:active {
			transform: translateY(-50%) scale(0.95);
		}

		.zone-nav-arrow-left {
			left: 20px;
		}

		.zone-nav-arrow-right {
			right: 20px;
		}

		.zone-nav-arrow {
			background: rgba(30, 35, 50, 0.9);
			border-color: rgba(140, 150, 200, 0.4);
			color: rgba(240, 242, 255, 0.9);
		}

		.zone-nav-arrow:hover {
			background: rgba(40, 45, 60, 1);
		}

		/* === Mobile scaling tweaks (<=650px) === */

	/* ============================================
	   CARD CHOICE ZONE - ADDITIONAL FEATURES
	   ============================================
	   Golden cards and selection disabled states
	*/
	.card-option.card-golden {
		/* Golden card = golden frame + subtle glow */
		--card-border: 2px solid rgba(210,170,50,0.85);
		--card-shadow: 0 4px 8px rgba(0,0,0,0.12), 0 12px 24px rgba(30,50,100,0.15), 0 0 20px rgba(200,160,40,0.2);
	}

	/* Static golden shine effect - no animation for better performance */
	.card-option.card-golden::before {
		content: '';
		position: absolute;
		top: 0;
		left: 0;
		right: 0;
		bottom: 0;
		background: linear-gradient(135deg, 
			rgba(255,220,100,0.15) 0%, 
			rgba(255,255,255,0.25) 25%, 
			rgba(255,220,100,0.1) 50%,
			rgba(255,255,255,0.2) 75%,
			rgba(255,220,100,0.15) 100%);
		pointer-events: none;
		border-radius: inherit;
		z-index: 3;
	}

	.card-option.card-golden .card-pattern {
		position: relative;
		z-index: 4;
		margin: auto;
		flex: 1 1 auto;
		display: grid;
		place-items: center;
		align-self: center;
		justify-self: center;
	}
	
	.card-option.card-golden .card-label,
	.card-option.card-golden .card-meta {
		position: relative;
		z-index: 4;
	}
	
	/* Ensure all badges show above the golden shine - use absolute positioning */
	.card-option.card-golden .card-boost-badge {
		position: absolute;
		top: 6px;
		left: 6px;
		z-index: 6;
	}
	
	.card-option.card-golden .card-meta--echo {
		position: absolute;
		left: 8px;
		bottom: 8px;
		z-index: 6;
	}
	
	.card-option.card-golden .card-label--echo {
		position: absolute;
		right: 8px;
		bottom: 8px;
		z-index: 6;
	}

	#card-choice-zone .card-option.selection-disabled {
		opacity: 0.45;
		pointer-events: none;
		filter: grayscale(0.25);
	}

	.card-option.card-golden {
		--card-border: 2px solid rgba(200,160,40,0.75);
		--card-shadow: 0 2px 4px rgba(0,0,0,0.2), 0 8px 24px rgba(0,0,0,0.3), 0 0 24px rgba(200,160,40,0.18);
	}

	.card-option.card-golden::before {
		background: linear-gradient(135deg, 
			rgba(255,200,80,0.12) 0%, 
			rgba(255,220,120,0.2) 25%, 
			rgba(255,200,80,0.08) 50%,
			rgba(255,220,120,0.15) 75%,
			rgba(255,200,80,0.12) 100%);
	}

	#card-choice-zone .card-option.selection-disabled {
		opacity: 0.32;
		filter: grayscale(0.4);
	}

	/* Deck kopie kaart (extraHandSize upgrade) */
	#card-choice-zone .card-option.card-deck-copy {
		position: relative;
		border: none;
	}
	#card-choice-zone .card-option.card-deck-copy::before {
		display: none;
		content: '';
	}
	#card-choice-zone .card-option.card-deck-copy {
		border-color: transparent;
	}
	#card-choice-zone .card-option.card-deck-copy::before {
		display: none;
	}

	/* Lucky draw kopie kaart */
	#card-choice-zone .card-option.card-lucky-copy {
		position: relative;
		border: none;
	}
	#card-choice-zone .card-option.card-lucky-copy::before {
		display: none;
		content: '';
	}
	#card-choice-zone .card-option.card-lucky-copy {
		border-color: transparent;
	}
	#card-choice-zone .card-option.card-lucky-copy::before {
		display: none;
	}

	@media (max-width: 650px) {
		#bottom-bar {
			padding-left: 5px;
			padding-right: 5px;
			margin-bottom: 5px;
		}

		#bottom-bar-score,
		#bottom-bar-coins {
			flex: 0 0 50%;
			min-width: 0;
		}

		#bottom-bar #scoreboard,
		#bottom-bar #gold-zone {
			width: 100%;
			padding: 6px 8px;
			box-sizing: border-box;
		}

		#bottom-bar #gold-zone {
			min-width: 0;
			gap: 9px;
		}

		#bottom-bar #card-options .card-option {
			max-width: 110px;
		}

		.bottom-bar-footer {
			display: flex;
			flex-direction: column;
			align-items: stretch;
			gap: 2px;
			justify-content: flex-start;
			margin-top: 10px;
		}

		#bottom-bar-left {
			display: flex;
			flex-direction: column;
			flex-wrap: nowrap;
			gap: 4px;
			flex: 1 1 auto;
			min-width: 0;
			align-items: stretch;
		}

		#bottom-bar-bonus {
			order: 2;
			flex: 0 0 auto;
			display: flex;
			flex-direction: column;
			align-items: stretch;
			justify-content: flex-start;
			gap: 8px;
		}

		#bottom-bar-score-coins {
			display: flex;
			flex-direction: row;
			gap: 4px;
			align-items: center;
			order: 3;
			flex: 1 1 auto;
			min-width: 0;
		}

		#bottom-bar-score {
			flex: 1 1 auto;
			min-width: 0;
		}

		#bottom-bar-coins {
			display: none;
		}

		#bottom-bar #bonus-zone {
			width: auto;
			flex: 1 1 auto;
			min-width: 0;
			padding: 6px 8px;
		}

		/* Place the coin panel next to the bonus inventory. */
		#bottom-bar-bonus #gold-zone {
			width: 100%;
			flex: 0 0 auto;
			padding: 3px 6px;
			margin: 0;
			display: flex;
			flex-direction: column;
			align-items: stretch;
			justify-content: flex-start;
			gap: 4px;
		}
		#bottom-bar-bonus #gold-zone .buy-placement-btn {
			margin-left: 0;
		}

		:root {
			--bottom-bar-height: 110px;
			--bottom-bar-gap: 4px;
			--bottom-bar-bottom-offset: -16px;
			--card-hand-lift: 0px;
		}

		#bottom-bar #card-options {
			padding-left: 0;
			padding-right: 0;
			touch-action: none;
			overflow-y: hidden;
		}

		#bonus-zone .bonus-hint {
			display: none;
		}

		#bottom-bar #scoreboard {
			--score-chip-gap: 3px;
		}

		/* Hide desktop bonus-zone on mobile (it's in bottom-bar) */
		#original-bonus-zone {
			display: none;
		}

		#bottom-bar #scoreboard .score-row {
			font-size: 0.62rem;
			padding: 2px 4px;
		}

		#bottom-bar #scoreboard .score-row .color-box {
			width: 8px;
			height: 8px;
		}

		#bottom-bar #scoreboard .score-row .score {
			font-size: 0.66rem;
		}

		#bottom-bar #scoreboard .score-total {
			font-size: 0.68rem;
		}

		#bottom-bar #scoreboard .score-total .total-score {
			font-size: 0.78rem;
		}

		#bottom-bar #scoreboard .score-total .label {
			font-size: 0.64rem;
		}

		#bottom-bar #new-cards-btn {
			height: 36px;
			padding: 6px 11px;
			font-size: 0.66rem;
		}

		#bottom-bar #rotate-card-btn {
			height: 34px;
			padding: 6px 10px;
			font-size: 0.62rem;
			width: 102px;
			margin-top: 6px;
		}

		#bottom-bar #collected-coins {
			grid-template-rows: repeat(3, 12px);
			grid-auto-columns: 12px;
			column-gap: 4px;
			row-gap: 4px;
		}

		#bottom-bar .coin {
			width: 12px;
			height: 12px;
		}
	}

	@media (max-width: 520px) {
	  :root {
		--bottom-bar-height: 110px;
		--bottom-bar-gap: 4px;
		--card-hand-lift: 0px;
	  }

	  #bottom-bar {
		padding-left: 4px;
		padding-right: 4px;
		padding-bottom: 4px;
	  }

	  #bottom-bar-cards {
		margin-top: 0;
		height: calc(var(--hand-card-height) + 10px);
	  }

	  #bottom-bar #card-options {
		display: flex;
		gap: 4px;
		align-items: flex-start;
		justify-content: flex-start;
		flex-wrap: nowrap;
		scroll-snap-type: x proximity;
		flex: 1 1 auto;
		min-width: 0;
		width: auto;
		max-width: 100%;
		transform: translateY(0px);
		padding: 0 0 8px 0;
		touch-action: pan-x;
		overflow-x: auto;
		overflow-y: hidden;
		scrollbar-width: thin;
		scrollbar-color: rgba(255,255,255,0.3) transparent;
	  }
	  
	  #bottom-bar #card-options::-webkit-scrollbar {
		height: 4px;
	  }
	  #bottom-bar #card-options::-webkit-scrollbar-track {
		background: transparent;
		border-radius: 2px;
	  }
	  #bottom-bar #card-options::-webkit-scrollbar-thumb {
		background: linear-gradient(90deg, rgba(255,255,255,0.25), rgba(200,210,255,0.35));
		border-radius: 2px;
	  }
	  #bottom-bar #card-options::-webkit-scrollbar-thumb:hover {
		background: linear-gradient(90deg, rgba(255,255,255,0.4), rgba(200,210,255,0.5));
	  }


	  #bottom-bar #card-choice-zone .card-option .card-cell {
		width: 8px;
		height: 8px;
	  }

	  #bottom-bar #card-choice-zone .card-option .card-pattern {
		gap: var(--preview-gap);
	  }

	  #bottom-bar #card-choice-zone .card-option .card-label {
		font-size: 0.52rem;
		padding: 1px 4px;
		gap: 1px;
	  }

	  #bottom-bar #card-choice-zone .card-option .card-label .label-dot {
		width: 5px;
		height: 5px;
	  }

	  #bottom-bar #new-cards-btn,
	  #bottom-bar #rotate-card-btn {
		width: 40px;
		height: 40px;
	  }

	  #bottom-bar #new-cards-btn::before {
		font-size: 1.6rem;
	  }

	  #bottom-bar #rotate-card-btn::before {
		font-size: 1.4rem;
	  }

	  .deck-count {
		padding: 5px 10px;
		font-size: 0.9rem;
		min-width: 45px;
		gap: 5px;
		border-radius: 9px;
	  }

	  .deck-count::before {
		font-size: 1rem;
	  }


	  #bottom-bar-left {
		gap: 3px;
	  }

	  .bottom-bar-footer {
		padding: 2px 3px 0;
	  }
	}


	@media (max-width: 650px) {
		:root {
			/* Use 0.5 for pixel-perfect scaling: 2px gaps become clean 1px after scaling */
			--board-scale: 0.5;
		}

		/* Classic mode (mobile): show ONLY the board + hamburger menu. */
		body.classic-mode #bottom-bar,
		body.classic-mode #card-choice-zone,
		body.classic-mode #bonus-zone,
		body.classic-mode #scoreboard,
		body.classic-mode #objective-zone,
		body.classic-mode #mobile-objective-banner,
		body.classic-mode #buy-placement-container,
			body.classic-mode #original-coins-zone,
			body.classic-mode #gold-zone,
			body.classic-mode .zone-info-btn,
		body.classic-mode .zone-info-popover {
			display: none;
		}

		/* Classic mode: don't scale down; board should fill the screen. */
		body.classic-mode {
			--board-scale: 1;
		}

		/* Hide the legacy UI column so the board uses the full width. */
		body.classic-mode #board > .column:last-child {
			display: none;
		}

		#original-card-zone {
			width: auto;
			max-width: 100%;
		}

		.board {
			gap: 2px;
			margin: 0;
			margin-top: 10px;
			margin-left: 5px;
			padding: 2px;
			transform-origin: top left;
			transition: transform 0.4s ease;	
			left: 50%;
			transform: translateX(-50%) scale(var(--board-scale, 0.5));
			max-height: none;
		}

		/* Bottom bar: keep hand cards same cell size as board, allow full card styling and labels. */
		#bottom-bar #card-choice-zone .card-option {
			width: 138px;
			min-height: 180px;
			padding: 10px;
			gap: 8px;
		}
		#bottom-bar #card-choice-zone .card-option .card-cell {
			width: var(--cell-size);
			height: var(--cell-size);
			border-radius: var(--cell-radius);
		}
		#bottom-bar #card-choice-zone .card-pattern {
			gap: var(--card-preview-gap);
		}

		/* Red zone sub-grids: center the grid inside each quadrant (also when NOT zoomed). */
		#red-zone.red-group > .zone {
			display: flex;
			align-items: center;
			justify-content: center;
		}
		#red-zone.red-group .grid {
			margin: 0;
		}

		/* Zones compacter maken voor betere fit */
		/* Green grid (lichtgroene binnenste area) beperken (niet tijdens zoom) */
		body:not(.zoomed-in) #green-grid {
			min-width: calc(15 * var(--cell-size));
			max-width: calc(15 * var(--cell-size) + 20px);
		}
		/* Zoomed-in: only the ACTIVE (zoom-focused) green zone may widen */
		body.zoomed-in #green-zone.zoom-focus #green-grid {
			min-width: calc(30 * var(--cell-size));
			max-width: calc(30 * var(--cell-size) + 20px);
		}

		/* Mobile: blue is vertically long by design; keep it scrollable but not a giant strip. */
		body:not(.zoomed-in) #blue-zone,
		#blue-zone--placeholder {
			overflow: auto;
		}

		/* World 2: verberg de (witte) scrollbar in de blauwe zone (blijft wel scrollbaar) */
		#blue-zone {
			scrollbar-width: none;
			-ms-overflow-style: none;
		}
		#blue-zone::-webkit-scrollbar {
			width: 0;
			height: 0;
			display: none;
		}

		/* Blue zone met scroll in zoom voor kaarten zichtbaarheid */
		#blue-zone.zoom-focus {
			max-height: 66vh;
			overflow-y: auto;
			scrollbar-width: none;
			-ms-overflow-style: none;
		}
		#blue-zone.zoom-focus::-webkit-scrollbar {
			width: 0;
			height: 0;
			display: none;
		}
		
	}

	@media (max-width: 600px) {
			:root {
				--bottom-bar-height: 115px;
				--zoom-top: 32%;
				--zoom-scale: 0.95;
			}
		.board {
			gap: 3px;
		}

		/* Green grid (lichtgroene binnenste area) beperken (niet tijdens zoom) */
		body:not(.zoomed-in) #green-grid {
			min-width: calc(15 * var(--cell-size));
			max-width: calc(15 * var(--cell-size) + 20px);
		}
		/* Zoomed-in: only the ACTIVE (zoom-focused) green zone may widen */
		body.zoomed-in #green-zone.zoom-focus #green-grid {
			min-width: calc(30 * var(--cell-size));
			max-width: calc(30 * var(--cell-size) + 20px);
		}

		#blue-zone.zoom-focus {
			max-height: 66vh;
		}

		/* Red zone: behoud originele verhoudingen bij zoom */
		#red-zone.zoom-focus {
		  flex-wrap: wrap;
		  flex-direction: row;
		  width: auto;
		  min-width: 380px;
		  height: auto;
		  max-width: 90vw;
		}
		
	}
	
	@media (max-width: 550px) {
			:root {
				--bottom-bar-height: 115px;
				--zoom-top: 35%;
				--zoom-scale: 0.95;
			}
		.board {
			gap: 3px;
		}

		#blue-zone.zoom-focus {
			max-height: 66vh;
		}

		/* Red zone: behoud originele verhoudingen bij zoom */
		#red-zone.zoom-focus {
		  flex-wrap: wrap;
		  flex-direction: row;
		  width: auto;
		  min-width: 380px;
		  height: auto;
		  max-width: 90vw;
		}
	
	}
	  
	@media (max-width: 490px) {
	
		:root {
			--bottom-bar-height: 110px;
		}
	
		.board {
			gap: 2px;
			padding: 0;
		}


		#blue-zone.zoom-focus {
			max-height: 66vh;
		}
		
		.zone.zoom-focus {
			max-height: 80vh;
			overflow: hidden;
		}
		#blue-zone.zoom-focus {
			overflow-y: auto;
		}



		.bottom-bar-footer {
			margin-top: 0px;
			padding-top: 0px;
		}
	
	}

	@media (max-width: 410px) {
	
		:root {
			--bottom-bar-height: 110px;
			--zoom-scale: 0.93;
		}
	
		.board {
			gap: 2px;
		}


	}
	
	@media (max-width: 390px) {
	
		:root {
			--bottom-bar-height: 110px;
			--zoom-scale: 0.60;
		}
	
		.board {
			gap: 2px;
		}

	
	}

	/* ============================================
	   ZONE HEADERS
	   ============================================
	   H2 titels die bovenaan elke zone verschijnen (bijv. "Geel vak", "Blauw vak")
	   Dark mode krijgt lichtere grijstint voor betere leesbaarheid
	*/
	h2 { color: #555; margin:0 0 8px; font-size:1rem; text-align:center }
	h2 { color: #b0b0b0; }

	/* ============================================
	   ZONE KLEUREN & AFMETINGEN
	   ============================================
	   Elk speelvak (zone) krijgt zijn eigen kleur, breedte en hoogte
	   Placeholder varianten zijn voor drag-and-drop preview
	   Dark mode krijgt donkere gradient overlays (zie verderop)
	*/
	#yellow-zone,
	#yellow-zone--placeholder { background: var(--zone-yellow); height: 450px; min-width: 300px; padding: 14px; }
	/* World 3: yellow zone should not stretch to the (wide) column; match grid/purple width.
	   IMPORTANT: keep zoomed-in view consistent across worlds, so apply only when NOT zoomed. */
	body.world-3:not(.zoomed-in) #yellow-zone,
	body.world-3:not(.zoomed-in) #yellow-zone--placeholder {
		min-width: 0;
		width: fit-content;
		align-self: center;
		padding: 10px;
	}
	/* Yellow (World 2): keep the generated grid visually centered (equal top/bottom spacing). */
	#yellow-zone,
	#yellow-zone--placeholder {
		display: flex;
		flex-direction: column;
		align-items: center;
		justify-content: center;
	}
	#green-zone,
	#green-zone--placeholder { background: var(--zone-green); }
	/* Mobile layout: keep green aligned with red (same outer margin). */
	@media (max-width: 650px) {
		#green-zone,
		#green-zone--placeholder {
			/* Reduce the vertical gap to the red zone, keep L/R equal. */
			margin: 10px;
		}
		#red-zone,
		#red-zone--placeholder {
			/* Reduce the vertical gap to the green zone, keep L/R equal. */
			margin: 10px;
		}

		/* World 1: keep purple grid visually centered (equal margins on all sides). */
		body.world-1 #purple-zone,
		body.world-1 #purple-zone--placeholder {
			display: flex;
			flex-direction: column;
			align-items: center;
			justify-content: center;
		}
	}
	/* World 2: keep green zone square (same width, more height). */
	body.world-2:not(.zoomed-in) #green-zone,
	body.world-2:not(.zoomed-in) #green-zone--placeholder {
		/* Width is set below; match height to that width. */
		height: calc(13 * var(--cell-size) + 80px);
		max-height: calc(13 * var(--cell-size) + 80px);
		overflow: auto;
	}
	/* Green (World 2 request): hide scrollbar visuals while keeping scroll. */
	#green-zone {
		scrollbar-width: none; /* Firefox */
		-ms-overflow-style: none; /* IE/Edge legacy */
	}
	#green-zone::-webkit-scrollbar {
		width: 0;
		height: 0;
		display: none;
	}
	#green-zone {
		cursor: grab;
	}
	#green-zone.drag-scroll-active {
		cursor: grabbing;
	}
	/* World 1: disable scrolling in green zone */
	#green-zone.no-scroll {
		overflow: hidden;
		cursor: default;
	}
	#green-zone.no-scroll.drag-scroll-active {
		cursor: default;
	}
	body.world-1 #green-zone,
	body.world-1 #green-zone--placeholder {
		overflow: hidden;
	}
	body.world-1 #green-zone #green-grid {
		max-height: none;
	}

	/* Desktop: beperk groene en rode zone breedte */
	@media (min-width: 651px) {
		#green-zone,
		#green-zone--placeholder {
			width: calc(13 * var(--cell-size) + 80px);
			max-width: calc(13 * var(--cell-size) + 80px);
		}
		#green-grid {
			max-width: calc(13 * var(--cell-size) + 40px);
		}
		/* Red zone should match the green zone width (user request). */
		#red-zone,
		#red-zone--placeholder {
			width: calc(13 * var(--cell-size) + 80px);
			max-width: calc(13 * var(--cell-size) + 80px);
			margin: 0;
		}
	}

	#yellow-zone,
	#yellow-zone--placeholder,
	#purple-zone,
	#purple-zone--placeholder {
		overflow: hidden;
	}
	#purple-zone,
	#purple-zone--placeholder { background: var(--zone-purple); height: 310px; }
	#blue-zone,
	#blue-zone--placeholder { background: var(--zone-blue); height: 760px; }

	/* World 4: keep the 3 visible zones aligned (same height as the blue zone) */
	@media (min-width: 651px) {
		body.world-4:not(.zoomed-in) #yellow-zone,
		body.world-4:not(.zoomed-in) #green-zone {
			height: 760px;
			max-height: 760px;
			overflow: auto;
		}

		/* World 4: distinct yellow styling (richer tone + subtle glow) */
		body.world-4:not(.zoomed-in) #yellow-zone {
			background: linear-gradient(135deg, rgba(251, 233, 160, 0.95), rgba(240, 198, 82, 0.95));
			border: 1px solid rgba(170, 130, 20, 0.35);
			box-shadow: 0 10px 20px rgba(110, 80, 0, 0.15);
		}
		body.world-4:not(.zoomed-in) #yellow-zone .cell:not(.void-cell) {
			border-color: rgba(140, 105, 20, 0.35);
			background: rgba(255, 252, 230, 0.95);
		}
		body.world-4:not(.zoomed-in) #yellow-zone .cell.active {
			box-shadow: 0 0 0 1px rgba(255, 210, 90, 0.45), 0 2px 6px rgba(80, 60, 0, 0.18);
		}

		/* World 4: force the 3 active zones to be true side-by-side columns */
		body.world-4:not(.zoomed-in) #board.board {
			display: grid;
			grid-template-columns: repeat(3, minmax(0, 1fr)) minmax(280px, 360px);
			align-items: start;
			gap: 12px;
		}
		body.world-4:not(.zoomed-in) #board.board > .column:nth-child(1),
		body.world-4:not(.zoomed-in) #board.board > .column:nth-child(2),
		body.world-4:not(.zoomed-in) #board.board > .column:nth-child(3) {
			display: contents;
		}
		body.world-4:not(.zoomed-in) #board.board > .column:nth-child(4) {
			grid-column: 4;
			grid-row: 2;
			align-self: start;
		}
		body.world-4:not(.zoomed-in) #yellow-zone { grid-column: 1; grid-row: 1; }
		body.world-4:not(.zoomed-in) #green-zone { grid-column: 2; grid-row: 1; }
		body.world-4:not(.zoomed-in) #blue-zone { grid-column: 3; grid-row: 1; }
		body.world-4:not(.zoomed-in) #purple-zone { grid-column: 1; grid-row: 2; }
		body.world-4:not(.zoomed-in) #red-zone { grid-column: 2; grid-row: 2; }
		body.world-4:not(.zoomed-in) #original-card-zone { grid-column: 4; grid-row: 1; }
	}

	/* World 4: keys/doors should visually match the active zone they are placed in */
	.cell.key-cell[data-w4-ink="geel"],
	.cell.door-cell[data-w4-ink="geel"] { color: rgba(170, 135, 20, 0.95); }
	.cell.key-cell[data-w4-ink="groen"],
	.cell.door-cell[data-w4-ink="groen"] { color: rgba(40, 140, 70, 0.95); }
	.cell.key-cell[data-w4-ink="blauw"],
	.cell.door-cell[data-w4-ink="blauw"] { color: rgba(60, 130, 210, 0.95); }
	.cell.key-cell[data-w4-ink="paars"],
	.cell.door-cell[data-w4-ink="paars"] { color: rgba(150, 110, 220, 0.95); }
	.cell.key-cell[data-w4-ink="rood"],
	.cell.door-cell[data-w4-ink="rood"] { color: rgba(220, 95, 95, 0.95); }

	/* Blue zone: vaste breedte, breder grid wordt scrollbaar */
	#blue-zone {
		width: 180px;
		max-width: 300px;
		min-width: 180px;
	}

	/* Blue (World 2): keep scroll but hide the (white) scrollbar visuals on desktop too. */
	#blue-zone {
		overflow-y: auto;
		overflow-x: auto;
		scrollbar-width: none; /* Firefox */
		-ms-overflow-style: none; /* IE/Edge legacy */
	}
	#blue-zone::-webkit-scrollbar {
		width: 0;
		height: 0;
		display: none;
	}
	#blue-zone #blue-grid {
		scrollbar-width: none;
		-ms-overflow-style: none;
	}
	#blue-zone #blue-grid::-webkit-scrollbar {
		width: 0;
		height: 0;
		display: none;
	}
	#gold-zone,
	#gold-zone--placeholder { background: var(--zone-gold); height: 100px; width: 280px; box-shadow: 0 0 8px var(--shadow-medium); }
	#red-zone,
	#red-zone--placeholder { background: var(--zone-red); height: auto; margin: 10px; border-radius: var(--radius-md); box-shadow: 0 2px 6px var(--shadow-light);
	  box-sizing: border-box; padding: 10px; touch-action: manipulation; overflow: visible; position: relative; }
	#red-zone.red-group {
		display: grid;
		grid-template-columns: repeat(2, max-content);
		justify-content: center;
		gap: 18px;
	}
	/* World 3: lock overlay for the red-stage transition (does not participate in grid layout). */
	#world3-red-lock {
		position: absolute;
		inset: 0;
		display: none;
		align-items: center;
		justify-content: center;
		pointer-events: none;
		z-index: 20;
		color: rgba(0, 0, 0, 0.48);
		opacity: 0.85;
	}
	#world3-red-lock {
		color: rgba(255, 255, 255, 0.38);
	}
	#world3-red-lock svg {
		width: 44px;
		height: 44px;
		display: block;
	}
	#red-zone.red-group > .zone {
		margin: 0;
	}
	/* Red subgrid points label (shows how many points a full subgrid yields). */
	#red-zone .red-grid-points-label {
		position: absolute;
		top: 4px;
		left: 4px;
		z-index: 25;
		pointer-events: none;
		font-size: 0.72rem;
		font-weight: 700;
		padding: 2px 7px;
		border-radius: 12px;
		background: #ffd6d1;
		border: 1px solid #ff7b73;
		color: #4b0000;
		line-height: 1;
	}
	  
	#red-grid1,
	#red-grid1--placeholder { background: var(--zone-red); margin: 10px; border-radius: 0; border:0; box-shadow: none; }
	#red-grid2,
	#red-grid2--placeholder { background: var(--zone-red); margin: 10px; border-radius: 0; border:0; box-shadow: none; }
	#red-grid3,
	#red-grid3--placeholder { background: var(--zone-red); margin: 10px; border-radius: 0; border:0; box-shadow: none; }
	#red-grid4,
	#red-grid4--placeholder { background: var(--zone-red); margin: 10px; border-radius: 0; border:0; box-shadow: none; }
	#red-grid5,
	#red-grid5--placeholder { background: var(--zone-red); margin: 10px; border-radius: 0; border:0; box-shadow: none; }
	#red-grid6,
	#red-grid6--placeholder { background: var(--zone-red); margin: 10px; border-radius: 0; border:0; box-shadow: none; }
	@media (min-width: 651px) {
		#red-zone.red-group #red-grid1,
		#red-zone.red-group #red-grid2,
		#red-zone.red-group #red-grid3,
		#red-zone.red-group #red-grid4,
		#red-zone.red-group #red-grid5,
		#red-zone.red-group #red-grid6 {
			margin: 0;
		}
	}
	/* When red-zone is zoomed, remove subgrid margins so the container doesn't overflow. */
	body.zoomed-in #red-zone.zoom-focus #red-grid1,
	body.zoomed-in #red-zone.zoom-focus #red-grid2,
	body.zoomed-in #red-zone.zoom-focus #red-grid3,
	body.zoomed-in #red-zone.zoom-focus #red-grid4,
	body.zoomed-in #red-zone.zoom-focus #red-grid5,
	body.zoomed-in #red-zone.zoom-focus #red-grid6 {
		margin: 0;
	}

	/* DARK MODE: Override zone kleuren met donkere gradient */

	#gold-zone--placeholder { 
		background: linear-gradient(145deg, #2d2920, #232119);
		border: 1px solid #3d3930;
	}
	

	/* ============================================
	   CEL KLEUREN PER ZONE
	   ============================================
	   Elke zone heeft cellen met hun eigen kleur schema
	   .cell = standaard (niet ingevuld)
	   .cell.active = ingevuld/actief (donkerder kleur)
	   .end-cell = speciale eindcel in groen vak
	*/
	#yellow-zone .cell,
	#yellow-zone--placeholder .cell { background: var(--cell-yellow-bg); color: var(--cell-yellow-color); border-color: var(--cell-yellow-border); }
	#red-zone .cell,
	#red-zone--placeholder .cell { background: var(--cell-red-bg); color: var(--cell-red-color); border-color: var(--cell-red-border); }
	#purple-zone .cell,
	#purple-zone--placeholder .cell { background: var(--cell-purple-bg); border-color: var(--cell-purple-border); }
	#green-zone .cell,
	#green-zone--placeholder .cell { background: var(--cell-green-bg); color: var(--cell-green-color); border-color: var(--cell-green-border); } 
	#green-zone .cell.end-cell,
	#green-zone--placeholder .cell.end-cell {background-color: var(--cell-green-end); border-color: var(--cell-green-end-border); } 
	#blue-zone .cell,
	#blue-zone--placeholder .cell { background: var(--cell-blue-bg); color: var(--cell-blue-color); border-color: var(--cell-blue-border); }
	#yellow-zone .cell.active,
	#yellow-zone--placeholder .cell.active { background: var(--cell-yellow-active); border-color: var(--cell-yellow-active-border); } 
	/* Yellow: highlight completed lines/segments/rings a bit darker (all worlds). */
	#yellow-zone .cell.active.yellow-completed-path,
	#yellow-zone--placeholder .cell.active.yellow-completed-path {
		filter: brightness(0.86);
	}
	#red-zone .cell.active,
	#red-zone--placeholder .cell.active { background: var(--cell-red-active); border-color: var(--cell-red-active-border); }
	#purple-zone .cell.active,
	#purple-zone--placeholder .cell.active { background: var(--cell-purple-active); color: var(--cell-purple-active-color); border-color: var(--cell-purple-active-border); }
	#green-zone .cell.active,
	#green-zone--placeholder .cell.active { background: var(--cell-green-active); border-color: var(--cell-green-active-border); }
	#green-zone .cell.end-cell.active,
	#green-zone--placeholder .cell.end-cell.active {background-color: var(--cell-green-end-active) !important; border-color: var(--cell-green-end-active-border) !important; } 
#yellow-zone .cell.end-cell.active,
#yellow-zone--placeholder .cell.end-cell.active { background-color: #cfae4a; border-color: #b8963c; }
#purple-zone .cell.end-cell.active,
#purple-zone--placeholder .cell.end-cell.active { background-color: #7a5aa8; border-color: #62478a; }
#blue-zone .cell.end-cell.active,
#blue-zone--placeholder .cell.end-cell.active { background-color: #3b7aa4; border-color: #2f6386; }

	/* Bold start cells should keep the normal active background but have a thicker/darker border */
	#green-zone .cell.bold-cell.active,
	#green-zone--placeholder .cell.bold-cell.active {
		background-color: var(--cell-green-active); /* match normal green active */
		border-color: #2b572b;
	}

	/* Start cell in green should not use the dark end-cell active color */
	#green-zone .cell.start-cell.active,
	#green-zone--placeholder .cell.start-cell.active { background-color: var(--cell-green-active); border-color: var(--cell-green-active-border); }
	#blue-zone .cell.active,
	#blue-zone--placeholder .cell.active { background: var(--cell-blue-active); border-color: var(--cell-blue-active-border); }

	/* ============================================
	   COIN SYMBOL STYLING
	   ============================================
	   Gebruik Segoe UI Symbol / Apple Color Emoji voor coin emoji
	   zodat het correct wordt weergegeven in alle browsers
	*/
	.coin-symbol {
		font-family: "Segoe UI Symbol", "Segoe UI Emoji", "Apple Color Emoji", "Noto Color Emoji", Arial, sans-serif;
	}
	
	/* Algemene emoji ondersteuning voor toast berichten, feedback, etc. */
	.toast-message,
	.blackhole-feedback,
	.blackhole-subtext,
	.objective-toast,
	.modal-score-summary,
	.round-summary-icon,
	.card-label,
	[class*="feedback"],
	[class*="toast"] {
		font-family: "Segoe UI", -apple-system, BlinkMacSystemFont, sans-serif, "Segoe UI Symbol", "Segoe UI Emoji", "Apple Color Emoji", "Noto Color Emoji";
	}
	
	/* ============================================
	   GRID LAYOUT BASIS
	   ============================================
	   Basisstijl voor alle grid containers binnen zones
	   Gebruikt CSS Grid voor automatische cel positionering
	*/
	.grid { display: grid; gap: var(--board-grid-gap, 2px); justify-content: center; margin: 20px; }
	/* Yellow (World 2): remove inner grid margin so spacing stays even and not clipped. */
	#yellow-zone #yellow-grid.grid,
	#yellow-zone--placeholder #yellow-grid.grid {
		margin: 0;
	}
	/* Purple: match Yellow centering (no inner grid margin). */
	#purple-zone #purple-grid.grid,
	#purple-zone--placeholder #purple-grid.grid {
		margin-left: 0;
		margin-right: 0;
	}
	/* Purple: World 1 keeps vertical breathing room; Worlds 2/3 remove it. */
	body.world-1 #purple-zone #purple-grid.grid,
	body.world-1 #purple-zone--placeholder #purple-grid.grid {
		margin-top: 20px;
		margin-bottom: 20px;
	}
	body.world-2:not(.zoomed-in) #purple-zone #purple-grid.grid,
	body.world-2:not(.zoomed-in) #purple-zone--placeholder #purple-grid.grid,
	body.world-3:not(.zoomed-in) #purple-zone #purple-grid.grid,
	body.world-3:not(.zoomed-in) #purple-zone--placeholder #purple-grid.grid {
		margin-top: 0;
		margin-bottom: 0;
	}
	/* Green: remove inner margin so the darker outer rim disappears. */
	#green-zone #green-grid {
		margin: 0;
		background: transparent;
	}
	
	/* ============================================
	   CEL STIJLEN - BASIS
	   ============================================
	   De individuele cellen in elk speelvak
	   .edge-cell = rode gloed voor rand-cellen (in rood vak)
	   .bold-cell = dikke zwarte rand
	   .end-cell = groene eindcel
	   .active = ingevuld met animatie
	   .gold-cell = heeft gouden muntje symbool
	*/
	.cell.edge-cell {
	  border: 2px solid rgba(255,80,80,0.95);
	  box-shadow: 0 0 10px 3px rgba(255,80,80,0.45);
	  z-index: 6; /* op de root-cellen liggen */
	  transition: box-shadow 0.18s ease, border 0.18s ease;
	}
	.cell{
	  width: var(--cell-size);
	  height: var(--cell-size);
	  background: #f9fafc;      
	  color: #222;
	  border: 1px solid #d8dee9;
	  box-shadow: 0 1px 2px rgba(0,0,0,0.05);
	  border-radius: var(--cell-radius);
	  position:relative;
	  user-select:none;
	  display: flex;
	  align-items: center;
	  justify-content: center;
	  transition: background 0.25s, transform 0.15s;
	  animation: growRoot 0.3s forwards;
	}

	/* Green root cells are absolutely positioned; shrink + center them to create visible spacing. */
	#green-grid .root-cell:not(.void-cell) {
		width: calc(var(--cell-size) - 2px);
		height: calc(var(--cell-size) - 2px);
		transform: translate(1px, 1px);
	}



	/* WORLD 2 (Yellow): Alternate diagonal shading so players see the diagonal-row rule.
	   Keep it subtle and do NOT affect active/void cells. */
	#yellow-grid .cell.diag-shade-odd:not(.void-cell):not(.active) {
	  filter: brightness(0.985);
	}
	#yellow-grid .cell.diag-shade-odd:not(.void-cell):not(.active) {
	  filter: brightness(1.06);
	}

	/* WORLD 3 (Yellow): alternate shading per ring (dark-light-dark) to match ring scoring. */
	body.world-3 #yellow-grid .cell.ring-shade-odd:not(.void-cell):not(.active) {
	  filter: brightness(1.02);
	}
	body.world-3 #yellow-grid .cell.ring-shade-even:not(.void-cell):not(.active) {
	  filter: brightness(0.965);
	}

	/* WORLD 1 (Yellow): alternate shading per column to match column scoring. */
	body.world-1 #yellow-grid .cell.col-shade-odd:not(.void-cell):not(.active) {
	  filter: brightness(0.97);
	}
	body.world-1 #yellow-grid .cell.col-shade-even:not(.void-cell):not(.active) {
	  filter: brightness(1.02);
	}

	/* WORLD 2 (Purple): Buitenste 2 ringen met subtiel andere achtergrondkleur */
	#purple-grid .cell.outer-ring-0:not(.void-cell):not(.active) {
	  /* Buitenste ring: iets lichter (subtiel) */
	  background: #efe8f7;
	  filter: brightness(1.00);
	}
	#purple-grid .cell.outer-ring-1:not(.void-cell):not(.active) {
	  /* Tweede ring: nog iets lichter */
	  background: #f3eefb;
	  filter: brightness(1.00);
	}
	#purple-grid .cell.outer-ring-0:not(.void-cell):not(.active) {
	  background: #d3c3ea;
	  filter: brightness(0.97);
	}
	#purple-grid .cell.outer-ring-1:not(.void-cell):not(.active) {
	  background: #d9ccec;
	  filter: brightness(0.97);
	}

	/* Ensure golden card frame shows in the bottom-bar hand (more specific than the hand card background rules). */
	#bottom-bar #card-choice-zone .card-option.card-golden {
		border: 2px solid rgba(220,180,60,0.92);
		box-shadow:
			0 18px 26px rgba(10,12,20,0.2),
			0 0 0 2px rgba(220,180,60,0.50) inset,
			0 0 18px rgba(184,120,18,0.28);
	}
	#bottom-bar #card-choice-zone .card-option.card-golden {
		border: 2px solid rgba(200,160,30,0.78);
		box-shadow:
			0 26px 44px rgba(0,0,0,0.55),
			0 0 0 2px rgba(200,160,30,0.32) inset,
			0 0 18px rgba(227,196,94,0.22);
	}
	.cell.void-cell {
	  visibility: hidden;
	  pointer-events: none;
	  border: none;
	  background: transparent;
	  box-shadow: none;
	  animation: none;
	}
	.cell:hover { background: #eef3ff; }
	.cell.active { background: #cde3ff; border-color: #a8c9ff; color: #000; transform: scale(1.1); box-shadow: 0 0 8px rgba(58,111,247,0.25); }
	.cell.bold-cell { border: 2px solid #2c3333 !important; }
	.cell.end-cell{ background:#a7d6aa; border-color:#a7d6aa }
	.cell.end-cell.active{ background:#81b884 }
	.cell.trap-cell { position: relative; }
	.cell.trap-triggered {
	  box-shadow: 0 0 12px rgba(196,56,56,0.55), inset 0 0 10px rgba(196,56,56,0.45);
	  animation: trapPulse 0.5s ease;
	}

	@keyframes trapPulse {
	  0% { transform: scale(1); }
	  50% { transform: scale(1.05); }
	  100% { transform: scale(1); }
	}
	
	/* ============================================
	   SYMBOLEN IN CELLEN
	   ============================================
	   Gekleurde vierkantjes die in cellen kunnen verschijnen
	   Tonen welke kleur/zone de cel vertegenwoordigt
	*/
	.symbol { display: inline-block; width: calc(var(--cell-size) * 0.52); height: calc(var(--cell-size) * 0.52); border-radius: calc(var(--cell-size) * 0.12); margin: auto; border: calc(var(--cell-size) * 0.08) solid #444; background-color: #999; box-sizing: border-box; }
	.symbol.yellow { background-color: #fff48f; }
	.symbol.green  { background-color: #69cf57; }
	.symbol.purple { background-color: #ae7eed; }
	.symbol.blue   { background-color: #76a0e3; }
	.symbol.red    { background-color: #ed7e89; }
		.symbol.trap-symbol {
			width: calc(var(--cell-size) * 0.65);
			height: calc(var(--cell-size) * 0.65);
			border-radius: calc(var(--cell-size) * 0.06);
			background: #656565;
			border: none;
			transform: rotate(45deg) scale(0.75);
			pointer-events: none;
			position: relative;
			overflow: hidden;
			box-sizing: border-box;
		}

	.symbol.trap-symbol::after {
	  content: "";
	  position: absolute;
	  inset: 4px;
	  border-radius: 1px;
	  background: linear-gradient(135deg, rgba(255,255,255,0.2) 0%, rgba(255,255,255,0) 50%);
	  opacity: 0.8;
	}

	.symbol.trap-symbol.trap-symbol--pit::after {
	  opacity: 0.6;
	}

	.symbol.trap-symbol.trap-symbol--black-hole {
	  background: radial-gradient(circle, #1a1a2e 0%, #0a0a15 60%, #000000 100%);
	  border-radius: 50%;
	  box-shadow: 
		0 0 15px rgba(138, 43, 226, 0.6),
		0 0 25px rgba(75, 0, 130, 0.4),
		inset 0 0 20px rgba(138, 43, 226, 0.3);
	  border: 2px solid rgba(138, 43, 226, 0.4);
	}

	.symbol.trap-symbol.trap-symbol--black-hole::after {
	  background: radial-gradient(circle, rgba(138, 43, 226, 0.25) 0%, transparent 70%);
	  opacity: 1;
	  border-radius: 50%;
	  /* Animation removed for performance - static effect */
	}

	/* Mega Bonus Symbol - grotere bonus met shimmer effect */
		.symbol.mega-bonus-symbol {
			width: 120%;
			height: 120%;
			border-radius: calc(var(--cell-size) * 0.15);
			cursor: pointer;
			display: flex;
			align-items: center;
			justify-content: center;
			font-size: calc(var(--cell-size) * 0.8);
			font-weight: bold;
			position: absolute;
			top: 50%;
			left: 50%;
			transform: translate(-50%, -50%);
			transition: transform 0.2s ease;
			z-index: 15;
	  /* Static glim effect - animation removed for performance */
	  background: linear-gradient(135deg, 
		rgba(255, 255, 255, 0.35) 0%, 
		transparent 35%, 
		transparent 65%, 
		rgba(255, 255, 255, 0.35) 100%);
	  box-shadow: 0 0 18px rgba(255, 255, 255, 0.55), 
				  inset 0 0 22px rgba(255, 255, 255, 0.35);
	}

	.symbol.mega-bonus-symbol:hover {
	  transform: translate(-50%, -50%) scale(1.15);
	}

	/* Upgrade Shop Symbol - shop icoon met gouden gloed */
		.symbol.upgrade-shop-symbol {
			width: 100%;
			height: 100%;
			border-radius: calc(var(--cell-size) * 0.15);
			cursor: pointer;
			display: flex;
			align-items: center;
			justify-content: center;
			font-size: calc(var(--cell-size) * 0.8);
			font-weight: bold;
			position: absolute;
			top: 50%;
			left: 50%;
			transform: translate(-50%, -50%);
			transition: transform 0.2s ease;
			z-index: 15;
		/* Diamond-like cool gradient to distinguish from traps */
		background: linear-gradient(135deg, #e6fbff 0%, #bfefff 40%, #9ad8ff 100%);
		color: #0b3b4a;
		box-shadow: 0 0 8px rgba(60,160,200,0.25), inset 0 0 6px rgba(255,255,255,0.6);
	}

/* Diamond glyph styling for inline text (toasts, titles) */
.diamond-glyph { color: #0b3b4a; font-weight: 700; text-shadow: 0 1px 0 rgba(255,255,255,0.25); }
.diamond-glyph { color: #bfefff; }

	.symbol.upgrade-shop-symbol:hover {
	  transform: translate(-50%, -50%) scale(1.15);
	}

	@keyframes upgrade-shop-glim {
	  0%, 100% { 
		background-position: 0% 50%;
	  }
	  50% { 
		background-position: 100% 50%;
	  }
	}

	@keyframes mega-bonus-glim {
	  0%, 100% { 
		background-position: 0% 50%;
	  }
	  50% { 
		background-position: 100% 50%;
	  }
	}

	@keyframes black-hole-pulse {
		0%, 100% {
			transform: scale(1);
			opacity: 0.8;
		}
		50% {
			transform: scale(1.1);
			opacity: 1;
		}
	}
	
	/* Portal cel styling - animations removed for performance */
	.portal-cell {
		box-shadow: 0 0 20px rgba(100, 150, 255, 0.9), inset 0 0 18px rgba(100, 150, 255, 0.6);
		z-index: 10;
	}

	.portal-symbol {
		position: absolute;
		top: 50%;
		left: 50%;
		transform: translate(-50%, -50%);
		font-size: calc(var(--cell-size) * 0.9);
		z-index: 100;
		pointer-events: none;
		filter: drop-shadow(0 0 12px rgba(100, 150, 255, 1));
		text-shadow: 0 0 18px rgba(100, 150, 255, 0.9);
		/* No rotation animation - static for performance */
	}
	
	/* Gouden muntje binnen een cel (gebruikt ::after pseudo-element) */
	.gold-cell::after { content: ""; position: absolute; top: 4px; left: 4px; width: 12px; height: 12px; border-radius: 50%; background: #ffea63; border: 2px solid #171615; z-index: 1; }
	.cell.active.gold-cell::after{ background:#edcd21 }
	
	/* ============================================
	   MUNTEN VERZAMELING (GOUDEN VAK)
	   ============================================
	   Container voor de 20 muntjes in het gouden vak
	   Toont hoeveel munten je hebt verzameld/gebruikt
	*/
	#collected-coins{ display:flex; gap:6px; flex-wrap:wrap; justify-content:center; margin-top:5px;  }
	
	/* ============================================
	   INDIVIDUELE MUNTEN
	   ============================================
	   Elk muntje heeft 3 states:
	   - standaard (grijs, niet verzameld)
	   - .active (goudkleurig, verzameld maar niet gebruikt)
	   - .used (donkergrijs, al uitgegeven in shop)
	*/
	.coin {
		width: 18px;
		height: 18px;
		border-radius: 50%;
		background: rgba(255,255,255,0.18);
		border: 1px solid rgba(255,255,255,0.28);
		box-shadow: inset 0 0 0 1px rgba(0,0,0,0.25), 0 0 6px rgba(0,0,0,0.25);
		transition: transform 0.2s ease, background 0.2s ease, border-color 0.2s ease, box-shadow 0.2s ease;
	}

	.coin.active {
		background: radial-gradient(circle at 30% 30%, #fff6b5, #f7bb36 70%);
		border-color: #f3b12b;
		box-shadow: 0 0 8px rgba(255,209,90,0.78), inset 0 0 2px rgba(255,255,255,0.85);
	}

	.coin.used {
		background: rgba(80,82,95,0.65);
		border-color: rgba(120,124,140,0.6);
		box-shadow: inset 0 0 0 1px rgba(0,0,0,0.4);
		transform: scale(1);
	}

	.coin {
		background: rgba(255,255,255,0.14);
		border-color: rgba(255,255,255,0.24);
	}

	.coin.active {
		background: radial-gradient(circle at 30% 30%, #ffe58c, #f5b72f 70%);
	}

	.coin.used {
		background: rgba(60,60,72,0.7);
		border-color: rgba(110,110,130,0.55);
		box-shadow: inset 0 0 0 1px rgba(0,0,0,0.55);
	}

	/* ============================================
	   +1 BLOKPLAATSING KNOP
	   ============================================ */
	.buy-placement-btn {
		display: flex;
		align-items: center;
		justify-content: center;
		gap: 6px;
		margin-top: 10px;
		padding: 8px 14px;
		border: 1px solid rgba(26,32,48,0.16);
		border-radius: 8px;
		background: linear-gradient(155deg, #eff3ff 0%, #dbe2f6 100%);
		color: #2b3148;
		font-weight: 600;
		font-size: 0.9rem;
		cursor: pointer;
		transition: transform 0.15s ease, box-shadow 0.15s ease, background 0.15s ease;
		box-shadow: 0 12px 20px rgba(10,12,20,0.22);
	}
	.buy-placement-btn:hover:not(:disabled) {
		transform: translateY(-2px);
		box-shadow: 0 18px 28px rgba(10,12,20,0.28);
		background: linear-gradient(155deg, #f4f7ff 0%, #e2e8fb 100%);
	}
	.buy-placement-btn:active:not(:disabled) {
		transform: translateY(0);
		box-shadow: 0 10px 18px rgba(10,12,20,0.22);
	}
	.buy-placement-btn:disabled {
		opacity: 0.5;
		cursor: not-allowed;
		background: linear-gradient(135deg, #e0e0e0, #bdbdbd);
		border-color: rgba(26,32,48,0.16);
		color: #757575;
	}
	.buy-placement-arrow {
		font-size: 1.05rem;
		line-height: 1;
		opacity: 0.9;
		transform: translateY(-0.5px);
	}
	/* Hide the arrow on touch devices */
	@media (pointer: coarse) {
		.buy-placement-arrow {
			display: none;
		}
	}
	.buy-placement-rainbow-cell {
		width: 18px;
		height: 18px;
		/* Border-radius: max 5px, minder rond */
		border-radius: min(5px, calc(18px / 5));
		display: inline-block;
		box-shadow: inset 0 0 0 1px rgba(0,0,0,0.22), 0 2px 6px rgba(0,0,0,0.22);
		background: linear-gradient(
			135deg,
			#ff5757 0%,
			#ffbf3a 22%,
			#8cff6a 45%,
			#47b1ff 70%,
			#b16cff 100%
		);
	}
	.buy-placement-cost {
		display: flex;
		gap: 3px;
		background: rgba(0,0,0,0.1);
		padding: 2px 6px;
		border-radius: 4px;
		font-size: 0.8rem;
	}
	.buy-placement-cost .coin-icon {
		display: inline-block;
		width: 0.9em;
		height: 0.9em;
		border-radius: 50%;
		background: radial-gradient(circle at 30% 30%, #fff6b5, #f7bb36 60%, #d49f20);
		box-shadow: inset 0 -1px 2px rgba(0,0,0,0.2);
		border: 1px solid #c9960a;
	}
	.buy-placement-btn {
		background: linear-gradient(160deg, #2b2d33 0%, #1f2126 100%);
		border-color: rgba(170,170,180,0.25);
		color: rgba(235,238,255,0.88);
		box-shadow: 0 16px 30px rgba(0,0,0,0.42);
	}
	.buy-placement-btn:hover:not(:disabled) {
		background: linear-gradient(160deg, #32343b 0%, #24262c 100%);
		box-shadow: 0 20px 34px rgba(0,0,0,0.5);
	}
	.buy-placement-btn:disabled {
		background: linear-gradient(135deg, #3a3a3a, #2a2a2a);
		border-color: rgba(140,150,200,0.2);
		color: #888;
		transform: scale(1);
	}
	.buy-placement-rainbow-cell {
		box-shadow: inset 0 0 0 1px rgba(255,255,255,0.12), 0 2px 8px rgba(0,0,0,0.55);
	}

	/* Gekocht blok preview in gold zone */
	#buy-placement-container {
		display: flex;
		justify-content: center;
		margin-top: 10px;
	}
	.purchased-block-preview {
		display: flex;
		flex-direction: column;
		align-items: center;
		gap: 6px;
		padding: 10px 16px;
		background: linear-gradient(135deg, rgba(240,98,114,0.15), rgba(255,245,90,0.15), rgba(78,211,70,0.15), rgba(93,144,240,0.15));
		border: 2px dashed rgba(150,100,200,0.5);
		border-radius: 10px;
		cursor: grab;
		transition: transform 0.15s ease, box-shadow 0.15s ease;
		box-shadow: 0 0 12px rgba(150,100,200,0.3);
		/* Animation removed for performance - static glow */
	}
	.purchased-block-preview:hover {
		transform: scale(1.05);
		box-shadow: 0 4px 16px rgba(150,100,200,0.3);
	}
	.purchased-block-preview:active {
		cursor: grabbing;
	}
	.purchased-block-cell {
		width: 28px;
		height: 28px;
		border-radius: 4px;
		background: linear-gradient(45deg, #f06272, #fff25a, #4ed346, #5d90f0, #a35eff);
		border: 2px solid rgba(255,255,255,0.5);
		box-shadow: 0 2px 8px rgba(0,0,0,0.2);
	}
	.purchased-block-label {
		font-size: 0.75rem;
		font-weight: 600;
		color: #6b4d8a;
	}
	@media (max-width: 650px) {
		.purchased-block-label {
			display: none;
		}
		.purchased-block-preview {
			gap: 4px;
			padding: 8px 12px;
		}
	}
	.purchased-block-preview {
		background: linear-gradient(135deg, rgba(240,98,114,0.1), rgba(255,245,90,0.1), rgba(78,211,70,0.1), rgba(93,144,240,0.1));
		border-color: rgba(180,140,220,0.4);
	}
	.purchased-block-label {
		color: #c9b0e8;
	}
	/* Keep the purchased preview visible everywhere; it's the drag handle to place the bought block. */
	@keyframes pulse-glow {
		0%, 100% { box-shadow: 0 0 8px rgba(150,100,200,0.2); }
		50% { box-shadow: 0 0 16px rgba(150,100,200,0.4); }
	}
	
	/* ============================================
	   SCOREBORD
	   ============================================
	   Toont score per kleur + totaal
	   Gepositioneerd in kolom 4 op desktop, in bottom-bar op mobiel
	   Score-rows gebruiken kleur-dots voor compactheid
	*/
	#scoreboard {
	  background: #fffbea;
	  border-radius: 12px;
	  padding: 16px 20px;
	  color: #333;
	  font-family: "Segoe UI", sans-serif;
	  width: 280px;
	  position: relative;
	  z-index: 1;
	  box-shadow: 0 0 8px rgba(0,0,0,0.4);
	  display: flex;
	  flex-direction: column;
	  align-items: stretch;
	  gap: 12px;
	}

	#scoreboard h2 {
	  margin: 0;
	}

	#scoreboard {
	  background: linear-gradient(145deg, #2b2d33, #1f2126);
	  border: 1px solid #3a3d44;
	  color: #e5e5e5;
	}

	.score-row { 
	  display: flex; 
	  align-items: center; 
	  justify-content: space-between; 
	  background: #eee; 
	  padding: 6px 10px; 
	  border-radius: 8px; 
	  margin: 0;
	  position: relative;
	  transition: transform 0.1s ease, background 0.3s, box-shadow 0.3s; 
	}

	/* Zone-info knopjes (links boven in elke zone) */
	.zone-info-btn {
		position: absolute;
		left: 8px;
		top: 8px;
		z-index: 20;
		width: 20px;
		height: 20px;
		border-radius: 999px;
		border: 1px solid rgba(0,0,0,0.18);
		background: rgba(255,255,255,0.7);
		color: rgba(0,0,0,0.75);
		font-weight: 800;
		font-size: 12px;
		line-height: 1;
		display: inline-flex;
		align-items: center;
		justify-content: center;
		cursor: pointer;
		padding: 0;
		-webkit-user-select: none;
		user-select: none;
	}

	/* When a zone is scrollable, pin the info UI to the zone viewport. */
	#blue-zone .zone-info-btn,
	#green-zone .zone-info-btn {
		position: sticky;
		top: 8px;
		left: 8px;
		margin: 0 0 -20px 0;
	}
	#blue-zone .zone-info-popover,
	#green-zone .zone-info-popover {
		position: sticky;
		top: 34px;
		left: 8px;
		margin: 0 0 -140px 0;
		height: 140px;
		max-height: 140px;
		overflow: auto;
	}
	#blue-zone,
	#green-zone {
		/* Prevent horizontal layout jumps when scrollbars appear/disappear */
		scrollbar-gutter: stable;
	}

	.zone-info-btn {
		border-color: rgba(255,255,255,0.18);
		background: rgba(0,0,0,0.2);
		color: rgba(255,255,255,0.82);
	}

	.zone-info-btn:focus {
		outline: 2px solid rgba(0,0,0,0.25);
		outline-offset: 2px;
	}

	.zone-info-btn:focus {
		outline-color: rgba(255,255,255,0.22);
	}

	.zone-info-popover {
		position: absolute;
		left: 8px;
		right: 8px;
		top: 34px;
		z-index: 30;
		display: block;
		opacity: 0;
		visibility: hidden;
		pointer-events: none;
		transition: opacity 120ms ease;
		padding: 10px 12px;
		border-radius: 10px;
		background: rgba(255,255,255,0.95);
		border: 1px solid rgba(0,0,0,0.14);
		box-shadow: 0 8px 20px rgba(0,0,0,0.18);
		font-size: 0.82rem;
		line-height: 1.25;
		color: rgba(0,0,0,0.78);
		-webkit-backdrop-filter: blur(6px);
		backdrop-filter: blur(6px);
	}

	.zone-info-popover {
		background: rgba(35, 33, 25, 0.96);
		border-color: rgba(255,255,255,0.12);
		box-shadow: 0 10px 22px rgba(0,0,0,0.55);
		color: rgba(255,255,255,0.85);
	}

	.zone[data-info-open="true"] .zone-info-popover {
		opacity: 1;
		visibility: visible;
		pointer-events: auto;
	}
	
	.score-row {
	  background: #383838;
	  color: #e0e0e0;
	}

	.score-row:hover { transform: scale(1.03); background: #383838; }
	
	/* Score highlighting voor behaalde doelstellingen - static glow for performance */
	.score-row.objective-achieved {
	  box-shadow: 0 0 12px 3px rgba(255, 215, 0, 0.7);
	  /* Animation removed for performance */
	}
	
	.score-row.objective-achieved {
	  box-shadow: 0 0 14px 3px rgba(255, 215, 0, 0.8);
	  /* Animation removed for performance */
	}

	/* Tutorial overlay + highlights */
	#tutorial-overlay {
	  position: fixed;
	  inset: 0;
	  background: rgba(0, 0, 0, 0.55);
	  display: none;
	  align-items: center;
	  justify-content: center;
	  z-index: 9999;
	  backdrop-filter: blur(2px);
	}
	#tutorial-overlay .tutorial-card {
	  background: #111827;
	  color: #f8fafc;
	  padding: 20px 22px;
	  border-radius: 12px;
	  box-shadow: 0 18px 60px rgba(0, 0, 0, 0.45);
	  max-width: 420px;
	  width: calc(100% - 32px);
	  text-align: center;
	  border: 1px solid rgba(255, 255, 255, 0.08);
	}
	#tutorial-overlay .tutorial-card h3 { margin: 0 0 8px 0; font-size: 1.1rem; }
	#tutorial-overlay .tutorial-card p { margin: 0 0 14px 0; opacity: 0.9; }
	#tutorial-overlay .tutorial-card button {
	  background: linear-gradient(135deg, #fbbf24, #f97316);
	  border: none;
	  color: #0f172a;
	  padding: 10px 18px;
	  border-radius: 10px;
	  font-weight: 700;
	  cursor: pointer;
	  box-shadow: 0 10px 30px rgba(249, 115, 22, 0.35);
	}
	.tutorial-glow {
	  position: relative;
	  box-shadow: 0 0 0 3px rgba(251, 191, 36, 0.8), 0 0 20px rgba(249, 115, 22, 0.95);
	  z-index: 9998;
	  /* Animation removed for performance - static highlight */
	}
	.tutorial-glow-soft {
	  position: relative;
	  box-shadow: 0 0 0 3px rgba(125, 211, 252, 0.65), 0 0 18px rgba(59, 130, 246, 0.8);
	  z-index: 9998;
	  /* Animation removed for performance - static highlight */
	}
	#tutorial-ghost {
	  position: fixed;
	  width: 64px;
	  left: 0%;
	  height: 64px;
	  pointer-events: none;
	  z-index: 9997;
	  display: none;
	}
	#tutorial-ghost .ghost-shape {
	  width: 100%;
	  height: 100%;
	  display: flex;
	  align-items: center;
	  justify-content: center;
	  background: transparent;
	  border-radius: 10px;
	  opacity: 0.95;
	  /* Animation removed for performance */
	}
	#tutorial-ghost .ghost-shape-grid {
	  display: grid;
	  align-items: center;
	  justify-items: center;
	}
	#tutorial-ghost .ghost-shape-cell {
	  box-sizing: border-box;
	  box-shadow: 0 10px 24px rgba(0,0,0,0.30);
	}
	#tutorial-ghost .ghost-label {
	  position: absolute;
	  top: -86px;
	  left: 20%;
	  transform: translateX(-50%);
	  background: linear-gradient(135deg, #111827, #1f2937);
	  color: #f8fafc;
	  padding: 10px 14px;
	  border-radius: 12px;
	  font-size: 13px;
	  font-weight: 800;
	  white-space: normal;
	  width: 280px;
	  text-align: center;
	  border: 1px solid rgba(255, 255, 255, 0.14);
	  box-shadow: 0 12px 26px rgba(0,0,0,0.38);
	}
	#tutorial-ghost .ghost-rotate-hint {
	  position: absolute;
	  top: -40px;
	  left: 20%;
	  transform: translateX(-50%);
	  background: rgba(17,24,39,0.94);
	  color: #e5e7eb;
	  padding: 10px 14px;
	  border-radius: 12px;
	  font-size: 12px;
	  font-weight: 800;
	  white-space: normal;
	  width: 280px;
	  text-align: center;
	  border: 1px solid rgba(255, 255, 255, 0.16);
	  box-shadow: 0 14px 26px rgba(0,0,0,0.4);
	  display: none;
	}

	.purple-pair-cell {
		position: relative;
	}

	.purple-pair-cell.purple-highlight::after {
		content: '';
		position: absolute;
		top: -4px;
		left: -4px;
		right: -4px;
		bottom: -4px;
		border-radius: 6px;
		box-shadow: 0 0 0 4px rgba(152, 103, 232, 0.9), 0 0 26px rgba(152, 103, 232, 0.65);
		pointer-events: none;
		/* Animation removed for performance - static glow */
	}

	.score-row:hover {
	  background: #484848;
	}

	.color-box { width: 14px; height: 14px; border-radius: 3px; margin-right: 8px; }
	.label { flex: 1; font-size: 0.9em; }
	.score { font-weight: bold; font-size: 1em; }
	.score-row.yellow .color-box { background-color: #f7e757; }
	.score-row.red .color-box { background-color: #ed7e89; }
	.score-row.green .color-box { background-color: #69cf57; }
	.score-row.purple .color-box { background-color: #ae7eed; }
	.score-row.blue .color-box { background-color: #76a0e3; }
	.score-row.bonus .color-box { background-color: #C0C0C0; }
	#scoreboard hr {
	  width: 100%;
	  border: none;
	  border-top: 1px solid rgba(0,0,0,0.08);
	  margin: 0;
	}

	#scoreboard hr {
	  border-top-color: rgba(255,255,255,0.12);
	}

	#scoreboard .score-total {
	  display: flex;
	  align-items: center;
	  justify-content: space-between;
	  gap: 6px;
	  padding: 4px 8px;
	  background: #f0ead8;
	  border-radius: 6px;
	  border: 1px solid #d9d0bd;
	  font-weight: 600;
	  color: #333;
	  margin-top: 3px;
	  font-size: 0.9rem;
	  transition: box-shadow 0.3s;
	}
	
	/* Total score highlighting voor behaalde doelstellingen - static glow */
	#scoreboard .score-total.objective-achieved {
	  box-shadow: 0 0 12px 3px rgba(255, 215, 0, 0.7);
	  /* Animation removed for performance */
	}
	
	#scoreboard .score-total.objective-achieved {
	  box-shadow: 0 0 14px 3px rgba(255, 215, 0, 0.8);
	  /* Animation removed for performance */
	}

	#scoreboard .score-total {
	  background: #2f3239;
	  border-color: #3d4048;
	  color: var(--color-text-light);
	}

	#scoreboard .trap-summary {
	  display: flex;
	  flex-direction: column;
	  gap: 6px;
	  padding: 10px 12px;
	  border-radius: 12px;
	  background: rgba(0,0,0,0.035);
	  border: 1px solid rgba(0,0,0,0.06);
	}

	#scoreboard .trap-summary-header {
	  display: flex;
	  justify-content: space-between;
	  align-items: center;
	  font-size: 0.78rem;
	  letter-spacing: 0.05em;
	  text-transform: uppercase;
	  color: rgba(0,0,0,0.55);
	}

	#scoreboard .trap-summary-header .trap-label {
	  font-weight: 600;
	}

	#scoreboard .trap-count {
	  font-weight: 600;
	  font-size: 0.85rem;
	  color: #c43838;
	}

	#scoreboard .trap-preview {
	  display: flex;
	  flex-wrap: wrap;
	  gap: 8px;
	  align-items: center;
	  overflow: hidden;
	  padding-bottom: 0;
	  scrollbar-width: none;
	}

	#scoreboard .trap-preview.trap-preview--compact {
	  gap: 6px;
	  row-gap: 4px;
	}

	#scoreboard .trap-preview:empty::after {
	  content: 'Geen valkuilen geactiveerd';
	  font-size: 0.85rem;
	  color: rgba(0,0,0,0.45);
	  font-style: italic;
	}

	.trap-preview::-webkit-scrollbar {
	  display: none;
	}

	.trap-preview::-webkit-scrollbar-track {
	  background: rgba(0,0,0,0.05);
	  border-radius: 6px;
	}

	.trap-preview::-webkit-scrollbar-thumb {
	  background: rgba(196,56,56,0.4);
	  border-radius: 6px;
	}

	.trap-preview--compact .trap-icon {
	  display: none;
	}

	.trap-compact-chip {
	  display: inline-flex;
	  align-items: center;
	  gap: 4px;
	  padding: 2px 9px;
	  border-radius: 999px;
	  font-weight: 600;
	  font-size: 0.8rem;
	  background: rgba(196,56,56,0.12);
	  color: #a51111;
	  border: 1px solid rgba(196,56,56,0.28);
	}

	.trap-compact-chip::before {
	  content: attr(data-symbol);
	  font-size: 1rem;
	  line-height: 1;
	}

	.trap-compact-chip span {
	  pointer-events: none;
	}

	.trap-compact-chip--black-hole {
	  background: rgba(62, 44, 143, 0.12);
	  color: #3e2c8f;
	  border-color: rgba(62, 44, 143, 0.26);
	}

	.trap-icon {
	  position: relative;
	  width: 40px;
	  height: 40px;
	  flex: 0 0 auto;
	  display: flex;
	  align-items: center;
	  justify-content: center;
	  border-radius: 10px;
	  background: radial-gradient(circle at 30% 30%, #ffeaea, #f6d3d3);
	  border: 1px solid rgba(196,56,56,0.35);
	  box-shadow: 0 4px 10px rgba(196,56,56,0.18);
	  font-size: 1.4rem;
	  color: #a51111;
	  transition: transform 0.2s ease, box-shadow 0.2s ease;
	}

	.trap-icon .penalty-chip {
	  position: absolute;
	  right: -4px;
	  bottom: -6px;
	  background: #2a0b0b;
	  color: #ffb3b3;
	  font-size: 0.7rem;
	  font-weight: 600;
	  padding: 1px 5px;
	  border-radius: 10px;
	  border: 1px solid rgba(255,255,255,0.25);
	  box-shadow: 0 4px 8px rgba(0,0,0,0.2);
	}

	.trap-icon.trap-icon--black-hole {
	  background: radial-gradient(circle at 35% 28%, #f1ecff 0%, #d7d1fb 60%, #bfb6ef 100%);
	  border-color: rgba(110, 80, 210, 0.35);
	  color: #3e2c8f;
	  box-shadow: 0 6px 14px rgba(80, 60, 160, 0.28);
	}

	.trap-icon.trap-icon--black-hole .penalty-chip {
	  background: rgba(40, 28, 100, 0.9);
	  color: #efe8ff;
	  border-color: rgba(255,255,255,0.38);
	}

	.trap-icon span {
	  pointer-events: none;
	}

	.trap-icon span:first-child {
	  font-size: 1.05rem;
	}

	.trap-icon.highlight {
	  transform: translateY(-3px) scale(1.05);
	  box-shadow: 0 8px 16px rgba(196,56,56,0.36);
	}

	#scoreboard .score-total .label {
	  font-size: 0.85rem;
	  letter-spacing: 0.08em;
	  text-transform: uppercase;
	  opacity: 0.8;
	}

	#scoreboard .score-total .total-score {
	  font-size: 2.2rem;
	  line-height: 1;
	  font-weight: 700;
	  color: #2b1a00;
	}


	#scoreboard .score-total {
	  background: linear-gradient(140deg, #3a331f, #2b2619);
	  border-color: rgba(255, 199, 63, 0.25);
	  color: #f6f1dd;
	  box-shadow: 0 16px 30px rgba(0,0,0,0.35);
	}

	#scoreboard .trap-summary {
	  background: rgba(255,255,255,0.03);
	  border-color: rgba(255,255,255,0.07);
	}

	.trap-icon {
	  background: radial-gradient(circle at 30% 30%, #3c1e1e, #281111);
	  border-color: rgba(196,56,56,0.45);
	  color: #f3bbbb;
	  box-shadow: 0 4px 12px rgba(0,0,0,0.45);
	}

	.trap-icon.trap-icon--black-hole {
	  background: radial-gradient(circle at 38% 32%, #403472 0%, #291f55 58%, #110b30 100%);
	  border-color: rgba(150,120,240,0.55);
	  color: #d9d5ff;
	  box-shadow: 0 6px 16px rgba(50,30,120,0.45);
	}

	.trap-icon .penalty-chip {
	  background: rgba(70,20,20,0.85);
	  color: #ffc9c9;
	}

	.trap-icon.trap-icon--black-hole .penalty-chip {
	  background: rgba(24,18,70,0.9);
	  color: #f0ecff;
	}

	#scoreboard .trap-summary-header {
	  color: rgba(255,240,210,0.6);
	}

	#scoreboard .trap-summary-header .trap-label {
	  color: rgba(255,240,210,0.9);
	}

	#scoreboard .trap-count {
	  color: #ff8585;
	}

	#scoreboard .trap-preview:empty::after {
	  color: rgba(255,255,255,0.35);
	}

	.trap-preview::-webkit-scrollbar-track {
	  background: rgba(255,255,255,0.05);
	}

	.trap-preview::-webkit-scrollbar-thumb {
	  background: rgba(255,120,120,0.45);
	}

	.trap-compact-chip {
	  background: rgba(196,56,56,0.18);
	  color: #ffb3b3;
	  border-color: rgba(196,56,56,0.32);
	}

	.trap-compact-chip--black-hole {
	  background: rgba(79, 64, 150, 0.22);
	  color: #d6d1ff;
	  border-color: rgba(131, 117, 210, 0.35);
	}

	.trap-icon {
	  background: radial-gradient(circle at 30% 30%, #4b1c1c, #2a1212);
	  border-color: rgba(255,120,120,0.45);
	  color: #ffb3b3;
	  box-shadow: 0 4px 10px rgba(0,0,0,0.4);
	}

	.trap-icon .penalty-chip {
	  background: #901717;
	  color: #ffe0e0;
	  border-color: rgba(0,0,0,0.45);
	}

	#scoreboard .score-total .label {
	  color: rgba(255, 243, 205, 0.8);
	}

	#scoreboard .score-total .total-score {
	  color: #ffe6a3;
	}

	/* ============================================
	   HIGH SCORE POPUP & MODAL
	   ============================================
	*/
	.highscore-toast {
		position: fixed;
		top: 80px;
		left: 50%;
		transform: translate(-50%, 0) scale(0.96);
		background: linear-gradient(120deg, #fff7d1, #ffe089);
		color: #2a1b00;
		padding: 14px 20px;
		border-radius: 16px;
		display: flex;
		align-items: center;
		gap: 12px;
		box-shadow: 0 18px 40px rgba(0,0,0,0.32);
		font-weight: 600;
		z-index: 2147483647;
		opacity: 0;
		animation: highscoreToastEnter 0.35s ease forwards;
		pointer-events: none;
	}

	.highscore-toast__icon {
		font-size: 1.5rem;
	}

	.highscore-toast__score {
		font-size: 1.25rem;
		font-weight: 800;
	}

	.highscore-toast {
		background: linear-gradient(120deg, #2f2a1f, #4d3f1d);
		color: #fff6cc;
		box-shadow: 0 20px 46px rgba(0,0,0,0.6);
	}

	@keyframes highscoreToastEnter {
		0% { opacity: 0; transform: translate(-50%, -30px) scale(0.8); }
		70% { opacity: 1; transform: translate(-50%, 6px) scale(1.03); }
		100% { opacity: 1; transform: translate(-50%, 0) scale(1); }
	}

	/* High Score Modal */
	.highscore-modal-overlay {
		position: fixed;
		inset: 0;
		background: rgba(0,0,0,0.5);
		backdrop-filter: blur(4px);
		display: none;
		align-items: center;
		justify-content: center;
		z-index: 10000;
	}
	.highscore-modal-overlay.show { display: flex; }
	.highscore-modal {
		background: white;
		padding: 30px;
		border-radius: 12px;
		text-align: center;
		box-shadow: 0 10px 30px rgba(0,0,0,0.3);
		max-width: 90%;
		width: 300px;
	}
	.highscore-modal {
		background: #2d2d2d;
		color: #eee;
	}
	.highscore-value {
		font-size: 3rem;
		font-weight: bold;
		color: #d4af37;
		margin: 20px 0;
	}
	.highscore-close-btn {
		background: #eee;
		border: none;
		padding: 10px 20px;
		border-radius: 6px;
		cursor: pointer;
		font-weight: bold;
	}
	.highscore-close-btn:hover { background: #ddd; }
	.highscore-close-btn {
		background: #444;
		color: #eee;
	}
	.highscore-close-btn:hover {
		background: #555;
	}

/* Saved-levels modal tweaks */
#saved-levels-modal .highscore-modal { width: 420px; max-width: 95%; text-align: left; }
#saved-levels-modal .highscore-modal h2 { margin: 0 0 12px 0; }
#saved-levels-modal #saved-levels-list { padding: 6px 4px; gap: 8px; }
#saved-levels-modal #saved-levels-list > div { display:flex; align-items:center; gap:8px; padding:8px; border-radius:6px; }
#saved-levels-modal #saved-levels-list > div:hover { background: rgba(0,0,0,0.03); }
#saved-levels-modal .highscore-modal button { padding:6px 10px; border-radius:6px; border:1px solid rgba(0,0,0,0.08); background:transparent; cursor:pointer; }
#saved-levels-modal .highscore-modal button:hover { background: rgba(0,0,0,0.04); }
#saved-levels-modal .trash-btn { color: #666; }
#saved-levels-modal .trash-btn:hover { color: #c0392b; }

/* Buttons: default + primary (blue) */
#saved-levels-modal .modal-btn { background: #f6f6f6; color: #222; border: 1px solid rgba(0,0,0,0.06); }
#saved-levels-modal .modal-btn.primary { background: linear-gradient(135deg,#4a90e2,#6fb1ff); color: #fff; border: none; }
#saved-levels-modal .modal-btn.primary:hover { filter: brightness(0.95); }

/* Dark mode overrides for better contrast */
#saved-levels-modal .modal-btn { background: #3a3a3a; color: #eee; border: 1px solid rgba(255,255,255,0.04); }
#saved-levels-modal .modal-btn.primary { background: linear-gradient(135deg,#2b6fb8,#4a90e2); color: #fff; }
#saved-levels-modal .modal-btn.primary:hover { filter: brightness(1.05); }
#saved-levels-modal .trash-btn { color: #ccc; }

/* Saved item title and label colors */
#saved-levels-modal .saved-title { font-size: 14px; color: rgba(0,0,0,0.9); }
#saved-levels-modal .saved-title { color: #fff; }

/* Custom scrollbar for saved-levels list */
#saved-levels-modal #saved-levels-list::-webkit-scrollbar { width:10px; }
#saved-levels-modal #saved-levels-list::-webkit-scrollbar-track { background: transparent; }
#saved-levels-modal #saved-levels-list::-webkit-scrollbar-thumb { background: rgba(0,0,0,0.12); border-radius: 6px; }
#saved-levels-modal #saved-levels-list::-webkit-scrollbar-thumb:hover { background: rgba(0,0,0,0.18); }

/* Saved level item text */
#saved-levels-modal .saved-obj-text { font-size: 13px; color: rgba(0,0,0,0.85); opacity: 1; }
#saved-levels-modal .saved-obj-text { color: #ddd; opacity: 0.95; }

	/* ============================================
	   ANIMATIES
	   ============================================
	*/
	@keyframes popIn {
	  to { transform: translate(-50%, -50%) scale(1); }
	}

	/*
	   Card theming: use CSS variables so variants (golden/dark) only adjust a few values.
	*/
	:root {
		--card-bg: radial-gradient(ellipse 80% 50% at 50% 0%, rgba(255,255,255,0.8) 0%, transparent 60%),
				linear-gradient(175deg, #f6f6f7 0%, #e2e4e8 100%);
		--card-border: 1.5px solid rgba(90,95,110,0.2);
		--card-shadow: 0 4px 8px rgba(0,0,0,0.08), 0 12px 24px rgba(20,24,32,0.12), 0 0 18px rgba(30,32,40,0.12), inset 0 1px 0 rgba(255,255,255,0.9);
		--card-cell-bg: rgba(255,255,255,0.95);
		--card-cell-size: var(--cell-size);
		--card-cell-radius: var(--cell-radius);
		--card-preview-gap: var(--preview-gap);
		--card-glow: drop-shadow(0 0 10px rgba(70,75,90,0.28)) drop-shadow(0 4px 10px rgba(0,0,0,0.2));
	}

	{
		--card-bg: radial-gradient(ellipse 80% 50% at 50% 0%, rgba(80,90,110,0.15) 0%, transparent 60%),
				linear-gradient(175deg, #2b2d33 0%, #1f2126 100%);
		--card-border: 1.5px solid rgba(150,155,170,0.22);
		--card-shadow: 0 4px 8px rgba(0,0,0,0.2), 0 12px 28px rgba(0,0,0,0.3), inset 0 1px 0 rgba(255,255,255,0.06);
		--card-cell-bg: rgba(24,26,32,0.85);
	}

	#card-choice-zone {
	  background: #fffbea;
	  border-radius: 16px;
	  color: #333;
	  font-family: "Segoe UI", sans-serif;
	  width: min(402px, 100%);
	  box-shadow: 0 0 12px rgba(0,0,0,0.45);
	  overflow: hidden;
	}

	#card-choice-zone {
	  background: linear-gradient(145deg, #2b2d33, #1f2126);
	  border: 1px solid #3a3d44;
	  box-shadow: 0 0 12px rgba(0,0,0,0.6);
	  color: #e5e5e5;
	}

	#card-controls {
		display: flex;
		flex-direction: row;
		align-items: flex-start;
		justify-content: center;
		gap: 16px;
		width: 100%;
		box-sizing: border-box;
	}

	#card-options {
		flex: 1 1 auto;
		min-width: 0;
		display: flex;
		flex-wrap: wrap;
		gap: 14px;
		justify-content: center;
		align-items: flex-start;
		margin: 0;
		padding: 0;
	}

	#card-action-buttons {
		display: flex;
		flex-direction: column;
		align-items: stretch;
		gap: 14px;
		max-width: 190px;
		width: 100%;
		flex: 0 0 auto;
	}

	.card-action-btn {
		position: relative;
		display: inline-flex;
		align-items: center;
		justify-content: flex-start;
		gap: 10px;
		width: 100%;
		min-width: 0;
		margin: 0;
		padding: 12px 16px;
		border-radius: 14px;
		border: 1px solid rgba(26,32,48,0.16);
		background: linear-gradient(155deg, #eff3ff 0%, #dbe2f6 100%);
		color: #2b3148;
		font-weight: 600;
		font-size: 0.88rem;
		letter-spacing: 0.04em;
		text-transform: none;
		box-shadow: 0 12px 20px rgba(10,12,20,0.22);
		cursor: pointer;
		transition: transform 0.18s ease, box-shadow 0.18s ease, border-color 0.25s ease, background 0.25s ease;
		min-height: 52px;
	}

	.card-action-btn::before {
		content: attr(data-icon);
		font-size: 1.4rem;
		line-height: 1;
	}

	.card-action-btn::after {
		content: attr(data-label);
		line-height: 1.1;
		white-space: nowrap;
	}

	/* Desktop: buttons zijn 52x52px iconen zonder tekst */
	@media (min-width: 651px) {
		/* Desktop must not show the mobile hand-scroll arrows. */
		.hand-scroll-btn,
		#card-controls.hand-scroll-enabled .hand-scroll-btn {
			display: none;
		}

		.card-action-btn {
			justify-content: center;
			padding: 12px;
			min-width: 52px;
			width: 52px;
			max-width: 52px;
			min-height: 52px;
			height: 52px;
		}

		.card-action-btn::after {
			display: none;
		}

		/* Ensure the â€œnext turnâ€ button matches the deck button and sits next to it. */
		#card-action-buttons .card-action-btn {
			width: 52px;
			max-width: 52px;
			min-width: 52px;
			justify-content: center;
		}
		#card-action-buttons .card-action-btn::after {
			display: none;
		}
		#card-action-buttons #new-cards-btn { order: 0; }
		#card-action-buttons #undo-inline-btn { order: 1; }
		#card-action-buttons #rotate-card-btn { order: 2; }
		#card-action-buttons #mirror-card-btn { order: 3; }
		#card-action-buttons #bonus-shop-btn { order: 4; }
		#card-action-buttons #deck-preview { order: 5; }
		
		/* Deck preview: vierkant en zelfde kleur als andere buttons */
		.deck-preview {
			min-width: 52px;
			width: 52px;
			max-width: 52px;
			min-height: 52px;
			height: 52px;
			padding: 0;
			background: linear-gradient(155deg, #eff3ff 0%, #dbe2f6 100%);
			border: 1px solid rgba(26,32,48,0.16);
			border-radius: 14px;
			display: flex;
			flex-direction: column;
			align-items: center;
			justify-content: center;
			gap: 2px;
			box-shadow: 0 12px 20px rgba(10,12,20,0.2);
		}
		
		.deck-preview::before {
			content: 'ðŸ“š';
			font-size: 1.2rem;
			display: block;
			line-height: 1;
		}

		.deck-preview::after {
			display: none;
		}
		
		/* Deck preview: zorg dat icoon ook in portrait mode zichtbaar is */
		body.desktop-portrait .deck-preview::before {
			content: 'ðŸ“š';
			display: block;
		}

		.deck-count {
			position: static;
			min-width: auto;
			padding: 0;
			background: none;
			border: none;
			box-shadow: none;
			font-size: 0.75rem;
			font-weight: 700;
			color: #2b3148;
			line-height: 1;
		}

		.deck-count::before {
			display: none;
		}

		.deck-preview {
			background: linear-gradient(160deg, #2b2d33 0%, #1f2126 100%);
			border-color: rgba(170,170,180,0.25);
		}

		.deck-count {
			color: rgba(235,238,255,0.88);
		}
	}

	.card-action-btn:hover:not(:disabled),
	.card-action-btn:focus-visible {
		transform: translateY(-2px);
		box-shadow: 0 18px 28px rgba(10,12,20,0.28);
	}

	.card-action-btn:focus-visible {
		outline: 3px solid rgba(210,210,220,0.6);
		outline-offset: 3px;
	}

	.card-action-btn:disabled {
		opacity: 0.55;
		cursor: not-allowed;
		transform: none;
		box-shadow: none;
	}

	.card-action-btn {
		background: linear-gradient(160deg, #2b2d33 0%, #1f2126 100%);
		border-color: rgba(170,170,180,0.25);
		color: rgba(235,238,255,0.88);
		box-shadow: 0 16px 30px rgba(0,0,0,0.42);
	}

	.card-action-btn:hover:not(:disabled),
	.card-action-btn:focus-visible {
		box-shadow: 0 20px 34px rgba(0,0,0,0.5);
	}

	/* Dark mode deck preview matching card buttons */
	#card-action-buttons .deck-preview {
		background: linear-gradient(160deg, #2b2d33 0%, #1f2126 100%);
		border-color: rgba(170,170,180,0.25);
	}

	#card-action-buttons .deck-count {
		color: rgba(235,238,255,0.88);
	}

	.deck-preview {
		position: relative;
		display: inline-flex;
		align-items: center;
		justify-content: space-between;
		gap: 10px;
		padding: 12px 16px;
		border-radius: 14px;
		border: 1px solid rgba(26,32,48,0.16);
		background: linear-gradient(160deg, #ffffff 0%, #edf1ff 100%);
		box-shadow: 0 12px 20px rgba(10,12,20,0.2);
		color: #2b3148;
		cursor: pointer;
		transition: transform 0.18s ease, box-shadow 0.18s ease, border-color 0.25s ease, background 0.25s ease;
		min-height: 52px;
		flex: 0 0 auto;
	}

	.deck-preview::after {
		display: none;
	}

	.deck-preview:hover,
	.deck-preview:focus-visible {
		transform: translateY(-2px);
		box-shadow: 0 18px 28px rgba(10,12,20,0.28);
	}

	.deck-preview:focus-visible {
		outline: 3px solid rgba(86,122,255,0.55);
		outline-offset: 3px;
	}
	
	/* Verwijder outline in desktop modes */
	@media (min-width: 651px) {
		.deck-preview:focus-visible {
			outline: none;
		}
	}

	.deck-count {
		display: inline-flex;
		align-items: center;
		justify-content: center;
		gap: 4px;
		min-width: 54px;
		padding: 6px 10px;
		border-radius: 10px;
		background: rgba(255,255,255,0.9);
		border: 1px solid rgba(26,32,48,0.16);
		box-shadow: inset 0 -1px 0 rgba(255,255,255,0.75), 0 6px 12px rgba(10,12,20,0.18);
		font-size: 1.05rem;
		font-weight: 700;
		color: #2b3148;
		font-variant-numeric: tabular-nums;
	}

	/* Desktop: deck count centered zonder icon */
	@media (min-width: 651px) {
		.deck-count {
			position: absolute;
			top: 50%;
			left: 50%;
			transform: translate(-50%, -50%);
			min-width: auto;
			padding: 0;
			background: none;
			border: none;
			box-shadow: none;
		}

		.deck-count::before {
			display: none;
		}
	}

	.deck-count::before {
		content: '\1F4DA';
		font-size: 1.1rem;
	}

	.deck-preview {
		background: linear-gradient(160deg, #2b2d33 0%, #1f2126 100%);
		border-color: rgba(170,170,180,0.25);
		color: rgba(235,238,255,0.9);
		box-shadow: 0 18px 30px rgba(0,0,0,0.4);
	}

	.deck-preview::after {
		color: rgba(235,238,255,0.75);
	}

	.deck-preview:focus-visible {
		outline-color: rgba(210,210,220,0.65);
	}

	.deck-count {
		background: rgba(18,22,36,0.92);
		border-color: rgba(120,140,220,0.38);
		color: rgba(235,238,255,0.88);
		box-shadow: inset 0 -1px 0 rgba(255,255,255,0.08), 0 6px 12px rgba(0,0,0,0.42);
	}

	#turn-counter-inline {
		display: none;
	}

	#turn-counter-inline {
		background: linear-gradient(145deg, #22252b, #1a1c21);
		border: 1px solid var(--color-border-dark);
		box-shadow: 0 6px 14px rgba(0,0,0,0.45);
		color: var(--color-text-light);
	}

	.card-option {
		position: relative;
		isolation: isolate;
		overflow: hidden;
		display: flex;
		flex-direction: column;
		align-items: center;
		justify-content: center;
		flex: 0 0 auto;
		width: 138px;
		min-height: 180px;
		padding: 12px 10px;
		gap: 10px;
		box-sizing: border-box;
		border-radius: 16px;
		--preview-cell: var(--card-cell-size);
		background: var(--card-bg);
		border: var(--card-border);
		box-shadow: var(--card-shadow);
		transition: transform 0.2s ease, box-shadow 0.2s ease, border-color 0.2s ease;
	}

	.card-option .card-label,
	.card-option .card-label--echo { order: 2; }
	.card-option .card-meta--echo { order: 1; }

	/* Desktop landscape request: cards a bit shorter (â‰ˆ10px). */
	body.desktop-landscape #card-choice-zone .card-option {
		min-height: 170px;
	}

	/* Desktop request: make cards ~20px smaller overall. */
	body.desktop-landscape .card-option {
		width: 118px;
	}

	.card-option::after {
		content: "";
		position: absolute;
		top: 0;
		left: 0;
		right: 0;
		height: 50%;
		border-radius: inherit;
		background: linear-gradient(180deg, rgba(255,255,255,0.6) 0%, rgba(255,255,255,0) 100%);
		pointer-events: none;
	}

	.card-option > * {
		position: relative;
		z-index: 1;
	}

	.card-meta-trigger {
		position: absolute;
		left: 0;
		right: 0;
		bottom: 0;
		height: clamp(24px, 30%, 40px);
		pointer-events: auto;
		z-index: 1;
	}

	.card-option:hover {
		transform: translateY(-4px);
		box-shadow: 
			0 4px 8px rgba(0,0,0,0.06),
			0 16px 32px rgba(30,50,100,0.14);
	}

	.card-option.selected {
		border-color: rgba(82,118,255,0.6);
		box-shadow: 0 32px 52px rgba(70,90,180,0.45);
	}

	/* Card control buttons voor mobiel en touch devices - fixed positie onderaan */
	.card-control-btn {
		position: fixed;
		/* Position bottom center for touch devices */
		bottom: calc(var(--bottom-bar-height) + 10px);
		width: 44px;
		height: 44px;
		border: 2px solid white;
		border-radius: 50%;
		display: none;
		align-items: center;
		justify-content: center;
		font-size: 20px;
		color: white;
		cursor: pointer;
		box-shadow: 0 4px 12px rgba(0,0,0,0.3);
		z-index: calc(var(--z-controls) + 10);
		user-select: none;
		transition: transform 0.15s ease, opacity 0.15s ease;
		pointer-events: auto;
		touch-action: manipulation;
	}

	.card-control-btn:hover {
		transform: scale(1.1);
	}

	.card-control-btn:active {
		transform: scale(0.95);
	}

	/* Toon buttons wanneer er een selectie is */
	.card-control-btn.visible {
		display: flex;
	}

	/* When JS positions the buttons near the dragged block, override the
	   fixed layout offsets (e.g. mobile-sidebar translateY + right:15px). */
	.card-control-btn.dynamic-pos {
		right: auto;
		margin-left: 0;
		transform: none;
	}

	.card-control-rotate {
		left: 50%;
		margin-left: 75px;
		background: #4a90e2;
	}

	.card-control-mirror {
		left: 50%;
		margin-left: 25px;
		background: #9b59b6;
	}

	.card-control-cancel {
		left: 50%;
		margin-left: -25px;
		background: #e74c3c;
	}

	/* Touch portrait mode: buttons blijven onderaan gecentreerd */
	body.touch-portrait .card-control-btn {
		bottom: calc(var(--bottom-bar-height) + 10px);
		top: auto;
		right: auto;
	}

	/* Small mobile + zoomed-in: push rotate/mirror/cancel lower so they don't overlap the zoomed zone */
	@media (max-width: 420px), (max-height: 720px) {
		body.zoomed-in .card-control-btn {
			bottom: max(4px, calc(var(--bottom-bar-height) - 6px));
		}
	}
	
	/* Mobile sidebar landscape: buttons aan de rechterkant */
	body.mobile-sidebar-layout .card-control-btn {
		bottom: auto;
		top: 50%;
		left: auto;
		right: 15px;
		margin-left: 0;
	}
	body.mobile-sidebar-layout .card-control-rotate {
		transform: translateY(-85px);
	}
	body.mobile-sidebar-layout .card-control-mirror {
		transform: translateY(-30px);
	}
	body.mobile-sidebar-layout .card-control-cancel {
		transform: translateY(25px);
	}

	.card-control-btn:hover {
		transform: scale(1.1);
	}
	
	.card-control-btn:active {
		transform: scale(0.95);
	}

	.card-control-rotate {
		background: #5a9fd4;
		border-color: #1e2128;
	}

	.card-control-mirror {
		background: #8e44ad;
		border-color: #1e2128;
	}

	.card-control-cancel {
		background: #c0392b;
		border-color: #1e2128;
	}

	.card-pattern {
		display: grid;
		gap: var(--card-preview-gap);
		align-items: center;
		justify-items: center;
		justify-content: center;
		align-content: center;
		place-items: center;
		filter: var(--card-glow);
		margin: auto;
		flex: 0 0 auto;
		align-self: center;
		justify-self: center;
		position: relative;
		z-index: 2;
	}

	.card-option .card-cell {
		width: var(--card-cell-size);
		height: var(--card-cell-size);
		border-radius: var(--card-cell-radius);
		border: 1.5px solid rgba(0,0,0,0.12);
		box-shadow: inset 0 1px 2px rgba(0,0,0,0.08), 0 1px 0 rgba(255,255,255,0.8);
		background: var(--card-cell-bg);
	}

	.card-label {
		display: inline-flex;
		align-items: center;
		justify-content: center;
		gap: 5px;
		padding: 4px 10px;
		border-radius: 8px;
		background: rgba(40,55,90,0.08);
		font-size: 0.68rem;
		font-weight: 700;
		letter-spacing: 0.04em;
		text-transform: uppercase;
		color: rgba(30,45,80,0.75);
		text-align: center;
	}

	.card-label.card-label--empty {
		display: none;
	}

	.card-meta {
		font-size: 0.72rem;
		letter-spacing: 0.05em;
		color: rgba(24,32,54,0.9);
		text-align: center;
		align-self: center;
		position: absolute;
		inset: 10px;
		display: flex;
		align-items: center;
		justify-content: center;
		padding: 10px 12px;
		background: rgba(15,20,32,0.8);
		color: #f2f6ff;
		border-radius: 12px;
		opacity: 0;
		pointer-events: none;
		transition: opacity 0.15s ease;
		z-index: 5;
	}

	.card-meta.card-meta--empty {
		display: none;
	}

	/* Show description only when card gets explicit meta toggle */
	.card-option.show-meta .card-meta {
		opacity: 1;
		pointer-events: auto;
	}

	.card-meta.card-meta--echo {
		display: flex;
		flex-direction: column;
		gap: 6px;
		align-items: center;
		font-size: 0.68rem;
		letter-spacing: 0.06em;
		color: rgba(15,20,32,0.68);
		position: absolute;
		inset: auto;
		left: 8px;
		bottom: 8px;
		z-index: 5;
		margin: 0;
		padding: 0;
		background: transparent;
		border-radius: 0;
		opacity: 0;
		pointer-events: none;
		transition: opacity 0.15s ease;
	}

	/* Show echo meta icons on hover */
	.card-option:hover .card-meta.card-meta--echo,
	.card-option.show-meta .card-meta.card-meta--echo {
		opacity: 1;
	}

	.card-meta--echo .card-meta-line {
		display: flex;
		flex-direction: column;
		align-items: center;
		justify-content: center;
		gap: 6px;
		text-align: center;
		font-size: 0.9rem;
	}

	.card-meta--echo .bonus-mini-icon {
		width: 18px;
		height: 18px;
		border-radius: 5px;
		background: linear-gradient(135deg, #ff5757 0%, #ffbf3a 22%, #8cff6a 45%, #47b1ff 70%, #b16cff 100%);
		box-shadow: inset 0 0 4px rgba(0,0,0,0.25), 0 2px 4px rgba(0,0,0,0.2);
		border: 1px solid rgba(120,120,180,0.35);
	}

	.card-meta--echo .coin-icon {
		display: inline-block;
		width: 18px;
		height: 18px;
		border-radius: 50%;
		background: radial-gradient(circle at 30% 30%, #fff6b5, #f7bb36 60%, #d49f20);
		box-shadow: inset 0 -1px 2px rgba(0,0,0,0.2), 0 2px 4px rgba(0,0,0,0.2);
		border: 1px solid #c9960a;
	}

	.card-meta--echo .card-meta-note {
		font-size: 0.88rem;
		letter-spacing: 0.04em;
		text-transform: none;
		color: rgba(15,20,32,0.6);
	}

	.card-meta--echo .meta-target-icon {
		font-size: 1.5em;
		line-height: 1;
		display: inline-block;
	}

	.card-meta.card-meta--level2 {
		font-weight: 800;
		letter-spacing: 0.08em;
		text-transform: uppercase;
		color: #0f243a;
	}

	.card-label.card-label--echo {
		background: linear-gradient(135deg, rgba(79,195,255,0.22), rgba(106,139,255,0.22));
		color: #0f243a;
		font-size: 0.78rem;
		letter-spacing: 0.08em;
		font-weight: 800;
		position: absolute;
		right: 8px;
		bottom: 8px;
		z-index: 5;
		margin: 0;
		pointer-events: none;
	}

	.card-label.card-label--echo .echo-icon {
		font-size: 0.92rem;
		line-height: 1;
	}

	.card-label.card-label--echo {
		background: linear-gradient(135deg, rgba(79,195,255,0.2), rgba(106,139,255,0.2));
		color: #e7f2ff;
	}

	.card-meta.card-meta--echo {
		color: rgba(230,235,255,0.78);
	}

	.card-meta--echo .card-meta-note {
		color: rgba(230,235,255,0.6);
	}

	.card-effect {
		margin-top: 6px;
		font-size: 0.68rem;
		font-weight: 700;
		letter-spacing: 0.05em;
		text-transform: uppercase;
		color: rgba(20,24,36,0.62);
		background: rgba(20,24,36,0.06);
		padding: 4px 10px;
		border-radius: 999px;
		display: inline-flex;
		align-items: center;
		gap: 6px;
	}

	.card-effect.card-effect-echo {
		background: linear-gradient(135deg, #e5f1ff, #d7e4ff);
		color: #0f243a;
		padding: 8px 10px;
		border-radius: 12px;
		box-shadow: 0 10px 22px rgba(0,0,0,0.16);
		gap: 10px;
		align-self: flex-start;
	}

	.card-effect-echo .card-effect-echo-icon {
		width: 24px;
		height: 24px;
		border-radius: 7px;
		background: linear-gradient(135deg, #4fc3ff, #6a8bff);
		display: grid;
		place-items: center;
		color: #0b1b2c;
		font-weight: 800;
		font-size: 14px;
		box-shadow: 0 6px 14px rgba(0,0,0,0.16);
	}

	.card-effect-echo .card-effect-echo-text {
		display: flex;
		flex-direction: column;
		line-height: 1.05;
		gap: 1px;
	}

	.card-effect-echo .card-effect-echo-title {
		font-size: 0.78rem;
		letter-spacing: 0.07em;
	}

	.card-effect-echo .card-effect-echo-sub {
		font-size: 0.7rem;
		letter-spacing: 0.04em;
		font-weight: 700;
		opacity: 0.82;
	}

	.card-effect.card-effect-boost {
		background: linear-gradient(135deg, #fff4cc, #ffd27a);
		color: #5a3a00;
		padding: 8px 10px;
		border-radius: 12px;
		box-shadow: 0 10px 22px rgba(0,0,0,0.16);
		gap: 10px;
		align-self: flex-start;
		display: inline-flex;
		align-items: center;
	}

	.card-effect-boost .card-effect-boost-icon {
		width: 24px;
		height: 24px;
		border-radius: 7px;
		background: linear-gradient(135deg, #ffd56b, #ffb347);
		display: grid;
		place-items: center;
		color: #4c2a00;
		font-weight: 800;
		font-size: 14px;
		box-shadow: 0 6px 14px rgba(0,0,0,0.16);
	}

	.card-effect-boost .card-effect-boost-text {
		display: flex;
		flex-direction: column;
		line-height: 1.05;
		gap: 1px;
	}

	.card-effect-boost .card-effect-boost-title {
		font-size: 0.78rem;
		letter-spacing: 0.07em;
		font-weight: 800;
	}

	.card-effect-boost .card-effect-boost-sub {
		font-size: 0.7rem;
		letter-spacing: 0.04em;
		font-weight: 700;
		opacity: 0.82;
	}

	.card-boost-badge {
		position: absolute;
		top: 6px;
		left: 6px;
		min-width: 22px;
		height: 18px;
		padding: 0 4px;
		display: flex;
		align-items: center;
		justify-content: center;
		border-radius: 6px;
		font-size: 0.65rem;
		font-weight: 800;
		color: #5a3a00;
		background: linear-gradient(135deg, #fff4cc, #ffd27a);
		box-shadow: 0 2px 6px rgba(0,0,0,0.18);
		border: 1px solid rgba(90,58,0,0.25);
		letter-spacing: 0;
		text-align: center;
		line-height: 1;
		pointer-events: none;
		z-index: 5;
	}

	.card-echo-badge {
		position: absolute;
		bottom: 6px;
		right: 6px;
		min-width: 30px;
		height: 30px;
		padding: 0 6px;
		display: flex;
		align-items: center;
		justify-content: center;
		border-radius: 10px;
		font-size: 0.68rem;
		font-weight: 800;
		color: #0b1b2c;
		background: linear-gradient(135deg, #e5f1ff, #d7e4ff);
		box-shadow: 0 8px 16px rgba(0,0,0,0.2);
		pointer-events: auto;
		cursor: pointer;
		border: 1px solid rgba(12,22,36,0.12);
		letter-spacing: 0;
		text-align: center;
		line-height: 1;
	}

	/* Bonus echo badge is now hidden (icon is redundant). */
	.card-echo-badge {
		display: none;
	}

	.card-echo-badge:focus-visible {
		outline: 2px solid rgba(255,255,255,0.9);
		outline-offset: 2px;
	}

	.card-echo-badge[data-variant="points"] {
		background: linear-gradient(135deg, #f7e58f, #f4c542);
		color: #4c3600;
	}

	.card-echo-badge[data-variant="bonus"] {
		background: linear-gradient(135deg, #b4f1d2, #6cd3a5);
		color: #0f3825;
	}

	.card-echo-badge[data-variant="replay"] {
		background: linear-gradient(135deg, #cfe2ff, #8fb2ff);
		color: #0b1b2c;
	}

	.card-echo-badge.card-echo-badge--ready {
		box-shadow: 0 0 0 3px rgba(34,197,94,0.25), 0 8px 16px rgba(0,0,0,0.25);
	}

	.card-option.card-replay-ready .card-echo-badge {
		animation: bonus-echo-replay-pulse 0.9s ease-out 1;
	}

	@keyframes bonus-echo-replay-pulse {
		0% { transform: scale(1); box-shadow: 0 0 0 0 rgba(74,144,226,0.55), 0 8px 16px rgba(0,0,0,0.2); }
		55% { transform: scale(1.18); box-shadow: 0 0 0 8px rgba(74,144,226,0.25), 0 10px 20px rgba(0,0,0,0.3); }
		100% { transform: scale(1); box-shadow: 0 0 0 0 rgba(74,144,226,0), 0 8px 16px rgba(0,0,0,0.2); }
	}

	.card-echo-tooltip {
		position: absolute;
		top: 8px;
		left: 50%;
		right: auto;
		max-width: 240px;
		padding: 8px 10px;
		background: rgba(12,18,28,0.92);
		color: #f3f5ff;
		border-radius: 12px;
		box-shadow: 0 14px 30px rgba(0,0,0,0.38);
		font-size: 0.75rem;
		line-height: 1.25;
		opacity: 0;
		pointer-events: none;
		transform: translateX(-50%) translateY(6px);
		transition: opacity 0.16s ease, transform 0.16s ease;
		z-index: 5;
	}

	.card-bonus-echo.show-meta .card-echo-tooltip,
	.card-bonus-echo.card-echo-tooltip-active .card-echo-tooltip {
		opacity: 1;
		transform: translateX(-50%) translateY(0);
	}

	.card-bonus-echo {
		background: linear-gradient(160deg, #2a334a 0%, #21283a 45%, #191f30 100%);
		border-color: rgba(120,160,255,0.45);
		box-shadow: 0 28px 46px rgba(0,0,0,0.42);
	}

	.card-bonus-boost {
		background: linear-gradient(160deg, #3a2f1a 0%, #2a2012 55%, #1f170c 100%);
		border-color: rgba(255,196,92,0.35);
		box-shadow: 0 26px 44px rgba(0,0,0,0.4);
	}

	.card-option::after {
		background: linear-gradient(180deg, rgba(255,255,255,0.08) 0%, rgba(255,255,255,0) 100%);
	}

	.card-option .card-cell {
		border-color: rgba(255,255,255,0.15);
		box-shadow: 
			inset 0 1px 3px rgba(0,0,0,0.3),
			0 1px 0 rgba(255,255,255,0.05);
		background: var(--card-cell-bg);
	}

	.card-label {
		background: rgba(255,255,255,0.08);
		color: rgba(220,230,255,0.85);
	}

	.card-meta {
		color: rgba(255,255,255,0.65);
	}

	.card-effect {
		color: rgba(255,255,255,0.85);
		background: rgba(255,255,255,0.08);
	}

	.card-effect.card-effect-echo {
		background: linear-gradient(135deg, #1f2f4c, #1a2741);
		color: #e7f2ff;
		box-shadow: 0 10px 22px rgba(0,0,0,0.45);
	}

	.card-effect.card-effect-boost {
		background: linear-gradient(135deg, #3b2a12, #2a1f10);
		color: #ffe9b0;
		box-shadow: 0 10px 22px rgba(0,0,0,0.45);
	}

	.card-effect-boost .card-effect-boost-icon {
		background: linear-gradient(135deg, #ffcc66, #ffb347);
		color: #2a1b00;
		box-shadow: 0 6px 14px rgba(0,0,0,0.35);
	}

	.card-boost-badge {
		background: linear-gradient(135deg, #3b2a12, #2a1f10);
		color: #ffe9b0;
		border-color: rgba(255,233,176,0.2);
		box-shadow: 0 8px 16px rgba(0,0,0,0.35);
	}

	.card-effect-echo .card-effect-echo-icon {
		background: linear-gradient(135deg, #5ac8ff, #809cff);
		color: #0b1626;
		box-shadow: 0 6px 14px rgba(0,0,0,0.35);
	}

	.card-replay-copy {
		position: relative;
		overflow: hidden;
		animation: replay-card-pop 0.65s ease-out 1;
	}

	.card-replay-copy::after {
		content: '';
		position: absolute;
		inset: 0;
		background: radial-gradient(circle at 30% 20%, rgba(255,255,255,0.45), rgba(255,255,255,0) 55%);
		opacity: 0;
		animation: replay-card-shine 0.8s ease-out 1;
		pointer-events: none;
	}

	@keyframes replay-card-pop {
		0% { transform: scale(0.92); box-shadow: 0 0 0 rgba(0,0,0,0); }
		60% { transform: scale(1.05); box-shadow: 0 20px 34px rgba(64,130,255,0.35); }
		100% { transform: scale(1); box-shadow: 0 18px 30px rgba(0,0,0,0.35); }
	}

	@keyframes replay-card-shine {
		0% { opacity: 0; }
		40% { opacity: 0.6; }
		100% { opacity: 0; }
	}

	@keyframes coinPop {
	  0% { transform: translate(-50%, -50%) scale(0); opacity: 0.2; }
	  70% { transform: translate(-50%, -50%) scale(1.3); opacity: 1; }
	  100% { transform: translate(-50%, -50%) scale(1); }
	}


	@keyframes growRoot {
	  from { opacity: 0; transform: scale(0.5); }
	  to { opacity: 1; transform: scale(1); }
	}

	.modal-overlay {
		position: fixed;
		inset: 0;
		padding: 18px;
		display: none;
		align-items: flex-start;
		justify-content: center;
		background: rgba(10, 12, 20, 0.6);
		backdrop-filter: blur(6px);
		-webkit-backdrop-filter: blur(6px);
		z-index: 1200;
		overflow-y: auto;
	}

	.modal-overlay.show {
		display: flex;
	}

	.game-modal {
		background: #fffbea;
		border-radius: 16px;
		padding: 24px;
		width: min(420px, 100%);
		box-shadow: 0 26px 48px rgba(10, 12, 20, 0.34);
		border: 1px solid rgba(20, 24, 36, 0.18);
		color: #191d2a;
		position: relative;
	}

	.game-modal {
		background: rgba(12, 14, 20, 0.95);
		border-color: rgba(255, 255, 255, 0.14);
		color: #f5f6ff;
		box-shadow: 0 30px 52px rgba(0, 0, 0, 0.55);
	}

	.game-modal h2 {
		margin-top: 0;
		margin-bottom: 8px;
		font-size: 1.35rem;
	}

	.game-modal p {
		margin: 8px 0;
		line-height: 1.5;
	}

	.modal-subtext {
		margin: 4px 0 0;
		font-size: 0.85rem;
		color: rgba(27, 33, 48, 0.7);
	}

	.modal-subtext {
		color: rgba(245, 246, 255, 0.7);
	}

	.modal-actions {
		display: flex;
		flex-wrap: wrap;
		gap: 12px;
		justify-content: flex-end;
		margin-top: 20px;
	}

	.modal-actions button {
		background: linear-gradient(145deg, #ffd560, #ffb23c);
		border: 1px solid rgba(20, 24, 36, 0.14);
		border-radius: 10px;
		padding: 10px 18px;
		font-weight: 600;
		cursor: pointer;
		transition: transform 0.2s ease, box-shadow 0.2s ease;
		color: #1f2433;
	}

	.modal-actions button:hover:not(:disabled) {
		transform: translateY(-2px);
		box-shadow: 0 14px 28px rgba(10, 12, 20, 0.28);
	}

	.modal-actions button:disabled {
		opacity: 0.6;
		cursor: not-allowed;
		box-shadow: none;
	}

	.modal-actions button {
		background: linear-gradient(145deg, #2f3546, #1c2233);
		border-color: rgba(255, 255, 255, 0.12);
		color: #f5f6ff;
	}

	.modal-score-summary {
		margin-top: 14px;
		display: flex;
		flex-direction: column;
		gap: 16px;
	}

	.round-summary-cards {
		display: flex;
		flex-wrap: wrap;
		gap: 12px;
		justify-content: center;
	}

	.round-summary-card {
		flex: 1 1 160px;
		min-width: 150px;
		padding: 14px 16px;
		border-radius: 16px;
		text-align: center;
		background: linear-gradient(145deg, rgba(255, 242, 196, 0.85), rgba(255, 214, 125, 0.9));
		border: 1px solid rgba(20, 24, 36, 0.08);
		box-shadow: 0 16px 24px rgba(31, 36, 51, 0.12);
	}

	.round-summary-card--coins {
		background: linear-gradient(145deg, rgba(255, 240, 200, 0.9), rgba(255, 199, 142, 0.95));
	}

	/* Unlock Modal Styles */
	.unlock-modal {
		max-width: 500px;
		text-align: center;
	}

	/* Modal button (Doorgaan knop) */
	.modal-button {
		background: linear-gradient(145deg, #667eea, #764ba2);
		border: 1px solid rgba(102, 126, 234, 0.3);
		border-radius: 10px;
		padding: 12px 28px;
		font-weight: 600;
		font-size: 1rem;
		cursor: pointer;
		transition: transform 0.2s ease, box-shadow 0.2s ease, background 0.2s ease;
		color: #fff;
		box-shadow: 0 8px 20px rgba(102, 126, 234, 0.3);
		margin-top: 10px;
	}

	.modal-button:hover {
		transform: translateY(-2px);
		box-shadow: 0 12px 28px rgba(102, 126, 234, 0.45);
		background: linear-gradient(145deg, #7a8ff0, #8a5cb8);
	}

	.modal-button {
		background: linear-gradient(145deg, #4a5fb8, #5a3d8a);
		border-color: rgba(139, 159, 245, 0.4);
		box-shadow: 0 8px 20px rgba(74, 95, 184, 0.4);
	}

	.modal-button:hover {
		background: linear-gradient(145deg, #5a6fc8, #6a4d9a);
		box-shadow: 0 12px 28px rgba(74, 95, 184, 0.55);
	}

	.unlock-modal-content {
		display: flex;
		flex-direction: column;
		align-items: center;
		gap: 20px;
	}

	.unlock-icon {
		font-size: 64px;
		animation: unlock-bounce 0.6s ease-out;
	}

	@keyframes unlock-bounce {
		0% { transform: scale(0) rotate(-180deg); opacity: 0; }
		50% { transform: scale(1.2) rotate(10deg); }
		100% { transform: scale(1) rotate(0deg); opacity: 1; }
	}

	.unlock-title {
		font-size: 1.8rem;
		margin: 0;
		background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
		-webkit-background-clip: text;
		-webkit-text-fill-color: transparent;
		background-clip: text;
	}

	.unlock-title {
		background: linear-gradient(135deg, #8b9ff5 0%, #a77bc9 100%);
		-webkit-background-clip: text;
		-webkit-text-fill-color: transparent;
		background-clip: text;
	}

	.unlock-items-container {
		width: 100%;
		display: flex;
		flex-direction: column;
		gap: 16px;
	}

	.unlock-item {
		background: linear-gradient(145deg, rgba(102, 126, 234, 0.1), rgba(118, 75, 162, 0.1));
		border: 2px solid rgba(102, 126, 234, 0.3);
		border-radius: 12px;
		padding: 16px;
		display: flex;
		align-items: center;
		gap: 16px;
		animation: unlock-slide-in 0.4s ease-out backwards;
	}

	.unlock-item {
		background: linear-gradient(145deg, rgba(102, 126, 234, 0.15), rgba(118, 75, 162, 0.15));
		border-color: rgba(139, 159, 245, 0.4);
	}

	.unlock-item:nth-child(2) { animation-delay: 0.1s; }
	.unlock-item:nth-child(3) { animation-delay: 0.2s; }
	.unlock-item:nth-child(4) { animation-delay: 0.3s; }

	@keyframes unlock-slide-in {
		from { 
			opacity: 0; 
			transform: translateX(-30px);
		}
		to {
			opacity: 1;
			transform: translateX(0);
		}
	}

	.unlock-item-icon {
		font-size: 32px;
		flex-shrink: 0;
	}

	.unlock-item-content {
		flex: 1;
		text-align: left;
	}

	.unlock-item-name {
		font-weight: bold;
		font-size: 1.1rem;
		margin-bottom: 4px;
		color: #667eea;
	}

	.unlock-item-name {
		color: #8b9ff5;
	}

	.unlock-item-description {
		font-size: 0.9rem;
		opacity: 0.8;
		margin: 0;
	}

	.unlock-item--feature {
		border-color: rgba(102, 126, 234, 0.5);
		background: linear-gradient(145deg, rgba(102, 126, 234, 0.2), rgba(118, 75, 162, 0.2));
	}

	.unlock-item--feature {
		border-color: rgba(139, 159, 245, 0.6);
		background: linear-gradient(145deg, rgba(102, 126, 234, 0.25), rgba(118, 75, 162, 0.25));
	}

	.unlock-item--feature .unlock-item-name {
		color: #8b6dff;
	}

	.unlock-item--feature .unlock-item-name {
		color: #a899ff;
	}

	.unlock-item--challenge {
		border-color: rgba(255, 99, 71, 0.4);
		background: linear-gradient(145deg, rgba(255, 99, 71, 0.1), rgba(255, 140, 0, 0.1));
	}

	.unlock-item--challenge {
		border-color: rgba(255, 140, 0, 0.5);
		background: linear-gradient(145deg, rgba(255, 99, 71, 0.15), rgba(255, 140, 0, 0.15));
	}

	.unlock-item--challenge .unlock-item-name {
		color: #ff6347;
	}

	.unlock-item--challenge .unlock-item-name {
		color: #ff8c69;
	}

	.round-summary-card {
		background: linear-gradient(145deg, rgba(46, 54, 78, 0.9), rgba(32, 39, 58, 0.95));
		border-color: rgba(255, 255, 255, 0.08);
		box-shadow: 0 18px 28px rgba(5, 8, 16, 0.6);
	}

	.round-summary-card--coins {
		background: linear-gradient(145deg, rgba(66, 52, 22, 0.82), rgba(97, 76, 36, 0.92));
	}

	.round-summary-icon {
		display: block;
		font-size: 1.35rem;
		margin-bottom: 6px;
	}

	.round-summary-label {
		display: block;
		font-size: 0.75rem;
		letter-spacing: 0.18em;
		text-transform: uppercase;
		color: rgba(31, 36, 51, 0.7);
		margin-bottom: 4px;
	}

	.round-summary-label {
		color: rgba(245, 246, 255, 0.6);
	}

	.round-summary-value {
		display: block;
		font-size: 2.1rem;
		font-weight: 700;
		color: #1f2433;
	}

	.round-summary-value {
		color: #f5f6ff;
	}

	.round-summary-bonus {
		display: inline-flex;
		align-items: center;
		justify-content: center;
		margin-top: 8px;
		padding: 4px 10px;
		border-radius: 999px;
		font-size: 0.78rem;
		font-weight: 600;
		background: rgba(31, 36, 51, 0.08);
		color: #1f2433;
	}

	.round-summary-bonus {
		background: rgba(245, 246, 255, 0.15);
		color: #f5f6ff;
	}

	.round-summary-bonus--muted {
		opacity: 0.6;
	}

	.modal-summary-line {
		display: flex;
		justify-content: space-between;
		align-items: center;
		gap: 12px;
		padding: 6px 0;
		font-size: 0.95rem;
		line-height: 1.5;
		border-bottom: 1px solid rgba(20, 24, 36, 0.1);
	}

	.modal-summary-line:last-child {
		border-bottom: none;
	}

	.modal-summary-line {
		border-color: rgba(255, 255, 255, 0.12);
	}

	#deck-modal {
		width: min(90vw, 780px);
		max-height: 80vh;
	}

	.deck-modal-grid {
		display: grid;
		grid-template-columns: repeat(auto-fit, minmax(110px, 1fr));
		gap: 12px;
		margin-top: 14px;
		max-height: 56vh;
		overflow-y: auto;
		padding: 0 6px;
	}

	.deck-modal-grid::-webkit-scrollbar {
		width: 6px;
	}

	.deck-modal-grid::-webkit-scrollbar-thumb {
		background: rgba(80, 90, 110, 0.35);
		border-radius: 6px;
	}

	.deck-modal-grid .card-option {
		transform: none;
		width: 100%;
		max-width: 160px;
		min-height: 200px;
		height: auto;
		margin: 0 auto;
		padding: 12px 8px;
		--preview-cell: var(--card-cell-size);
		gap: 0;
		display: flex;
		flex-direction: column;
		justify-content: center;
		align-items: center;
		text-align: center;
		position: relative;
		overflow: hidden;
		background: linear-gradient(165deg, #ffffff 0%, #eef2ff 45%, #dfe4ff 100%);
		border: 1px solid rgba(40,55,120,0.18);
		box-shadow: 0 8px 16px rgba(10,12,20,0.15);
		border-radius: 12px;
	}

	.deck-modal-grid .card-option::after {
		display: none;
	}

	/* The deck overview modal is a read-only preview: clicking should NOT select cards there. */
	#deck-modal-content.deck-modal-grid .card-option {
		pointer-events: none;
		cursor: default;
	}

	/* Remove golden card shine animation in deck overview */
	#deck-modal-content.deck-modal-grid .card-option.card-golden::before {
		animation: none;
		display: none;
	}
	
	/* Golden cards in deck modal inherit the same flex layout. */

	/* The golden unlock modal MUST be clickable (pick 1 of 3). */
	#golden-unlock-content.deck-modal-grid .card-option {
		pointer-events: auto;
		cursor: pointer;
	}

	.deck-modal-grid .card-pattern {
		gap: var(--card-preview-gap);
		margin: auto;
		flex: 0 0 auto;
		display: grid;
		place-items: center;
		filter: var(--card-glow);
		position: relative;
		z-index: 1;
	}

	/* Deck overview: pattern is the ONLY centered flow child.
	   All other children are absolute overlays so they never push the pattern. */
	.deck-modal-grid .card-option .card-label,
	.deck-modal-grid .card-option .card-meta,
	.deck-modal-grid .card-option .card-boost-badge,
	.deck-modal-grid .card-option .card-echo-badge,
	.deck-modal-grid .card-option .card-echo-tooltip {
		position: absolute;
		pointer-events: none;
		z-index: 10;
	}

	/* Meta trigger stays absolute but MUST receive pointer events for hover */
	.deck-modal-grid .card-option .card-meta-trigger {
		position: absolute;
		pointer-events: auto;
		z-index: 11;
	}

	/* Label badge at bottom center */
	.deck-modal-grid .card-option .card-label {
		bottom: 8px;
		left: 8px;
		right: 8px;
		margin: 0;
		justify-content: center;
	}

	.deck-modal-grid .card-option .card-boost-badge {
		top: auto;
		bottom: 8px;
		left: 8px;
		font-size: 0.6rem;
		min-width: 18px;
		height: 16px;
		padding: 0 3px;
	}

	.deck-modal-grid .card-option .card-meta--echo {
		bottom: 8px;
		left: 8px;
		right: auto;
		font-size: 0.55rem;
		background: transparent;
		padding: 0;
		border-radius: 0;
	}

	/* Combined deck overview badge: icons -> text */
	.deck-modal-grid .deck-modal-combo-badge {
		position: absolute;
		left: 50%;
		bottom: 8px;
		transform: translateX(-50%);
		display: inline-flex;
		align-items: center;
		gap: 6px;
		padding: 2px 6px;
		border-radius: 7px;
		background: rgba(120, 170, 255, 0.92);
		color: #fff;
		font-size: 0.56rem;
		font-weight: 800;
		letter-spacing: 0.02em;
		box-shadow: 0 2px 6px rgba(0,0,0,0.25);
		z-index: 10;
		pointer-events: none;
	}

	.deck-modal-grid .deck-modal-combo-badge .combo-icons {
		display: inline-flex;
		gap: 2px;
		align-items: center;
	}

	.deck-modal-grid .deck-modal-combo-badge .combo-arrow {
		opacity: 0.85;
		font-weight: 900;
	}

	/* Reward picker (golden/XL/XXL) - larger, balanced layout */
	#golden-unlock-modal {
		width: min(92vw, 680px);
		max-height: 80vh;
		padding: 18px 18px 20px;
	}

	#golden-unlock-modal h2 {
		font-size: 1.3rem;
		margin-bottom: 6px;
	}

	#golden-unlock-modal .modal-subtext {
		font-size: 0.9rem;
		margin-bottom: 6px;
	}

	#golden-unlock-content.deck-modal-grid {
		grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
		gap: 14px;
		padding: 0 8px 6px;
		max-height: 56vh;
	}

	#golden-unlock-content.deck-modal-grid .card-option {
		max-width: none;
		min-height: 190px;
		height: 190px;
		padding: 12px;
		gap: 8px;
		justify-content: center;
		align-items: center;
		text-align: center;
		--preview-cell: var(--card-cell-size);
	}

	/* Show labels in golden unlock modal */
	#golden-unlock-content.deck-modal-grid .card-option .card-label {
		display: inline-flex;
	}

	/* Deck overview: use same cell size as board for consistency. */
	.deck-modal-grid .card-option {
		--preview-cell: var(--card-cell-size);
	}

	.deck-modal-grid .deck-modal-card.deck-modal-card--depleted {
		opacity: 0.35;
		filter: saturate(35%);
	}

	/* Inactive blueprint badge: small exclamation in the corner. Exclude
	   multikleur cards (they are special and should not show this). */
	.deck-modal-grid .deck-modal-card.deck-modal-card--inactive {
		position: relative;
		opacity: 0.5;
		filter: grayscale(40%);
	}
	.deck-modal-grid .deck-modal-card.deck-modal-card--inactive::after {
		content: '!';
		position: absolute;
		top: 6px;
		right: 6px;
		background: #ffcc00;
		color: #3b2b00;
		font-weight: 700;
		font-size: 11px;
		line-height: 14px;
		width: 18px;
		height: 18px;
		border-radius: 10px;
		display: inline-flex;
		align-items: center;
		justify-content: center;
		box-shadow: 0 2px 4px rgba(0,0,0,0.25);
	}

	/* Explicit badge element styling (fallback for older browsers / layout) */
	.deck-modal-inactive-badge {
		position: absolute;
		top: 6px;
		right: 6px;
		width: 20px;
		height: 20px;
		border-radius: 10px;
		background: #ffcc00;
		color: #3b2b00;
		display: inline-flex;
		align-items: center;
		justify-content: center;
		font-weight: 700;
		font-size: 12px;
		box-shadow: 0 2px 4px rgba(0,0,0,0.25);
		pointer-events: none;
	}
	/* Hide badge for multikleur (rainbow) cards which already have their own corner mark */
	.deck-modal-grid .deck-modal-card[data-card-label*="MULTIKLEUR" i].deck-modal-card--inactive::after,
	.deck-modal-grid .deck-modal-card[data-card-label*="RAINBOW" i].deck-modal-card--inactive::after,
	.deck-modal-grid .deck-modal-card[data-card-label*="MULTI" i].deck-modal-card--inactive::after {
		display: none;
	}

	.deck-modal-grid .deck-modal-card.deck-modal-card--in-hand {
		opacity: 0.55;
	}

	.deck-modal-grid .card-option:hover,
	.deck-modal-grid .card-option:focus {
		transform: none;
		box-shadow: 0 2px 8px rgba(0,0,0,0.12);
	}

	.deck-modal-grid .card-option:hover,
	.deck-modal-grid .card-option:focus {
		box-shadow: 0 2px 10px rgba(0,0,0,0.3);
	}
	
	/* Keep golden border on deck overview cards - enhanced styling */
	#deck-modal-content.deck-modal-grid .card-option.card-golden {
		border: 2px solid rgba(200,160,50,0.6);
		box-shadow: 
			0 4px 8px rgba(0,0,0,0.08),
			0 10px 20px rgba(30,50,100,0.12),
			0 0 12px rgba(200,160,40,0.25),
			inset 0 1px 0 rgba(255,220,100,0.3);
	}
	
	#deck-modal-content.deck-modal-grid .card-option.card-golden {
		border: 2px solid rgba(200,160,50,0.6);
		box-shadow: 
			0 4px 8px rgba(0,0,0,0.2),
			0 10px 20px rgba(0,0,0,0.25),
			0 0 14px rgba(200,160,40,0.25),
			inset 0 1px 0 rgba(255,220,100,0.12);
	}
	/* Remove golden card shine in deck overview (dark mode) */
	#deck-modal-content.deck-modal-grid .card-option.card-golden::before {
		animation: none;
		display: none;
	}

	.deck-modal-empty {
		margin: 18px 0 6px;
		text-align: center;
		color: rgba(0, 0, 0, 0.6);
	}

	.blackhole-modal {
	  width: min(92vw, 760px);
	  max-height: 82vh;
	  background: radial-gradient(circle at 15% 20%, rgba(108,125,255,0.08), transparent 32%),
		linear-gradient(145deg, #0d1020 0%, #0c1226 45%, #0a0f1f 100%);
	  border: 1px solid rgba(130, 160, 255, 0.25);
	  box-shadow: 0 18px 48px rgba(0, 6, 28, 0.55), inset 0 1px 0 rgba(255,255,255,0.05);
	  backdrop-filter: blur(6px);
	}

	.blackhole-modal h2 {
		display: flex;
		align-items: center;
		justify-content: space-between;
		gap: 12px;
	}

	.blackhole-hero {
		position: relative;
		width: 64px;
		height: 64px;
		flex: 0 0 auto;
		border-radius: 50%;
		background: radial-gradient(circle at 40% 35%, rgba(130, 150, 255, 0.35), rgba(40, 50, 110, 0.65) 45%, rgba(8, 10, 22, 0.95) 70%);
		box-shadow: 0 0 22px rgba(110, 140, 255, 0.45), inset 0 0 12px rgba(0,0,0,0.6);
		overflow: hidden;
	}
	.blackhole-hero::before {
		content: '';
		position: absolute;
		inset: -20%;
		border-radius: 50%;
		background: conic-gradient(from 45deg, rgba(120, 180, 255, 0.0), rgba(120, 180, 255, 0.4), rgba(120, 180, 255, 0.0));
		/* Animation removed for performance - static glow */
	}
	.blackhole-hero::after {
		content: '';
		position: absolute;
		inset: 18%;
		border-radius: 50%;
		background: radial-gradient(circle, rgba(0,0,0,0.95) 0%, rgba(0,0,0,0.6) 55%, rgba(70, 90, 180, 0.25) 100%);
		box-shadow: inset 0 0 14px rgba(0,0,0,0.85);
	}

	.blackhole-subtext {
		color: rgba(210, 225, 255, 0.8);
		font-weight: 500;
	}

	.blackhole-card-grid {
	  margin-top: 16px;
	  gap: 14px;
	}

	.blackhole-card-grid .blackhole-card {
	  pointer-events: auto;
	  cursor: pointer;
	  background: transparent;
	  border: 1px solid rgba(130, 160, 255, 0.25);
	  box-shadow: 0 14px 32px rgba(0, 10, 40, 0.35);
	  border-radius: 14px;
	  padding: 0;
	  aspect-ratio: 1;
	  position: relative;
	  perspective: 900px;
	  transition: transform 0.18s ease, box-shadow 0.18s ease, border-color 0.18s ease;
	}

	.blackhole-card-grid .blackhole-card:hover {
	  transform: translateY(-4px);
	  box-shadow: 0 22px 36px rgba(40, 32, 88, 0.32);
	}

	.blackhole-card-grid .blackhole-card.selected {
	  border-color: rgba(140, 190, 255, 0.8);
	  box-shadow: 0 26px 44px rgba(70, 120, 220, 0.35), 0 0 0 1px rgba(140, 190, 255, 0.45);
	}

	.blackhole-card-inner {
		position: absolute;
		inset: 0;
		border-radius: 12px;
		transform-style: preserve-3d;
		transition: transform 0.6s cubic-bezier(0.2, 0.6, 0.2, 1);
	}

	.blackhole-card.is-revealed .blackhole-card-inner {
		transform: rotateY(180deg);
	}

	.blackhole-card-face {
		position: absolute;
		inset: 0;
		display: flex;
		align-items: center;
		justify-content: center;
		border-radius: 12px;
		backface-visibility: hidden;
		font-weight: 700;
		letter-spacing: 0.4px;
	}

	.blackhole-card-front {
		background: linear-gradient(140deg, rgba(30, 38, 80, 0.75), rgba(12, 16, 32, 0.95));
		color: rgba(220, 235, 255, 0.9);
		border: 1px solid rgba(120, 150, 255, 0.2);
		box-shadow: inset 0 0 12px rgba(0,0,0,0.45);
		font-size: 26px;
	}

	.blackhole-card-front::after {
		content: '';
		position: absolute;
		inset: 8px;
		border-radius: 10px;
		border: 1px dashed rgba(140, 170, 255, 0.2);
	}

	.blackhole-card-back {
		transform: rotateY(180deg);
		color: #0b0e1a;
		font-size: 22px;
		background: linear-gradient(150deg, rgba(220, 230, 255, 0.95), rgba(160, 180, 240, 0.92));
	}

	.blackhole-card--points .blackhole-card-back {
		background: linear-gradient(150deg, #ecf2ff, #b9c8ff);
		color: #1b2350;
		box-shadow: inset 0 0 20px rgba(120, 140, 255, 0.45);
	}

	.blackhole-card--coins .blackhole-card-back {
		background: linear-gradient(150deg, #ecfff1, #b9f2c6);
		color: #1e4b2c;
		box-shadow: inset 0 0 20px rgba(90, 190, 120, 0.35);
	}

	.blackhole-card--multiplier .blackhole-card-back {
		background: linear-gradient(150deg, #fff5c2, #ffd36c);
		color: #5a3d00;
		box-shadow: inset 0 0 20px rgba(255, 200, 60, 0.45);
	}

	.blackhole-card--blackhole .blackhole-card-back {
		background: radial-gradient(circle at 40% 35%, rgba(110, 130, 255, 0.35), rgba(12, 16, 32, 0.9) 55%, #020205 100%);
		color: #ff9aa0;
		box-shadow: inset 0 0 26px rgba(30, 20, 60, 0.85), 0 0 18px rgba(90, 40, 120, 0.5);
	}

	.blackhole-modal.effect-pulse {
		animation: blackhole-pulse 0.6s ease;
	}
	.blackhole-modal.effect-spark {
		animation: blackhole-spark 0.7s ease;
	}
	.blackhole-modal.effect-shake {
		animation: blackhole-shake 0.6s ease;
	}

	@keyframes blackhole-pulse {
		0% { transform: scale(1); box-shadow: 0 18px 48px rgba(0, 6, 28, 0.55); }
		50% { transform: scale(1.02); box-shadow: 0 22px 60px rgba(80, 110, 220, 0.45); }
		100% { transform: scale(1); box-shadow: 0 18px 48px rgba(0, 6, 28, 0.55); }
	}
	@keyframes blackhole-spark {
		0% { transform: scale(1); }
		40% { transform: scale(1.03); }
		100% { transform: scale(1); }
	}
	@keyframes blackhole-shake {
		0% { transform: translateX(0); }
		20% { transform: translateX(-4px); }
		40% { transform: translateX(4px); }
		60% { transform: translateX(-3px); }
		80% { transform: translateX(3px); }
		100% { transform: translateX(0); }
	}

	.blackhole-stats {
	  display: flex;
	  flex-wrap: wrap;
	  justify-content: space-between;
	  gap: 12px;
	  padding: 10px 12px;
	  font-size: 0.95rem;
	  color: rgba(220,230,255,0.86);
	  background: rgba(255,255,255,0.04);
	  border: 1px solid rgba(140, 160, 240, 0.25);
	  border-radius: 12px;
	}

	.blackhole-stats strong {
	  font-weight: 700;
	  color: #94b0ff;
	}

	.blackhole-feedback {
	  min-height: 22px;
	  font-size: 0.95rem;
	  color: rgba(210,220,255,0.82);
	  margin-top: 10px;
	  padding: 8px 10px;
	  background: rgba(110, 130, 220, 0.14);
	  border: 1px solid rgba(140, 170, 255, 0.28);
	  border-radius: 10px;
	  transition: opacity 0.2s ease;
	  opacity: 0;
	}

	.blackhole-feedback.show {
	  opacity: 1;
	}

	.blackhole-feedback[data-tone="warn"] {
	  color: #ffb4b4;
	  background: rgba(176, 50, 74, 0.22);
	  border-color: rgba(255, 120, 140, 0.35);
	}

	.blackhole-actions {
	  display: flex;
	  justify-content: flex-end;
	  gap: 10px;
	}

	.blackhole-actions button {
	  min-width: 140px;
	}

	.deck-modal-grid::-webkit-scrollbar-thumb {
		background: rgba(160, 170, 210, 0.25);
	}

	.deck-modal-empty {
		color: rgba(255, 255, 255, 0.65);
	}
	.deck-modal-grid .card-option {
		background: linear-gradient(160deg, #2d3142 0%, #232635 45%, #1b1e2c 100%);
		border: 1px solid rgba(120,140,220,0.2);
		box-shadow: 0 8px 20px rgba(0,0,0,0.4);
	}

	.deck-modal-grid .card-option.card-golden {
	  border: 2px solid rgba(200,160,50,0.7);
	  box-shadow:
		0 4px 8px rgba(0,0,0,0.2),
		0 10px 20px rgba(0,0,0,0.25),
		0 0 12px rgba(200,160,40,0.2),
		inset 0 1px 0 rgba(255,220,100,0.1);
	}

	.blackhole-stats {
	  color: rgba(220, 224, 248, 0.82);
	}

	.blackhole-stats strong {
	  color: #d4cffd;
	}

	.blackhole-feedback {
	  color: rgba(210, 210, 248, 0.75);
	}

	.blackhole-feedback[data-tone="warn"] {
	  color: #ff9a9a;
	}

	/* Rules Modal Styling */
	#rules-modal {
		max-height: 80vh;
		overflow-y: auto;
	}

	.rules-section {
		margin-bottom: 20px;
	}

	.rules-section:last-child {
		margin-bottom: 0;
	}

	.rules-section h3 {
		margin: 0 0 10px 0;
		font-size: 1.1rem;
		font-weight: 700;
		color: rgba(20,24,36,0.9);
	}

	.rules-section ul {
		margin: 8px 0;
		padding-left: 24px;
	}

	.rules-section li {
		margin-bottom: 6px;
		line-height: 1.5;
	}

	.rules-section p {
		margin: 8px 0;
		line-height: 1.6;
	}

	.rules-section strong {
		color: rgba(20,24,36,0.95);
		font-weight: 600;
	}

	.rules-section h3 {
		color: rgba(255, 255, 255, 0.95);
	}

	.rules-section strong {
		color: rgba(255, 255, 255, 0.9);
	}

	/* ============================================
	   DECK MODAL & SHOP - MOBILE
	   ============================================ */
	@media (max-width: 650px) {
		#deck-modal {
			width: min(96vw, 560px);
			max-height: 74vh;
			padding: 12px;
		}

		#deck-modal h2 {
			font-size: 0.98rem;
			margin-bottom: 4px;
		}

		#deck-modal .modal-subtext {
			font-size: 0.78rem;
		}

		.deck-modal-grid {
			grid-template-columns: repeat(auto-fit, minmax(64px, 1fr));
			gap: 12px;
			padding: 0 2px;
			max-height: 54vh;
		}

		.deck-modal-grid .card-option {
			min-height: 152px;
			height: 152px;
			padding: 8px 6px;
			overflow: hidden;
			display: flex;
			justify-content: center;
			align-items: center;
			gap: 0;
			text-align: center;
		}

		.deck-modal-grid .card-pattern {
			gap: 4px;
			margin: 0 auto;
		}

		.deck-modal-grid .card-option {
			--preview-cell: 12px;
		}

		/* Reward picker (golden unlock) on mobile: keep 3 columns, smaller cells, bigger cards */
		#golden-unlock-content.deck-modal-grid {
			grid-template-columns: repeat(3, minmax(0, 1fr));
			gap: 10px;
			padding: 0 4px;
		}
		#golden-unlock-content.deck-modal-grid .card-option {
			max-width: none;
			min-height: 156px;
			height: 156px;
			padding: 6px;
			--preview-cell: 8px;
		}

		.deck-modal-grid .card-option .card-label {
			font-size: 0.52rem;
			padding: 2px 6px;
			gap: 4px;
			letter-spacing: 0.05em;
			text-transform: none;
			white-space: nowrap;
			max-width: 100%;
			overflow: hidden;
			text-overflow: ellipsis;
		}

		.deck-modal-grid .card-option .card-meta {
			font-size: 0.52rem;
			letter-spacing: 0.03em;
			white-space: nowrap;
			max-width: 100%;
			overflow: hidden;
			text-overflow: ellipsis;
		}
	}

	@media (max-width: 450px) {
		/* Deck Modal - kleinere kaarten met betere spacing */
		#deck-modal {
			width: min(94vw, 420px);
			max-height: 75vh;
			padding: 10px;
		}

		.deck-modal-grid {
			grid-template-columns: repeat(auto-fit, minmax(58px, 1fr));
			gap: 10px;
			max-height: 54vh;
		}

		.deck-modal-grid .card-option {
			min-height: 130px;
			height: 130px;
			max-width: 80px;
			padding: 6px 5px;
			transform: none;
			overflow: hidden;
			display: flex;
			justify-content: center;
			align-items: center;
			gap: 0;
			text-align: center;
		}

		.deck-modal-grid .card-pattern {
			gap: 3px;
			margin: 0 auto;
		}

		.deck-modal-grid .card-option {
			--preview-cell: 11px;
		}

		/* Reward picker (golden unlock) on small phones */
		#golden-unlock-content.deck-modal-grid {
			grid-template-columns: repeat(3, minmax(0, 1fr));
			gap: 8px;
			padding: 0 2px;
		}
		#golden-unlock-content.deck-modal-grid .card-option {
			max-width: none;
			min-height: 146px;
			height: 146px;
			padding: 5px;
			--preview-cell: 7px;
		}

		.deck-modal-grid .card-option .card-label {
			font-size: 0.5rem;
			padding: 2px 6px;
			gap: 4px;
			letter-spacing: 0.03em;
			text-transform: none;
			white-space: nowrap;
			max-width: 100%;
			overflow: hidden;
			text-overflow: ellipsis;
		}

		.deck-modal-grid .card-option .card-meta {
			font-size: 0.5rem;
			letter-spacing: 0.02em;
			white-space: nowrap;
			max-width: 100%;
			overflow: hidden;
			text-overflow: ellipsis;
		}

		/* Shop Modal - compactere layout */
		#shop-modal {
			width: min(96vw, 420px);
			max-height: 72vh;
			padding: 12px 14px;
			gap: 8px;
		}

		#shop-modal h2 {
			font-size: 0.88rem;
		}

		/* Verberg uitleg tekst */
		#shop-modal-message {
			display: none;
		}

		/* Verberg shop-card-header */
		.shop-card-header {
			display: none;
		}

		/* Shop cards - kleiner schalen */
		.shop-card {
			transform: scale(0.85);
			transform-origin: center;
			padding: 8px;
			gap: 6px;
		}

		.shop-card-list {
			grid-template-columns: repeat(2, 1fr);
			gap: 16px;
		}

		.shop-card-preview {
			max-width: 100%;
		}

		.shop-card-preview .card-option {
			width: 100%;
			min-height: 120px;
		}

		/* Shop lower grid - force side by side with flexbox */
		.shop-lower-grid {
			display: grid;
			grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
			gap: 10px;
			width: 100%;
		}

		.shop-upgrades-section,
		.shop-bonus-section {
			flex: 1 1 0;
			min-width: 0;
			width: auto;
			max-width: none;
			padding: 12px;
			flex-direction: column;
			align-items: stretch;
			justify-content: flex-start;
			border-radius: 12px;
		}

		.shop-section-title {
			font-size: 0.72rem;
			margin-bottom: 10px;
		}

		.shop-section-title::before {
			font-size: 0.85rem;
		}

		.shop-upgrade-container {
			display: grid;
			grid-template-columns: 1fr;
			gap: 10px;
			width: 100%;
		}

		/* Bonus container ook single column */
		.shop-bonus-container {
			display: flex;
			flex-direction: column;
			gap: 10px;
			width: 100%;
		}

		/* Bonus cards compacter - verticale layout */
		.shop-bonus-card {
			flex-direction: column;
			align-items: flex-start;
			gap: 8px;
			padding: 10px 12px;
		}

		.shop-bonus-info {
			width: 100%;
			gap: 8px;
			font-size: 0.75rem;
		}



		.shop-bonus-actions {
			width: 100%;
		}

		.shop-bonus-actions button {
			width: 100%;
			padding: 8px 12px;
			font-size: 0.75rem;
		}

		.shop-upgrade-card {
			padding: 12px;
			gap: 8px;
		}

		.shop-upgrade-card::before {
			height: 2px;
		}

		.shop-upgrade-header {
			font-size: 0.8rem;
		}

		.upgrade-icon {
			width: 28px;
			height: 28px;
			font-size: 1rem;
			border-radius: 8px;
		}

		.shop-upgrade-desc {
			font-size: 0.7rem;
			line-height: 1.35;
		}

		.shop-upgrade-actions button {
			padding: 8px 14px;
			font-size: 0.75rem;
			border-radius: 8px;
		}

		.shop-empty-state {
			padding: 14px;
			font-size: 0.72rem;
		}
	}

	/* ============================================
	   SHOP MODAL - BASIS (DESKTOP)
	   ============================================
	   Pop-up winkel waar je met munten extra kaarten en upgrades kunt kopen
	   2-kolommen layout: kaarten links, upgrades rechts
	*/
	#shop-modal {
		display: flex;
		flex-direction: column;
		gap: 18px;
		padding: 24px;
		background: linear-gradient(160deg, rgba(255,255,255,0.98), rgba(232,238,252,0.92));
		border: 1px solid rgba(60,70,140,0.12);
		box-shadow: 0 32px 54px rgba(12,18,38,0.25);
		border-radius: 20px;
		max-width: 920px;
		width: min(92vw, 920px);
		margin: auto;
		max-height: calc(100vh - 36px);
		overflow-y: auto;
		overscroll-behavior: contain;
		-webkit-overflow-scrolling: touch;
		contain: layout paint;
		scrollbar-width: thin;
		scrollbar-color: rgba(100, 120, 180, 0.5) transparent;
	}

	/* Shop overlay: avoid nested scrolling (keeps scrolling smooth inside the modal). */
	#shop-modal-layer {
		overflow: hidden;
		overscroll-behavior: contain;
	}
	
	#shop-modal::-webkit-scrollbar {
		width: 8px;
	}
	#shop-modal::-webkit-scrollbar-track {
		background: transparent;
		border-radius: 4px;
	}
	#shop-modal::-webkit-scrollbar-thumb {
		background: linear-gradient(180deg, rgba(100, 120, 180, 0.6), rgba(80, 100, 160, 0.4));
		border-radius: 4px;
		border: 1px solid rgba(255,255,255,0.2);
	}
	#shop-modal::-webkit-scrollbar-thumb:hover {
		background: linear-gradient(180deg, rgba(120, 140, 200, 0.8), rgba(100, 120, 180, 0.6));
	}

	#shop-modal {
		background: linear-gradient(160deg, rgba(28,30,44,0.96), rgba(20,22,35,0.96));
		border-color: rgba(140,150,220,0.22);
		box-shadow: 0 34px 60px rgba(0,0,0,0.55);
		scrollbar-color: rgba(140, 160, 220, 0.4) transparent;
	}
	#shop-modal::-webkit-scrollbar-thumb {
		background: linear-gradient(180deg, rgba(100, 120, 180, 0.5), rgba(80, 100, 160, 0.3));
		border-color: rgba(255,255,255,0.1);
	}
	#shop-modal::-webkit-scrollbar-thumb:hover {
		background: linear-gradient(180deg, rgba(120, 140, 200, 0.6), rgba(100, 120, 180, 0.5));
	}
	.shop-coin-display {
		background: linear-gradient(145deg, rgba(42,44,62,0.92), rgba(32,34,52,0.9));
		border-color: rgba(160, 178, 255, 0.24);
		box-shadow: inset 0 0 0 1px rgba(255,255,255,0.08), 0 18px 34px rgba(0,0,0,0.5);
	}
	.shop-coin-label {
		color: rgba(214, 220, 255, 0.72);
	}
	.shop-coin-balance {
		color: #f6f7ff;
	}
	.shop-coin-display.is-empty {
		background: linear-gradient(145deg, rgba(110, 32, 32, 0.4), rgba(140, 28, 28, 0.35));
		border-color: rgba(255, 120, 120, 0.35);
	}
	.shop-coin-display.is-empty .shop-coin-label {
		color: rgba(255, 196, 196, 0.78);
	}
	.shop-coin-display.is-empty .shop-coin-balance {
		color: rgba(255, 220, 220, 0.9);
	}

	.shop-modal-header {
		display: flex;
		flex-wrap: wrap;
		justify-content: space-between;
		align-items: center;
		gap: 16px;
	}

	.shop-coin-display {
		display: inline-flex;
		align-items: center;
		gap: 10px;
		padding: 6px 14px;
		border-radius: 999px;
		background: linear-gradient(145deg, rgba(255,255,255,0.96), rgba(236,246,255,0.92));
		border: 1px solid rgba(120,140,200,0.25);
		box-shadow: inset 0 0 0 1px rgba(255,255,255,0.25), 0 16px 28px rgba(14,22,48,0.16);
	}

	.shop-coin-label {
		font-size: 0.78rem;
		font-weight: 600;
		letter-spacing: 0.05em;
		text-transform: uppercase;
		color: rgba(24,32,60,0.68);
	}

	.shop-coin-balance {
		position: relative;
		font-weight: 700;
		font-size: 1.05rem;
		color: #1c253c;
		padding-left: 1.4em;
		min-width: 2.4em;
		text-align: right;
	}

	.shop-coin-balance::before {
		content: "";
		position: absolute;
		left: 0;
		top: 50%;
		transform: translateY(-50%);
		width: 1em;
		height: 1em;
		border-radius: 50%;
		background: radial-gradient(circle at 30% 30%, #fff6b5, #f7bb36 60%, #d49f20);
		box-shadow: inset 0 -2px 4px rgba(0,0,0,0.2), 0 1px 2px rgba(0,0,0,0.15);
		border: 1px solid #c9960a;
	}

	.shop-coin-display.is-empty {
		background: linear-gradient(145deg, rgba(245, 80, 80, 0.1), rgba(255, 140, 140, 0.12));
		border-color: rgba(220, 90, 90, 0.24);
	}

	.shop-coin-display.is-empty .shop-coin-label {
		color: rgba(160, 48, 48, 0.8);
	}

	.shop-coin-display.is-empty .shop-coin-balance {
		color: rgba(164, 52, 52, 0.9);
	}

	/* 2-kolommen grid voor shop inhoud */
	.shop-content-grid {
		display: flex;
		flex-direction: column;
		gap: 24px;
		margin-top: 12px;
		align-items: stretch;
	}
	.shop-content-grid--single {
		display: grid;
		grid-template-columns: minmax(0, 1fr);
		gap: 10px;
	}
	.shop-section--tight {
		min-width: 0;
	}
	.inline-option {
		display: flex;
		gap: 8px;
		align-items: center;
		margin: 6px 0;
	}
	.modal-actions--end {
		justify-content: flex-end;
	}
	.print-settings-hint {
		margin-top: 6px;
	}
	
	.shop-lower-grid {
		display: grid;
		grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
		gap: 24px 28px;
		align-items: start;
	}

	/* Pre-world deck picker modal */
	.preworld-pick-header {
		display: flex;
		align-items: center;
		justify-content: space-between;
		gap: 12px;
	}
	.preworld-pick-budget {
		font-weight: 700;
		color: rgba(32,40,68,0.7);
		background: rgba(40,55,120,0.08);
		border-radius: 999px;
		padding: 6px 12px;
	}
	.preworld-pick-grid {
		display: grid;
		grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
		gap: 14px;
		margin-top: 12px;
		max-height: 60vh;
		overflow: auto;
		scrollbar-width: thin;
		scrollbar-color: rgba(80,110,200,0.45) rgba(30,36,58,0.12);
	}
	.preworld-pick-grid::-webkit-scrollbar {
		width: 10px;
	}
	.preworld-pick-grid::-webkit-scrollbar-track {
		background: rgba(30,36,58,0.12);
		border-radius: 999px;
	}
	.preworld-pick-grid::-webkit-scrollbar-thumb {
		background: linear-gradient(180deg, rgba(110,140,255,0.85), rgba(80,110,200,0.75));
		border-radius: 999px;
		border: 2px solid rgba(30,36,58,0.12);
	}
	.preworld-pick-grid::-webkit-scrollbar-thumb:hover {
		background: linear-gradient(180deg, rgba(130,160,255,0.95), rgba(90,120,220,0.9));
	}
	.preworld-pick-item {
		border: 1px solid rgba(40,55,120,0.14);
		background: rgba(255,255,255,0.96);
		border-radius: 14px;
		padding: 10px;
		display: flex;
		flex-direction: column;
		gap: 8px;
		cursor: pointer;
		transition: transform 0.2s ease, box-shadow 0.2s ease, border-color 0.2s ease;
		position: relative;
	}
	.preworld-pick-item.selected {
		border-color: rgba(55,110,255,0.95);
		box-shadow: 0 14px 26px rgba(55,90,190,0.32), 0 0 0 2px rgba(80,130,255,0.35);
		background: linear-gradient(180deg, rgba(235,242,255,0.98), rgba(255,255,255,0.92));
		transform: translateY(-2px);
	}
	.preworld-pick-item.selected::after {
		content: 'âœ“ Geselecteerd';
		position: absolute;
		top: 8px;
		right: 8px;
		font-size: 0.7rem;
		font-weight: 800;
		letter-spacing: 0.02em;
		padding: 4px 8px;
		border-radius: 999px;
		background: rgba(60,120,255,0.95);
		color: #fff;
		box-shadow: 0 6px 14px rgba(40,70,160,0.35);
		z-index: 3;
	}
	.preworld-pick-item.selected .preworld-pick-card {
		box-shadow: 0 10px 18px rgba(30,50,120,0.25);
		transform: translateZ(0);
	}
	.preworld-pick-item.disabled {
		opacity: 0.45;
		cursor: not-allowed;
	}
	.preworld-cost {
		position: absolute;
		top: 8px;
		left: 8px;
		font-size: 0.75rem;
		font-weight: 700;
		background: linear-gradient(135deg, rgba(40,60,140,0.9), rgba(65,85,170,0.85));
		border-radius: 999px;
		padding: 4px 8px;
		color: #f3f6ff;
		box-shadow: 0 6px 14px rgba(25,35,70,0.25);
		z-index: 2;
	}
	.preworld-pick-warning {
		margin-top: 8px;
		padding: 8px 12px;
		border-radius: 10px;
		font-size: 0.85rem;
		font-weight: 600;
		background: rgba(255,196,0,0.12);
		color: #a06a00;
		border: 1px solid rgba(255,196,0,0.35);
		display: none;
	}
	.preworld-pick-item {
		background: rgba(26,30,48,0.92);
		border-color: rgba(140,160,220,0.22);
	}
	.preworld-pick-item.selected {
		border-color: rgba(120,160,255,0.95);
		box-shadow: 0 14px 26px rgba(40,70,140,0.45), 0 0 0 2px rgba(110,160,255,0.35);
		background: linear-gradient(180deg, rgba(40,48,80,0.95), rgba(30,35,60,0.9));
	}
	.preworld-pick-item.selected::after {
		background: rgba(120,160,255,0.95);
		color: #0b1224;
	}
	.preworld-pick-budget {
		background: rgba(120,140,200,0.18);
		color: rgba(230,235,255,0.85);
	}
	.preworld-cost {
		background: linear-gradient(135deg, rgba(80,110,220,0.9), rgba(60,80,170,0.85));
		color: rgba(240,245,255,0.95);
	}
	.preworld-pick-warning {
		background: rgba(255,196,0,0.12);
		color: rgba(255,214,120,0.95);
		border-color: rgba(255,196,0,0.35);
	}

	/* Modal close button styling */
	.modal-close-btn {
		position: absolute;
		top: 16px;
		right: 16px;
		width: 32px;
		height: 32px;
		border: none;
		background: rgba(0,0,0,0.08);
		border-radius: 50%;
		font-size: 24px;
		line-height: 1;
		color: #666;
		cursor: pointer;
		transition: all 0.2s ease;
		display: flex;
		align-items: center;
		justify-content: center;
		padding: 0;
		z-index: 10;
	}

	.modal-close-btn:hover {
		background: rgba(0,0,0,0.12);
		color: #333;
		transform: scale(1.1);
	}

	.modal-close-btn {
		background: rgba(255,255,255,0.1);
		color: #ccc;
	}

	.modal-close-btn:hover {
		background: rgba(255,255,255,0.15);
		color: #fff;
	}

	/* Elke sectie (kaarten of upgrades) */
	.shop-section {
		display: flex;
		flex-direction: column;
		gap: 16px;
	}

	.shop-upgrades-section,
	.shop-bonus-section,
	.shop-freeplace-section {
		display: flex;
		flex-direction: column;
		align-items: stretch;
		gap: 14px;
		padding: 20px;
		border-radius: 16px;
		background: linear-gradient(160deg, rgba(248,250,255,0.95), rgba(240,244,255,0.9));
		border: 1px solid rgba(40,55,120,0.12);
		box-shadow: 0 8px 24px rgba(12,18,38,0.08);
		position: relative;
	}

	.shop-upgrades-section::before,
	.shop-bonus-section::before,
	.shop-freeplace-section::before {
		content: '';
		position: absolute;
		top: 0;
		left: 20px;
		right: 20px;
		height: 1px;
		background: linear-gradient(90deg, transparent, rgba(40,55,120,0.15), transparent);
	}

	.shop-upgrades-section,
	.shop-bonus-section,
	.shop-freeplace-section {
		background: linear-gradient(160deg, rgba(36,40,60,0.95), rgba(24,28,44,0.95));
		border-color: rgba(150,170,240,0.2);
		box-shadow: 0 12px 32px rgba(0,0,0,0.4);
	}

	.shop-upgrades-section::before,
	.shop-bonus-section::before,
	.shop-freeplace-section::before {
		background: linear-gradient(90deg, transparent, rgba(150,170,240,0.2), transparent);
	}

	.shop-section-title {
		margin: 0 0 4px 0;
		font-size: 0.85rem;
		font-weight: 700;
		letter-spacing: 0.08em;
		text-transform: uppercase;
		color: rgba(20,24,46,0.6);
		display: flex;
		align-items: center;
		gap: 8px;
	}

	.shop-section-title::before {
		content: 'âš™ï¸';
		font-size: 1rem;
	}

	.shop-bonus-section .shop-section-title::before {
		content: 'ðŸŽ';
	}

	.shop-section-title {
		color: rgba(240,242,255,0.6);
	}

	.shop-upgrade-container {
		margin-top: 0;
		padding: 0;
		border-radius: 0;
		background: transparent;
		border: none;
		box-shadow: none;
		display: grid;
		grid-template-columns: repeat(2, 1fr);
		gap: 12px;
	}

	.shop-empty-state {
		margin: 0;
		padding: 20px;
		font-size: 0.85rem;
		font-weight: 500;
		color: rgba(24,32,52,0.55);
		text-align: center;
		background: rgba(0,0,0,0.03);
		border-radius: 12px;
		border: 1px dashed rgba(40,55,120,0.15);
	}

	.shop-empty-state {
		color: rgba(235,238,255,0.5);
		background: rgba(255,255,255,0.03);
		border-color: rgba(150,170,240,0.15);
	}

	/* Kaarten sectie (links) met rechter border */
	.shop-cards-section {
		border-right: 1px solid rgba(40,55,120,0.12);
		padding-right: 20px;
	}

	@media (max-width: 720px) {
		.shop-cards-section {
			border-right: none;
			padding-right: 0;
			border-bottom: 1px solid rgba(40,55,120,0.12);
			padding-bottom: 18px;
		}
		.shop-upgrades-section,
		.shop-bonus-section {
			padding: 16px;
		}
		.shop-cards-section {
			border-bottom-color: rgba(140,150,200,0.22);
		}
		.shop-card-list {
			grid-template-columns: 1fr;
		}
		.shop-card-price {
			align-self: flex-start;
		}
		.shop-card-actions {
			margin-top: 0;
		}
	}

	/* Grid van kaarten in de shop */
	.shop-card-list {
		display: grid;
		grid-template-columns: repeat(auto-fill, minmax(260px, 1fr));
		gap: 24px;
		align-items: stretch;
	}

	#shop-card-options {
		flex: 1 1 auto;
	}

	#shop-upgrade-container {
		flex: 0 0 auto;
	}

	.shop-section-title {
		color: rgba(240,242,255,0.85);
	}

	.shop-cards-section {
		border-right-color: rgba(140,150,200,0.25);
	}

	.shop-section--empty {
		opacity: 0.75;
	}

	.shop-empty-state {
		margin: 0;
		font-size: 0.84rem;
		font-weight: 600;
		color: rgba(24,32,52,0.68);
	}

	.shop-empty-state {
		color: rgba(235,238,255,0.64);
	}

	/* Individuele shop kaart met prijs en koop knop */
	.shop-card {
		border: 2px solid rgba(40, 55, 120, 0.15);
		border-radius: 20px;
		padding: 20px;
		background: linear-gradient(155deg, rgba(255,255,255,0.98), rgba(248,252,255,0.95));
		display: flex;
		flex-direction: column;
		gap: 16px;
		box-shadow: 0 4px 16px rgba(12,18,38,0.08), 0 12px 40px rgba(12,18,38,0.12);
		transition: transform 0.2s ease, box-shadow 0.2s ease;
		position: relative;
		overflow: hidden;
	}
	
	.shop-card::before {
		content: '';
		position: absolute;
		top: 0;
		left: 0;
		right: 0;
		height: 4px;
		background: linear-gradient(90deg, #ffb347, #ffda76, #ffc65d);
		opacity: 0;
		transition: opacity 0.2s ease;
	}
	
	.shop-card:hover {
		transform: translateY(-4px);
		box-shadow: 0 8px 24px rgba(12,18,38,0.12), 0 16px 48px rgba(12,18,38,0.16);
	}
	
	.shop-card:hover::before {
		opacity: 1;
	}
	
	.shop-card-random {
		border-color: rgba(255, 215, 0, 0.4);
		background: linear-gradient(155deg, rgba(255,252,245,0.98), rgba(255,248,235,0.95));
	}
	
	.shop-card-random::before {
		background: linear-gradient(90deg, #ffd700, #ffed4e, #ffd700);
	}

	.shop-card {
		background: linear-gradient(155deg, rgba(38,42,58,0.95), rgba(28,32,48,0.95));
		border-color: rgba(160, 170, 240, 0.22);
		box-shadow: 0 4px 16px rgba(0,0,0,0.25), 0 12px 40px rgba(0,0,0,0.35);
	}
	
	.shop-card:hover {
		box-shadow: 0 8px 24px rgba(0,0,0,0.35), 0 16px 48px rgba(0,0,0,0.45);
	}
	
	.shop-card-random {
		border-color: rgba(255, 215, 0, 0.3);
		background: linear-gradient(155deg, rgba(48,44,32,0.95), rgba(38,36,28,0.95));
	}

	.shop-card-header {
		display: flex;
		align-items: center;
		justify-content: space-between;
		gap: 12px;
		font-weight: 700;
		font-size: 1.05rem;
	}
	
	/* Verberg lege header voor random kaarten */
	.shop-card-random .shop-card-header:empty {
		display: none;
	}
	
	.shop-card-header span:first-child {
		flex: 1;
		color: #1a2644;
	}
	
	.shop-card-header span:first-child {
		color: #e8ebff;
	}
	
	.card-meta {
		font-size: 0.75rem;
		font-weight: 700;
		padding: 4px 10px;
		border-radius: 12px;
		background: rgba(100, 120, 200, 0.12);
		color: #3d4e7a;
		letter-spacing: 0.05em;
		text-transform: uppercase;
	}
	
	.card-meta {
		background: rgba(120, 140, 220, 0.18);
		color: #a8b8ff;
	}

	.shop-card-price {
		font-size: 1rem;
		font-weight: 700;
		color: #e67e22;
		letter-spacing: 0.02em;
		padding: 6px 14px;
		background: rgba(230, 126, 34, 0.08);
		border-radius: 12px;
		display: inline-block;
	}

	.shop-card-price {
		color: #ffb84d;
		background: rgba(255, 184, 77, 0.12);
	}

	.shop-card-preview {
		display: flex;
		justify-content: center;
		align-items: center;
		padding: 20px;
		border-radius: 16px;
		background: linear-gradient(145deg, rgba(235,242,255,0.6), rgba(245,248,255,0.8));
		border: 1px solid rgba(100, 120, 200, 0.08);
		min-height: 160px;
	}

	.shop-card-preview {
		background: linear-gradient(145deg, rgba(20,24,36,0.4), rgba(28,32,44,0.6));
		border-color: rgba(120, 140, 220, 0.12);
	}

	.shop-card-actions {
		display: flex;
		justify-content: stretch;
		align-items: center;
		margin-top: 4px;
	}

	.shop-card-actions button {
		flex: 1;
		background: linear-gradient(145deg, #ffb347, #ff9f33);
		border: 2px solid rgba(230, 126, 34, 0.3);
		border-radius: 14px;
		padding: 12px 24px;
		font-weight: 700;
		font-size: 0.95rem;
		letter-spacing: 0.04em;
		cursor: pointer;
		transition: all 0.2s ease;
		box-shadow: 0 4px 12px rgba(255, 140, 50, 0.25);
		color: #fff;
		text-shadow: 0 1px 2px rgba(0,0,0,0.2);
	}

	.shop-card-actions button:hover:not(:disabled) {
		transform: translateY(-2px);
		box-shadow: 0 6px 20px rgba(255, 140, 50, 0.35);
		background: linear-gradient(145deg, #ffc55a, #ffb347);
	}
	
	.shop-card-actions button:active:not(:disabled) {
		transform: translateY(0);
	}

	.shop-card-actions button:disabled {
		cursor: not-allowed;
		opacity: 0.5;
		box-shadow: none;
		background: linear-gradient(145deg, #aaa, #999);
		border-color: rgba(100, 100, 100, 0.3);
	}

	.shop-upgrade-container {
		margin-top: 0;
		padding: 0;
		border-radius: 0;
		background: transparent;
		border: none;
		box-shadow: none;
		display: grid;
		grid-template-columns: 1fr;
		gap: 12px;
		width: 100%;
	}

	.shop-upgrade-card {
		min-width: 0;
	}

	/* Mystery Card Styles */
	.mystery-card-container {
		width: 100%;
		height: 200px;
		perspective: 1000px;
		position: relative;
	}

	.mystery-card-inner {
		width: 100%;
		height: 100%;
		transition: transform 0.8s;
		transform-style: preserve-3d;
		position: relative;
	}

	.mystery-card-inner.flipped {
		transform: rotateY(180deg);
	}

	.mystery-card-front,
	.mystery-card-back {
		position: absolute;
		width: 100%;
		height: 100%;
		backface-visibility: hidden;
		display: flex;
		align-items: center;
		justify-content: center;
		border-radius: 12px;
	}

	.mystery-card-front {
		background: linear-gradient(145deg, #4a4a4a, #2a2a2a);
		border: 2px solid rgba(255, 215, 0, 0.5);
		box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
	}

	.mystery-card-front .question-mark {
		font-size: 96px;
		font-weight: bold;
		color: #ffd700;
		text-shadow: 0 0 24px rgba(255, 215, 0, 0.7);
		/* Animation removed for performance - static glow */
	}

	.mystery-card-back {
		transform: rotateY(180deg);
		background: white;
		padding: 15px;
	}

	.mystery-card-back {
		background: rgba(28,32,44,0.95);
	}

	.shop-upgrade-container h3 {
		margin: 0;
		font-size: 0.92rem;
	}

	.shop-upgrade-container p {
		margin: 0;
		font-size: 0.78rem;
		color: rgba(20,24,36,0.7);
	}

	.shop-upgrade-actions {
		display: flex;
		gap: 10px;
		align-items: center;
		flex-wrap: wrap;
	}

	.shop-upgrade-actions button {
		background: linear-gradient(145deg, #ffe580, #ffbd4f);
		border: 1px solid rgba(140, 95, 10, 0.35);
		color: #5a2d00;
		border-radius: 999px;
		padding: 7px 16px;
		font-weight: 700;
		letter-spacing: 0.04em;
		cursor: pointer;
		transition: transform 0.2s ease, box-shadow 0.2s ease;
	}

	.shop-upgrade-actions button:disabled {
		opacity: 0.5;
		cursor: not-allowed;
		transform: none;
		box-shadow: none;
	}

	.shop-upgrade-actions button:not(:disabled):hover {
		transform: translateY(-1px);
		box-shadow: 0 10px 18px rgba(180,120,20,0.26);
	}

	.shop-bonus-container {
		display: grid;
		grid-template-columns: repeat(auto-fill, minmax(220px, 1fr));
		gap: 14px;
		align-items: start;
	}

	.shop-bonus-card {
		display: flex;
		align-items: center;
		justify-content: space-between;
		gap: 12px;
		padding: 10px 14px;
		border-radius: 14px;
		background: rgba(255,255,255,0.78);
		border: 1px solid rgba(40,55,120,0.12);
		box-shadow: 0 14px 26px rgba(12,18,38,0.12);
		height: 100%;
	}

	.shop-bonus-card {
		background: rgba(28,30,48,0.92);
		border-color: rgba(150,170,240,0.18);
		box-shadow: 0 16px 30px rgba(0,0,0,0.45);
	}

	.shop-bonus-info {
		display: flex;
		align-items: center;
		gap: 10px;
		font-weight: 600;
		color: rgba(26,34,52,0.88);
	}

	.shop-bonus-info {
		color: rgba(235,238,255,0.88);
	}



	.shop-bonus-actions button {
		background: linear-gradient(145deg, #8be6ff, #44bdf1);
		border: 1px solid rgba(20,60,120,0.24);
		border-radius: 999px;
		padding: 7px 16px;
		font-weight: 700;
		color: #04344f;
		cursor: pointer;
		transition: transform 0.2s ease, box-shadow 0.2s ease;
		box-shadow: 0 12px 20px rgba(68,189,241,0.26);
	}

	.shop-bonus-actions button:hover:not(:disabled) {
		transform: translateY(-1px);
		box-shadow: 0 16px 28px rgba(68,189,241,0.32);
	}

	.shop-bonus-actions button:disabled {
		opacity: 0.45;
		cursor: not-allowed;
		box-shadow: none;
	}

	.shop-bonus-actions button {
		color: #062f45;
	}
	.shop-bonus-upgrade-btn {
		background: linear-gradient(145deg, #d8a640, #f0c04f);
		border-color: rgba(255,223,128,0.4);
		color: #fff6d2;
	}

	.shop-bonus-upgrade-btn {
		background: linear-gradient(145deg, #ffe580, #ffbd4f);
		border: 1px solid rgba(140, 95, 10, 0.35);
		color: #5a2d00;
	}

	.shop-bonus-upgrade-btn:hover:not(:disabled) {
		transform: translateY(-1px);
		box-shadow: 0 14px 24px rgba(180,120,20,0.25);
	}

	.shop-bonus-status {
		display: inline-flex;
		align-items: center;
		gap: 6px;
		font-size: 0.78rem;
		font-weight: 700;
		padding: 6px 12px;
		border-radius: 999px;
		background: linear-gradient(135deg, rgba(255,255,255,0.85), rgba(240,245,255,0.75));
		border: 1px solid rgba(120,140,200,0.28);
		color: rgba(26,32,52,0.78);
	}

	.shop-bonus-status {
		background: linear-gradient(135deg, rgba(40,42,60,0.9), rgba(32,34,52,0.88));
		border-color: rgba(180,196,255,0.26);
		color: rgba(236,240,255,0.85);
	}

	.shop-upgrade-note {
		font-size: 0.72rem;
		color: rgba(20,24,36,0.65);
	}

	.shop-upgrade-card {
		padding: 16px 18px;
		border-radius: 16px;
		background: linear-gradient(155deg, rgba(255,255,255,0.95), rgba(248,250,255,0.9));
		border: 1px solid rgba(40,55,120,0.12);
		box-shadow: 0 8px 24px rgba(12,18,38,0.1);
		display: flex;
		flex-direction: column;
		gap: 12px;
		height: 100%;
		transition: transform 0.2s ease, box-shadow 0.2s ease;
		position: relative;
		overflow: hidden;
	}

	.shop-upgrade-card::before {
		content: '';
		position: absolute;
		top: 0;
		left: 0;
		right: 0;
		height: 3px;
		background: linear-gradient(90deg, #a78bfa, #818cf8, #6366f1);
		opacity: 0.7;
	}

	.shop-upgrade-card:hover {
		transform: translateY(-2px);
		box-shadow: 0 12px 32px rgba(12,18,38,0.15);
	}

	.shop-upgrade-card--locked {
		opacity: 0.6;
	}

	.shop-upgrade-card--locked::before {
		background: linear-gradient(90deg, #9ca3af, #6b7280);
	}

	.shop-upgrade-card--owned::before {
		background: linear-gradient(90deg, #34d399, #10b981, #059669);
	}

	.shop-upgrade-header {
		display: flex;
		align-items: center;
		gap: 10px;
		font-weight: 700;
		font-size: 0.95rem;
		color: #1a2644;
	}

	.upgrade-icon {
		font-size: 1.4rem;
		width: 36px;
		height: 36px;
		display: flex;
		align-items: center;
		justify-content: center;
		background: linear-gradient(145deg, rgba(167,139,250,0.15), rgba(129,140,248,0.1));
		border-radius: 10px;
		flex-shrink: 0;
	}

	.shop-upgrade-desc {
		margin: 0;
		font-size: 0.82rem;
		color: rgba(20,24,36,0.7);
		line-height: 1.45;
	}

	.shop-upgrade-price {
		display: inline-flex;
		align-items: center;
		gap: 4px;
		font-size: 0.85rem;
		font-weight: 700;
		color: #e67e22;
		padding: 4px 10px;
		background: rgba(230, 126, 34, 0.1);
		border-radius: 8px;
		margin-top: auto;
	}

	.shop-upgrade-actions {
		display: flex;
		gap: 10px;
		align-items: center;
		flex-wrap: wrap;
		margin-top: auto;
	}

	.shop-upgrade-actions button {
		background: linear-gradient(145deg, #a78bfa, #818cf8);
		border: none;
		color: #fff;
		border-radius: 10px;
		padding: 10px 18px;
		font-weight: 700;
		font-size: 0.85rem;
		letter-spacing: 0.03em;
		cursor: pointer;
		transition: transform 0.2s ease, box-shadow 0.2s ease;
		box-shadow: 0 4px 12px rgba(129,140,248,0.3);
	}

	.shop-upgrade-actions button:disabled {
		opacity: 0.5;
		cursor: not-allowed;
		transform: none;
		box-shadow: none;
		background: linear-gradient(145deg, #9ca3af, #6b7280);
	}

	.shop-upgrade-actions button:not(:disabled):hover {
		transform: translateY(-2px);
		box-shadow: 0 8px 20px rgba(129,140,248,0.4);
	}

	.shop-upgrade-note {
		color: rgba(240,242,255,0.65);
	}

	.shop-upgrade-card {
		background: linear-gradient(155deg, rgba(38,42,58,0.95), rgba(28,32,48,0.95));
		border-color: rgba(150,170,240,0.2);
		box-shadow: 0 8px 24px rgba(0,0,0,0.35);
	}

	.shop-upgrade-card:hover {
		box-shadow: 0 12px 32px rgba(0,0,0,0.45);
	}

	.shop-upgrade-header {
		color: #e8ebff;
	}

	.upgrade-icon {
		background: linear-gradient(145deg, rgba(167,139,250,0.25), rgba(129,140,248,0.15));
	}

	.shop-upgrade-desc {
		color: rgba(240,242,255,0.7);
	}

	.shop-upgrade-price {
		color: #ffb84d;
		background: rgba(255, 184, 77, 0.15);
	}

	.shop-upgrade-actions button {
		background: linear-gradient(145deg, #a78bfa, #818cf8);
		color: #fff;
	}

	.shop-card-actions button {
		background: linear-gradient(145deg, #ffa940, #ff8835);
		border-color: rgba(255, 255, 255, 0.16);
	}

	.shop-card .card-option {
		flex: 0 0 auto;
		width: 138px;
		min-height: 180px;
		padding: 0;
		display: flex;
		flex-direction: column;
		align-items: center;
		justify-content: center;
		gap: 12px;
		border-radius: 16px;
		background: linear-gradient(165deg, #ffffff 0%, #eef2ff 45%, #dfe4ff 100%);
		border: 1px solid rgba(40,55,120,0.18);
		box-shadow: 0 18px 26px rgba(10,12,20,0.2);
		position: relative;
		overflow: hidden;
		transition: transform 0.2s ease, box-shadow 0.2s ease, border-color 0.2s ease;
	}

	.shop-card .card-option::after {
		content: "";
		position: absolute;
		inset: 0;
		border-radius: inherit;
		background: linear-gradient(120deg, rgba(255,255,255,0.65), rgba(255,255,255,0) 58%);
		opacity: 0.45;
		pointer-events: none;
	}

	.shop-card .card-option > :not(.card-echo-badge):not(.card-echo-tooltip) {
		position: relative;
		z-index: 1;
	}

	.shop-card .card-pattern {
		display: grid;
		gap: 4px;
		align-items: center;
		justify-items: center;
	}

	.shop-card .card-option .card-cell {
		width: 22px;
		height: 22px;
		/* Border-radius: max 5px, minder rond */
		border-radius: min(5px, calc(22px / 5));
		border: 1px solid rgba(12,16,30,0.12);
		box-shadow: inset 0 0 4px rgba(0,0,0,0.18);
		background: rgba(255,255,255,0.95);
	}

	.shop-card .card-label {
		display: inline-flex;
		align-items: center;
		gap: 6px;
		padding: 5px 10px;
		border-radius: 999px;
		background: rgba(30, 40, 70, 0.08);
		font-size: 0.72rem;
		font-weight: 600;
		letter-spacing: 0.04em;
		color: #2a2f45;
		box-shadow: inset 0 0 0 1px rgba(40,55,120,0.16);
	}

	.shop-card .card-meta {
		font-size: 0.75rem;
		font-weight: 600;
		letter-spacing: 0.05em;
		text-transform: uppercase;
		color: rgba(30, 35, 60, 0.85);
	}

	.shop-card .card-option {
		background: rgba(20, 24, 36, 0.82);
		border-color: rgba(255, 255, 255, 0.16);
		box-shadow: 0 18px 36px rgba(0, 0, 0, 0.5);
	}

	.shop-card .card-option::after {
		background: linear-gradient(120deg, rgba(255,255,255,0.24), rgba(255,255,255,0) 62%);
	}

	.shop-card .card-option .card-cell {
		border-color: rgba(255,255,255,0.08);
		background: rgba(32, 36, 52, 0.92);
	}

	.shop-card .card-label {
		background: rgba(255,255,255,0.1);
		color: #f3f4ff;
		box-shadow: inset 0 0 0 1px rgba(255,255,255,0.18);
	}

	.shop-card .card-meta {
		color: rgba(240, 242, 255, 0.75);
	}

	/* Mobile shop modal optimization */
	@media (max-width: 650px) {
		.game-modal {
			padding: 14px;
			width: clamp(320px, 94vw, 480px);
		}

		#shop-modal {
			width: clamp(320px, 94vw, 480px);
			max-height: 72vh;
			padding: 10px 16px;
			gap: 10px;
			overflow-y: auto;
		}

		#shop-modal h2 {
			font-size: 0.94rem;
			margin: 0 0 4px;
		}

		#shop-modal p {
			font-size: 0.74rem;
			margin: 0 0 6px 0;
		}

		.shop-content-grid {
			display: grid;
			grid-template-columns: minmax(0, 1fr);
			gap: 12px;
			margin-top: 8px;
			align-items: start;
		}

		.shop-section {
			min-width: 220px;
		}

		.shop-cards-section {
			border: none;
			padding-right: 0;
			padding-bottom: 0;
		}

		#shop-card-options {
			max-height: none;
			overflow: visible;
		}

		.shop-card-list {
			display: grid;
			grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
			gap: 10px;
			margin-top: 8px;
		}

		.shop-card {
			padding: 10px;
			gap: 8px;
			align-items: center;
		}

		.shop-card .card-option {
			width: 100%;
			max-width: none;
			min-height: 110px;
			gap: 6px;
		}

		.shop-card .card-pattern {
			gap: 2px;
		}

		.shop-card .card-option .card-cell {
			width: 12px;
			height: 12px;
			/* Border-radius: max 5px, minder rond */
			border-radius: min(5px, calc(12px / 5));
		}

		.shop-card .card-label {
			padding: 3px 6px;
			font-size: 0.6rem;
			gap: 3px;
		}

		.shop-card .card-meta {
			font-size: 0.62rem;
		}

		.shop-card-price {
			font-size: 0.78rem;
		}

		.shop-card-actions {
			width: 100%;
		}

		.shop-card-actions button {
			padding: 5px 10px;
			font-size: 0.78rem;
		}

		.modal-actions {
			gap: 8px;
			margin-top: 10px;
		}

		.modal-actions button {
			padding: 7px 14px;
			font-size: 0.84rem;
		}

		.shop-upgrade-container {
			padding: 0;
			margin-top: 0;
			display: grid;
			grid-template-columns: repeat(2, minmax(0, 1fr));
			gap: 10px;
		}

		.shop-upgrade-card {
			padding: 8px 10px;
			gap: 6px;
			height: 100%;
		}

		.shop-upgrade-header {
			font-size: 0.8rem;
			gap: 6px;
		}

		.upgrade-icon {
			font-size: 1rem;
		}

		.shop-upgrade-desc {
			font-size: 0.68rem;
			line-height: 1.35;
		}

		.shop-upgrade-price {
			font-size: 0.78rem;
		}

		.shop-upgrade-actions {
			justify-content: flex-start;
		}

		.shop-upgrade-actions button {
			padding: 5px 10px;
			font-size: 0.74rem;
		}
	}


	@media (max-width: 520px) {
		#shop-modal {
			width: clamp(300px, 96vw, 420px);
			max-height: 70vh;
			padding: 10px 14px;
			gap: 8px;
		}

		#shop-modal h2 {
			font-size: 0.9rem;
		}

		#shop-modal p {
			font-size: 0.72rem;
		}

		.shop-content-grid {
			grid-template-columns: minmax(0, 1fr);
			gap: 10px;
		}

		.shop-section-title {
			font-size: 0.8rem;
		}

		.shop-card-list {
			grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
			gap: 8px;
		}

		.shop-card {
			padding: 8px;
			gap: 6px;
		}

		.shop-card .card-option {
			min-height: 104px;
		}

		.shop-card .card-option .card-cell {
			width: 11px;
			height: 11px;
			/* Border-radius erft van base regel */
		}

		.shop-card-header {
			font-size: 0.74rem;
		}

		.shop-card-price {
			font-size: 0.76rem;
		}

		.shop-card-actions button {
			padding: 4px 10px;
			font-size: 0.76rem;
		}

		.modal-actions button {
			padding: 6px 12px;
			font-size: 0.82rem;
		}

		.shop-upgrade-card {
			padding: 7px 9px;
		}

		.shop-upgrade-header {
			font-size: 0.78rem;
		}

		.upgrade-icon {
			font-size: 0.96rem;
		}

		.shop-upgrade-desc {
			font-size: 0.65rem;
		}

		.shop-upgrade-container {
			grid-template-columns: repeat(2, minmax(0, 1fr));
			gap: 9px;
		}

		.shop-upgrade-actions button {
			padding: 4px 10px;
			font-size: 0.72rem;
		}
	}

	@media (max-width: 380px) {
		#shop-modal {
			width: clamp(280px, 96vw, 360px);
			max-height: 68vh;
			padding: 9px 12px;
			gap: 6px;
		}

		#shop-modal h2 {
			font-size: 0.86rem;
		}

		#shop-modal p {
			font-size: 0.68rem;
		}

		.shop-content-grid {
			grid-template-columns: minmax(0, 1fr);
			gap: 9px;
		}

		.shop-section-title {
			font-size: 0.76rem;
		}

		.shop-card-list {
			grid-template-columns: repeat(auto-fit, minmax(115px, 1fr));
			gap: 7px;
		}

		.shop-card {
			padding: 7px;
		}

		.shop-card .card-option {
			min-height: 98px;
		}

		.shop-card .card-option .card-cell {
			width: 10px;
			height: 10px;
			/* Border-radius erft van base regel */
		}

		.shop-card-header {
			font-size: 0.7rem;
		}

		.shop-card-price {
			font-size: 0.72rem;
		}

		.shop-card-actions button {
			padding: 4px 9px;
			font-size: 0.72rem;
		}

		.modal-actions {
			margin-top: 8px;
		}

		.modal-actions button {
			padding: 6px 10px;
			font-size: 0.8rem;
		}

		.shop-upgrade-card {
			padding: 6px 9px;
		}

		.shop-upgrade-header {
			font-size: 0.74rem;
		}

		.upgrade-icon {
			font-size: 0.92rem;
		}

		.shop-upgrade-desc {
			font-size: 0.62rem;
		}

		.shop-upgrade-container {
			grid-template-columns: repeat(2, minmax(0, 1fr));
			gap: 8px;
		}

		.shop-upgrade-actions button {
			padding: 4px 9px;
			font-size: 0.7rem;
		}
	}

	/* VERWIJDERD: Dubbele #card-choice-zone .card-option styling - deze stond al eerder gedefinieerd */

	/* VERWIJDERD: Dubbele @keyframes coinPop - definitie staat eerder in het bestand */

	.objective-toast {
		position: fixed;
		top: 18px;
		left: 50%;
		transform: translateX(-50%);
		background: linear-gradient(135deg, #2b2d33 0%, #23262c 60%, #1f2126 100%);
		color: #f0f4ff;
		padding: 10px 18px;
		border-radius: 999px;
		font-size: 0.85rem;
		font-weight: 600;
		letter-spacing: 0.04em;
		box-shadow: 0 14px 28px rgba(8,10,14,0.35);
		opacity: 0;
		pointer-events: none;
		transition: opacity 0.25s ease, transform 0.25s ease;
		z-index: 1200;
	}

	.objective-toast {
		background: linear-gradient(135deg, #1e2026 0%, #1a1c21 65%, #15171b 100%);
		color: #f7f9ff;
		box-shadow: 0 16px 28px rgba(0,0,0,0.5);
	}

	.objective-toast.show {
		opacity: 1;
		transform: translateX(-50%) translateY(0);
	}

	.objective-popup {
		position: fixed;
		top: 50%;
		left: 50%;
		transform: translate(-50%, -50%) scale(0.95);
		background: linear-gradient(135deg, #1f2126, #15171b);
		color: #f8fafc;
		padding: 16px 18px;
		border-radius: 16px;
		min-width: 260px;
		max-width: 420px;
		text-align: center;
		box-shadow: 0 24px 48px rgba(0,0,0,0.45);
		border: 1px solid rgba(255, 255, 255, 0.12);
		opacity: 0;
		pointer-events: none;
		transition: opacity 0.25s ease, transform 0.25s ease;
		z-index: 1300;
	}

	.objective-popup {
		background: linear-gradient(135deg, #1b1d22, #14161a);
		color: #f1f5f9;
		box-shadow: 0 24px 52px rgba(0,0,0,0.6);
	}

	.objective-popup .objective-popup-title {
		font-weight: 800;
		font-size: 1rem;
		margin-bottom: 6px;
		letter-spacing: 0.01em;
	}

	.objective-popup .objective-popup-body {
		font-size: 0.9rem;
		line-height: 1.4;
		opacity: 0.92;
	}

	.objective-popup.show {
		opacity: 1;
		transform: translate(-50%, -50%) scale(1);
	}


	/* VERWIJDERD: Dubbele @keyframes growRoot - definitie staat eerder in het bestand */

	/* === Mobile layout (<=650px): keep compact 23-10 HUD === */
	@media (max-width: 650px) {
		body {
			display: block;
			position: relative;
			width: 100%;
			min-height: 100svh;
			height: 100svh;
			margin: 0;
			padding: 16px 8px calc(var(--bottom-bar-clearance) + 24px);
			padding-top: 62px;
			box-sizing: border-box;
			background: linear-gradient(180deg, #1e1f23 0%, #16171b 55%, #101114 100%);
			color: #f5f6ff;
			overflow-x: hidden;
			overflow-y: hidden;
		}

		html {
			background: #16171b;
		}

		{
			background: linear-gradient(180deg, #0b0c10 0%, #040406 100%);
			color: #f5f6ff;
		}

		#mobile-objective-banner {
			display: flex;
			position: fixed;
			top: calc(env(safe-area-inset-top, 0px) + 0px);
			left: 8px;
			right: 8px;
			z-index: calc(var(--z-blur) + 20);
			justify-content: center;
			pointer-events: none;
		}

		body.zoomed-in #mobile-objective-banner {
			filter: none;
		}

		#mobile-objective-banner #objective-zone {
			pointer-events: none;
			width: min(100%, 400px);
			margin: 0;
			margin-top: 10px;
			padding: 10px 8px 8px;
			gap: 4px;
			border-radius: 14px;
			box-shadow: 0 12px 26px rgba(10,18,35,0.28);
		}

		/* Mobile: force objective panel to stack (avoid desktop flex-row quirks and odd number spacing). */
		#mobile-objective-banner #objective-zone {
			display: flex;
			flex-direction: column;
			align-items: center;
			justify-content: center;
			text-align: center;
		}
		#mobile-objective-banner #objective-current {
			display: block;
			width: 100%;
			text-align: center;
		}
		#mobile-objective-banner #objective-current strong {
			white-space: nowrap;
		}

		#mobile-objective-banner #objective-zone h2 {
			margin: 0;
			font-size: 0.66rem;
			letter-spacing: 0.08em;
			text-transform: uppercase;
			color: rgba(20,24,36,0.72);
		}

		#mobile-objective-banner #objective-zone h2 {
			color: rgba(230,235,255,0.8);
		}

		#mobile-objective-banner .objective-current {
			font-size: 0.78rem;
			line-height: 1.35;
		}

		#mobile-objective-banner .objective-history {
			display: none;
		}

		/* ============================================
		   HAMBURGER MENU KNOP (MOBIEL)
		   ============================================
		   Gouden ronde knop linksboven met 3 streepjes
		   Opent/sluit het controls menu
		   Animeer naar X wanneer open (.active class)
		*/
		#menu-toggle {
			position: fixed;
			left: 8px;
			top: 16px;
			display: flex;
			align-items: center;
			justify-content: center;
			flex-direction: column;
			gap: 3px;
			width: 38px;
			height: 38px;
			padding: 8px;
			border-radius: 6px;
			background: linear-gradient(145deg, #2f3546, #1c2233);
			border: 1px solid rgba(255,255,255,0.12);
			box-shadow: 0 4px 10px rgba(0,0,0,0.28);
			cursor: pointer;
			transition: transform 0.2s ease, box-shadow 0.2s ease;
			z-index: var(--z-menu);
		}

		#menu-toggle:hover {
			transform: scale(1.05);
			box-shadow: 0 6px 14px rgba(0,0,0,0.32);
		}

		#menu-toggle span {
			display: block;
			width: 18px;
			height: 2px;
			background: rgba(255,255,255,0.88);
			border-radius: 2px;
			transition: transform 0.28s ease, opacity 0.28s ease;
		}

		/* Wider phones: scale the hamburger button up (similar steps as the hand cards). */
		@media (max-width: 650px) and (min-width: 291px) {
			#menu-toggle { width: 38px; height: 38px; padding: 10px; }
			#menu-toggle span { width: 24px; }
		}
		@media (max-width: 650px) and (min-width: 341px) {
			#menu-toggle { width: 40px; height: 40px; padding: 12px; }
			#menu-toggle span { width: 28px; }
		}
		@media (max-width: 650px) and (min-width: 391px) {
			#menu-toggle { width: 44px; height: 44px; padding: 14px; }
			#menu-toggle span { width: 32px; }
		}

		#menu-toggle.active span:nth-child(1) { transform: translateY(6px) rotate(45deg); }
		#menu-toggle.active span:nth-child(2) { opacity: 0; }
		#menu-toggle.active span:nth-child(3) { transform: translateY(-6px) rotate(-45deg); }

		/* ============================================
		   FLOATING UNDO KNOP
		   ============================================
		   Altijd zichtbaar naast de hamburger (mobiel)
		   of linksboven bij het bord (desktop).
		*/
		#undo-floating-btn {
			position: fixed;
			left: 12px;
			top: 64px;
			width: 38px;
			height: 38px;
			display: flex;
			align-items: center;
			justify-content: center;
			font-size: 1.15rem;
			line-height: 1;
			border-radius: var(--radius-md, 8px);
			background: linear-gradient(145deg, #2f3546, #1c2233);
			border: 1px solid rgba(255,255,255,0.12);
			box-shadow: 0 4px 10px rgba(0,0,0,0.28);
			color: rgba(255,255,255,0.88);
			cursor: pointer;
			transition: transform 0.2s ease, box-shadow 0.2s ease, opacity 0.2s ease;
			z-index: var(--z-menu);
			padding: 0;
		}
		#undo-floating-btn:hover:not(:disabled) {
			transform: scale(1.08);
			box-shadow: 0 6px 14px rgba(0,0,0,0.32);
		}
		#undo-floating-btn:disabled {
			opacity: 0.35;
			cursor: not-allowed;
		}

		/* Styling is dark by default now. */

		/* ============================================
		   CONTROLS MENU (MOBIEL)
		   ============================================
		   Pop-up menu met game controls (nieuw spel, reset, dark mode, etc.)
		   Verschijnt naast hamburger knop wanneer .open class wordt toegevoegd
		   Alleen op mobiel (<650px), op desktop is dit altijd fixed zichtbaar
		*/
		#controls {
			position: fixed;
			left: 64px;
			top: 12px;
			right: auto;
			bottom: auto;
			transform: translateX(0);
			opacity: 1;
			pointer-events: auto;
			background: rgba(18,20,28,0.96);
			border: 1px solid rgba(255,255,255,0.14);
			border-radius: 12px;
			padding: 10px 12px;
			box-shadow: 0 8px 20px rgba(0,0,0,0.38);
			transition: transform 0.28s ease, opacity 0.2s ease;
			z-index: calc(var(--z-controls) - 1);
			display: none;
			flex-direction: column;
			gap: 6px;
			min-width: 160px;
		}

		#controls.open {
			transform: translateX(0);
			opacity: 1;
			pointer-events: auto;
			display: flex;
		}

		#controls {
			background: rgba(8,9,14,0.96);
			border-color: rgba(255,255,255,0.1);
		}

		#controls button {
			background: rgba(255,255,255,0.08);
			border: 1px solid rgba(255,255,255,0.18);
			color: #f5f6ff;
			padding: 10px 14px;
			border-radius: 8px;
			cursor: pointer;
			transition: background 0.2s ease;
			width: 100%;
			text-align: left;
			font-size: 0.9rem;
		}

		#controls button:disabled {
			opacity: 0.55;
			cursor: not-allowed;
		}

		#controls #debug-mode-toggle {
			display: flex;
			align-items: center;
			justify-content: space-between;
			gap: 12px;
			font-weight: 600;
		}

		#controls #debug-mode-toggle.debug-active {
			background: linear-gradient(145deg, rgba(112,198,255,0.28), rgba(72,132,255,0.32));
			border-color: rgba(112, 198, 255, 0.5);
			box-shadow: inset 0 0 0 1px rgba(255,255,255,0.18);
		}

		#controls button:hover:not(:disabled) {
			background: rgba(255,255,255,0.12);
		}



		/* ============================================
		   BOTTOM BAR (MOBIEL)
		   ============================================
		   Vaste strip onderaan met kaarten, score en munten
		   Altijd zichtbaar tijdens mobiel spelen
		   Bevat:
		   - Kaart keuze (3 opties)
		   - Score overzicht (compacte dots)
		   - Munten teller
		   - Bonus status
		*/
		#bottom-bar {
			position: fixed;
			left: 0;
			right: 0;
			bottom: var(--bottom-bar-bottom-offset);
			height: auto;
			min-height: var(--bottom-bar-height);
			padding: 0 0 6px;
			padding-left: calc(5px + env(safe-area-inset-left, 0px));
			padding-right: calc(5px + env(safe-area-inset-right, 0px));
			display: flex;
			flex-direction: column;
			background: linear-gradient(180deg, rgba(47,50,68,0.95) 0%, rgba(33,36,52,0.97) 52%, rgba(22,24,36,0.98) 100%);
			border-radius: 18px 18px 0 0;
			border-top: 1px solid rgba(255,255,255,0.16);
			box-shadow: 0 -18px 40px rgba(0,0,0,0.42);
			backdrop-filter: blur(12px);
			-webkit-backdrop-filter: blur(12px);
			overflow-x: hidden;
			overflow-y: hidden;
			overscroll-behavior-y: contain;
			clip-path: none;
			z-index: var(--z-bottom);
		}

		#bottom-bar {
			background: linear-gradient(180deg, rgba(20,22,32,0.96) 0%, rgba(14,16,26,0.98) 55%, rgba(8,9,16,0.99) 100%);
			border-top-color: rgba(255,255,255,0.1);
		}

		#bottom-bar-cards {
			display: flex;
			align-items: center;
			justify-content: flex-start;
			gap: 0;
			overflow-x: hidden;
			overflow-y: hidden;
			overscroll-behavior: contain;
			touch-action: pan-x;
			scrollbar-width: none; /* Firefox */
			-ms-overflow-style: none; /* IE/Edge legacy */
			padding: 0;
			margin-top: 0;
			transform: none;
			scroll-snap-type: x mandatory;
			border-radius: 0;
			background: transparent;
			border: none;
			flex: 0 0 auto;
			height: calc(var(--hand-card-height) + 20px);
			min-height: calc(var(--hand-card-height) + 20px);
			position: relative;
			z-index: 10;
			clip-path: none;
		}

		br {
		display: none;
		}

		.bottom-bar-footer {
			display: flex;
			justify-content: space-between;
			align-items: flex-end;
			gap: 0;
			padding: 0 4px 0;
			transform: none;
		}

		#bottom-bar-score-coins {
			display: flex;
			flex-direction: row;
			align-items: flex-end;
			justify-content: space-between;
			gap: 8px;
			width: 100%;
		}

		#bottom-bar-score,
		#bottom-bar-coins {
			display: flex;
			align-items: center;
		}

		#bottom-bar-score {
			justify-content: flex-start;
			flex: 1 1 auto;
			min-width: 0;
			max-width: 450px;
		}

		#bottom-bar-coins {
			justify-content: flex-end;
			flex: 0 0 auto;
			flex-direction: column;
			align-items: flex-end;
			gap: 4px;
			min-width: 0;
		}

		#bottom-bar-cards::-webkit-scrollbar {
			display: none;
		}

		#card-choice-zone {
			flex: 1 0 auto;
			display: flex;
			flex-direction: column;
			align-items: center;
			justify-content: center;
			background: none;
			width: 100%;
			height: 100%;
			padding: 0;
			margin: 0;
			overflow: visible;
			clip-path: none;
		}

		/* In de mobile bottom bar moet het kaartvlak geen â€œlos panelâ€ zijn.
		   Dit voorkomt een asymmetrische aflopende rand onder de kaarten. */
		#bottom-bar #card-choice-zone {
			background: transparent;
			border: none;
			border-radius: 0;
			box-shadow: none;
			padding: 0;
			position: relative;
			z-index: 0;
		}

		#card-controls {
			display: flex;
			flex-direction: row;
			align-items: center;
			justify-content: space-between;
			gap: 8px;
			width: 100%;
			position: relative;
			z-index: 12;
			overflow: visible;
			clip-path: none;
		}

		#card-options {
			flex: 1 1 auto;
			min-width: 0;
			max-width: none;
			overflow: visible;
			clip-path: none;
			margin: 0;
			padding: 0;
		}

		#card-action-buttons {
			display: flex;
			flex-direction: column;
			gap: 6px;
			align-items: center;
			justify-content: center;
			flex: 0 0 auto;
			width: auto;
			min-width: 0;
			max-width: none;
			margin: 0;
			padding-top: 0;
	}

	#card-action-buttons .deck-preview {
		order: 5;
		margin: 0;
	}

	#card-action-buttons #new-cards-btn {
		order: 0;
	}
	#card-action-buttons #undo-inline-btn {
		order: 1;
	}
	#card-action-buttons #rotate-card-btn,
	#card-action-buttons #mirror-card-btn {
		order: 2;
		display: none; /* Verberg in mobiel, toon alleen in floating preview */
	}

	#card-action-buttons #turn-counter-inline {
		order: 6;
	}
		#card-action-buttons .card-action-btn {
			min-height: 50px;
			width: 50px;
			flex: 0 0 auto;
			padding: 0;
			border-radius: 14px;
			display: flex;
			align-items: center;
			justify-content: center;
			gap: 0;
			font-size: 1rem;
			letter-spacing: 0;
			text-transform: none;
			box-shadow: 0 12px 22px rgba(10,12,20,0.25);
		}

		#card-action-buttons .card-action-btn::after {
			display: none;
		}

		#card-action-buttons .card-action-btn::before {
			font-size: 1.6rem;
		}

		/* Deck preview: zelfde stijl als card action buttons (mobile) */
		#card-action-buttons .deck-preview {
			min-height: 50px;
			width: 50px;
			flex: 0 0 auto;
			padding: 0;
			border-radius: 14px;
			display: flex;
			align-items: center;
			justify-content: center;
			background: linear-gradient(160deg, #2b2d33 0%, #1f2126 100%);
			border: 1px solid rgba(170,170,180,0.25);
			box-shadow: 0 16px 30px rgba(0,0,0,0.42);
			color: rgba(235,238,255,0.88);
		}

		#card-action-buttons .deck-preview::after {
			display: none;
		}

	#card-action-buttons .deck-count {
		position: static;
		min-width: auto;
		padding: 0;
		background: none;
		border: none;
		box-shadow: none;
		font-size: 1rem;
		font-weight: 700;
		color: #2b3148;
	}		#turn-counter-inline {
			margin-top: 0;
			padding: 4px 8px;
			font-size: 0.7rem;
			box-shadow: 0 6px 12px rgba(10,12,20,0.18);
			border-radius: 10px;
		}

		#card-choice-zone::-webkit-scrollbar { display: none; }
		#kiesKaartTitel { display: none; }

		#card-controls {
			display: flex;
			flex-direction: row;
			align-items: center;
			justify-content: space-between;
			gap: 8px;
			width: 100%;
			position: relative;
		}

		.hand-scroll-btn {
			display: none;
			position: absolute;
			top: 50%;
			transform: translateY(-50%);
			width: 24px;
			height: 24px;
			border-radius: 999px;
			border: 1px solid rgba(26,32,48,0.16);
			background: rgba(239,243,255,0.7);
			box-shadow: 0 6px 10px rgba(10,12,20,0.14);
			color: rgba(74,82,104,0.85);
			font-size: 16px;
			font-weight: 900;
			line-height: 1;
			align-items: center;
			justify-content: center;
			z-index: 25;
			cursor: pointer;
			user-select: none;
			pointer-events: auto;
		}

		#card-controls.hand-scroll-enabled .hand-scroll-btn {
			display: inline-flex;
		}

		#hand-scroll-left {
			left: calc(6px + env(safe-area-inset-left, 0px));
		}

		#hand-scroll-right {
			/* Keep clear of the action button column on the right. */
			right: calc(58px + env(safe-area-inset-right, 0px));
		}

		#card-controls.hand-scroll-enabled #hand-scroll-left:disabled,
		#card-controls.hand-scroll-enabled #hand-scroll-right:disabled {
			opacity: 0.45;
			cursor: default;
			box-shadow: none;
		}

		#bottom-bar #card-options {
			display: flex;
			gap: 6px;
			align-items: flex-start;
			justify-content: flex-start;
			flex-wrap: nowrap;
			scroll-snap-type: x proximity;
			flex: 1 1 auto;
			min-width: 0;
			width: auto;
			max-width: none;
			padding: 0;
			margin: 0;
			transform: translateY(0px);
			position: relative;
			z-index: 20;
			overflow-x: auto;
			overflow-y: hidden;
			touch-action: pan-x;
			clip-path: none;
		}

		#bottom-bar #card-options::-webkit-scrollbar { display: none; }

		#bottom-bar #new-cards-btn {
			display: flex;
			align-items: center;
			justify-content: center;
			height: 44px;
			width: 44px;
			padding: 0;
			margin: 0;
			font-weight: 400;
			font-size: 1.5rem;
			cursor: pointer;
			border-radius: 10px;
			border: 1px solid rgba(26,32,48,0.16);
			background: linear-gradient(155deg, #eff3ff 0%, #dbe2f6 100%);
			box-shadow: 0 8px 14px rgba(10,12,20,0.22);
			transition: transform 0.18s ease, box-shadow 0.18s ease, background 0.3s ease, border-color 0.3s ease;
			position: relative;
		}

		#bottom-bar #new-cards-btn::before {
			content: 'â†’';
			color: #4a5268;
			font-size: 1.8rem;
			font-weight: 700;
			position: absolute;
			top: 50%;
			left: 50%;
			transform: translate(-50%, -50%);
			transition: color 0.3s ease;
		}

		#bottom-bar #new-cards-btn.ready-for-next-turn {
			background: linear-gradient(155deg, #fef8e7 0%, #f0c149 100%);
			border-color: rgba(20,24,36,0.14);
		}

		#bottom-bar #new-cards-btn.ready-for-next-turn::before {
			color: #5a4a1e;
		}

		#bottom-bar #new-cards-btn:disabled {
			background: linear-gradient(155deg, #eff3ff 0%, #dbe2f6 100%);
			border-color: rgba(26,32,48,0.16);
			box-shadow: none;
			opacity: 0.6;
			cursor: default;
			transform: none;
			pointer-events: none;
		}

		#bottom-bar #new-cards-btn:disabled::before {
			color: rgba(74,82,104,0.6);
		}

		#bottom-bar #new-cards-btn.complete-round {
			background: linear-gradient(155deg, #e8f5e9 0%, #66bb6a 100%);
			border-color: rgba(46,125,50,0.3);
		}

		#bottom-bar #new-cards-btn.complete-round::before {
			content: 'âœ“';
			color: #1b5e20;
			font-size: 2rem;
			font-weight: 900;
		}

		@media (max-width: 520px) {
			#card-controls {
				gap: 6px;
			}

			#bottom-bar #new-cards-btn {
				height: 40px;
				width: 40px;
				border-radius: 10px;
			}

			#bottom-bar #new-cards-btn::before {
				font-size: 1.6rem;
			}

			#card-action-buttons .card-action-btn,
			#card-action-buttons .deck-preview {
				min-height: 44px;
				width: 44px;
				border-radius: 12px;
			}

			#hand-scroll-right {
				right: calc(54px + env(safe-area-inset-right, 0px));
			}

			/* Keep only the total coin text in the bottom bar. */
			#bottom-bar .coin,
			#bottom-bar #collected-coins {
				display: none;
			}
		}

		#bottom-bar #rotate-card-btn {
			display: none; /* Verberg in mobiel, alleen in floating preview */
		}

		#bottom-bar #rotate-card-btn::before {
			content: 'â†»';
			color: #4a5268;
			font-size: 1.6rem;
			position: absolute;
			top: 50%;
			left: 50%;
			transform: translate(-50%, -50%);
		}

		#bottom-bar #new-cards-btn:hover {
			transform: translateY(-2px);
			box-shadow: 0 12px 20px rgba(10,12,20,0.26);
		}

		#bottom-bar #rotate-card-btn:hover:not(:disabled) {
			transform: translateY(-1px);
			box-shadow: 0 10px 18px rgba(10,12,20,0.26);
		}

		#bottom-bar #rotate-card-btn:disabled {
			opacity: 0.6;
			box-shadow: none;
			transform: none;
		}

		#bottom-bar #new-cards-btn {
			color: #f5f6ff;
			border-color: rgba(255,255,255,0.16);
			background: linear-gradient(155deg, #3c3f55 0%, #25283a 100%);
			box-shadow: 0 10px 18px rgba(0,0,0,0.4);
		}

		#bottom-bar #new-cards-btn::before {
			color: rgba(255,255,255,0.75);
		}

		#bottom-bar #new-cards-btn.ready-for-next-turn {
			background: linear-gradient(155deg, #ffd560 0%, #ffb23c 100%);
			border-color: rgba(255,255,255,0.35);
		}

		#bottom-bar #new-cards-btn.ready-for-next-turn::before {
			color: #1c1c1c;
		}

		#bottom-bar #new-cards-btn:disabled {
			background: linear-gradient(155deg, #3c3f55 0%, #25283a 100%);
			border-color: rgba(255,255,255,0.16);
			box-shadow: none;
			opacity: 0.6;
			cursor: default;
			transform: none;
			pointer-events: none;
		}

		#bottom-bar #new-cards-btn:disabled::before {
			color: rgba(245,246,255,0.6);
		}

		#bottom-bar #new-cards-btn.complete-round {
			background: linear-gradient(155deg, #2e7d32 0%, #1b5e20 100%);
			border-color: rgba(129,199,132,0.3);
		}

		#bottom-bar #new-cards-btn.complete-round::before {
			color: #a5d6a7;
		}

		#bottom-bar #rotate-card-btn {
			color: #f4f6ff;
			border-color: rgba(255,255,255,0.18);
			background: linear-gradient(155deg, #2b3247 0%, #1c2233 100%);
			box-shadow: 0 9px 18px rgba(0,0,0,0.4);
		}

		#bottom-bar #rotate-card-btn:disabled {
			opacity: 0.5;
			box-shadow: none;
		}

		#bottom-bar #card-choice-zone .card-option {
			flex: 1 1 auto;
			width: var(--hand-card-width, 75px);
			max-width: var(--hand-card-width, 75px);
			height: var(--hand-card-height);
			min-height: var(--hand-card-height);
			max-height: var(--hand-card-height);
			padding: 4px 5px 6px;
			display: flex;
			flex-direction: column;
			align-items: center;
			justify-content: center;
			gap: 3px;
			border-radius: 12px;
			background: linear-gradient(165deg, #ffffff 0%, #eef2ff 45%, #dfe4ff 100%);
			border: 1px solid rgba(40,55,120,0.16);
			box-shadow: 0 20px 35px rgba(10,12,20,0.35), 0 8px 16px rgba(10,12,20,0.2);
			scroll-snap-align: center;
			transition: transform 0.2s ease, box-shadow 0.2s ease, border-color 0.2s ease;
			position: relative;
			overflow: hidden;
			z-index: 15;
		}

		#bottom-bar #card-choice-zone .card-option::after {
			content: "";
			position: absolute;
			inset: 0;
			border-radius: inherit;
			background: linear-gradient(120deg, rgba(255,255,255,0.65), rgba(255,255,255,0) 58%);
			opacity: 0.45;
			pointer-events: none;
		}

		#bottom-bar #card-choice-zone .card-option > .card-pattern {
			position: relative;
			z-index: 1;
		}

		#bottom-bar #card-choice-zone .card-option:hover {
			transform: translateY(-6px);
			box-shadow: 0 26px 44px rgba(20,30,60,0.32);
		}

		#bottom-bar #card-choice-zone .card-option.selected {
			border-color: rgba(82,118,255,0.6);
			box-shadow: 0 28px 48px rgba(70,90,180,0.45);
		}

		#bottom-bar #card-choice-zone .card-pattern {
			display: grid;
			gap: var(--preview-gap);
			align-items: center;
			justify-items: center;
			margin: auto;
			flex: 0 0 auto;
		}

		#bottom-bar #card-choice-zone .card-option .card-cell {
			width: 10px;
			height: 10px;
			/* Keep the same rounding style as board cells */
			border-radius: clamp(2px, calc(10px / 6), 6px);
			border: 1px solid rgba(12,16,30,0.1);
			box-shadow: inset 0 0 1px rgba(0,0,0,0.12);
		}

		#bottom-bar #card-choice-zone .card-label {
			display: none;
		}

		#bottom-bar #card-choice-zone .card-label span {
			display: inline-block;
		}

		#bottom-bar #card-choice-zone .card-meta {
			opacity: 0;
			pointer-events: none;
		}

		#bottom-bar #card-choice-zone .card-label--echo,
		#bottom-bar #card-choice-zone .card-meta--echo {
			display: inline-flex;
		}

		#bottom-bar #card-choice-zone .card-boost-badge {
			position: absolute;
			left: 5px;
			bottom: 5px;
			z-index: 6;
			min-width: 18px;
			height: 16px;
			font-size: 0.55rem;
			padding: 0 3px;
		}
		#bottom-bar #card-choice-zone .card-meta--echo,
		#bottom-bar #card-choice-zone .card-label--echo {
			position: absolute;
			right: 5px;
			bottom: 5px;
			z-index: 6;
			font-size: 0.55rem;
		}

		#bottom-bar #card-choice-zone .card-meta--echo .bonus-mini-icon {
			width: 8px;
			height: 8px;
			border-radius: 2px;
		}
		#bottom-bar #card-choice-zone .card-meta--echo .coin-icon {
			width: 8px;
			height: 8px;
		}
		#bottom-bar #card-choice-zone .card-meta--echo .meta-target-icon {
			font-size: 0.6em;
		}
			padding: 2px 5px;
			border-radius: 4px;
		}

		#bottom-bar #card-choice-zone .card-option {
			background: linear-gradient(160deg, #2d3142 0%, #232635 45%, #1b1e2c 100%);
			border-color: rgba(120,140,220,0.18);
			box-shadow: 0 20px 34px rgba(0,0,0,0.5);
		}

		#bottom-bar #card-choice-zone .card-option::after {
			opacity: 0.25;
		}

		#bottom-bar #card-choice-zone .card-option .card-cell {
			border-color: rgba(255,255,255,0.08);
			box-shadow: inset 0 0 6px rgba(0,0,0,0.35);
		}

		#bottom-bar #card-choice-zone .card-label {
			background: rgba(255,255,255,0.08);
			color: rgba(255,255,255,0.8);
		}

		#bottom-bar #card-choice-zone .card-meta {
			color: rgba(255,255,255,0.65);
		}

		@media (max-width: 450px) {
			#bottom-bar #card-options {
				transform: none;
			}

			#bottom-bar #card-choice-zone .card-option {
				width: var(--hand-card-width, 50px);
				padding: 2px;
			}

			#bottom-bar #card-choice-zone .card-option .card-cell {
				width: 7px;
				height: 7px;
			}

			#bottom-bar #card-choice-zone .card-label {
				font-size: 0.4rem;
			}

			#bottom-bar #card-choice-zone .card-meta {
				font-size: 0.45rem;
			}
			
			#turn-counter-inline {
				display: none;
			}
		}

		#bottom-bar #scoreboard {
			width: 100%;
			max-width: none;
			margin: 0;
			padding: 2px 3px;
			background: rgba(18,20,28,0.9);
			border: 1px solid rgba(255,255,255,0.12);
			border-radius: 10px;
			box-shadow: 0 8px 16px rgba(0,0,0,0.26);
			display: flex;
			flex-direction: row;
			flex-wrap: nowrap;
			gap: 4px;
			justify-content: space-between;
			align-items: center;
			color: #f5f6ff;
		}

		#bottom-bar #scoreboard {
			background: rgba(12,14,22,0.92);
			border-color: rgba(255,255,255,0.14);
			color: #f5f6ff;
		}

		#bottom-bar #scoreboard::-webkit-scrollbar { display: none; }

		#bottom-bar #scoreboard::before,
		#bottom-bar #scoreboard hr {
			display: none;
		}

		#bottom-bar #scoreboard h2 {
			display: none;
		}

		#bottom-bar #scoreboard .score-row {
			display: flex;
			flex-direction: row;
			align-items: center;
			justify-content: center;
			gap: 4px;
			padding: 2px 4px;
			background: rgba(255,255,255,0.08);
			border-radius: 6px;
			color: inherit;
			font-size: 0.64rem;
			min-width: 0;
			flex: 1 1 auto;
		}

		#bottom-bar #scoreboard .score-row .color-box {
			width: 9px;
			height: 9px;
			border-radius: 50%;
			box-shadow: 0 0 5px rgba(0,0,0,0.26);
			flex-shrink: 0;
		}

		#bottom-bar #scoreboard .score-row .label {
			display: none;
		}

		#bottom-bar #scoreboard .score-row .score {
			margin: 0;
			font-weight: 700;
			font-size: 0.7rem;
			line-height: 1;
		}

		#bottom-bar #scoreboard .score-total {
			display: flex;
			flex-direction: row;
			align-items: center;
			justify-content: center;
			gap: 4px;
			padding: 2px 5px;
			background: rgba(255,255,255,0.12);
			border-radius: 6px;
			font-weight: 700;
			font-size: 0.72rem;
			min-width: 0;
			flex: 1 1 auto;
			box-shadow: none;
			border: none;
			color: inherit;
		}

		#bottom-bar #scoreboard .score-total::before {
			content: none;
		}

		#bottom-bar #scoreboard .score-total .label {
			display: inline;
			font-size: 0.6rem;
			letter-spacing: 0.04em;
			opacity: 0.75;
			line-height: 1;
		}

		#bottom-bar #scoreboard .score-total .total-score {
			font-size: 0.88rem;
			font-weight: 700;
			line-height: 1;
		}

		#bottom-bar #scoreboard .trap-summary {
			padding: 4px 6px;
			gap: 3px;
			border: none;
			border-radius: 6px;
			background: rgba(255,255,255,0.08);
		}

		#bottom-bar #scoreboard .trap-summary-header .trap-label,
		#bottom-bar #scoreboard .trap-summary-header .trap-count {
			display: none;
		}

		#bottom-bar #scoreboard .trap-summary {
			background: rgba(255,255,255,0.04);
		}

		#bottom-bar #scoreboard .trap-summary-header {
			font-size: 0.58rem;
			letter-spacing: 0.05em;
		}

		#bottom-bar #scoreboard .trap-count {
			font-size: 0.62rem;
		}

		#bottom-bar #scoreboard .trap-preview {
			gap: 3px;
			padding-bottom: 0;
		}

		#bottom-bar #scoreboard .trap-preview.trap-preview--compact {
			gap: 4px;
		}

		#bottom-bar #scoreboard .trap-preview:empty::after {
			display: none;
		}

		#bottom-bar #scoreboard .trap-compact-chip {
			font-size: 0.62rem;
			padding: 1px 6px;
			border-radius: 12px;
		}

		#bottom-bar #scoreboard .trap-icon {
			width: 26px;
			height: 26px;
			border-radius: 8px;
			font-size: 1rem;
			box-shadow: 0 3px 6px rgba(196,56,56,0.16);
		}

		#bottom-bar #scoreboard .trap-icon .penalty-chip {
			right: -4px;
			bottom: -4px;
			font-size: 0.55rem;
			padding: 1px 4px;
		}

		#bottom-bar #scoreboard .trap-icon.trap-icon--black-hole {
			box-shadow: 0 4px 8px rgba(80,60,160,0.2);
		}

		#bottom-bar #gold-zone {
			width: auto;
			max-width: 100%;
			margin: 0;
			padding: 2px 6px;
			background: rgba(18,20,28,0.9);
			border: 1px solid rgba(255,255,255,0.12);
			border-radius: 8px;
			box-shadow: 0 8px 16px rgba(0,0,0,0.26);
			display: flex;
			flex-direction: row;
			align-items: center;
			justify-content: center;
			gap: 6px;
			color: #f5f6ff;
			height: auto;
			min-height: 0;
		}

		#bottom-bar #gold-zone {
			background: rgba(12,14,22,0.92);
			border-color: rgba(255,255,255,0.14);
		}

		#bottom-bar #gold-zone h2 {
			display: none;
		}

		/* Deck preview (binnen card-action-buttons) */
		.deck-preview {
			display: flex;
			flex-direction: column;
			align-items: center;
			justify-content: center;
			gap: 4px;
			flex: 0 0 auto;
			cursor: pointer;
			background: linear-gradient(160deg, #2b2d33 0%, #1f2126 100%);
			border: 1px solid rgba(170,170,180,0.25);
			box-shadow: 0 16px 30px rgba(0,0,0,0.42);
			padding: 0;
			min-height: 0;
			transition: transform 0.15s ease;
			color: rgba(235,238,255,0.88);
		}

		.deck-preview:hover {
			transform: translateY(-2px);
		}

		#card-action-buttons .deck-preview {
			order: 3;
			width: 100%;
		}
		
		/* Verberg het ðŸ“š icoon in mobiele versie - alleen deck-count tonen */
		#card-action-buttons .deck-preview::before {
			display: none;
		}

		#card-action-buttons .deck-preview::after {
			display: none;
		}

		#card-action-buttons .deck-preview:focus-visible {
			outline: 2px solid rgba(255,215,80,0.7);
			outline-offset: 4px;
		}

		#card-action-buttons .deck-preview:focus-visible {
			outline-color: rgba(120,160,255,0.65);
		}

		#bottom-bar #card-action-buttons {
			position: relative;
		}

		#bottom-bar #card-action-buttons .deck-preview {
			position: static;
		}

		.deck-count {
			background: linear-gradient(145deg, #ffd560, #ffb23c);
			border: 1px solid rgba(255,255,255,0.35);
			border-radius: 10px;
			padding: 6px 10px;
			font-size: 0.95rem;
			font-weight: 700;
			color: #1c1c1c;
			box-shadow: 0 6px 12px rgba(0,0,0,0.26);
			min-width: 46px;
			text-align: center;
			display: flex;
			align-items: center;
			justify-content: center;
			gap: 4px;
			pointer-events: auto;
		}

		.deck-preview:focus-visible .deck-count {
			outline: 3px solid rgba(255, 215, 80, 0.9);
			outline-offset: 3px;
		}

		.deck-preview:focus-visible .deck-count {
			outline-color: rgba(120, 160, 255, 0.8);
		}

		.deck-count::before {
			content: 'ðŸ“š';
			font-size: 1.1rem;
		}

		.deck-count {
			background: linear-gradient(145deg, #2f3546, #1c2233);
			border-color: rgba(255,255,255,0.12);
			color: rgba(255,255,255,0.88);
		}

		.preview-card {
			display: none;
		}


		#bottom-bar #gold-zone h2 {
			display: none;
		}

		/* Mobile: keep coin counter next to the buy button. */
		#bottom-bar #gold-zone::before {
			display: none;
			content: none;
		}
		#bottom-bar #gold-zone::after {
			content: '\1FA99  ' attr(data-coin-text);
			display: inline-flex;
			align-items: center;
			justify-content: center;
			order: 1;
			text-align: center;
			font-size: 0.82rem;
			font-weight: 800;
			color: #f5f6ff;
			padding: 0;
			background: transparent;
			border: none;
			white-space: nowrap;
			opacity: 0.92;
			font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", "Helvetica Neue", Arial, sans-serif, "Segoe UI Emoji", "Apple Color Emoji", "Noto Color Emoji";
		}

		#bottom-bar #collected-coins {
			display: none;
		}
		
		/* Mobiele +1 blokplaatsing knop */
		#bottom-bar .buy-placement-btn {
			padding: 4px 8px;
			font-size: 0.7rem;
			border-radius: 6px;
			margin: 0;
			gap: 3px;
		}
		#bottom-bar .buy-placement-arrow {
			font-size: 0.9rem;
		}
		#bottom-bar .buy-placement-rainbow-cell {
			width: 14px;
			height: 14px;
			/* Border-radius: max 5px, minder rond */
			border-radius: min(5px, calc(14px / 5));
		}
		#bottom-bar .buy-placement-cost {
			padding: 1px 4px;
			font-size: 0.65rem;
		}

		#bottom-bar .coin {
			width: 13px;
			height: 13px;
			border-radius: 50%;
			background: rgba(255,255,255,0.18);
			border: 1px solid rgba(255,255,255,0.26);
			box-shadow: inset 0 0 0 1px rgba(0,0,0,0.22), 0 0 4px rgba(0,0,0,0.2);
			transition: transform 0.2s ease, background 0.2s ease, border-color 0.2s ease, box-shadow 0.2s ease;
		}

		#bottom-bar .coin.active {
			background: radial-gradient(circle at 30% 30%, #fff6b5, #f7bb36 70%);
			border-color: #f3b12b;
			box-shadow: 0 0 8px rgba(255,209,90,0.78), inset 0 0 2px rgba(255,255,255,0.85);
			transform: scale(1.05);
		}

		#bottom-bar .coin.used {
			background: rgba(80,82,95,0.65);
			border-color: rgba(120,124,140,0.6);
			box-shadow: inset 0 0 0 1px rgba(0,0,0,0.4);
			transform: scale(1);
		}

		#bottom-bar .coin {
			background: rgba(255,255,255,0.14);
			border-color: rgba(255,255,255,0.24);
		}

		#bottom-bar .coin.used {
			background: rgba(60,60,72,0.7);
			border-color: rgba(110,110,130,0.55);
			box-shadow: inset 0 0 0 1px rgba(0,0,0,0.55);
			transform: scale(1);
		}

		#bottom-bar .coin.active {
			background: radial-gradient(circle at 30% 30%, #ffe58c, #f5b72f 70%);
		}

		/* Mobile bonus-inventory: hide labels, show only swatches + counts */
		@media (max-width: 650px) {
			/* Two-row footer:
			   - row 1 (top): bonus inventory + coin total + buy button
			   - row 2 (bottom): scoreboard
			   Keeps everything visible with minimal height. */
			#bottom-bar-left {
				display: flex;
				flex-direction: column;
				align-items: stretch;
				justify-content: flex-start;
				gap: 6px;
				width: 100%;
				min-width: 0;
			}

			#bottom-bar-bonus {
				display: flex;
				flex-direction: row;
				align-items: center;
				justify-content: flex-start;
				gap: 8px;
				min-width: 0;
				padding: 0;
			}

			#bottom-bar-score-coins {
				display: flex;
				flex-direction: row;
				gap: 0;
				align-items: stretch;
			}

			#bottom-bar-score {
				flex: 1 1 auto;
				min-width: 0;
			}

			/* Give the bonus inventory most of the width (70/30 split vs coins) WITHOUT leaving a visible gap. */
			#bottom-bar-bonus {
				gap: 6px;
			}
			#bottom-bar-bonus #bonus-zone {
				flex: 1 1 auto;
				min-width: 0;
			}
			#bottom-bar-bonus #gold-zone {
				flex: 0 0 auto;
				min-width: 0;
			}

			#bottom-bar #gold-zone {
				flex: 0 1 auto;
			}

			#bottom-bar #buy-placement-container {
				flex: 0 1 auto;
				display: flex;
				align-items: center;
				justify-content: center;
				order: 2;
				margin: 0;
				padding: 0;
			}

			/* Inside the bottom bar, the bonus zone should not look like a big panel. */
			#bottom-bar #bonus-zone {
				background: transparent;
				border: none;
				box-shadow: none;
				padding: 0;
				margin: 0;
				gap: 0;
			}

			#bottom-bar #bonus-zone h2,
			#bottom-bar #bonus-zone .bonus-hint {
				display: none;
			}

			/* One-line, low-height bonus badges: must fit 5 side-by-side. */
			#bottom-bar .bonus-inventory {
				display: flex;
				flex-wrap: nowrap;
				gap: 3px;
				align-items: center;
				justify-content: space-between;
				overflow: hidden;
				padding: 0;
			}
			#bottom-bar .bonus-inventory::-webkit-scrollbar { display: none; }

			#bottom-bar .bonus-badge {
				flex: 1 1 0;
				min-width: 0;
				padding: 2px 4px;
				border-radius: 10px;
				gap: 3px;
				font-size: 0.58rem;
				line-height: 1;
				justify-content: center;
			}



			#bottom-bar .bonus-badge .bonus-count {
				margin-left: 0;
				font-size: 0.58rem;
				padding: 0 4px;
			}

			/* #gold-zone is styled as a compact pill globally; no special nesting needed. */

			#bottom-bar #gold-zone::after {
				font-size: 0.82rem;
				font-weight: 800;
			}

			#bottom-bar .buy-placement-btn {
				padding: 4px 8px;
				font-size: 0.66rem;
				border-radius: 8px;
				margin-top: 0;
			}

			#bottom-bar .buy-placement-cost {
				font-size: 0.62rem;
				padding: 1px 4px;
			}

			/* Ensure bonus inventory stays one line (no vertical wrap) and looks compact. */
			#bottom-bar-bonus .bonus-inventory {
				display: flex;
				flex-wrap: nowrap;
				gap: 3px;
				justify-content: space-between;
				align-items: center;
				overflow: hidden;
				padding: 0;
			}
			#bottom-bar-bonus .bonus-inventory::-webkit-scrollbar { display: none; }

			#bottom-bar-bonus #bonus-zone {
				background: transparent;
				border: none;
				box-shadow: none;
				padding: 0;
			}

			#bottom-bar-bonus .bonus-badge .bonus-label { display: none; }

			#bottom-bar-bonus .bonus-badge .bonus-count {
				margin-left: 0;
				font-size: 0.58rem;
				padding: 0 4px;
			}

			/* Mobile: show ONLY the total coin text (under the buy button), never the coin circles. */
			#bottom-bar #gold-zone::before {
				display: none;
				content: none;
			}
			#bottom-bar #gold-zone::after {
				display: block;
			}

			#bottom-bar #collected-coins,
			#bottom-bar .coin {
				display: none;
			}

			/* Mobile cards strip: keep buttons fully inside the bar.
			   Reduce left padding and reserve a bit more space on the right. */
			#bottom-bar #card-controls {
				gap: 6px;
			}
			#bottom-bar #card-options {
				padding-left: 2px;
				padding-right: 14px;
				max-width: none;
			}
			#bottom-bar #card-action-buttons {
				flex: 0 0 52px;
			}
		}

		@media (max-width: 550px) {
			/* Compact mode: prevent coins/buy from pushing bonus inventory away. */
			.bottom-bar-footer {
				margin-top: 0;
			}

			#bottom-bar-bonus {
				gap: 6px;
			}
			#bottom-bar-bonus #bonus-zone {
				flex: 7 1 0;
				min-width: 0;
				padding: 0;
			}
			#bottom-bar-bonus #gold-zone {
				flex: 3 1 0;
				min-width: 0;
			}
			#bottom-bar .bonus-inventory,
			#bottom-bar-bonus .bonus-inventory {
				margin: 0;
				overflow: hidden;
				flex-wrap: nowrap;
				align-items: center;
			}

			#bottom-bar .bonus-badge {
				padding: 2px 5px;
				border-radius: 9px;
				font-size: 0.58rem;
			}

			#bottom-bar .bonus-badge .bonus-count {
				font-size: 0.58rem;
				padding: 0 4px;
			}

			#bottom-bar #gold-zone {
				padding: 2px 4px;
				background: transparent;
				border: none;
				box-shadow: none;
				gap: 6px;
			}

			#bottom-bar #gold-zone::before {
				display: none;
				content: none;
			}

			#bottom-bar #gold-zone::after {
				font-size: 0.76rem;
				font-weight: 800;
			}

			#bottom-bar .buy-placement-btn {
				margin-top: 0;
				padding: 3px 6px;
				gap: 4px;
				border: none;
				box-shadow: none;
				font-size: 0.62rem;
			}
			#bottom-bar .buy-placement-arrow { font-size: 0.8rem; }
			#bottom-bar .buy-placement-rainbow-cell { width: 12px; height: 12px; border-radius: min(5px, calc(12px / 5)); }
			#bottom-bar .buy-placement-cost { font-size: 0.58rem; padding: 0 3px; }

			/* Bonus upgrade shop is no longer accessed via a button. */
			#bonus-shop-btn,
			#bottom-bar #bonus-shop-btn {
				display: none;
			}

			/* Make the key action buttons smaller on very compact mobile. */
			#bottom-bar #new-cards-btn,
			#bottom-bar #bonus-shop-btn {
				height: 42px;
				padding: 6px 10px;
				font-size: 0.68rem;
			}

			#card-action-buttons .card-action-btn,
			#card-action-buttons .deck-preview {
				min-height: 42px;
				width: 42px;
				border-radius: 12px;
			}

			#card-action-buttons .deck-count {
				padding: 0;
				font-size: 0.72rem;
				border-radius: 0;
				min-width: 0;
			}
			#card-action-buttons .deck-count::before { display: none; }

			/* Deck: show icon above smaller number (narrower). */
			#card-action-buttons .deck-preview {
				flex-direction: column;
				gap: 2px;
			}
			#card-action-buttons .deck-preview::before {
				content: 'ðŸ“š';
				display: block;
				font-size: 1.05rem;
				line-height: 1;
			}
		}
	}


	.score-popup {
	  position: fixed;
	  font-size: 1.2rem;
	  font-weight: 700;
	  color: white;
	  text-shadow: 0 0 6px rgba(0,0,0,0.7), 0 0 12px rgba(255,255,255,0.5);
	  pointer-events: none;
	  opacity: 1;
	  transform: translateY(0) translateX(-50%);
	  animation: floatUp 1.2s ease-out forwards;
	  z-index: var(--z-score);
	  white-space: nowrap;
	}

	@keyframes floatUp {
	  0% {
		opacity: 1;
		transform: translateY(0) translateX(-50%);
	  }
	  70% {
		opacity: 1;
	  }
	  100% {
		opacity: 0;
		transform: translateY(-45px) translateX(-50%);
	  }
	}
	
	.sparkle {
	  position: fixed;
	  width: 16px;
	  height: 16px;
	  border-radius: 70%;
	  background: gold;
	  opacity: 0.5;
	  animation: sparkle 1.8s ease-out forwards;
	  pointer-events: none;
	  z-index: var(--z-score);
	}

	@keyframes sparkle {
	  0% { transform: scale(1) translate(0, 0); opacity: 1; }
	  100% { transform: scale(0) translate(var(--dx), var(--dy)); opacity: 0; }
	}
	
		/* Zorg dat .flash overal kan werken */
	.flash {
	  animation: flashAnim 0.4s ease;
	}

	@keyframes flashAnim {
	  0% {
		transform: scale(1.4);
		color: #fff;
		text-shadow: 0 0 8px #fff;
		filter: brightness(2);
	  }
	  100% {
		transform: scale(1);
		text-shadow: none;
		filter: brightness(1);

	  }
}





	/* Titels krijgen lichtblauwe gloed voor betere zichtbaarheid */
	h1, 
	#total-score {
	  color: #f0f3ff;
	  text-shadow: 0 0 10px rgba(100, 150, 255, 0.3);
	}

	h2 {
	  color: #a0a3ad;
	  font-weight: 500;
	}

	/* Cellen: donker met blauwe gloed bij activatie */
	.cell {
	  background: #272a31;
	  border: 1px solid #3a3d45;
	  color: #ddd;
	  transition: background 0.25s, transform 0.15s;
	}

	.cell.active {
	  background: #3a6ff7;
	  color: #fff;
	  box-shadow: 0 0 8px rgba(58,111,247,0.4);
	}

	.cell.locked-cell {
	  position: relative;
	  background: repeating-linear-gradient(45deg, rgba(255,120,80,0.18) 0, rgba(255,120,80,0.18) 8px, rgba(0,0,0,0.05) 8px, rgba(0,0,0,0.05) 16px);
	  border-color: rgba(255,120,80,0.6);
	}

	.cell.locked-cell::after {
	  content: '!';
	  position: absolute;
	  inset: 0;
	  display: grid;
	  place-items: center;
	  font-weight: 900;
	  color: #ff7148;
	  text-shadow: 0 1px 3px rgba(0,0,0,0.35);
	  pointer-events: none;
	}

	.cell.door-open {
	  box-shadow: inset 0 0 0 2px rgba(90, 200, 140, 0.65);
	}

	/* World 4: cells behind a door (unreachable until door is opened) */
	.cell.locked-behind-door {
	  position: relative;
	  background: linear-gradient(135deg, rgba(0,0,0,0.45), rgba(0,0,0,0.15));
	  border-color: rgba(30, 30, 35, 0.8);
	  filter: saturate(0.55) brightness(0.85);
	}
	.cell.locked-behind-door::after {
	  content: '';
	  position: absolute;
	  inset: 0;
	  background: repeating-linear-gradient(45deg, rgba(255,255,255,0.04) 0, rgba(255,255,255,0.04) 7px, rgba(0,0,0,0.0) 7px, rgba(0,0,0,0.0) 14px);
	  pointer-events: none;
	}

	/* World 4: sleutel/deur visuals */
	.cell.door-cell {
	  position: relative;
	}
	.cell.door-cell:not(.door-open) {
	  outline: 2px solid rgba(255, 120, 80, 0.75);
	  outline-offset: -2px;
	}
	.cell.door-cell.door-armed:not(.door-open) {
	  outline-color: rgba(255, 215, 0, 0.85);
	}
	.cell.door-cell.door-open {
	  outline: 2px solid rgba(90, 200, 140, 0.9);
	  outline-offset: -2px;
	}
	.cell.door-cell .door-symbol {
	  position: absolute;
	  inset: 0;
	  display: grid;
	  place-items: center;
	  width: 100%;
	  height: 100%;
	  pointer-events: none;
	  text-shadow: 0 1px 2px rgba(0,0,0,0.35);
	}
	.cell.door-cell .door-symbol svg {
	  width: 14px;
	  height: 14px;
	  opacity: 0.95;
	}
	.cell.door-cell .door-symbol .door-glyph {
	  display: inline-block;
	  font-size: 16px;
	  line-height: 1;
	  opacity: 0.96;
	  transform: translateY(0.5px);
	}
	.cell.key-cell {
	  position: relative;
	  outline: 2px solid rgba(255, 215, 0, 0.85);
	  outline-offset: -2px;
	}
	.cell.key-cell .key-symbol {
	  position: absolute;
	  inset: 0;
	  display: grid;
	  place-items: center;
	  width: 100%;
	  height: 100%;
	  pointer-events: none;
	  filter: drop-shadow(0 1px 2px rgba(0,0,0,0.35));
	}
	.cell.key-cell .key-symbol svg {
	  width: 14px;
	  height: 14px;
	  opacity: 0.95;
	}
	.cell.key-cell .key-symbol .key-glyph {
	  display: inline-block;
	  font-size: 16px;
	  line-height: 1;
	  opacity: 0.96;
	  transform: translateY(0.5px);
	}
	.cell.key-cell.key-consumed {
	  outline-color: rgba(90, 200, 140, 0.9);
	}

	/* Hover effect op cellen */
	.cell:hover {
	  background: #31343b;
	}

	/* Symbolen iets minder verzadigd in dark mode */
	.symbol {
	  filter: brightness(0.9) saturate(0.9);
	}

	.symbol.trap-symbol {
	  background: #555555;
	}

	.symbol.trap-symbol::after {
	  background: linear-gradient(135deg, rgba(220,220,220,0.25) 0%, rgba(220,220,220,0) 50%);
	}

	.symbol.trap-symbol.trap-symbol--black-hole {
	  background: radial-gradient(circle, #2a2a3e 0%, #1a1a2e 60%, #0a0a15 100%);
	  border-radius: 50%;
	  box-shadow: 
		0 0 20px rgba(138, 43, 226, 0.8),
		0 0 30px rgba(75, 0, 130, 0.6),
		inset 0 0 25px rgba(138, 43, 226, 0.4);
	  border: 2px solid rgba(138, 43, 226, 0.6);
	}

	.symbol.trap-symbol.trap-symbol--black-hole::after {
	  background: radial-gradient(circle, rgba(138, 43, 226, 0.3) 0%, transparent 70%);
	  opacity: 1;
	  border-radius: 50%;
	}
	
	/* Gouden vak wordt donkergrijs met scoreboard styling */
	#gold-zone { 
		background: linear-gradient(145deg, #22252b, #1a1c21);
		border: 1px solid #2d2f36;
		box-shadow: 0 0 12px rgba(0,0,0,0.6);
		color: #e5e5e5;
	}

	/* Scorebord dark mode styling */
	#scoreboard {
	  background: linear-gradient(145deg, #22252b, #1a1c21);
	  border: 1px solid #2d2f36;
	  box-shadow: 0 0 12px rgba(0,0,0,0.6);
	  color: #e5e5e5;
	}
	
	.score-row { 
		background: #2a2d35;
		color: #e5e5e5;
	}



	/* ============================================
	   KAART SYSTEEM - BASIS
	   ============================================
	   Kaarten die je kunt plaatsen op het bord
	   Gebruikt CSS Grid voor cel-layout binnen kaart
	*/
	.card {
	  display: grid;
	  background: var(--color-dark-gray);
	  border-radius: 6px;
	  box-sizing: border-box;
	  transition: transform 0.2s, box-shadow 0.2s;
	}
	
	.card:hover {
	  transform: scale(1.05);
	  box-shadow: 0 0 6px rgba(0,0,0,0.25);
	}
	.card-cell {
	  width: var(--card-cell-size, 20px);
	  height: var(--card-cell-size, 20px);
	  /* Keep the same rounding style as board cells */
	  border-radius: clamp(2px, calc(var(--card-cell-size, 20px) / 6), 6px);
	}

	.card.selected {
	  outline: 3px solid #7a8aad;
	  outline-offset: -3px;
	}

	.card.card-locked-color {
	  position: relative;
	  filter: grayscale(0.8) brightness(0.65);
	  box-shadow: inset 0 0 0 2px rgba(255, 120, 80, 0.5);
	}

	.card .card-lock-badge {
	  position: absolute;
	  inset: 6px;
	  display: grid;
	  place-items: center;
	  border: 2px dashed rgba(255, 110, 60, 0.8);
	  border-radius: 6px;
	  color: #ff7148;
	  font-weight: 900;
	  font-size: 22px;
	  letter-spacing: 1px;
	  pointer-events: none;
	  background: linear-gradient(135deg, rgba(0,0,0,0.0), rgba(0,0,0,0.35));
	  text-shadow: 0 2px 6px rgba(0,0,0,0.35);
	}
	
	.card.selected {
	  outline: 3px solid #a7a9ad;
	  outline-offset: -3px;
	}

	.draggable {
	  cursor: none;
	  transition: box-shadow 0.2s;
	  z-index: var(--z-draggable);
	  /* Allow re-picking the draggable even if it's inside #drag-overlay (which is pointer-events:none). */
	  pointer-events: auto;
	  /* Ruimere touch hitbox voor makkelijker oppakken op scrollable zones */
	  padding: 18px;
	  margin: -18px;
	}

	.draggable:active {
	  cursor: none;
	  box-shadow: 0 0 10px rgba(0,0,0,0.5);
	}
	
	/* preview styling - cells blijven exact dezelfde grootte als grid cells */
	.cell.preview-allowed {
	  outline: 2px solid rgba(0,200,100,0.8);
	  transition: outline 0.08s;
	}
	.cell.preview-denied {
	  outline: 2px solid rgba(220,20,60,0.8);
	  transition: outline 0.08s;
	}
	
	body.dragging * {
	  cursor: none;
	  -webkit-user-select: none;
	  user-select: none;
	}

	.draggable { touch-action: none; user-select: none; cursor: none; }

	/* ============================================
	   BONUS INVENTORY STYLING (GLOBAL)
	   ============================================
	   Werkt voor zowel desktop (#bonus-zone) als mobiel (#bottom-bar-bonus)
	   Specifieke overrides voor mobiel staan in de mobiele media queries
	*/
	:is(#bonus-zone, #bottom-bar-bonus) .bonus-badge {
		position: relative;
		overflow: hidden;
		appearance: none;
		display: inline-flex;
		align-items: center;
		gap: 6px;
		border: 1px solid transparent;
		border-radius: 12px;
		padding: 6px 10px;
		font-size: 0.74rem;
		color: #1c2434;
		background: linear-gradient(150deg, rgba(255,255,255,0.96) 0%, rgba(236,246,255,0.92) 100%);
		box-shadow: 0 10px 22px rgba(10, 12, 20, 0.22);
		transition: transform 0.15s ease, box-shadow 0.15s ease;
		cursor: pointer;
	}

	:is(#bonus-zone, #bottom-bar-bonus) .bonus-badge::before {
		content: "";
		position: absolute;
		inset: 0;
		background: linear-gradient(120deg, rgba(255,255,255,0.4), rgba(255,255,255,0));
		opacity: 0.45;
		pointer-events: none;
	}

	:is(#bonus-zone, #bottom-bar-bonus) .bonus-badge:not(.disabled):hover {
		transform: translateY(-1px);
		box-shadow: 0 14px 30px rgba(10, 12, 20, 0.28);
	}

	:is(#bonus-zone, #bottom-bar-bonus) .bonus-badge .bonus-count {
		/* Dark pill for better contrast and centered numeric value */
		display: inline-flex;
		align-items: center;
		justify-content: center;
		min-width: 28px;
		height: 20px;
		padding: 0 8px;
		margin-left: auto;
		font-variant-numeric: tabular-nums;
		font-weight: 600;
		border-radius: 999px;
		background: rgba(6,10,16,0.6);
		color: #fff;
	}



	:is(#bonus-zone, #bottom-bar-bonus) .bonus-badge .bonus-label {
		position: absolute;
		clip: rect(0 0 0 0);
		clip-path: inset(50%);
		height: 1px;
		width: 1px;
		overflow: hidden;
		white-space: nowrap;
	}

	:is(#bonus-zone, #bottom-bar-bonus) .bonus-badge[data-bonus-color="geel"] {
		background: linear-gradient(135deg, #fff2b0, #f2c94c);
		border-color: rgba(214, 176, 68, 0.6);
		color: #463100;
	}

	:is(#bonus-zone, #bottom-bar-bonus) .bonus-badge[data-bonus-color="rood"] {
		background: linear-gradient(135deg, #ffd6d3, #f58f9c);
		border-color: rgba(212, 112, 122, 0.55);
		color: #4a1420;
	}

	:is(#bonus-zone, #bottom-bar-bonus) .bonus-badge[data-bonus-color="groen"] {
		background: linear-gradient(135deg, #d5f5d2, #8fcfa0);
		border-color: rgba(104, 180, 126, 0.55);
		color: #143720;
	}

	:is(#bonus-zone, #bottom-bar-bonus) .bonus-badge[data-bonus-color="paars"] {
		background: linear-gradient(135deg, #eadcff, #b9a4f9);
		border-color: rgba(146, 110, 209, 0.55);
		color: #2d1955;
	}

	:is(#bonus-zone, #bottom-bar-bonus) .bonus-badge[data-bonus-color="blauw"] {
		background: linear-gradient(135deg, #d3e9ff, #8cbaf5);
		border-color: rgba(94, 138, 196, 0.55);
		color: #123357;
	}

	:is(#bonus-zone, #bottom-bar-bonus) .bonus-badge.active {
		box-shadow: 0 0 0 2px rgba(82,118,255,0.38), 0 12px 28px rgba(48,72,140,0.35);
	}

	:is(#bonus-zone, #bottom-bar-bonus) .bonus-badge.bonus-mastered {
		border-style: solid;
		box-shadow: 0 0 0 2px rgba(255, 215, 0, 0.6), 0 16px 30px rgba(255, 215, 0, 0.35);
	}

	:is(#bonus-zone, #bottom-bar-bonus) .bonus-badge.bonus-mastered .bonus-count {
		/* Keep the pill visible for mastered bonuses */
		background: rgba(6,10,16,0.6);
		color: #fff;
		font-weight: 700;
		box-shadow: none;
	}

	:is(#bonus-zone, #bottom-bar-bonus) .bonus-badge.disabled,
	:is(#bonus-zone, #bottom-bar-bonus) .bonus-badge:disabled {
		opacity: 0.9;
		box-shadow: none;
		border-style: dashed;
		color: inherit;
	}

	:is(#bonus-zone, #bottom-bar-bonus) .bonus-badge.bonus-mastered.disabled,
	:is(#bonus-zone, #bottom-bar-bonus) .bonus-badge.bonus-mastered:disabled {
		opacity: 1;
		border-style: solid;
	}

	:is(#bonus-zone, #bottom-bar-bonus) .bonus-badge.disabled::before,
	:is(#bonus-zone, #bottom-bar-bonus) .bonus-badge:disabled::before {
		opacity: 0.2;
	}

	:is(#bonus-zone, #bottom-bar-bonus) .bonus-badge.disabled::after,
	:is(#bonus-zone, #bottom-bar-bonus) .bonus-badge:disabled::after {
		content: "";
		position: absolute;
		inset: 0;
		background: linear-gradient(0deg, rgba(255,255,255,0.55), rgba(255,255,255,0));
		pointer-events: none;
	}

	/* Dark mode bonus badges */
	:is(#bonus-zone, #bottom-bar-bonus) .bonus-badge {
		box-shadow: 0 16px 32px rgba(0,0,0,0.5);
		color: #f5f6ff;
	}
	:is(#bonus-zone, #bottom-bar-bonus) .bonus-badge.bonus-mastered {
		box-shadow: 0 0 0 2px rgba(255, 214, 97, 0.7), 0 16px 34px rgba(255, 214, 97, 0.42);
	}

	:is(#bonus-zone, #bottom-bar-bonus) .bonus-badge::before {
		background: linear-gradient(120deg, rgba(255,255,255,0.18), rgba(255,255,255,0));
		opacity: 0.3;
	}

	:is(#bonus-zone, #bottom-bar-bonus) .bonus-badge[data-bonus-color="geel"] {
		background: linear-gradient(140deg, rgba(255, 207, 102, 0.24), rgba(198, 147, 44, 0.58));
		border-color: rgba(255, 207, 102, 0.45);
		color: #fff3c0;
	}

	:is(#bonus-zone, #bottom-bar-bonus) .bonus-badge[data-bonus-color="rood"] {
		background: linear-gradient(140deg, rgba(255, 170, 174, 0.25), rgba(215, 90, 112, 0.6));
		border-color: rgba(215, 90, 112, 0.45);
		color: #ffd6dc;
	}

	:is(#bonus-zone, #bottom-bar-bonus) .bonus-badge[data-bonus-color="groen"] {
		background: linear-gradient(140deg, rgba(158, 223, 175, 0.2), rgba(78, 148, 102, 0.55));
		border-color: rgba(118, 186, 136, 0.45);
		color: #ddffe7;
	}

	:is(#bonus-zone, #bottom-bar-bonus) .bonus-badge[data-bonus-color="paars"] {
		background: linear-gradient(140deg, rgba(210, 186, 255, 0.24), rgba(120, 92, 190, 0.65));
		border-color: rgba(167, 132, 230, 0.45);
		color: #f0e9ff;
	}

	:is(#bonus-zone, #bottom-bar-bonus) .bonus-badge[data-bonus-color="blauw"] {
		background: linear-gradient(140deg, rgba(168, 205, 255, 0.22), rgba(70, 116, 186, 0.6));
		border-color: rgba(120, 162, 226, 0.45);
		color: #e2f1ff;
	}

	:is(#bonus-zone, #bottom-bar-bonus) .bonus-badge.active {
		box-shadow: 0 0 0 2px rgba(142,174,255,0.38), 0 16px 32px rgba(0,0,0,0.55);
	}

	:is(#bonus-zone, #bottom-bar-bonus) .bonus-badge.disabled,
	:is(#bonus-zone, #bottom-bar-bonus) .bonus-badge:disabled {
		opacity: 0.85;
		border-color: rgba(142,174,255,0.35);
	}

	:is(#bonus-zone, #bottom-bar-bonus) .bonus-badge.disabled::after,
	:is(#bonus-zone, #bottom-bar-bonus) .bonus-badge:disabled::after {
		background: linear-gradient(0deg, rgba(4,6,14,0.55), rgba(4,6,14,0));
	}

	:is(#bonus-zone, #bottom-bar-bonus) .bonus-badge .bonus-count {
		background: rgba(12,14,20,0.55);
		color: #f5f6ff;
	}

	:is(#bonus-zone, #bottom-bar-bonus) .bonus-badge.bonus-mastered .bonus-count {
		background: rgba(12,14,20,0.55);
		box-shadow: none;
	}

	

	/* ============================================
	   DESKTOP LAYOUT (>650px)
	   ============================================
	   Op grotere schermen gebruiken we een 4-kolommen layout
	   zonder bottom-bar. Alle controls zijn altijd zichtbaar.
	   
	   Kolom 1: Paars + Rood vak
	   Kolom 2: Groen + Geel vak
	   Kolom 3: Blauw vak
	   Kolom 4: Score, Munten, Bonus, Doelen
	*/
	@media (min-width: 651px) {
	  html {
		background: #1e1f23;
		overflow: hidden;
		height: 100%;
	  }

	  html, body {
		scrollbar-width: none;
		-ms-overflow-style: none;
	  }

	  html::-webkit-scrollbar,
	  body::-webkit-scrollbar {
		display: none;
		width: 0;
		height: 0;
	  }

	  body {
		display: grid;
		position: static;
		margin: 0;
		padding: 10px;
		min-height: 100vh;
		min-height: 100svh;
		width: 100%;
		background: #1e1f23;
		color: #e5e5e5;
		overflow: hidden;
	  }

	  {
		background: var(--color-dark-bg);
		color: var(--color-text-light);
	  }

	  /* ============================================
	     DESKTOP LAYOUT REORGANISATIE
	     ============================================
	     - Doel bovenaan (boven de grids)
	     - Menu linksbovenin
	     - Grids centraal
	     - Score, bonussen en kaarten onderaan
	  */

  /* Wrapper voor desktop layout */
  #desktop-wrapper {
	display: grid;
	grid-template-areas:
	  "menu objective objective"
	  "left grids right"
	  "left bottom right";
		grid-template-columns: minmax(200px, 280px) 1fr minmax(200px, 290px);
	grid-template-rows: auto 1fr auto;
	gap: 16px;
	padding: 12px;
	/* Keep centered on very wide screens: limit width and auto-center. */
	width: 100%;
	margin: 0 auto;
	height: calc(100vh - 20px);
	box-sizing: border-box;
	margin: 0 auto;
	position: relative;
	/* Allow board shadows / scaled content without being clipped by the wrapper. */
	overflow: visible;
	transform-origin: top center;
  }

	  /* Portrait mode: stack (objective -> board -> bottom) so nothing ends up off-screen on narrow widths. */
	  body.desktop-portrait {
		/* No scrolling - everything should fit */
		overflow: hidden;
	  }

	  body.desktop-portrait #desktop-wrapper {
		display: flex !important;
		flex-direction: column;
		flex-wrap: nowrap;
		align-items: center;
		justify-content: flex-start;
		gap: 4px;
		width: 100%;
		max-width: 100%;
		margin: 0 auto;
		padding: 6px;
		box-sizing: border-box;
		height: calc(100vh - 20px);
		height: calc(100svh - 20px);
		min-height: 0;
		max-height: none;
		overflow: hidden;
	  }

	  /* Hide empty sidebars in portrait: JS moves content into #desktop-bottom. */
	  body.desktop-portrait #desktop-left,
	  body.desktop-portrait #desktop-right {
		display: none !important;
	  }

	  /* Board area - don't stretch, just fit content and scale */
	  body.desktop-portrait #desktop-grids {
		flex: 0 0 auto;
		min-height: 0;
		width: 100%;
		display: flex;
		justify-content: center;
		align-items: flex-start;
		overflow: visible;
	  }

	  /* Scale board to fit in constrained portrait */
	  body.desktop-portrait #desktop-grids .board {
		transform-origin: top center;
	  }

	  body.desktop-portrait.desktop-portrait #desktop-bottom {
		flex: 0 0 auto;
		width: 100%;
		max-width: 100%;
		margin-top: 2px;
	  }

	  /* Narrow desktop portrait (split-screen / iPad-ish): keep bottom UI compact so the board keeps height. */
	  @media (min-width: 651px) and (max-width: 925px) {
		/* Compact objective in portrait */
		body.desktop-portrait #objective-zone {
			padding: 6px 12px;
			min-height: 32px;
			gap: 8px;
		}
		body.desktop-portrait #objective-zone h2 {
			font-size: 0.85rem;
		}
		body.desktop-portrait #objective-current {
			font-size: 0.8rem;
		}
		
		body.desktop-portrait.desktop-portrait #desktop-bottom {
			flex-wrap: nowrap !important;
			justify-content: center;
			align-items: stretch;
			gap: 8px;
			padding: 4px 8px;
			max-height: none;
			overflow: visible;
		}

		body.desktop-portrait.desktop-portrait #desktop-bottom-left {
			flex: 0 0 140px;
			min-width: 130px;
			max-width: 160px;
		}

		body.desktop-portrait.desktop-portrait #desktop-bottom-center {
			flex: 1 1 auto;
			min-width: 180px;
			max-width: 350px;
			align-items: center;
		}
		
		/* On touch devices (iPad portrait), action buttons go INSIDE bottom-center, below cards */
		body.desktop-portrait.touch-portrait #desktop-bottom-center #card-action-buttons {
			display: flex;
			flex-direction: row;
			gap: 6px;
			align-items: center;
			justify-content: center;
			margin-top: 6px;
			padding: 0;
			width: 100%;
		}
		body.desktop-portrait.touch-portrait #desktop-bottom-center .card-action-btn,
		body.desktop-portrait.touch-portrait #desktop-bottom-center .deck-preview {
			width: 36px;
			min-width: 36px;
			height: 36px;
			min-height: 36px;
			padding: 6px;
		}

		body.desktop-portrait.desktop-portrait #desktop-bottom-buttons {
			flex: 0 0 auto;
			min-width: 0;
			width: auto;
		}

		body.desktop-portrait.desktop-portrait #desktop-bottom-right {
			flex: 0 0 110px;
			min-width: 100px;
			max-width: 130px;
		}

		/* Card panel: remove extra vertical chrome and force a single row of cards. */
		body.desktop-portrait #card-choice-zone {
			padding: 4px 6px;
		}
		body.desktop-portrait #card-choice-zone h2,
		body.desktop-portrait #kiesKaartTitel,
		body.desktop-portrait #card-choice-zone br {
			display: none;
		}
		body.desktop-portrait.desktop-portrait #desktop-bottom-center #card-controls {
			flex-direction: row;
			justify-content: center;
			width: fit-content;
		}
		body.desktop-portrait.desktop-portrait #desktop-bottom-center #card-options {
			flex-wrap: nowrap;
			justify-content: center;
			gap: 6px;
			width: 100%;
		}
		body.desktop-portrait.desktop-portrait #desktop-bottom-center .card-option {
			width: 120px;
			max-width: 140px;
			min-height: var(--card-min-height, 200px);
			padding: 8px;
			gap: 6px;
			--preview-cell: 16px;
		}
		body.desktop-portrait.desktop-portrait #desktop-bottom-center .card-option .card-cell {
			width: var(--preview-cell, 16px);
			height: var(--preview-cell, 16px);
		}
		body.desktop-portrait.desktop-portrait #desktop-bottom-center .card-label {
			font-size: 0.5rem;
			padding: 2px 4px;
		}

		/* Buttons: smaller footprint in the dedicated portrait button column. */
		body.desktop-portrait.desktop-portrait #desktop-bottom-buttons #card-action-buttons {
			display: flex;
			flex-direction: column;
			gap: 4px;
			align-items: center;
			justify-content: flex-start;
			margin: 0;
			padding: 0;
		}
		body.desktop-portrait.desktop-portrait #desktop-bottom-buttons .card-action-btn,
		body.desktop-portrait #desktop-bottom-buttons .deck-preview {
			width: 36px;
			min-width: 36px;
			max-width: 36px;
			height: 36px;
			min-height: 36px;
			padding: 6px;
		}
		body.desktop-portrait.desktop-portrait #desktop-bottom-buttons .card-action-btn::before {
			font-size: 0.95rem;
		}
		body.desktop-portrait.desktop-portrait #desktop-bottom-buttons .deck-preview::before {
			font-size: 0.9rem;
		}
		body.desktop-portrait.desktop-portrait #desktop-bottom-buttons .deck-count {
			font-size: 0.6rem;
		}

		/* Scoreboard: compact but readable */
		body.desktop-portrait #scoreboard {
			padding: 6px 8px;
			background: rgba(40, 45, 60, 0.9);
			border-radius: 8px;
		}
		body.desktop-portrait #scoreboard h2,
		body.desktop-portrait #scoreboard hr {
			display: none;
		}
		body.desktop-portrait #scoreboard .score-row {
			font-size: 0.75rem;
			padding: 2px 4px;
			gap: 6px;
		}
		body.desktop-portrait #scoreboard .score-row .label {
			display: none;
		}
		body.desktop-portrait #scoreboard .score-row .color-box {
			width: 12px;
			height: 12px;
		}
		body.desktop-portrait #scoreboard .score-total {
			padding: 4px 6px;
			gap: 6px;
			margin-top: 4px;
			border-top: 1px solid rgba(255,255,255,0.2);
		}
		body.desktop-portrait #scoreboard .score-total .label {
			display: inline;
			font-size: 0.7rem;
			opacity: 0.8;
		}
		body.desktop-portrait #scoreboard .score-total .total-score {
			font-size: 0.95rem;
			font-weight: bold;
		}
		body.desktop-portrait #scoreboard .score-total {
			justify-content: center;
		}

		/* Bonus panel: compact */
		body.desktop-portrait #bonus-zone {
			padding: 4px 6px;
			background: rgba(40, 45, 60, 0.9);
			border-radius: 6px;
		}
		body.desktop-portrait #bonus-zone h2,
		body.desktop-portrait #bonus-zone .bonus-hint {
			display: none;
		}
		body.desktop-portrait .bonus-inventory {
			gap: 2px;
			flex-wrap: wrap;
			justify-content: center;
		}
		body.desktop-portrait .bonus-badge {
			padding: 2px 4px;
			font-size: 0.55rem;
		}
		body.desktop-portrait .bonus-count {
			font-size: 0.5rem;
			padding: 1px 3px;
		}

		/* Coins: ultra-compact inline with buy button */
		body.desktop-portrait #gold-zone {
			flex-direction: row;
			align-items: center;
			justify-content: flex-start;
			gap: 4px;
			padding: 4px 6px;
			min-height: 0;
			max-height: 36px;
			background: rgba(40, 45, 60, 0.9);
			border-radius: 6px;
			flex-wrap: nowrap;
			overflow: visible;
		}
		body.desktop-portrait #gold-zone h2 {
			display: none;
		}
		body.desktop-portrait #gold-zone::after {
			content: attr(data-coin-text) ' ðŸª™';
			font-size: 0.7rem;
			font-weight: bold;
			text-align: center;
			color: #ffd700;
			display: inline;
			flex: 0 0 auto;
			white-space: nowrap;
			min-width: 40px;
		}
		body.desktop-portrait #gold-zone #buy-placement-container {
			margin: 0;
			flex: 0 1 auto;
			min-width: 0;
		}
		body.desktop-portrait #gold-zone .buy-placement-btn {
			padding: 3px 5px;
			max-width: 70px;
			width: auto;
			white-space: nowrap;
			font-size: 0.5rem;
			border-radius: 4px;
			overflow: hidden;
			text-overflow: ellipsis;
		}
		body.desktop-portrait #collected-coins {
			display: none !important;
		}

		/* Remove fixed zone heights - let them scale naturally */
		body.desktop-portrait #blue-zone,
		body.desktop-portrait #blue-zone--placeholder,
		body.desktop-portrait #green-zone,
		body.desktop-portrait #green-zone--placeholder {
			height: auto;
			min-height: 0;
		}
	  }

	  /* Short desktop height (<=925px) in landscape: use same compact styles as narrow portrait.
	     This ensures portrait mode kicks in when there's not enough vertical space. */
	  @media (min-width: 926px) and (max-height: 925px) and (orientation: landscape) {
		body.desktop-portrait #objective-zone {
			padding: 6px 12px;
			min-height: 32px;
			gap: 8px;
		}
		body.desktop-portrait #objective-zone h2 {
			font-size: 0.85rem;
		}
		body.desktop-portrait #objective-current {
			font-size: 0.8rem;
		}
		
		body.desktop-portrait.desktop-portrait #desktop-bottom {
			flex-wrap: nowrap !important;
			justify-content: center;
			align-items: stretch;
			gap: 8px;
			padding: 4px 8px;
			max-height: 140px;
		}

		body.desktop-portrait.desktop-portrait #desktop-bottom-left {
			flex: 0 0 140px;
			min-width: 130px;
			max-width: 160px;
		}

		body.desktop-portrait.desktop-portrait #desktop-bottom-center {
			flex: 1 1 auto;
			min-width: 180px;
			max-width: 450px;
			align-items: center;
		}

		body.desktop-portrait.desktop-portrait #desktop-bottom-buttons {
			flex: 0 0 auto;
			min-width: 0;
			width: auto;
		}

		body.desktop-portrait.desktop-portrait #desktop-bottom-right {
			flex: 0 0 100px;
			min-width: 90px;
			max-width: 140px;
		}

		/* Card panel: compact horizontal row */
		body.desktop-portrait #card-choice-zone {
			padding: 4px 6px;
		}
		body.desktop-portrait #card-choice-zone h2,
		body.desktop-portrait #kiesKaartTitel,
		body.desktop-portrait #card-choice-zone br {
			display: none;
		}
		body.desktop-portrait.desktop-portrait #desktop-bottom-center #card-controls {
			flex-direction: row;
			justify-content: center;
			width: fit-content;
		}
		body.desktop-portrait.desktop-portrait #desktop-bottom-center #card-options {
			flex-wrap: nowrap;
			justify-content: center;
			gap: 6px;
			width: 100%;
		}
		body.desktop-portrait.desktop-portrait #desktop-bottom-center .card-option {
			width: 120px;
			max-width: 140px;
			min-height: var(--card-min-height, 200px);
			padding: 8px;
			gap: 6px;
			--preview-cell: 16px;
		}
		body.desktop-portrait.desktop-portrait #desktop-bottom-center .card-option .card-cell {
			width: var(--preview-cell, 16px);
			height: var(--preview-cell, 16px);
		}
		body.desktop-portrait.desktop-portrait #desktop-bottom-center .card-label {
			font-size: 0.5rem;
			padding: 2px 4px;
		}

		/* Buttons: compact column */
		body.desktop-portrait.desktop-portrait #desktop-bottom-buttons #card-action-buttons {
			display: flex;
			flex-direction: column;
			gap: 4px;
			align-items: center;
			justify-content: flex-start;
			margin: 0;
			padding: 0;
		}
		body.desktop-portrait.desktop-portrait #desktop-bottom-buttons .card-action-btn,
		body.desktop-portrait #desktop-bottom-buttons .deck-preview {
			width: 36px;
			min-width: 36px;
			max-width: 36px;
			height: 36px;
			min-height: 36px;
			padding: 6px;
		}

		/* Scoreboard: compact */
		body.desktop-portrait #scoreboard {
			padding: 6px 8px;
			background: rgba(40, 45, 60, 0.9);
			border-radius: 8px;
		}
		body.desktop-portrait #scoreboard h2,
		body.desktop-portrait #scoreboard hr {
			display: none;
		}
		body.desktop-portrait #scoreboard .score-row {
			font-size: 0.75rem;
			padding: 2px 4px;
			gap: 6px;
		}
		body.desktop-portrait #scoreboard .score-row .label {
			display: none;
		}
		body.desktop-portrait #scoreboard .score-row .color-box {
			width: 12px;
			height: 12px;
		}
		body.desktop-portrait #scoreboard .score-total {
			padding: 4px 6px;
			gap: 6px;
			margin-top: 4px;
		}
		body.desktop-portrait #scoreboard .score-total .total-score {
			font-size: 0.95rem;
			font-weight: bold;
		}

		/* Bonus panel: compact */
		body.desktop-portrait #bonus-zone {
			padding: 4px 6px;
			background: rgba(40, 45, 60, 0.9);
			border-radius: 6px;
		}
		body.desktop-portrait #bonus-zone h2,
		body.desktop-portrait #bonus-zone .bonus-hint {
			display: none;
		}
		body.desktop-portrait .bonus-inventory {
			gap: 2px;
			flex-wrap: wrap;
			justify-content: center;
		}
		body.desktop-portrait .bonus-badge {
			padding: 2px 4px;
			font-size: 0.55rem;
		}
		body.desktop-portrait .bonus-count {
			font-size: 0.5rem;
			padding: 1px 3px;
		}

		/* Coins: compact with visible coin icon */
		body.desktop-portrait #gold-zone {
			flex-direction: row;
			align-items: center;
			justify-content: center;
			gap: 6px;
			padding: 4px 8px;
			min-height: 0;
			max-height: 36px;
			background: rgba(40, 45, 60, 0.9);
			border-radius: 6px;
			flex-wrap: nowrap;
			overflow: visible;
		}
		body.desktop-portrait #gold-zone h2 {
			display: none;
		}
		body.desktop-portrait #gold-zone::after {
			content: attr(data-coin-text) ' ðŸª™';
			font-size: 0.8rem;
			font-weight: bold;
			text-align: center;
			color: #ffd700;
			display: inline;
			flex: 0 0 auto;
			white-space: nowrap;
		}
		body.desktop-portrait #gold-zone #buy-placement-container {
			margin: 0;
			flex: 0 1 auto;
			min-width: 0;
		}
		body.desktop-portrait #gold-zone .buy-placement-btn {
			padding: 4px 6px;
			max-width: 100px;
			width: auto;
			white-space: nowrap;
			font-size: 0.55rem;
			border-radius: 4px;
			overflow: hidden;
			text-overflow: ellipsis;
		}
		body.desktop-portrait #collected-coins {
			display: none !important;
		}

		/* Remove fixed zone heights */
		body.desktop-portrait #blue-zone,
		body.desktop-portrait #blue-zone--placeholder,
		body.desktop-portrait #green-zone,
		body.desktop-portrait #green-zone--placeholder {
			height: auto;
			min-height: 0;
		}
	  }

	  #desktop-bottom-left,
	  #desktop-bottom-center,
	  #desktop-bottom-buttons,
	  #desktop-bottom-right {
		display: flex;
		flex-direction: column;
		gap: 12px;
		flex-shrink: 1;
	  }
	  
	  #desktop-bottom-left,
	  #desktop-bottom-right {
		flex: 1 1 220px;
		min-width: 160px;
		max-width: 280px;
	  }
	  
	  #desktop-bottom-buttons {
		display: none; /* Hidden in landscape, shown in portrait */
		flex: 0 0 auto;
	  }

	  /* Portrait mode: elementen verdelen */
	  body.desktop-portrait.desktop-portrait #desktop-bottom-left {
		flex: 1 1 220px;
		min-width: 160px;
		max-width: 260px;
	  }

	  body.desktop-portrait.desktop-portrait #desktop-bottom-center {
		flex: 2 1 320px;
		min-width: 220px;
		max-width: 520px;
		align-items: stretch;
	  }

	  body.desktop-portrait.desktop-portrait #desktop-bottom-right {
		flex: 1 1 200px;
		min-width: 150px;
		max-width: 260px;
	  }
	  
	  body.desktop-portrait.desktop-portrait #desktop-bottom-buttons {
		display: flex !important;
		flex-direction: column;
		justify-content: flex-start;
		align-items: center;
		flex: 0 0 auto;
		width: auto;
	  }

  @media (max-width: 400px) {
	body.desktop-portrait #desktop-wrapper {
	  transform: scale(0.75);
	}
  }

  @media (max-width: 350px) {
	body.desktop-portrait #desktop-wrapper {
	  transform: scale(0.7);
	}
  }

  /* iPad / constrained landscape: when right sidebar would overflow, scale the whole layout */
  @media (min-width: 651px) and (max-width: 1650px) and (orientation: landscape) {
	body.desktop-landscape #desktop-wrapper {
		grid-template-columns: minmax(120px, 160px) 1fr minmax(120px, 160px);
		gap: 6px;
		padding: 6px;
		max-width: 100vw;
		overflow: visible;
	}
	
	body.desktop-landscape #desktop-left,
	body.desktop-landscape #desktop-right {
		min-width: 110px;
		max-width: 160px;
		flex-shrink: 0;
	}
	
	body.desktop-landscape #desktop-right #card-choice-zone {
		padding: 6px;
	}
	
	body.desktop-landscape #desktop-right .card-option {
		width: 60px;
		min-height: 80px;
		padding: 5px;
		--preview-cell: 10px;
	}
	
	body.desktop-landscape #desktop-right .card-option .card-cell {
		width: 9px;
		height: 9px;
	}
	
	body.desktop-landscape #desktop-right .card-label {
		font-size: 0.5rem;
	}
	
	body.desktop-landscape #desktop-right #bonus-zone {
		padding: 5px;
	}
	
	body.desktop-landscape #desktop-right .bonus-badge {
		padding: 3px 5px;
		font-size: 0.55rem;
	}
	
	body.desktop-landscape #desktop-left #scoreboard {
		padding: 6px;
	}
	
	body.desktop-landscape #desktop-left #scoreboard h2 {
		font-size: 0.8rem;
	}
	
	body.desktop-landscape #desktop-left #scoreboard .score-row {
		font-size: 0.65rem;
		padding: 2px 3px;
	}
	
	body.desktop-landscape #desktop-left #gold-zone {
		padding: 5px 6px;
	}
  }

  /* Slightly wider screens (1100-1650px): allow a bit more room */
  @media (min-width: 1101px) and (max-width: 1650px) and (orientation: landscape) {
	body.desktop-landscape #desktop-wrapper {
		grid-template-columns: minmax(150px, 200px) 1fr minmax(150px, 200px);
		gap: 10px;
		padding: 10px;
	}
	
	body.desktop-landscape #desktop-left,
	body.desktop-landscape #desktop-right {
		min-width: 140px;
		max-width: 200px;
	}
	
	body.desktop-landscape #desktop-right .card-option {
		width: 75px;
		min-height: 95px;
		padding: 6px;
		--preview-cell: 12px;
	}
	
	body.desktop-landscape #desktop-right .card-option .card-cell {
		width: 11px;
		height: 11px;
	}
	
	body.desktop-landscape #desktop-right .card-label {
		font-size: 0.55rem;
	}
	
	body.desktop-landscape #desktop-left #scoreboard h2 {
		font-size: 0.9rem;
	}
	
	body.desktop-landscape #desktop-left #scoreboard .score-row {
		font-size: 0.7rem;
		padding: 2px 4px;
	}
  }

  /* Very constrained iPad landscape: force portrait-style bottom layout */
  @media (min-width: 651px) and (max-width: 950px) and (max-height: 700px) and (orientation: landscape) {
	body.desktop-landscape #desktop-wrapper {
		display: flex !important;
		flex-direction: column;
		align-items: center;
	}
	
	body.desktop-landscape #desktop-left,
	body.desktop-landscape #desktop-right {
		display: none !important;
	}
	
	body.desktop-landscape #desktop-bottom {
		display: flex !important;
		flex-wrap: wrap;
		justify-content: center;
		gap: 8px;
		width: 100%;
	}
  }

	  /* Menu linksbovenin - altijd zichtbaar */
	  #desktop-menu {
		grid-area: menu;
		display: flex;
		align-items: flex-start;
		justify-content: flex-start;
		z-index: 1002;
		position: sticky;
		top: 0;
	  }

	  /* Hamburger button - altijd zichtbaar in desktop */
	  #desktop-menu-toggle {
		display: none;
		flex-direction: column;
		justify-content: center;
		align-items: center;
		width: 50px;
		height: 50px;
		background: #fffbea;
		border: 1px solid #e3e6ea;
		border-radius: 12px;
		cursor: pointer;
		transition: all 0.3s ease;
		box-shadow: 0 2px 8px rgba(0,0,0,0.15);
		position: relative;
		z-index: 1003;
	  }

	  #desktop-menu-toggle:hover {
		background: #fff5d1;
		transform: translateY(-2px);
		box-shadow: 0 4px 12px rgba(0,0,0,0.2);
	  }

	  #desktop-menu-toggle span {
		width: 24px;
		height: 3px;
		background: #2b3148;
		border-radius: 2px;
		transition: all 0.3s ease;
		display: block;
		margin: 3px 0;
	  }

	  #desktop-menu-toggle.active span:nth-child(1) {
		transform: rotate(45deg) translate(8px, 8px);
	  }

	  #desktop-menu-toggle.active span:nth-child(2) {
		opacity: 0;
	  }

	  #desktop-menu-toggle.active span:nth-child(3) {
		transform: rotate(-45deg) translate(8px, -8px);
	  }

	  #desktop-menu-toggle {
		background: #2d2f36;
		border-color: #4a4c54;
	  }

	  #desktop-menu-toggle span {
		background: #eee;
	  }

	  #desktop-menu-toggle:hover {
		background: #3a3c44;
	  }

	  #controls {
		position: fixed;
		left: 64px;
		top: 12px;
		opacity: 1;
		pointer-events: auto;
		background: #fffbea;
		border: 1px solid #e3e6ea;
		border-radius: 12px;
		box-shadow: 0 4px 16px rgba(0,0,0,0.2);
		padding: 12px;
		display: none;
		flex-direction: column;
		gap: 8px;
		width: 220px;
		margin: 0;
		z-index: calc(var(--z-menu) - 1);
	  }

	  #controls.open {
		display: flex;
	  }

  /* Doel bovenaan */
  #desktop-objective {
	grid-area: objective;
	display: flex;
	justify-content: center;
	align-items: center;
	width: 100%;
  }

  /* In landscape mode: objective alleen boven grids kolom */
  body:not(.desktop-portrait) #desktop-objective {
	grid-column: 2 / 3; /* Alleen boven de grids kolom */
  }

  #objective-zone {
	margin: 0 auto;
	padding: 14px 24px 10px;
	width: 100%;
	max-width: 100%;
	min-height: 50px;
	display: flex;
	align-items: center;
	gap: 16px;
	justify-content: center;
	text-align: center;
	box-sizing: border-box;
	background: #fffbea;
	border-radius: 10px;
	border: 1px solid #e3e6ea;
	box-shadow: 0 2px 6px rgba(0,0,0,0.12);
  }	  #objective-zone {
		background: linear-gradient(145deg, #22252b, #1a1c21);
		border: 1px solid var(--color-border-dark);
		box-shadow: 0 4px 10px var(--shadow-dark);
		color: var(--color-text-light);
	  }

	  #objective-zone h2 {
		margin: 0;
		font-size: 1.1rem;
		font-weight: 600;
		white-space: nowrap;
		flex-shrink: 0;
		color: #333;
	  }

	  #objective-zone h2 {
		color: var(--color-text-light);
	  }

	  #objective-current {
		margin: 0;
		padding: 0;
		font-size: 0.95rem;
		line-height: 1.3;
		flex: 1;
		display: flex;
		align-items: center;
		gap: 8px;
	  }

	  /* Verwijder het doelwit icoontje */
	  #objective-current::before {
		content: none;
	  }

	  #objective-history {
		margin: 0;
		padding: 0;
		display: none; /* Verberg history op desktop voor compactheid */
	  }

	  /* Verberg empty state tekst op desktop */
	  .objective-empty-state {
		display: none;
	  }

	  /* Board met grids centraal */
	  #desktop-grids {
		grid-area: grids;
		display: flex;
		justify-content: center;
		align-items: center;
		overflow: visible;
	  }

	  /* Half-screen desktop landscape (â‰ˆ900-1200px): tighten sidebars + gaps so the full board fits. */
	  @media (min-width: 651px) and (max-width: 1200px) and (orientation: landscape) {
		body.desktop-landscape #desktop-wrapper {
			grid-template-columns: minmax(88px, 118px) 1fr minmax(88px, 118px);
			gap: 3px;
			padding: 4px;
			margin: 0;
		}
		body.desktop-landscape #desktop-left,
		body.desktop-landscape #desktop-right {
			min-width: 88px;
			max-width: 118px;
		}
		body.desktop-landscape #desktop-right .card-option {
			width: 54px;
			min-height: 76px;
			padding: 4px;
			--preview-cell: 9px;
		}
		body.desktop-landscape #desktop-right .card-option .card-cell {
			width: 8px;
			height: 8px;
		}
		body.desktop-landscape #desktop-right .card-label {
			font-size: 0.48rem;
		}
		body.desktop-landscape #desktop-left #scoreboard {
			padding: 5px;
		}
		body.desktop-landscape #desktop-left #gold-zone {
			padding: 4px 5px;
		}
	  }

	  /* Extra fit: if the window is narrow, slightly reduce cell-size (keeps proportions consistent). */
	  @media (min-width: 651px) and (max-width: 1200px) and (orientation: landscape) {
		body.desktop-landscape {
			--cell-size: 26px;
		}
	  }

	  /* Extra-tight landscape for small desktop widths: pull sidebars inward so right sidebar stays visible. */
	  @media (min-width: 651px) and (max-width: 1050px) and (orientation: landscape) {
		body.desktop-landscape #desktop-wrapper {
			grid-template-columns: minmax(82px, 108px) 1fr minmax(82px, 108px);
			gap: 2px;
			padding: 2px;
			margin: 0;
		}
		body.desktop-landscape #desktop-left,
		body.desktop-landscape #desktop-right {
			min-width: 82px;
			max-width: 108px;
		}
		body.desktop-landscape #desktop-right .card-option {
			width: 52px;
			min-height: 72px;
			padding: 3px;
			--preview-cell: 8px;
		}
		body.desktop-landscape #desktop-right .card-option .card-cell {
			width: 7px;
			height: 7px;
		}
		body.desktop-landscape #desktop-left #scoreboard,
		body.desktop-landscape #desktop-left #gold-zone {
			padding: 4px;
		}
	  }

	  .board {
		display: flex;
		gap: 12px;
		margin: 0;
		transform: none;
		max-height: none;
	  }

	  .column {
		transform: none;
	  }

	  /* Eerste 3 kolommen (grids) naast elkaar */
	  .column:nth-child(1),
	  .column:nth-child(2),
	  .column:nth-child(3) {
		flex: 0 0 auto;
		width: auto;
	  }

	  /* 4e kolom verbergen op desktop */
	  .column:nth-child(4) {
		display: none;
	  }

	  /* Linker sidebar voor score en munten */
	  #desktop-left {
		grid-area: left;
		display: flex;
		flex-direction: column;
		gap: 12px;
		overflow-y: auto;
		overflow-x: hidden;
		scrollbar-width: thin;
		scrollbar-color: rgba(80, 90, 110, 0.35) transparent;
	  }

	  /* Rechter sidebar voor kaarten en bonussen */
	  #desktop-right {
		grid-area: right;
		display: flex;
		flex-direction: column;
		gap: 12px;
		overflow-y: auto;
		overflow-x: hidden;
		scrollbar-width: thin;
		scrollbar-color: rgba(80, 90, 110, 0.35) transparent;
	  }

	  /* Wanneer de kaartenlijst zelf scrollt (4+ kaarten), laat de sidebar NIET meescrollen.
	     Dit voorkomt dat het muiswiel op #desktop-right "verdwijnt" i.p.v. in #card-options. */
	  #desktop-right.hand-has-scroll {
		overflow-y: hidden;
	  }

	  #desktop-left::-webkit-scrollbar,
	  #desktop-right::-webkit-scrollbar {
		width: 8px;
	  }

	  #desktop-left::-webkit-scrollbar-thumb,
	  #desktop-right::-webkit-scrollbar-thumb {
		background: rgba(80, 90, 110, 0.35);
		border-radius: 10px;
	  }

	  #desktop-left::-webkit-scrollbar-thumb,
	  #desktop-right::-webkit-scrollbar-thumb {
		background: rgba(255, 255, 255, 0.16);
	  }

  /* Bottom section voor alle modes */
  #desktop-bottom {
	grid-area: bottom;
	display: flex;
	gap: 12px;
	align-items: start;
	width: 100%;
	flex-wrap: nowrap;
	justify-content: space-between;
  }

  /* Landscape mode: verberg de bottom bar (scores + bonussen zijn in sidebars) */
  body:not(.desktop-portrait) #desktop-bottom {
	display: none;
  }

  /* Portrait mode: toon bottom bar - clean consolidated layout */
  body.desktop-portrait.desktop-portrait #desktop-bottom {
	display: flex !important;
	flex-wrap: wrap;
	justify-content: center;
	align-items: flex-start;
	gap: 10px;
	width: 100%;
	max-width: 100%;
	padding: 0 10px;
	box-sizing: border-box;
  }

  #desktop-bottom-left,
  #desktop-bottom-center,
  #desktop-bottom-buttons,
  #desktop-bottom-right {
	display: flex;
	flex-direction: column;
	gap: 10px;
	flex-shrink: 1;
  }

  body.desktop-portrait.desktop-portrait #desktop-bottom-left {
	flex: 1 1 200px;
	min-width: 140px;
	max-width: 240px;
  }

  body.desktop-portrait.desktop-portrait #desktop-bottom-center {
	flex: 2 1 300px;
	min-width: 220px;
	max-width: 500px;
  }

  body.desktop-portrait.desktop-portrait #desktop-bottom-right {
	flex: 1 1 180px;
	min-width: 130px;
	max-width: 220px;
  }

  body.desktop-portrait.desktop-portrait #desktop-bottom-buttons {
	display: flex !important;
	flex-direction: column;
	justify-content: flex-start;
	align-items: center;
	flex: 0 0 auto;
	width: auto;
  }

  #desktop-bottom-buttons {
	display: none; /* Hidden in landscape */
  }

	  /* Portrait mode: bonus inventory verticaal */
	  body.desktop-portrait .bonus-inventory {
		flex-direction: column;
		align-items: stretch;
		gap: 4px;
	  }
	  
	  body.desktop-portrait .bonus-badge {
		padding: 6px 8px;
		font-size: 0.7rem;
		min-height: auto;
	  }
	  
	  body.desktop-portrait .bonus-count {
		font-size: 0.65rem;
		padding: 2px 5px;
	  }

	  /* Portrait mode: toon munten onder bonussen */
	  body.desktop-portrait.desktop-portrait #desktop-bottom-right #gold-zone {
		order: 10;
	  }

	  /* Portrait mode: hide coin grid, show text counter like mobile */
	  body.desktop-portrait #gold-zone {
		display: flex !important;
		flex-direction: row;
		align-items: center;
		justify-content: flex-start;
		gap: 10px;
		min-height: auto;
		max-height: none;
		padding: 6px 10px;
		min-width: auto;
	  }

	  body.desktop-portrait #gold-zone h2 {
		display: none;
	  }

	  body.desktop-portrait #gold-zone::after {
		content: '\1FA99  ' attr(data-coin-text);
		display: block;
		flex: 0 0 auto;
		text-align: center;
		font-size: 0.95rem;
		font-weight: 700;
		color: #333;
		padding: 0;
		background: transparent;
		border-radius: 0;
		border: none;
		white-space: nowrap;
		font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", "Helvetica Neue", Arial, sans-serif, "Segoe UI Emoji", "Apple Color Emoji", "Noto Color Emoji";
	  }

	  body.desktop-portrait #gold-zone #buy-placement-container {
		margin-top: 0;
		margin-left: auto;
	  }

	  body.desktop-portrait #gold-zone .buy-placement-btn {
		margin-top: 0;
		padding: 6px 10px;
		max-width: 180px;
		width: fit-content;
	  }

	  body.desktop-portrait #collected-coins {
		display: none !important;
	  }

	  body.desktop-portrait #gold-zone::after {
		color: #e5e5e5;
	  }

	  #desktop-bottom-center {
		display: flex;
		flex-direction: column;
		justify-content: flex-start;
		align-items: center;
		flex: 1 1 auto;
		min-width: 0;
		gap: 12px;
	  }

	  /* Portrait mode: card-choice-zone past zich aan */
	  body.desktop-portrait #card-choice-zone {
		width: 100%;
	  }

	  /* Portrait mode: card action buttons in separate middle zone */
	  body.desktop-portrait #card-controls {
		flex-direction: column;
		align-items: center;
	  }
	  
	  body.desktop-portrait #card-options {
		width: 100%;
	  }
	  
	  body.desktop-portrait .card-option {
		min-height: 140px;
		padding: 8px 6px;
	  }
	  
	  body.desktop-portrait .card-option .card-cell {
		width: 16px;
		height: 16px;
	  }

	  body.desktop-portrait #card-controls #card-action-buttons {
		display: none;
	  }
	  
	  body.desktop-portrait.desktop-portrait #desktop-bottom-buttons #card-action-buttons {
		display: flex;
		flex-direction: column;
		align-items: center;
		flex: 0 0 auto;
		width: auto;
	  }

	  /* Kaarten in rechter sidebar: verticaal gestapeld */
	  #desktop-right #card-choice-zone {
		width: 100%;
		background: #fffbea;
		border: 1px solid #e3e6ea;
		border-radius: 10px;
		padding: 12px;
		display: flex;
		flex-direction: column;
		min-height: 0;
	  }

	  #desktop-right #card-choice-zone {
		background: linear-gradient(145deg, #22252b, #1a1c21);
		border: 1px solid #2d2f36;
	  }

	  #desktop-right #card-options {
		display: flex;
		flex-direction: column;
		gap: 12px;
		align-items: stretch;
		overflow-x: hidden;
		flex: 1 1 auto;
		min-height: 0;
		padding-bottom: 8px;
		padding-right: 10px;
	  }

	  /* Desktop sidebar: cards should use the available width (less cramped). */
	  #desktop-right #card-choice-zone .card-option {
		width: calc(100% - 20px);
		margin-left: auto;
		margin-right: auto;
		min-width: 0;
		min-height: var(--card-min-height, 200px);
		height: auto;
		--preview-cell: 24px;
		box-sizing: border-box;
	  }
	  
	  /* Scrolling alleen wanneer er 4+ kaarten zijn (class toegevoegd via JS) */
	  #desktop-right #card-options.has-scroll {
		max-height: 920px;
		min-height: 0;
		overflow-y: auto;
		scrollbar-width: thin;
		scrollbar-color: rgba(100, 120, 180, 0.5) transparent;
	  }
	  
	  #desktop-right #card-options.has-scroll::-webkit-scrollbar {
		width: 6px;
	  }
	  #desktop-right #card-options.has-scroll::-webkit-scrollbar-track {
		background: transparent;
		border-radius: 3px;
	  }
	  #desktop-right #card-options.has-scroll::-webkit-scrollbar-thumb {
		background: linear-gradient(180deg, rgba(100, 120, 180, 0.6), rgba(80, 100, 160, 0.4));
		border-radius: 3px;
	  }
	  #desktop-right #card-options.has-scroll::-webkit-scrollbar-thumb:hover {
		background: linear-gradient(180deg, rgba(120, 140, 200, 0.8), rgba(100, 120, 180, 0.6));
	  }
	  
	  #desktop-right #card-options.has-scroll {
		scrollbar-color: rgba(140, 160, 220, 0.4) transparent;
	  }
	  #desktop-right #card-options.has-scroll::-webkit-scrollbar-thumb {
		background: linear-gradient(180deg, rgba(100, 120, 180, 0.5), rgba(80, 100, 160, 0.3));
	  }

	  /* Buttons centreren onder kaarten op desktop */
	  #desktop-right > #card-action-buttons,
	  #card-choice-zone #card-action-buttons {
		display: flex;
		flex-direction: row;
		gap: 8px;
		align-items: center;
		justify-content: center;
		margin-top: 12px;
		margin-bottom: 12px;
		width: 100%;
		max-width: 100%;
		box-sizing: border-box;
		flex-wrap: wrap;
		padding: 0 8px;
	  }
	  
	  /* Hide buttons when still in card-controls during landscape layout */
	  body.desktop-landscape #card-controls #card-action-buttons {
		display: none;
	  }
	  
	  body.desktop-landscape #desktop-right > #card-action-buttons {
		display: flex;
		justify-content: center;
		gap: 10px;
	  }

	  body.desktop-landscape #desktop-right > #card-action-buttons .card-action-btn,
	  body.desktop-landscape #desktop-right > #card-action-buttons .deck-preview {
		flex: 0 0 auto;
		margin: 0;
	  }

	  body.desktop-landscape #gold-zone .buy-placement-btn {
		padding: 8px 10px;
		max-width: 150px;
		white-space: nowrap;
	  }

	  /* Verberg originele wrapper zones op desktop */
	  #original-coins-zone,
	  #original-score-zone,
	  #original-objective-zone,
	  #original-bonus-zone,
	  #original-card-zone,
	  #original-controls-zone {
		display: none;
	  }

	  /* Zone styling op desktop - geen achtergrond (wordt per zone ingesteld) */
	  /* Dark mode borders en shadows worden al bovenaan gedefinieerd */

	  /* Coins display integreren in scoreboard sectie */
	  #gold-zone {
		padding: 12px;
		margin: 0 0 12px 0;
		width: 100%;
		min-height: 140px;
		border-radius: 10px;
		border: 1px solid #e3e6ea;
		box-shadow: 0 2px 6px rgba(0,0,0,0.12);
		background: #fffbea;
		text-align: left;
		overflow: hidden;
	  }

	  /* Give the buy-placement button enough width so it never clips in the coin zone. */
	  #gold-zone #buy-placement-container {
		width: 100%;
		justify-content: stretch;
	  }
	  #gold-zone #buy-placement-btn {
		width: 100%;
	  }

	  /* Landscape mode: hide coin grid, show text counter (unless classic mode). */
	  body.desktop-landscape:not(.classic-mode) #gold-zone::after {
		content: '\1FA99  ' attr(data-coin-text);
		display: block;
		font-size: 1.2rem;
		font-weight: 800;
		color: #333;
		margin-top: 8px;
		text-align: center;
		white-space: nowrap;
		max-width: 100%;
		overflow: hidden;
		text-overflow: ellipsis;
		font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", "Helvetica Neue", Arial, sans-serif, "Segoe UI Emoji", "Apple Color Emoji", "Noto Color Emoji";
	  }
	  body.desktop-landscape:not(.classic-mode) #collected-coins {
		display: none;
	  }
	  body.desktop-landscape:not(.classic-mode) #gold-zone::after {
		color: var(--color-text-light);
	  }

	  /* Classic mode: keep only the board + coins visible. */
	  body.classic-mode #card-choice-zone,
	  body.classic-mode #bonus-zone,
	  body.classic-mode #scoreboard,
	  body.classic-mode #objective-zone,
	  body.classic-mode #mobile-objective-banner,
	  body.classic-mode #buy-placement-container,
	  body.classic-mode #bottom-bar {
		display: none;
	  }

	  /* Classic mode: hide coins + zone info + theme toggle; only board + hamburger remain. */
	  body.classic-mode #original-coins-zone,
	  body.classic-mode #gold-zone,
	  body.classic-mode #collected-coins,
	  body.classic-mode .zone-info-btn,
	  body.classic-mode .zone-info-popover {
		display: none;
	  }
	  body.classic-mode #board > .column:last-child {
		display: none;
	  }

	  /* Classic mode: hide next turn / shop / deck controls everywhere. */
	  body.classic-mode #card-action-buttons,
	  body.classic-mode #new-cards-btn,
	  body.classic-mode #bonus-shop-btn,
	  body.classic-mode #deck-preview {
		display: none;
	  }
	  body.classic-mode #gold-zone::after {
		content: none;
	  }
	  /* Classic mode: show max 20 coin slots. */
	  body.classic-mode #collected-coins .coin:nth-child(n+21) {
		display: none;
	  }

	  /* Classic mode: hamburger menu shows only essentials. */
	  body.classic-mode #controls button:not(#classic-mode-toggle):not(#print-btn) {
		display: none;
	  }

	  /* Classic mode: keep coins visible even on mobile layout. */
	  body.classic-mode #gold-zone {
		position: fixed;
		top: calc(10px + env(safe-area-inset-top, 0px));
		right: calc(10px + env(safe-area-inset-right, 0px));
		width: auto;
		max-width: 220px;
		z-index: calc(var(--z-ui, 200) + 2);
	  }

	  #gold-zone h2 {
		margin: 0 0 14px 0;
		font-size: 1.1rem;
		font-weight: 600;
		color: #333;
		text-align: center;
	  }

	  #gold-zone {
		border: 1px solid var(--color-border-dark);
		box-shadow: 0 4px 10px var(--shadow-dark);
		background: linear-gradient(145deg, #22252b, #1a1c21);
		color: var(--color-text-light);
	  }

	  #gold-zone h2 {
		color: var(--color-text-light);
	  }

	  #bonus-zone {
		width: 100%;
		padding: 10px;
		border-radius: 10px;
		border: 1px solid #e3e6ea;
		box-shadow: 0 2px 6px rgba(0,0,0,0.12);
		margin: 0;
		background: #fffbea;
		text-align: left;
	  }

	  #bonus-zone h2 {
		margin: 0 0 8px 0;
		font-size: 1.1rem;
		font-weight: 600;
		color: #333;
		display: block;
		color: #333;
	  }

	  #bonus-zone .bonus-hint {
		display: none;
	  }

	  #bonus-zone {
		border: 1px solid #2d2f36;
		box-shadow: 0 4px 10px rgba(0,0,0,0.5);
		background: linear-gradient(145deg, #22252b, #1a1c21);
		color: #e5e5e5;
	  }

	  #bonus-zone h2 {
		color: var(--color-text-light);
	  }

	  #bonus-zone h2 {
		color: var(--color-text-light);
	  }

	  /* Desktop bottom columns spacing */
	  #desktop-bottom-left,
	  #desktop-bottom-right {
		display: flex;
		flex-direction: column;
		gap: 12px;
	  }

	  #desktop-bottom-center {
		display: flex;
		justify-content: center;
		align-items: flex-start;
	  }

	  /* Trap summary verbergen tot level 5 op desktop */
	  .trap-summary {
		display: none;
	  }
	  
	  body[data-traps-active="true"] .trap-summary {
		display: block;
	  }

	  /* ============================================
	     MOBIEL UI VERBERGEN OP DESKTOP
	     ============================================
	     Bottom-bar en gerelateerde elementen zijn alleen voor mobiel
	  */
	  #bottom-bar,
	  #bottom-bar-cards,
	  .bottom-bar-footer,
	  #bottom-bar-score,
	  #bottom-bar-coins,
	  #mobile-objective-banner {
		display: none;
	  }

	  /* Hamburger menu: fixed overlay so it doesn't take vertical space. */
	  #menu-toggle {
		display: flex;
		position: fixed;
		left: 12px;
		top: 12px;
		z-index: var(--z-menu);
		pointer-events: auto;
		align-items: center;
		justify-content: center;
		flex-direction: column;
		gap: 5px;
		width: 44px;
		height: 44px;
		padding: 10px;
		border-radius: 12px;
		background: linear-gradient(145deg, #ffd560, #ffb23c);
		border: 1px solid rgba(255,255,255,0.35);
		box-shadow: 0 8px 16px rgba(0,0,0,0.28);
		cursor: pointer;
		transition: transform 0.2s ease, box-shadow 0.2s ease;
	  }
	  #menu-toggle span {
		width: 20px;
		height: 2px;
		background: #1c1c1c;
		border-radius: 2px;
		transition: all 0.3s ease;
		display: block;
	  }
	  #menu-toggle.active span:nth-child(1) { transform: translateY(6px) rotate(45deg); }
	  #menu-toggle.active span:nth-child(2) { opacity: 0; }
	  #menu-toggle.active span:nth-child(3) { transform: translateY(-6px) rotate(-45deg); }
	  #menu-toggle {
		background: linear-gradient(145deg, #2b2d33, #1f2126);
		border-color: rgba(255,255,255,0.14);
	  }
	  #menu-toggle span {
		background: rgba(255,255,255,0.88);
	  }

	  /* Floating undo knop â€” desktop positie */
	  #undo-floating-btn {
		left: 12px;
		top: 64px;
		width: 44px;
		height: 44px;
		font-size: 1.25rem;
		border-radius: 12px;
	  }

	  /* Legacy desktop toggle (unused): keep hidden so only #menu-toggle is visible. */
	  #desktop-menu-toggle {
		display: none;
	  }

	/* Dark mode toggle is removed; no standalone button present. */

	  /* Desktop request: remove rotate/mirror buttons from the UI. */
	  #rotate-card-btn,
	  #mirror-card-btn {
		display: none !important;
	  }

	  /* ============================================
	     CONTROLS MENU (DESKTOP)
	     ============================================
	     Op desktop zijn controls altijd zichtbaar in de layout
	  */

	  #controls {
		background: #2d2f36;
		color: #eee;
		box-shadow: 0 4px 16px rgba(0,0,0,0.4);
		border-color: #4a4c54;
	  }

	  #controls button {
		background: #ffffff;
		border: 1px solid #ddd;
		color: #222;
		padding: 10px 14px;
		border-radius: 8px;
		cursor: pointer;
		transition: all 0.2s ease;
		font-size: 0.9rem;
		width: 100%;
		text-align: left;
	  }

	  #controls button:hover {
		background: #f0f0f0;
		transform: translateY(-1px);
	  }

	  #controls button {
		background: #3a3c44;
		border-color: #4a4c54;
		color: #eee;
	  }

	  #controls button:hover {
		background: #454750;
	  }

	#controls #debug-mode-toggle {
		display: inline-flex;
		align-items: center;
		gap: 10px;
		font-weight: 600;
	}

	#controls #debug-mode-toggle.debug-active {
		background: linear-gradient(145deg, #d8f3ff, #b6e2ff);
		border-color: #6fbef3;
		color: #0d3c60;
	}

	#controls #debug-mode-toggle.debug-active {
		background: linear-gradient(145deg, #17435f, #1f587c);
		border-color: #39a1d9;
		color: #e4f6ff;
	}

	  #controls button {
		background: var(--color-dark-gray);
		color: #eee;
		border-color: #555;
	  }

	  #controls button:hover:not(:disabled) {
		background: #f0f0f0;
	  }

	  #controls button:hover:not(:disabled) {
		background: #444;
	  }

	  /* ============================================
	     KAART KEUZE ZONE (DESKTOP)
	     ============================================
	     Drijvende zone met 3 kaart opties
	     Altijd zichtbaar op vaste positie rechtsonder
	  */
	  #card-choice-zone {
		background: #fffbea;
		border-radius: 10px;
		color: #333;
		font-family: "Segoe UI", sans-serif;
		width: 100%;
		box-shadow: 0 2px 6px rgba(0,0,0,0.12);
		border: 1px solid #e3e6ea;
		margin: 0;
		padding: 10px;
		text-align: left;
	  }

	  #card-choice-zone h2 {
		margin: 0 0 8px 0;
		color: #333;
		font-size: 1.1rem;
		font-weight: 600;
		color: #333;
	  }

	  #card-choice-zone {
		background: linear-gradient(145deg, #22252b, #1a1c21);
		border: 1px solid var(--color-border-dark);
		box-shadow: 0 4px 10px var(--shadow-dark);
		color: var(--color-text-light);
	  }

	  #card-choice-zone h2 {
		color: var(--color-text-light);
	  }

	  #kiesKaartTitel {
		display: block;
	  }

	  /* Container voor de 3 kaart opties */
	  #card-options {
		display: flex;
		flex-wrap: nowrap;
		gap: 8px;
		justify-content: center;
		align-items: stretch;
		margin: 14px auto 18px;
	  }

	  /* Individuele kaart in keuze menu (desktop heeft meer ruimte) */
	  #card-choice-zone .card-option {
		display: flex;
		flex-direction: column;
		align-items: center;
		gap: 4px;
		width: auto;
		min-width: 120px;
		min-height: var(--card-min-height, 200px);
		height: auto;
		flex: 1 1 0;
		padding: 12px 8px;
		--preview-cell: 24px;
		border-radius: 12px;
		background: linear-gradient(165deg, #ffffff 0%, #eef2ff 45%, #dfe4ff 100%);
		border: 1px solid rgba(40,55,120,0.18);
		box-shadow: 0 8px 16px rgba(10,12,20,0.15);
		transition: transform 0.2s, box-shadow 0.2s;
	  }

	  #card-choice-zone .card-option {
		background: linear-gradient(160deg, #2d3142 0%, #232635 45%, #1b1e2c 100%);
		border: 1px solid rgba(120,140,220,0.2);
		box-shadow: 0 8px 20px rgba(0,0,0,0.4);
	  }

	  #card-choice-zone .card-option:hover {
		transform: scale(1.05);
		box-shadow: 0 0 10px rgba(0,0,0,0.25);
	  }

	  #card-choice-zone .card-option:hover {
		box-shadow: 0 0 14px rgba(0,0,0,0.5);
	  }

	  #card-choice-zone .card-option.selected {
		outline: 3px solid #3a6ff7;
		outline-offset: -3px;
		border-color: #3a6ff7;
	  }

	  #card-choice-zone .card-option.selected {
		outline: 3px solid #5a8fff;
		outline-offset: -3px;
		border-color: #5a8fff;
	  }

	  /* Positionering reset voor desktop (geen absolute positioning) */
	  #card-choice-zone .card-option::after {
		display: none;
	  }

	/* Only pattern and regular label are in flow; everything else stays absolute */
	#card-choice-zone .card-option > .card-pattern,
	#card-choice-zone .card-option > .card-label:not(.card-label--echo) {
		position: static;
	}

	/* Meta overlay must always paint in front of the pattern */
	#card-choice-zone .card-option .card-meta {
		z-index: 30;
	}

	  /* Labels en metadata zichtbaar op desktop */
	  #card-choice-zone .card-label:not(.card-label--echo) {
		display: inline-flex;
		margin-top: 8px;
	  }

	  /* Kaart patroon (grid met cellen) */
	  #card-choice-zone .card-pattern {
		display: grid;
		gap: var(--preview-gap);
		align-items: center;
		justify-items: center;
	  }

	  #card-choice-zone .card-option .card-cell {
		width: 20px;
		height: 20px;
		border-radius: 3px;
		border: none;
		box-shadow: none;
	  }

	  /* "Nieuwe kaarten" knop (desktop styling) */
	  #new-cards-btn {
		display: inline-flex;
		align-items: center;
		justify-content: flex-start;
		gap: 8px;
		margin: 0 auto;
		padding: 8px 12px;
		border-radius: 8px;
		border: 1px solid #999;
		background: #fafafa;
		color: #222;
		font-weight: 600;
		text-transform: none;
		letter-spacing: normal;
		cursor: pointer;
		transition: background 0.2s ease, transform 0.2s ease;
		position: relative;
	  }

	  #new-cards-btn::before {
		content: 'â†’';
		color: #4a5268;
		font-size: 1.8rem;
		font-weight: 700;
		position: relative;
		top: 0;
		left: 0;
		transform: none;
		transition: color 0.3s ease;
		line-height: 1;
	  }

	  #new-cards-btn.ready-for-next-turn {
		background: linear-gradient(155deg, #fef8e7 0%, #f0c149 100%);
		border-color: rgba(20,24,36,0.14);
	  }

	  #new-cards-btn.ready-for-next-turn::before {
		color: #5a4a1e;
	  }

	  #new-cards-btn:disabled::before {
		color: rgba(74,82,104,0.6);
	  }

	  #new-cards-btn.complete-round {
		background: linear-gradient(155deg, #e8f5e9 0%, #66bb6a 100%);
		border-color: rgba(46,125,50,0.3);
	  }

	  #new-cards-btn.complete-round::before {
		content: 'âœ“';
		color: #1b5e20;
		font-size: 2rem;
		font-weight: 900;
	  }

	  #new-cards-btn {
		background: linear-gradient(145deg, #22252b, #1a1c21);
		border: 1px solid #2d2f36;
		box-shadow: 0 6px 14px rgba(0,0,0,0.45);
		color: #e5e5e5;
	  }

	  #new-cards-btn::before {
		color: rgba(255,255,255,0.75);
	  }

	  #new-cards-btn.ready-for-next-turn {
		background: linear-gradient(155deg, #ffd560 0%, #ffb23c 100%);
		border-color: rgba(255,255,255,0.35);
	  }

	  #new-cards-btn.ready-for-next-turn::before {
		color: #1c1c1c;
	  }

	  #new-cards-btn:disabled::before {
		color: rgba(245,246,255,0.6);
	  }

	  #new-cards-btn.complete-round {
		background: linear-gradient(155deg, #2e7d32 0%, #1b5e20 100%);
		border-color: rgba(129,199,132,0.3);
	  }

	  #new-cards-btn.complete-round::before {
		color: #a5d6a7;
	  }

	  #new-cards-btn:hover {
		background: #f0f0f0;
		transform: translateY(-2px);
	  }

	  #new-cards-btn:hover {
		background: linear-gradient(150deg, #2a2d35, #1f2230);
		border-color: #373a42;
		box-shadow: 0 8px 18px rgba(0,0,0,0.5);
	  }

	  /* Sub-breakpoints verplaatst naar top-level @media blokken (regel ~12223+) */

	  #rotate-card-btn {
		display: none;
		align-items: center;
		justify-content: flex-start;
		gap: 8px;
		margin: 6px auto 0;
		padding: 8px 14px;
		border-radius: 8px;
		border: 1px solid #9aa1b1;
		background: #e9edf7;
		color: #1f2532;
		font-weight: 600;
		text-transform: none;
		letter-spacing: 0.01em;
		cursor: pointer;
		transition: background 0.2s ease, transform 0.2s ease, opacity 0.2s ease;
		position: relative;
	  }

	  #rotate-card-btn::before {
		content: 'â†»';
		color: #4a5268;
		font-size: 1.6rem;
		position: relative;
		top: 0;
		left: 0;
		transform: none;
		line-height: 1;
	  }

	  #rotate-card-btn {
		background: linear-gradient(145deg, #22252b, #1a1c21);
		border: 1px solid #2d2f36;
		box-shadow: 0 6px 14px rgba(0,0,0,0.45);
		color: #e5e5e5;
	  }

	  #rotate-card-btn::before {
		color: rgba(255,255,255,0.75);
	  }

	  #rotate-card-btn:hover:not(:disabled) {
		background: #dbe2f2;
		transform: translateY(-1px);
	  }

	  #rotate-card-btn:hover:not(:disabled) {
		background: linear-gradient(150deg, #2a2d35, #1f2230);
		border-color: #373a42;
		box-shadow: 0 8px 18px rgba(0,0,0,0.5);
	  }

	  #rotate-card-btn:disabled {
		opacity: 0.55;
		cursor: not-allowed;
		transform: none;
	  }

	  #scoreboard {
		background: #fffbea;
		border-radius: 10px;
		padding: 6px;
		color: #333;
		width: 100%;
		box-shadow: 0 2px 6px rgba(0,0,0,0.12);
		border: 1px solid #e3e6ea;
		margin: 0;
	  }

	  #scoreboard h2 {
		margin: 0 0 3px 0;
		font-size: 0.95rem;
	  }

	  #scoreboard .score-row {
		padding: 2px 6px;
		margin-bottom: 1px;
		font-size: 0.85rem;
	  }

	  #scoreboard hr {
		margin: 2px 0;
	  }

	  #scoreboard {
		background: linear-gradient(145deg, #22252b, #1a1c21);
		border: 1px solid var(--color-border-dark);
		box-shadow: 0 4px 10px var(--shadow-dark);
		color: var(--color-text-light);
	  }

	  #scoreboard h2,
	  #scoreboard hr {
		display: block;
	  }

	  #scoreboard h2 {
		color: var(--color-text-light);
	  }

	  #scoreboard hr {
		border-color: #3d4048;
	  }

	  #scoreboard .score-row {
		background: #f5f0e4;
		padding: 3px 6px;
		margin-bottom: 2px;
		border-radius: 5px;
		color: #333;
		transition: transform 0.1s ease, background 0.3s;
	  }

	  #scoreboard .score-row {
		background: #2a2d35;
		color: var(--color-text-light);
	  }

	  #scoreboard .score-row:hover {
		transform: scale(1.02);
		background: #ebe4d4;
		color: #222;
	  }

	  #scoreboard .score-row:hover {
		background: #32353d;
	  }

	  #scoreboard .score-row .label {
		display: inline;
		font-size: 0.8rem;
	  }

	  #scoreboard .score-row .color-box {
		width: 10px;
		height: 10px;
		border-radius: 2px;
	  }

	  #scoreboard .score-total {
		font-size: 0.9rem;
		margin-top: 3px;
		padding: 4px 8px;
		background: #f0ead8;
		border-radius: 6px;
		border: 1px solid #d9d0bd;
		color: #333;
		font-weight: 600;
	  }

	  #scoreboard .score-total {
		background: #2f3239;
		border-color: #3d4048;
		color: #e5e5e5;
	  }

	#objective-zone {
		display: flex;
		flex-direction: column;
		gap: 8px;
		background: #fffbea;
		border: 1px solid #e3e6ea;
		box-shadow: 0 2px 6px rgba(0,0,0,0.12);
		position: relative;
		z-index: var(--z-zoom);
		text-align: left;
		justify-content: flex-start;
	}

	  #mobile-objective-banner {
		display: none;
	  }

	  #objective-zone {
		background: linear-gradient(145deg, #22252b, #1a1c21);
		border: 1px solid var(--color-border-dark);
		box-shadow: 0 4px 10px var(--shadow-dark);
		color: var(--color-text-light);
	  }

	  #objective-zone h2 {
		margin-bottom: 4px;
	  }

	  .objective-current {
		font-size: 0.92rem;
		font-weight: 600;
		line-height: 1.35;
	  }

	  .objective-history {
		list-style: none;
		margin: 0;
		padding: 0;
		display: flex;
		flex-direction: column;
		gap: 6px;
		font-size: 0.78rem;
		color: rgba(20,24,36,0.6);
	  }

	  .objective-history {
		color: rgba(255,255,255,0.6);
	  }

	  .objective-history li {
		display: flex;
		align-items: center;
		gap: 6px;
	  }

	  .objective-history li::before {
		content: "âœ”";
		font-size: 0.8rem;
		color: #2c9a4b;
	  }

	  .objective-history li::before {
		color: #7fe48e;
	  }

	  .objective-empty-state {
		font-size: 0.76rem;
		color: rgba(20,24,36,0.6);
	  }

	  .objective-empty-state {
		color: rgba(255,255,255,0.55);
	  }

	  #bonus-zone,
	  #original-bonus-zone .zone {
		display: flex;
		flex-direction: column;
		gap: 10px;
		background: #fffbea;
		border: 1px solid #e3e6ea;
		box-shadow: 0 2px 6px rgba(0,0,0,0.12);
		text-align: left;
	  }

	  /* Desktop Dark Mode voor Bonus Zone - mooie gradient zoals objective-zone */
	  #bonus-zone,
	  #original-bonus-zone .zone {
		background: linear-gradient(145deg, #22252b, #1a1c21);
		border: 1px solid var(--color-border-dark);
		box-shadow: 0 4px 10px var(--shadow-dark);
		color: var(--color-text-light);
	  }

	  #bonus-zone h2,
	  #original-bonus-zone .zone h2 {
		margin: 0;
	  }

	  #bonus-zone h2,
	  #original-bonus-zone .zone h2 {
		color: #e4e8ff;
	  }

	  .bonus-inventory {
		display: flex;
		flex-wrap: wrap;
		gap: 8px;
	  }

	  /* Bonus badge styling wordt nu volledig afgehandeld door de globale :is(#bonus-zone, #bottom-bar-bonus) .bonus-badge sectie */

	  #bottom-bar-score,
	  #bottom-bar-bonus,
	  #bottom-bar-coins {
		flex: 1 1 0;
	  }

	  .symbol.bonus-used {
		opacity: 0.25;
		filter: grayscale(0.4);
	  }

	  /* Note: Volledige dark mode styling voor desktop zones staat verderop 
	     in de dedicated DESKTOP DARK MODE secties na de #gold-zone styling */
	}

#original-coins-zone:empty,
	#original-score-zone:empty,
	#original-objective-zone:empty,
	#original-card-zone:empty,
	#original-controls-zone:empty,
	#gold-zone:empty,
	#scoreboard:empty,
	#card-choice-zone:empty,
	#controls-zone:empty {
	  display: none;
	}

	/* Extra mobile finetuning for smaller screens */
	@media (max-width: 520px) {
	  #bottom-bar-bonus .bonus-inventory {
		gap: 8px;
	  }

	  #bottom-bar-bonus .bonus-badge {
		padding: 5px 10px;
		font-size: 0.7rem;
	  }



	  #bottom-bar-bonus .bonus-count {
		font-size: 0.68rem;
		padding: 2px 6px;
	  }
	}

	@media (max-width: 400px) {
	  #bottom-bar-bonus .bonus-inventory {
		gap: 6px;
	  }

	  #bottom-bar-bonus .bonus-badge {
		padding: 4px 8px;
		font-size: 0.66rem;
	  }



	  #bottom-bar-bonus .bonus-count {
		font-size: 0.64rem;
		padding: 1px 5px;
	  }
	}

	/* FINAL OVERRIDES: mobile hand cards + bottom-bar height (ensure these win) */
	/* Compacte kaarten met HOGERE bottom-bar voor voldoende ruimte */
	@media (max-width: 650px) {
		:root {
			--hand-card-height: 20px;
			--hand-card-width: 36px;
			--bottom-bar-height: 180px;
		}
		#card-choice-zone .card-option {
			height: var(--hand-card-height);
			min-height: var(--hand-card-height);
			max-height: var(--hand-card-height);
		}
		#bottom-bar-cards {
			height: calc(var(--hand-card-height) + 35px);
			min-height: calc(var(--hand-card-height) + 35px);
		}
		#bottom-bar #card-choice-zone .card-option {
			width: var(--hand-card-width);
			max-width: var(--hand-card-width);
			height: var(--hand-card-height);
			min-height: var(--hand-card-height);
			max-height: var(--hand-card-height);
			padding: 3px 3px 4px;
			gap: 1px;
			--preview-cell: 12px;
		}
		#bottom-bar #card-choice-zone .card-option .card-cell {
			width: 10px;
			height: 10px;
		}
	}
	@media (max-width: 650px) and (min-width: 291px) {
		:root {
			--hand-card-height: 22px;
			--hand-card-width: 41px;
			--bottom-bar-height: 190px;
		}
		#bottom-bar #card-choice-zone .card-option {
			--preview-cell: 12px;
		}
		#bottom-bar #card-choice-zone .card-option .card-cell {
			width: 10px;
			height: 10px;
		}
	}
	@media (max-width: 650px) and (min-width: 341px) {
		:root {
			--hand-card-height: 25px;
			--hand-card-width: 46px;
			--bottom-bar-height: 200px;
		}
		#bottom-bar #card-choice-zone .card-option {
			--preview-cell: 12px;
		}
		#bottom-bar #card-choice-zone .card-option .card-cell {
			width: 10px;
			height: 10px;
		}
	}
	@media (max-width: 650px) and (min-width: 391px) {
		:root {
			--hand-card-height: 28px;
			--hand-card-width: 50px;
			--bottom-bar-height: 210px;
		}
		#bottom-bar #card-choice-zone .card-option {
			--preview-cell: 12px;
		}
		#bottom-bar #card-choice-zone .card-option .card-cell {
			width: 10px;
			height: 10px;
		}
	}

	/* Deck modal: compactere kaarten op mobiel */
	@media (max-width: 650px) {
		.deck-modal-grid {
			grid-template-columns: repeat(auto-fit, minmax(64px, 1fr));
			gap: 12px;
			max-height: 54vh;
		}
		.deck-modal-grid .card-option {
			min-height: 152px;
			height: 152px;
			padding: 8px 6px;
			overflow: hidden;
			display: flex;
			justify-content: center;
			align-items: center;
			gap: 0;
			--preview-cell: 12px;
		}
		#deck-modal {
			width: min(96vw, 560px);
			max-height: 74vh;
			padding: 12px;
		}
	}

	/* Desktop sub-breakpoints: compactere layout bij smallere viewport */
	@media (min-width: 651px) and (max-width: 1100px) {

		#card-choice-zone .card-option {
			min-width: 80px;
			min-height: 160px;
			padding: 8px 4px;
		}

		#card-choice-zone .card-option .card-cell {
			width: 18px;
			height: 18px;
		}

		#new-cards-btn,
		#rotate-card-btn {
			width: 44px;
			height: 44px;
			padding: 0;
			font-size: 0;
			justify-content: center;
		}

		#new-cards-btn::before,
		#rotate-card-btn::before {
			font-size: 1.8rem;
			position: absolute;
			top: 50%;
			left: 50%;
			transform: translate(-50%, -50%);
		}

		#rotate-card-btn {
			margin-top: 8px;
		}

		.deck-count {
			height: 44px;
			min-width: 44px;
			padding: 6px 8px;
			font-size: 0.95rem;
		}

		.deck-preview {
			padding: 6px 8px;
			min-height: 44px;
			width: auto;
			gap: 4px;
		}

		.deck-preview::after {
			display: none;
		}

		#turn-counter-inline {
			text-align: left;
			font-size: 0.9rem;
			padding-left: 8px;
		}

		#turn-counter-inline::before {
			content: '';
		}

		#objective-zone {
			width: 85%;
			max-width: 900px;
			padding: 8px 12px;
		}

		#desktop-bottom-left,
		#desktop-bottom-right {
			width: auto;
			min-width: 280px;
			max-width: 360px;
			flex-shrink: 1;
		}

		#desktop-wrapper {
			padding: 8px;
			gap: 12px;
		}
	}

	@media (min-width: 651px) and (max-width: 850px) {
		#objective-zone {
			width: 92%;
			max-width: 700px;
			padding: 8px 12px;
			font-size: 0.9rem;
		}

		#objective-zone h2 {
			font-size: 0.9rem;
		}

		#objective-current {
			font-size: 0.85rem;
		}

		#desktop-wrapper {
			padding: 8px;
			gap: 10px;
		}

		#desktop-bottom-left,
		#desktop-bottom-right {
			min-width: 240px;
			max-width: 320px;
		}

		#desktop-bottom {
			gap: 8px;
		}
	}

	@media (min-width: 651px) and (max-width: 900px) {
		body.desktop-portrait.desktop-portrait #desktop-bottom {
			gap: 8px;
			padding: 0 8px;
		}

		body.desktop-portrait.desktop-portrait #desktop-bottom-left {
			flex: 0 1 180px;
			min-width: 130px;
			max-width: 200px;
		}

		body.desktop-portrait.desktop-portrait #desktop-bottom-center {
			flex: 1 1 340px;
			min-width: 240px;
			max-width: 480px;
		}

		body.desktop-portrait.desktop-portrait #desktop-bottom-right {
			flex: 0 1 160px;
			min-width: 120px;
			max-width: 200px;
		}

		body.desktop-portrait #scoreboard {
			max-width: 190px;
			padding: 4px 5px;
			font-size: 0.8rem;
		}

		body.desktop-portrait #scoreboard .score-row {
			padding: 1px 3px;
			font-size: 0.75rem;
		}

		body.desktop-portrait #scoreboard .score-total {
			padding: 3px 5px;
			font-size: 0.78rem;
		}

		body.desktop-portrait #gold-zone {
			padding: 2px 6px;
			font-size: 0.85rem;
		}

		body.desktop-portrait .bonus-badge {
			padding: 4px 6px;
			font-size: 0.68rem;
		}
	}

	/* === Mobile zoom: make zoomed zones uniform (user request) ===
	   Apply to ALL touch devices (phones + tablets) so World 2/3 can't diverge from World 1 sizing. */
	@media (max-width: 650px), (hover: none) and (pointer: coarse) {
		body.zoomed-in #yellow-zone.zoom-focus,
		body.zoomed-in #green-zone.zoom-focus,
		body.zoomed-in #blue-zone.zoom-focus,
		body.zoomed-in #purple-zone.zoom-focus,
		body.zoomed-in #red-zone.zoom-focus {
			position: fixed;
			left: 0;
			right: 0;
			width: 100vw;
			max-width: 100vw;
			min-height: var(--mobile-zoom-height, 57svh);
			max-height: var(--mobile-zoom-height, 57svh);
			min-width: 0;
			margin: 0;

			/* Center position matches existing yellow-ish placement; JS clamps to avoid objective/bottom-bar overlap. */
			top: var(--mobile-zoom-center);
			height: var(--mobile-zoom-height, 57svh);
			transform: translateY(-50%);
			z-index: var(--z-zoom);
			box-shadow: 0 0 30px rgba(0, 0, 0, 0.5);
		}

		/* Yellow/Purple zoom: center the grid and prevent bottom clipping.
		   Purple needs flex for justify-content to have any effect. */
		body.zoomed-in #yellow-zone.zoom-focus,
		body.zoomed-in #purple-zone.zoom-focus {
			display: flex;
			flex-direction: column;
			align-items: center;
			justify-content: center;
			overflow: auto;
			-webkit-overflow-scrolling: touch;
		}
		/* Remove extra grid margins in zoom so it truly centers within the container. */
		body.zoomed-in #yellow-zone.zoom-focus #yellow-grid.grid,
		body.zoomed-in #purple-zone.zoom-focus #purple-grid.grid {
			margin-top: 0;
			margin-bottom: 0;
		}
		/* Green zoom: let JS handle scroll-centering to the start cell; don't use align-items which moves the grid. */
		body.zoomed-in #green-zone.zoom-focus {
			align-items: flex-start;
			justify-content: flex-start;
		}

		/* Red zone: center the 2Ã—2 subgrids vertically within the fixed zoom container. */
		body.zoomed-in #red-zone.zoom-focus.red-group {
			display: grid;
			grid-template-columns: repeat(2, max-content);
			justify-content: center;
			gap: 18px;
			align-content: center;
		}

		/* Red zone: ignore legacy min-height so it matches other zoomed zones. */
		body.zoomed-in #red-zone.zoom-focus {
			min-height: 0;
			max-width: 100vw;
		}

		/* Keep green/blue scrollable while zoomed. */
		body.zoomed-in #green-zone.zoom-focus,
		body.zoomed-in #blue-zone.zoom-focus {
			overflow: auto;
			-webkit-overflow-scrolling: touch;
		}

		/* Red can be bigger than the viewport; allow scrolling in the fixed-height zoom container. */
		body.zoomed-in #red-zone.zoom-focus {
			overflow: auto;
			-webkit-overflow-scrolling: touch;
		}
	}

	/* Desktop: hide floating undo (inline undo is used) */
	@media (min-width: 651px) {
		#undo-floating-btn { display: none; }
	}

	/* Mobile / touch override: hide floating undo (inline undo used) */
	@media (max-width: 650px), (hover: none) and (pointer: coarse) {
		#undo-floating-btn { display: none; }
		#undo-inline-btn { display: inline-flex; }
	}

	/* Final color fixes: ensure deck preview text is light on dark buttons
	   and remove the gray background from bonus-count badges for readability. */
	/* Target card-action area (mobile & desktop compact areas) */
	#card-action-buttons .deck-count,
	#card-action-buttons .deck-preview .deck-count,
	#bottom-bar #card-action-buttons .deck-count {
		background: none;
		border: none;
		box-shadow: none;
		color: rgba(235,238,255,0.95);
	}

	/* Bonus counts: keep pill visible (desktop + mobile) */

	</style>
	<link rel="stylesheet" href="responsive.css">
	<script>
    // Simple menu toggle: toggles .open on #controls and .active on #menu-toggle
    document.addEventListener('DOMContentLoaded', function() {
        const menuToggle = document.getElementById('menu-toggle');
        const controls = document.getElementById('controls');
		const classicToggle = document.getElementById('classic-mode-toggle');

        if (!menuToggle || !controls) return;

        // ensure initial state: closed
        menuToggle.classList.remove('active');
        controls.classList.remove('open');

        // click toggles open state
        menuToggle.addEventListener('click', function(e) {
            e.stopPropagation();
            const opened = menuToggle.classList.toggle('active');
            if (opened) controls.classList.add('open'); else controls.classList.remove('open');
        });

        // clicking outside closes the menu
        document.addEventListener('click', function(event) {
            if (!menuToggle.contains(event.target) && !controls.contains(event.target)) {
                menuToggle.classList.remove('active');
                controls.classList.remove('open');
            }
        });

		// Classic mode toggle (persisted)
		const CLASSIC_MODE_KEY = 'locusClassicMode';
		const applyClassicModeUi = (enabled) => {
			document.body.classList.toggle('classic-mode', !!enabled);
			if (classicToggle) {
				classicToggle.setAttribute('aria-pressed', enabled ? 'true' : 'false');
				classicToggle.textContent = enabled ? 'Klassieke versie: aan' : 'Klassieke versie: uit';
			}
			// Mobile classic mode should run in landscape when the browser allows it.
			try {
				if (enabled && window.innerWidth <= (typeof MOBILE_BREAKPOINT !== 'undefined' ? MOBILE_BREAKPOINT : 650)) {
					if (screen && screen.orientation && typeof screen.orientation.lock === 'function') {
						screen.orientation.lock('landscape');
					}
				} else if (!enabled) {
					if (screen && screen.orientation && typeof screen.orientation.unlock === 'function') {
						screen.orientation.unlock();
					}
				}
			} catch (e) {}
			if (typeof updateCoinCounter === 'function') {
				updateCoinCounter();
			}
			if (typeof initialiseCoins === 'function') {
				try { initialiseCoins(enabled ? 20 : 50); } catch {}
			}
			if (typeof scheduleLayoutReflow === 'function') {
				scheduleLayoutReflow(0);
			}
		};

		try {
			const saved = localStorage.getItem(CLASSIC_MODE_KEY);
			applyClassicModeUi(saved === '1');
		} catch (e) {
			applyClassicModeUi(false);
		}

		if (classicToggle) {
			classicToggle.addEventListener('click', function(e) {
				e.stopPropagation();
				const enabled = !document.body.classList.contains('classic-mode');
				applyClassicModeUi(enabled);
				try {
					localStorage.setItem(CLASSIC_MODE_KEY, enabled ? '1' : '0');
				} catch (err) {}
				// Keep the menu open so the user can immediately toggle back.
				menuToggle.classList.add('active');
				controls.classList.add('open');
			});
		}
    });
  </script>
</head>

<body>
<div class="blur-overlay"></div>
<div id="drag-overlay"></div>

<!-- Floating preview voor touch-vriendelijke plaatsing -->
<div id="floating-preview">
  <div id="floating-preview-pattern"></div>
  <button id="floating-preview-rotate" title="Draai blok (tap of R)">â†»</button>
  <button id="floating-preview-mirror" title="Spiegel blok (tap of M)">â‡„</button>
  <button id="floating-preview-cancel" title="Annuleer selectie">Ã—</button>
</div>

<!-- Zoom-lens voor plaatsing preview (linksboven touch punt) -->
<div id="placement-zoom-lens" style="display: none;">
  <div id="zoom-lens-content"></div>
</div>

	<!-- dark-mode toggle removed: app now uses dark-only theme -->
	<button id="menu-toggle" class="menu-toggle" title="Menu" aria-label="Menu">
    <span></span>
    <span></span>
    <span></span>
  </button>
	<button id="undo-floating-btn" onclick="undo()" title="Undo (Ctrl+Z)" aria-label="Undo" disabled>â†©</button>
	<div id="mobile-objective-banner"></div>

	<!-- Mobile Sidebar Layout Container (hidden by default, JS populates for mobile) -->
	<div id="mobile-landscape-wrapper" style="display: none;">
		<div id="ml-sidebar-left"></div>
		<div id="ml-board-center">
			<div id="ml-objective-top" style="display: none;"></div>
		</div>
		<div id="ml-sidebar-right"></div>
	</div>
  
	<div id="board" class="board">
		<!-- Column 1: purple and yellow zones -->
		<div class="column">
		<div class="zone" data-color="paars" id="purple-zone">
			<button class="zone-info-btn" type="button" aria-label="Info: Paars" aria-expanded="false">i</button>
			<div class="zone-info-popover" role="tooltip" aria-hidden="true"></div>
			<div id="purple-grid" class="grid"></div>
		</div>
		<div class="zone" data-color="geel" id="yellow-zone">
			<button class="zone-info-btn" type="button" aria-label="Info: Geel" aria-expanded="false">i</button>
			<div class="zone-info-popover" role="tooltip" aria-hidden="true"></div>
		  <div id="yellow-grid" class="grid"></div>
		</div>
	  </div>
		  <!-- Column 2: green zone on top, red zone below -->
	  <div class="column">
		<div class="zone" data-color="groen" id="green-zone" >
			<button class="zone-info-btn" type="button" aria-label="Info: Groen" aria-expanded="false">i</button>
			<div class="zone-info-popover" role="tooltip" aria-hidden="true"></div>
			<div id="green-grid" class="grid"></div>
		</div>
		<div id="red-zone"  class="zone red-group" data-color="rood">
			<button class="zone-info-btn" type="button" aria-label="Info: Rood" aria-expanded="false">i</button>
			<div class="zone-info-popover" role="tooltip" aria-hidden="true"></div>
			<div id="world3-red-lock" aria-hidden="true">
				<svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
					<path d="M7.5 10V8a4.5 4.5 0 0 1 9 0v2" fill="none" stroke="currentColor" stroke-width="1.75" stroke-linecap="round" stroke-linejoin="round" />
					<rect x="6.25" y="10" width="11.5" height="10" rx="2" fill="none" stroke="currentColor" stroke-width="1.75" />
					<path d="M12 14v3" fill="none" stroke="currentColor" stroke-width="1.75" stroke-linecap="round" />
				</svg>
			</div>
		  <div id="red-grid1" data-color="rood" data-zone="red-grid1" class="zone" data-subgrid="1"></div>
		  <div id="red-grid2" data-color="rood" data-zone="red-grid2" class="zone" data-subgrid="2"></div>
		  <div id="red-grid3" data-color="rood" data-zone="red-grid3" class="zone" data-subgrid="3"></div>
		  <div id="red-grid4" data-color="rood" data-zone="red-grid4" class="zone" data-subgrid="4"></div>
		  <div id="red-grid5" data-color="rood" data-zone="red-grid5" class="zone" data-subgrid="5" style="display:none;"></div>
		  <div id="red-grid6" data-color="rood" data-zone="red-grid6" class="zone" data-subgrid="6" style="display:none;"></div>
		</div>
		<div id="original-card-zone">
		<div class="zone" id="card-choice-zone">
	    <h2 id="kiesKaartTitel">Kies een kaart</h2>
		<br>
		    <div id="card-controls">
		      <div id="card-options"></div>
			  <button id="hand-scroll-left" class="hand-scroll-btn" type="button" aria-label="Scroll kaarten naar links" title="Vorige kaarten">â€¹</button>
			  <button id="hand-scroll-right" class="hand-scroll-btn" type="button" aria-label="Scroll kaarten naar rechts" title="Volgende kaarten">â€º</button>
			  <div id="turn-counter-inline" aria-live="polite">Beurt 1</div>
				<div id="card-action-buttons">
				<button id="new-cards-btn" class="card-action-btn" type="button" data-icon="âžœ" data-label="Volgende hand" aria-label="Volgende hand"></button>
				<button id="undo-inline-btn" class="card-action-btn" type="button" onclick="undo()" title="Undo (Ctrl+Z)" aria-label="Undo" disabled>â†©</button>
				<button id="rotate-card-btn" class="card-action-btn" type="button" data-icon="âŸ³" data-label="Draai kaart" aria-label="Draai kaart"></button>
				<button id="mirror-card-btn" class="card-action-btn" type="button" data-icon="â‡„" data-label="Spiegel kaart" aria-label="Spiegel kaart"></button>
				<button id="bonus-shop-btn" class="card-action-btn" type="button" data-icon="ðŸª" data-label="Bonuswinkel" aria-label="Open bonuswinkel" style="display: none;"></button>
				<div id="deck-preview" class="deck-preview" role="button" tabindex="0" aria-haspopup="dialog" aria-controls="deck-modal" aria-label="Bekijk het volledige deck" data-label="Deck">
		        <div class="deck-count" data-deck-count="0">0</div>
		        </div>
		      </div>
		    </div>
		</div>
		</div>
	  </div>
	  <!-- Column 3: blue zone (long strip) -->
	  <div class="column">
		  <div class="zone" data-color="blauw" id="blue-zone">
			<button class="zone-info-btn" type="button" aria-label="Info: Blauw" aria-expanded="false">i</button>
			<div class="zone-info-popover" role="tooltip" aria-hidden="true"></div>
			<div id="blue-grid" class="grid"></div>
		  </div>
	  </div>
	   <!-- Column 4: coins, scoreboard, controls -->
	   <div class="column">
			<div id="original-coins-zone">
			<div class="zone" id="gold-zone">
			<h2 id="muntenTitel">Munten</h2>
			<div id="collected-coins"></div>
			<div id="buy-placement-container">
				<button id="buy-placement-btn" class="buy-placement-btn" type="button" title="Koop bonusblok (2 munten)">
					<span class="buy-placement-cost"><span class="coin-icon"></span><span class="coin-icon"></span></span>
					<span class="buy-placement-arrow" aria-hidden="true">â†’</span>
					<span class="buy-placement-rainbow-cell" aria-hidden="true"></span>
				</button>
				<div id="purchased-block-preview" class="purchased-block-preview" style="display: none;">
					<div class="purchased-block-cell"></div>
					<span class="purchased-block-label">Sleep me!</span>
				</div>
			</div>
		  </div>
			</div>
		<div id="original-score-zone">
		<div id="scoreboard" class="zone">
		  <h2>Score</h2>
		  <div class="score-total">
			<span class="label">Totaal</span>
			<span class="total-score" id="total-score">0</span>
		  </div>
		  <hr>
		  <div class="score-row yellow">
			<span class="color-box"></span>
			<span class="label">Geel</span>
			<span class="score" id="yellow-score">0</span>
		  </div>
		  <div class="score-row red">
			<span class="color-box"></span>
			<span class="label">Rood</span>
			<span class="score" id="red-score">0</span>
		  </div>
		  <div class="score-row green">
			<span class="color-box"></span>
			<span class="label">Groen</span>
			<span class="score" id="green-score">0</span>
		  </div>
		  <div class="score-row purple">
			<span class="color-box"></span>
			<span class="label">Paars</span>
			<span class="score" id="purple-score">0</span>
		  </div>
		  <div class="score-row blue">
			<span class="color-box"></span>
			<span class="label">Blauw</span>
			<span class="score" id="blue-score">0</span>
		  </div>
		</div>
		</div>
		<div id="original-objective-zone">
		  <div id="objective-zone" class="zone">
			<h2>Doel</h2>
			<div id="objective-current" class="objective-current objective-empty-state">Doelen worden geladenâ€¦</div>
			<ul id="objective-history" class="objective-history"></ul>
		  </div>
		</div>
		<div id="original-bonus-zone">
		  <div class="zone" id="bonus-zone">
			<h2>Bonussen</h2>
			<div id="bonus-inventory" class="bonus-inventory"></div>
			<p class="bonus-hint">Klik op een kleur om een gratis 1Ã—2 blok te plaatsen.</p>
		  </div>
		</div>
		<div class="zone" id="controls">
			<button onclick="undo()">Undo</button>
			<button id="new-game-btn" type="button">Nieuw Spel</button>
			<button id="classic-mode-toggle" type="button" aria-pressed="false">Klassieke versie: uit</button>
			<button id="debug-mode-toggle" type="button" aria-pressed="false">Debug modus: uit</button>
			<button id="menu-editor-btn" type="button">ðŸ› ï¸ Editor</button>
			<button id="menu-open-levels-btn" type="button" onclick="showSavedLevelsModal()">Open level</button>
			<button id="import-scenario-btn" type="button" onclick="importScenarioFile()">ðŸ“¤ Importeer scenario</button>
			<!-- mobile dark-mode toggle removed: dark-only theme -->
			<button id="menu-rules-btn" onclick="showRulesModal()">ðŸ“– Spelregels</button>
			<button id="menu-highscore-btn" onclick="showHighScoreModal()">ðŸ† High Score</button>
		</div>
		<div id="original-controls-zone">
		  <div id="original-controls-zone-inner"></div>
		</div>
		<div class="tetris-block" data-shape='[[1,1],[1,1]]' data-color="#f00"></div>
	  </div> 
	</div>
		<!-- Mobile HUD: bottom bar injected via moveGameElements() for <=650px -->
		<div id="bottom-bar">
			<div id="bottom-bar-cards"></div>
			<div class="bottom-bar-footer">
				<div id="bottom-bar-left">
					<div id="bottom-bar-bonus"></div>
					<div id="bottom-bar-score-coins">
						<div id="bottom-bar-score"></div>
						<div id="bottom-bar-coins"></div>
					</div>
				</div>
			</div>
		</div>

		<div id="game-modal-layer" class="modal-overlay">
			<div id="round-modal" class="game-modal" role="dialog" aria-modal="true" aria-labelledby="round-modal-title">
				<h2 id="round-modal-title">Ronde voltooid</h2>
				<p id="round-modal-message">Goed gespeeld! Kies een optie om verder te gaan.</p>
				<div id="round-modal-summary" class="modal-score-summary"></div>
				<div class="modal-actions">
					<button id="round-modal-next">Volgende level</button>
					<button id="round-modal-restart">Opnieuw spelen</button>
					<button id="round-modal-current-run" style="display:none;">Terug naar vorig spel</button>
				</div>
			</div>
		</div>

		<div id="shop-modal-layer" class="modal-overlay">
			<div id="shop-modal" class="game-modal" role="dialog" aria-modal="true" aria-labelledby="shop-modal-title">
				<div class="shop-modal-header">
					<h2 id="shop-modal-title">Kaarten &amp; Upgrades</h2>
					<button class="modal-close-btn" id="shop-modal-close" aria-label="Sluit winkel">&times;</button>
					<div class="shop-coin-display" id="shop-coin-display">
						<span class="shop-coin-label">Munten</span>
						<span class="shop-coin-balance" id="shop-coin-balance" aria-live="polite" aria-atomic="true">0</span>
					</div>
				</div>
				<p id="shop-modal-message">Besteed je munten aan kaarten, upgrades of bonussen.</p>
				<div class="shop-content-grid">
					<div class="shop-section shop-cards-section">
						<h3 class="shop-section-title">ðŸƒ Kaarten</h3>
						<div id="shop-card-options" class="shop-card-list"></div>
					</div>
					<div class="shop-lower-grid">
						<div class="shop-section shop-upgrades-section">
							<h3 class="shop-section-title">âš™ï¸ Upgrades</h3>
							<div id="shop-upgrade-container" class="shop-upgrade-container"></div>
						</div>
						<div class="shop-section shop-bonus-section">
							<h3 class="shop-section-title">âœ¨ Bonussen</h3>
							<div id="shop-bonus-container" class="shop-bonus-container"></div>
						</div>
						<div class="shop-section shop-freeplace-section">
							<h3 class="shop-section-title">ðŸŽ Extra Plaatsing</h3>
							<div id="shop-freeplace-container" class="shop-freeplace-container"></div>
						</div>
					</div>
				</div>
				<div class="modal-actions">
					<button id="shop-modal-skip">Naar volgend level</button>
				</div>
			</div>
		</div>

		<div id="preworld-pick-layer" class="modal-overlay" aria-hidden="true">
			<div id="preworld-pick-modal" class="game-modal" role="dialog" aria-modal="true" aria-labelledby="preworld-pick-title">
				<div class="preworld-pick-header">
					<h2 id="preworld-pick-title">Kies startkaarten</h2>
					<div class="preworld-pick-budget">Budget: <span id="preworld-pick-budget">9</span>ðŸª™</div>
				</div>
				<p id="preworld-pick-subtext" class="modal-subtext">Kaarten kosten 1ðŸª™ per blok. Kies een combinatie tot 9ðŸª™.</p>
				<div id="preworld-pick-grid" class="preworld-pick-grid"></div>
				<div class="modal-actions">
					<button id="preworld-pick-confirm">Start level</button>
				</div>
			</div>
		</div>

		<div id="print-settings-layer" class="modal-overlay" aria-hidden="true">
			<div id="print-settings-modal" class="game-modal" role="dialog" aria-modal="true" aria-labelledby="print-settings-title">
				<div class="shop-modal-header">
					<h2 id="print-settings-title">Print instellingen</h2>
					<button class="modal-close-btn" id="print-settings-close" aria-label="Sluit print instellingen">&times;</button>
				</div>
				<p id="print-settings-hint" class="print-settings-hint">Printvriendelijk (geen screenshot): alleen het speelveld, met zo min mogelijk inkt.</p>
				<div class="shop-content-grid shop-content-grid--single">
					<div class="shop-section shop-section--tight">
						<h3 class="shop-section-title">Speelveld</h3>
						<label class="inline-option">
							<input type="radio" name="print-board-source" value="current" checked>
							<span>Huidig speelveld</span>
						</label>
						<label class="inline-option">
							<input type="radio" name="print-board-source" value="world1">
							<span>Genereer Wereld 1</span>
						</label>
						<label class="inline-option">
							<input type="radio" name="print-board-source" value="world2">
							<span>Genereer Wereld 2</span>
						</label>
					</div>
					<div class="shop-section shop-section--tight">
						<h3 class="shop-section-title">Opties</h3>

						<label class="inline-option">
							<input id="print-opt-no-bonuses" type="checkbox" checked>
							<span>Zonder bonussen/symbolen (minder inkt)</span>
						</label>
					</div>
				</div>
				<div class="modal-actions modal-actions--end">
					<button id="print-settings-cancel" type="button">Annuleer</button>
					<button id="print-settings-preview" type="button">Preview</button>
					<button id="print-settings-print" type="button">Print</button>
				</div>
			</div>
		</div>

		<!-- Unlock Modal -->
		<div id="unlock-modal-layer" class="modal-overlay">
			<div id="unlock-modal" class="game-modal unlock-modal" role="dialog" aria-modal="true">
				<div class="unlock-modal-content">
					<div class="unlock-icon" id="unlock-icon">ðŸŽ‰</div>
					<h2 id="unlock-title" class="unlock-title">Nieuwe Content!</h2>
					<div id="unlock-items" class="unlock-items-container"></div>
					<button id="unlock-modal-continue" class="modal-button">Doorgaan</button>
				</div>
			</div>
		</div>

		<div id="rules-modal-layer" class="modal-overlay">
			<div id="rules-modal" class="game-modal" role="dialog" aria-modal="true" aria-labelledby="rules-modal-title">
				<h2 id="rules-modal-title">ðŸ“– Spelregels</h2>
				
				<div class="rules-section">
					<h3>Hoe te spelen</h3>
					<p><strong>Doel:</strong> Voltooi het actieve level-objectief voordat je kaarten op zijn.</p>
				</div>

				<div class="rules-section">
					<h3>ðŸŽ´ Kaarten plaatsen</h3>
					<ul>
						<li>Kies een kaart uit je hand (3-4 kaarten)</li>
						<li>Klik op een kaart om te selecteren, klik opnieuw om te deselecteren</li>
						<li>Gebruik de draaiknop (â†») om de kaart te roteren</li>
						<li>Sleep de kaart naar een zone en plaats de blokken</li>
						<li>Kaarten verdwijnen na plaatsing</li>
					</ul>
				</div>

				<div class="rules-section">
					<h3>ðŸŽ¯ Zones & Scoring</h3>
					<ul>
						<li><strong>ðŸŸ¡ Geel:</strong> Vul hele kolommen voor punten (start: 10pt/kolom, groeit per level)</li>
						<li><strong>ðŸŸ¢ Groen:</strong> +10pt per takje dat je voltooit</li>
						<li><strong>ðŸŸ£ Paars:</strong> +1pt per blok voor elke aangrenzende verbinding</li>
						<li><strong>ðŸ”´ Rood:</strong> Vul alle 4 subgrids voor 10pt elk</li>
						<li><strong>ðŸ”µ Blauw:</strong> Vul rijen voor punten (elke 4e rij = vetgedrukt)</li>
						<li><strong>âœ¨ Gouden kaarten:</strong> Kunnen op elke zone geplaatst worden (unlock via upgrade)</li>
					</ul>
				</div>

				<div class="rules-section">
					<h3><span class="coin-symbol">ðŸª™</span> Munten & Upgrades</h3>
					<ul>
						<li>Verzamel munten door gouden cellen te activeren</li>
						<li>Gebruik munten in de winkel voor nieuwe kaarten of upgrades</li>
						<li>Upgrades: grotere hand, gouden kaarten, bonus boost, lucky draw, etc.</li>
					</ul>
				</div>

				<div class="rules-section">
					<h3>âš¡ Bonussen</h3>
					<ul>
						<li>Vul rijen met symbolen om bonusblokken te verdienen</li>
						<li>Klik op een bonus om een gratis 1Ã—2 blok te plaatsen</li>
						<li>Elke 3 bonuspunten = +1 munt</li>
					</ul>
				</div>

				<div class="rules-section">
					<h3>ðŸ“± Mobiele Bediening</h3>
					<ul>
						<li>Tik op een zone om in te zoomen</li>
						<li>Gebruik â—€â–¶ pijlen om tussen zones te navigeren</li>
						<li>Tik buiten de zone om uit te zoomen</li>
					</ul>
				</div>

				<div class="modal-actions">
					<button id="rules-modal-close">Sluiten</button>
				</div>
			</div>
		</div>

		<div id="upgrade-modal-layer" class="modal-overlay">
			<div id="upgrade-modal" class="game-modal" role="dialog" aria-modal="true" aria-labelledby="upgrade-modal-title">
				<h2 id="upgrade-modal-title">Upgrades (binnenkort)</h2>
				<p id="upgrade-modal-message">Dit scherm is gereserveerd voor toekomstige kaart-upgrades. Suggesties zijn welkom!</p>
				<div class="modal-actions">
					<button id="upgrade-modal-close">Sluiten</button>
				</div>
			</div>
		</div>

		<div id="confirm-complete-layer" class="modal-overlay">
			<div id="confirm-complete-modal" class="game-modal" role="dialog" aria-modal="true" aria-labelledby="confirm-complete-title">
				<h2 id="confirm-complete-title">Ronde voltooien?</h2>
				<p id="confirm-complete-message">Weet je zeker dat je de ronde wil voltooien?</p>
				<p id="confirm-complete-details" class="modal-subtext"></p>
				<div class="modal-actions">
					<button id="confirm-complete-yes">Ja</button>
					<button id="confirm-complete-no">Nee</button>
				</div>
			</div>
		</div>
		
		<div id="confirm-new-game-layer" class="modal-overlay">
			<div id="confirm-new-game-modal" class="game-modal" role="dialog" aria-modal="true" aria-labelledby="confirm-new-game-title">
				<h2 id="confirm-new-game-title">âš ï¸ Nieuw Spel Starten</h2>
				<p id="confirm-new-game-message">Weet je zeker dat je een nieuw spel wil starten?</p>
				<p id="confirm-new-game-details" class="modal-subtext">Je huidige voortgang (level, kaarten, upgrades) wordt permanent verwijderd.</p>
				<div class="modal-actions">
					<button id="confirm-new-game-yes" style="background: #d32f2f;">Ja, nieuw spel</button>
					<button id="confirm-new-game-no">Annuleren</button>
				</div>
			</div>
		</div>
		
		<div id="golden-unlock-layer" class="modal-overlay" aria-hidden="true">
			<div id="golden-unlock-modal" class="game-modal" role="dialog" aria-modal="true" aria-labelledby="golden-unlock-title" tabindex="-1">
				<h2 id="golden-unlock-title">âœ¨ Kies je eerste gouden kaart</h2>
				<p id="golden-unlock-subtext" class="modal-subtext">Je hebt <strong>Gouden Kaarten</strong> ontgrendeld. Kies er 1 uit 3.</p>
				<div id="golden-unlock-content" class="deck-modal-grid" role="list"></div>
			</div>
		</div>
		
		<div id="deck-modal-layer" class="modal-overlay" aria-hidden="true">
			<div id="deck-modal" class="game-modal" role="dialog" aria-modal="true" aria-labelledby="deck-modal-title">
				<h2 id="deck-modal-title">Deckoverzicht</h2>
				<p id="deck-modal-subtext" class="modal-subtext"></p>
				<div id="deck-modal-content" class="deck-modal-grid" role="list"></div>
				<div class="modal-actions">
					<button id="deck-modal-close" type="button">Sluiten</button>
				</div>
			</div>
		</div>
		<div id="blackhole-modal-layer" class="modal-overlay" aria-hidden="true">
			<div id="blackhole-modal" class="game-modal blackhole-modal" role="dialog" aria-modal="true" aria-labelledby="blackhole-modal-title" tabindex="-1">
				<h2 id="blackhole-modal-title">Zwart Gat Challenge <span class="blackhole-hero" aria-hidden="true"></span></h2>
				<p id="blackhole-modal-subtext" class="modal-subtext blackhole-subtext"></p>
				<div class="blackhole-stats">
					<span>Kaarten gekozen: <strong id="blackhole-selection-count">0</strong>/<span id="blackhole-selection-limit">0</span></span>
					<span>PotentiÃ«le bonus: <strong id="blackhole-reward">0</strong></span>
					<span class="blackhole-stake">Inzet: <strong id="blackhole-stake-value">0</strong><span class="coin-symbol">ðŸª™</span> (x<strong id="blackhole-stake-mult">1</strong>)
						<input id="blackhole-stake" type="range" min="0" max="10" value="0" step="1" aria-label="Inzet munten" />
					</span>
				</div>
				<div id="blackhole-feedback" class="blackhole-feedback" aria-live="polite"></div>
				<div id="blackhole-card-grid" class="deck-modal-grid blackhole-card-grid" role="list"></div>
				<div class="modal-actions blackhole-actions">
					<button id="blackhole-claim-btn" type="button" disabled>Claim bonus</button>
					<button id="blackhole-forfeit-btn" type="button">Stop (âˆ’5)</button>
				</div>
			</div>
		</div>
		

  <script>
	// ---------- Utilities ----------
	
	// Helper functie om coin symbool te wrappen met correcte font
	// Zorgt voor consistente weergave in Edge en andere browsers
	function coinIcon(count = 1) {
		const coins = 'ðŸª™'.repeat(count);
		return `<span class="coin-symbol">${coins}</span>`;
	}
	
	const historyStack = [];
	const MOBILE_BREAKPOINT = 650;
	const DESKTOP_LOW_HEIGHT_BREAKPOINT = 1080;
	const TRAP_PENALTY = 5;
	// Optional: log world progress to a remote endpoint (required for GitHub Pages).
	// Set WORLD_PROGRESS_LOG_ENDPOINT to your backend URL (e.g., Google Apps Script / Supabase).
	const WORLD_PROGRESS_LOG_ENDPOINT = '';
	const WORLD_PROGRESS_LOG_ENABLED = true;

	function isCoarsePointer() {
		try {
			return !!(window.matchMedia && window.matchMedia('(pointer: coarse)').matches);
		} catch {
			return false;
		}
	}

	// isMobileViewport() is defined later in the file with a more comprehensive implementation.

	// User request: black holes should be rarer.
	const BLACK_HOLE_DEFAULT_CHANCE = 0.12;
	const BLACK_HOLE_CARD_COUNT = 25; // 5x5 grid
	const BLACK_HOLE_MAX_SELECTION = 25;
	const BLACK_HOLE_POINT_MULTIPLIER = 2;
	const BLACK_HOLE_CARD_COLOR = {
	  name: 'zwart gat',
	  code: 'linear-gradient(135deg, #5f5a93 0%, #3b3662 55%, #191532 100%)'
	};

  function shuffleArray(a){
    for(let i=a.length-1;i>0;i--){
      const j = Math.floor(Math.random()*(i+1));
      [a[i],a[j]] = [a[j],a[i]];
    }
    return a;
  }
  
	let isDragging = false;
	let totalScoreFlashToken = 0;

	let yellow=0, green=0, purple=0, blue=0, red=0, bonus=0;
	let blackHoleBonus = 0;
	let totalBonusesCollected = 0;
	let latestScoreSnapshot = null;
	window.lastPlacementFailure = null;
	let blackHoleState = {
	  trap: null,
	  cards: [],
	  selected: new Set(),
	  reward: 0,
	  stake: 0,
	  feedbackTimeout: null
	};
	let lastBlackHoleAutosave = 0;
// Shop-sessie state voor Level 2 upgrades (Bonus Echo)
let shopLevel2Variant = null;
let shopLevel2Used = false;

	const GOLDEN_COLOR = { name: 'gouden', code: '#f5d76e', isGolden: true };
	const GOLDEN_FILL = 'linear-gradient(135deg, #fff4bf, #f5d76e, #d49f32)';
	const GOLDEN_CARD_SHAPES = [
		{ name: 'Gouden Vierkant', matrix: [[1,1],[1,1]], category: 'golden' },
		{ name: 'Gouden L', matrix: [[1,0],[1,0],[1,1]], category: 'golden' },
		{ name: 'Gouden Zuil', matrix: [[1],[1],[1]], category: 'golden' }
	];

	// ========== UPGRADE SYSTEEM ==========
	const UPGRADES = {
		wildcardCards: {
			id: 'wildcardCards',
			name: 'Multikleur Kaarten',
			description: 'Ontgrendel multikleur kaarten die op elk grid geplaatst kunnen worden.',
			cost: 13,
			icon: 'ðŸŒˆ',
			purchased: false,
			shopChance: 0.35,
			onPurchase: () => {
				showObjectiveToast('ðŸŒˆ Multikleur kaarten ontgrendeld! Kies meteen 1 multikleur kaart.');
				setTimeout(() => {
					openMulticolorRewardPicker();
				}, 80);
			}
		},
		miniPack34: {
			id: 'miniPack34',
			name: 'Compact Deck',
			description: 'Koop 3 mini-kaarten (max. 3 blokjes): kies 1 uit 3, drie keer.',
			cost: 8,
			icon: 'ðŸ“¦',
			purchased: false,
			onPurchase: () => {
				showObjectiveToast('ðŸ“¦ Compact Deck gekocht! Kies je 3 kaarten.');
				setTimeout(() => {
					startMini34RewardSequence();
				}, 80);
			}
		},
		goldenCards: {
			id: 'goldenCards',
			name: 'Gouden Kaarten',
			description: 'Ontgrendel gouden kaarten die altijd geplaatst kunnen worden.',
			cost: 15,
			icon: 'âœ¨',
			purchased: false,
			onPurchase: () => {
				showObjectiveToast('âœ¨ Gouden kaarten ontgrendeld! Kies meteen 1 gouden kaart.');
				// Immediate reward: let the player pick 1 of 3 golden cards.
				setTimeout(() => {
					openGoldenUnlockModal();
				}, 80);
			}
		},
		extraHandSize: {
			id: 'extraHandSize',
			name: 'Grotere Hand',
			description: 'Toon 1 extra kaart als kopie uit je deck (deck raakt niet sneller op).',
			cost: 17,
			icon: 'ðŸƒ',
			purchased: false,
			onPurchase: () => {
				// Logica staat in drawNextHand - toont kopie uit deck
			}
		},
		bonusBoost: {
			id: 'bonusBoost',
			name: 'Bonus Boost kaarten',
			description: 'Ontgrendel Bonus Boost kaarten (en krijg er direct 1). Een Bonus Boost kaart geeft 2Ã— bonussen voor de kleur van die kaart.',
			cost: 15,
			icon: 'âš¡',
			purchased: false,
			onPurchase: () => {
				try {
					if (typeof createBonusBoostCardBlueprint !== 'function') return;
					const blueprint = createBonusBoostCardBlueprint();
					if (!blueprint) return;
					ownedDeckBlueprints.push(blueprint);
					// Immediate reward: also give one copy right now.
					try {
						const card = instantiateBlueprint(blueprint);
						if (card) currentHand.push(card);
					} catch (e) {}
					updateDeckPreview();
					saveGameState();
					renderCurrentHand();
					showObjectiveToast('âš¡ Bonus Boost kaart ontvangen! Speel hem om 2Ã— bonussen van die kleur te krijgen.');
				} catch (e) {}
			}
		},
		bonusEcho: {
			id: 'bonusEcho',
			name: 'Level 2 kaarten',
			description: 'Ontgrendel Level 2 upgrades voor je deck. Koop dit Ã©Ã©n keer; daarna kun je in de shop kaarten upgraden voor 5 munten per kaart.',
			cost: 5,
			icon: 'ðŸ”',
			purchased: false,
			onPurchase: () => {
				try {
					UPGRADES.bonusEcho.purchased = true;
					if (!shopLevel2Variant) shopLevel2Variant = pickBonusEchoVariant();
					showObjectiveToast('ðŸ” Level 2 upgrades ontgrendeld! Je kunt nu in de shop kaarten upgraden.');
					updateShopUpgradeUI();
				} catch (e) { console.error('Failed to unlock Level 2 upgrade flow', e); }
			}
		},
		multicolorBoost: {
			id: 'multicolorBoost',
			name: 'Multikleur Boost',
			description: '100% meer kans op multikleur tetris blokken (ook bij random shop).',
			cost: 10,
			icon: 'ðŸŒˆ',
			purchased: false,
			onPurchase: () => {
				showObjectiveToast('ðŸŒˆ Multikleur Boost actief! Dubbele kans op rainbow blokken.');
			}
		},
		luckyDraw: {
			id: 'luckyDraw',
			name: 'Lucky Draw',
			description: '25% kans op een bonuskopie van een kaart die nog in het deck zit.',
			cost: 8,
			icon: 'ðŸ€',
			purchased: false,
			onPurchase: () => {
				// Deze upgrade wijzigt drawNextHand
			}
		},
		coinMaster: {
			id: 'coinMaster',
			name: 'Muntmeester',
			description: 'Krijg 2 extra munten aan het begin van elk level.',
			cost: 6,
			icon: 'ðŸª™',
			purchased: false,
			onPurchase: () => {
				// Geef direct 2 munten
				const goldZone = document.getElementById('collected-coins');
				if (goldZone) {
					const coins = goldZone.querySelectorAll('.coin');
					let added = 0;
					coins.forEach(coin => {
						if (!coin.classList.contains('active') && added < 2) {
							coin.classList.add('active');
							added++;
						}
					});
					updateCoinCounter();
				}
			}
		},
		blackHoleAccess: {
			id: 'blackHoleAccess',
			name: 'Zwart Gat Pas',
			description: 'Ontgrendel het zwart gat bonuslevel wanneer je op een zwart gat landt.',
			cost: 21,
			icon: 'ðŸŒ€',
			purchased: false,
			onPurchase: () => {
				rebuildGameBoards();
				showObjectiveToast('ðŸŒ€ Zwart Gat Pas geactiveerd! Zwarte gaten zijn nu zichtbaar.');
			}
		},
		portals: {
			id: 'portals',
			name: 'Portals',
			description: 'Portals verschijnen op het speelveld waarvan je ook kan starten met plaatsen.',
			cost: 20,
			icon: 'ðŸŒ',
			purchased: false,
			onPurchase: () => {
				activatePortals();
				showObjectiveToast('ðŸŒ Portals geactiveerd! Een portal is verschenen op het bord.');
			}
		},
		betterCards: {
			id: 'betterCards',
			name: 'Betere Kaarten',
			description: 'Ontgrendel een extra premium kaart in de shop (grotere vormen, meer kans op goud/multikleur).',
			cost: 25,
			icon: 'â™¦',
			purchased: false,
			onPurchase: () => {
				showObjectiveToast('â™¦ Premium shopkaart ontgrendeld!');
			}
		},
		xlBlocks: {
			id: 'xlBlocks',
			name: 'XL Blokken',
			description: 'Ontgrendel XL tetris vormen (6 blokjes) in de shop.',
			cost: 20,
			icon: 'ðŸ§±',
			purchased: false,
			onPurchase: () => {
				showObjectiveToast('ðŸ§± XL blokken ontgrendeld!');
				try { openXLRewardPicker('xl'); } catch (e) {}
			}
		},
		extraLargeBlocks: {
			id: 'extraLargeBlocks',
			name: 'XXL Blokken',
			description: 'Ontgrendel XXL tetris vormen (7+ blokjes) in de shop.',
			cost: 25,
			icon: 'ðŸ§±',
			purchased: false,
			onPurchase: () => {
				showObjectiveToast('ðŸ§± XXL blokken ontgrendeld!');
				try { openXLRewardPicker('xxl'); } catch (e) {}
			}
		},
		world4StarterKey: {
			id: 'world4StarterKey',
			name: 'Startsleutel',
			description: 'Start elk World 4 level met 1 deurkleur alvast ontgrendeld.',
			cost: 12,
			icon: 'ðŸ—ï¸',
			purchased: false,
			onPurchase: () => {
				showObjectiveToast('ðŸ—ï¸ Startsleutel actief voor World 4!');
			}
		},
		world4DoorSurge: {
			id: 'world4DoorSurge',
			name: 'Deurboost',
			description: 'Elke geopende deur geeft 1 gratis plaatsing.',
			cost: 14,
			icon: 'ðŸšª',
			purchased: false,
			onPurchase: () => {
				showObjectiveToast('ðŸšª Deurboost geactiveerd!');
			}
		},
		world4KeyEcho: {
			id: 'world4KeyEcho',
			name: 'Sleutel-echo',
			description: 'Een gebruikte sleutel geeft 1 bonus van die kleur.',
			cost: 10,
			icon: 'âœ¨',
			purchased: false,
			onPurchase: () => {
				showObjectiveToast('âœ¨ Sleutel-echo geactiveerd!');
			}
		}
	};

	// Unlock systeem - bepaalt welke content beschikbaar is per level
	const UNLOCK_PROGRESSION = {
		// Kaart categorieÃ«n unlocks
		cardCategories: {
			mini: { unlockedAtLevel: 1, name: 'Mini Kaarten', icon: 'ðŸ“¦', description: 'Compacte kaarten van 2-3 blokjes' },
			standard: { unlockedAtLevel: 1, name: 'Standaard Kaarten', icon: 'ðŸŽ´', description: 'Klassieke Tetris vormen' },
			large: { unlockedAtLevel: 3, name: 'Grote Kaarten', icon: 'ðŸ“', description: 'Uitgebreide vormen met 5+ blokjes' }
		},
		// Speciale features
		features: {
			bonusShop: { unlockedAtWorld: 2, name: 'Bonus Shop', icon: 'ðŸª', description: 'Upgrade je bonussen permanent in de shop!' },
			randomShopCard: { unlockedAtLevel: 2, name: 'Random Shopkaart', icon: 'âœ¨', description: 'Mystery kaart verschijnt in de shop.' }
		},
		// Upgrade unlocks (level waarop ze in de shop verschijnen)
		upgrades: {
			miniPack34: { unlockedAtLevel: 5, announcement: 'nieuwe upgrade' },
			wildcardCards: { unlockedAtLevel: 7, announcement: 'nieuwe upgrade' },
			coinMaster: { unlockedAtLevel: 5, announcement: 'nieuwe upgrade' },
			goldenCards: { unlockedAtLevel: 7, announcement: 'nieuwe upgrade' },
			luckyDraw: { unlockedAtLevel: 5, announcement: 'nieuwe upgrade' },
			extraHandSize: { unlockedAtWorld: 3, unlockedAtLevel: 21, announcement: 'nieuwe upgrade' },
			multicolorBoost: { unlockedAtWorld: 3, unlockedAtLevel: 21, announcement: 'nieuwe upgrade' },
			bonusBoost: { unlockedAtWorld: 2, unlockedAtLevel: 5, announcement: 'nieuwe upgrade' },
			bonusEcho: { unlockedAtWorld: 2, unlockedAtLevel: 12, announcement: 'nieuwe upgrade' },
			blackHoleAccess: { unlockedAtLevel: 11, announcement: 'nieuwe uitdaging' },
			portals: { unlockedAtLevel: 11, announcement: 'nieuwe upgrade' },
			betterCards: { unlockedAtWorld: 3, unlockedAtLevel: 21, announcement: 'nieuwe upgrade' },
			xlBlocks: { unlockedAtLevel: 7, announcement: 'nieuwe upgrade' },
			extraLargeBlocks: { unlockedAtWorld: 3, unlockedAtLevel: 21, announcement: 'nieuwe upgrade' },
			world4StarterKey: { unlockedAtWorld: 4, unlockedAtLevel: 31, announcement: 'nieuwe upgrade' },
			world4DoorSurge: { unlockedAtWorld: 4, unlockedAtLevel: 33, announcement: 'nieuwe upgrade' },
			world4KeyEcho: { unlockedAtWorld: 4, unlockedAtLevel: 35, announcement: 'nieuwe upgrade' }
		},
		// Elk level track welke content unlocked is
		getLevelUnlocks: function(level, world = 1) {
			const unlocks = {
				cardCategories: [],
				upgrades: [],
				features: [],
				shopType: level % 2 === 0 ? 'full' : 'cards-only' // Elke 2 levels volledige shop (met upgrades)
			};
			
			// Check card categories
			Object.entries(this.cardCategories).forEach(([key, data]) => {
				if (data.unlockedAtLevel === level) {
					unlocks.cardCategories.push({ key, ...data });
				}
			});
			
			// Check features
			Object.entries(this.features || {}).forEach(([key, data]) => {
				if (data.unlockedAtLevel === level) {
					unlocks.features.push({ key, ...data });
				}
			});
			
			// Check upgrades
			Object.entries(this.upgrades).forEach(([key, data]) => {
				if (data.unlockedAtLevel === level && (!data.unlockedAtWorld || world >= data.unlockedAtWorld)) {
					unlocks.upgrades.push({ 
						key, 
						...data, 
						upgradeData: UPGRADES[key] 
					});
				}
			});
			
			return unlocks;
		},
		isUpgradeUnlocked: function(upgradeId, currentLevel, world = 1) {
			const u = this.upgrades[upgradeId];
			if (!u) return false;
			if (u.unlockedAtWorld && world < u.unlockedAtWorld) return false;
			return u.unlockedAtLevel <= currentLevel;
		},
		isCategoryUnlocked: function(category, currentLevel) {
			return this.cardCategories[category] && this.cardCategories[category].unlockedAtLevel <= currentLevel;
		},
		isFeatureUnlocked: function(featureId, level, world = 1) {
			const feature = this.features && this.features[featureId];
			if (!feature) return false;
			if (feature.unlockedAtWorld && world < feature.unlockedAtWorld) return false;
			if (feature.unlockedAtLevel && level < feature.unlockedAtLevel) return false;
			return true;
		}
	};

	// Helper functie om upgrade status te checken
	function hasUpgrade(upgradeId) {
		// Back-compat: old saves used 'compactCards'. It now maps to miniPack34.
		if (upgradeId === 'miniPack34') return !!(UPGRADES.miniPack34?.purchased || UPGRADES.compactCards?.purchased);
		if (upgradeId === 'compactCards') return !!(UPGRADES.compactCards?.purchased || UPGRADES.miniPack34?.purchased);
		return UPGRADES[upgradeId]?.purchased || false;
	}

	function isUpgradeAvailable(upgradeId, levelOverride = null, worldOverride = null) {
		const lvl = Number(levelOverride ?? (typeof currentLevel !== 'undefined' ? currentLevel : 1)) || 1;
		let world = worldOverride;
		if (!Number.isFinite(Number(world))) {
			try {
				if (typeof currentWorld !== 'undefined' && Number.isFinite(Number(currentWorld))) world = currentWorld;
			} catch (e) {}
		}
		if (!Number.isFinite(Number(world))) {
			try {
				world = Number((typeof getWorldAndSubLevel === 'function' ? getWorldAndSubLevel(lvl)?.world : 1) || 1);
			} catch (e) { world = 1; }
		}
		if (!UNLOCK_PROGRESSION || typeof UNLOCK_PROGRESSION.isUpgradeUnlocked !== 'function') return false;
		return !!UNLOCK_PROGRESSION.isUpgradeUnlocked(upgradeId, lvl, Number(world) || 1);
	}

	function isWorld2Upgrade(upgradeId) {
		const meta = UNLOCK_PROGRESSION?.upgrades?.[upgradeId];
		if (!meta) return false;
		if (meta.unlockedAtWorld) return Number(meta.unlockedAtWorld) >= 2;
		const lvl = Number(meta.unlockedAtLevel) || 1;
		const info = (typeof getWorldAndSubLevel === 'function') ? getWorldAndSubLevel(lvl) : { world: 1 };
		return Number(info?.world || 1) >= 2;
	}

	function getEffectiveUpgradeCost(upgradeId) {
		const base = Number(UPGRADES?.[upgradeId]?.cost) || 0;
		if (Number(currentWorld || 1) >= 2 && isWorld2Upgrade(upgradeId)) return base * 2;
		return base;
	}

	// Unlock Modal Functies
	let pendingUnlockCallback = null;
	
	function showUnlockModal(levelUnlocks, callback) {
		const unlockModalLayer = document.getElementById('unlock-modal-layer');
		const unlockIcon = document.getElementById('unlock-icon');
		const unlockTitle = document.getElementById('unlock-title');
		const unlockItems = document.getElementById('unlock-items');
		
		if (!unlockModalLayer || !unlockItems) return;
		
		// Sla de callback op
		pendingUnlockCallback = callback;
		
		// Bepaal de icon en titel op basis van wat er is unlocked
		const hasChallenge = levelUnlocks.upgrades.some(u => u.announcement === 'nieuwe uitdaging');
		
		if (hasChallenge) {
			unlockIcon.textContent = 'âš ï¸';
			unlockTitle.textContent = 'Pas Op!';
		} else {
			unlockIcon.textContent = 'ðŸŽ‰';
			unlockTitle.textContent = 'Nieuwe Content Ontgrendeld!';
		}
		
		// Bouw unlock items
		unlockItems.innerHTML = '';
		
		// Voeg card categories toe
		levelUnlocks.cardCategories.forEach(cat => {
			const item = document.createElement('div');
			item.className = 'unlock-item';
			item.innerHTML = `
				<div class="unlock-item-icon">${cat.icon}</div>
				<div class="unlock-item-content">
					<div class="unlock-item-name">${cat.name}</div>
					<p class="unlock-item-description">${cat.description}</p>
				</div>
			`;
			unlockItems.appendChild(item);
		});
		
		// Voeg features toe (zoals Mega Bonus)
		if (levelUnlocks.features) {
			levelUnlocks.features.forEach(feature => {
				const item = document.createElement('div');
				item.className = 'unlock-item unlock-item--feature';
				item.innerHTML = `
					<div class="unlock-item-icon">${feature.icon}</div>
					<div class="unlock-item-content">
						<div class="unlock-item-name">${feature.name}</div>
						<p class="unlock-item-description">${feature.description}</p>
					</div>
				`;
				unlockItems.appendChild(item);
			});
		}
		
		// Voeg upgrades toe
		levelUnlocks.upgrades.forEach(upgrade => {
			const item = document.createElement('div');
			const isChallenge = upgrade.announcement === 'nieuwe uitdaging';
			item.className = isChallenge ? 'unlock-item unlock-item--challenge' : 'unlock-item';
			item.innerHTML = `
				<div class="unlock-item-icon">${upgrade.upgradeData.icon}</div>
				<div class="unlock-item-content">
					<div class="unlock-item-name">${upgrade.upgradeData.name}</div>
					<p class="unlock-item-description">${upgrade.upgradeData.description}</p>
				</div>
			`;
			unlockItems.appendChild(item);
		});
		
		unlockModalLayer.classList.add('show');
	}

	function hideUnlockModal() {
		const unlockModalLayer = document.getElementById('unlock-modal-layer');
		if (unlockModalLayer) {
			unlockModalLayer.classList.remove('show');
		}
		// Roep de callback aan als die er is
		if (typeof pendingUnlockCallback === 'function') {
			const cb = pendingUnlockCallback;
			pendingUnlockCallback = null;
			cb();
		}
	}

	// Portal systeem - plaats 2 portals per level in niet-rode zones
	let portalsActive = false;
	let portalCells = [];

	function activatePortals() {
		portalsActive = true;
		placePortalsForLevel();
	}

	function placePortalsForLevel() {
		// Verwijder oude portals
		clearPortals();

		const candidateZoneIds = ['yellow-grid', 'purple-grid', 'blue-grid', 'green-grid'];
		const availableZones = candidateZoneIds
			.map(id => ({ id, el: document.getElementById(id) }))
			.filter(z => z.el);
		if (!availableZones.length) return;

		const zonesWithCells = availableZones
			.map(({ id, el }) => ({
				id,
				el,
				cells: Array.from(el.querySelectorAll('.cell:not(.void-cell):not(.active)'))
			}))
			.filter(z => z.cells.length > 0);

		if (!zonesWithCells.length) return;

		const chosen = [];

		// Eerst 1 per zone (als het kan) om spreiding te krijgen
		const shuffledZones = zonesWithCells.sort(() => Math.random() - 0.5);
		for (const z of shuffledZones) {
			if (chosen.length >= 2) break;
			const picked = z.cells[Math.floor(Math.random() * z.cells.length)];
			if (picked) chosen.push({ cell: picked, id: z.id });
		}

		// Als we nog geen 2 portals hebben, vul aan uit overgebleven cellen
		if (chosen.length < 2) {
			const allCandidates = zonesWithCells.flatMap(z => z.cells.map(cell => ({ cell, id: z.id })));
			const remaining = allCandidates.filter(c => !chosen.some(ch => ch.cell === c.cell));
			const shuffledRemaining = remaining.sort(() => Math.random() - 0.5);
			for (const item of shuffledRemaining) {
				if (chosen.length >= 2) break;
				chosen.push(item);
			}
		}

		chosen.forEach(({ cell, id }) => {
			setupPortalCell(cell, id);
			portalCells.push(cell);
		});

	}
	
	function clearPortals() {
		portalCells.forEach(cell => {
			if (!cell) return;
			cell.classList.remove('portal-cell');
			cell.classList.remove('portal-anchor');
			cell.classList.remove('bold-cell');
			const oldSymbol = cell.querySelector('.portal-symbol');
			if (oldSymbol) oldSymbol.remove();
		});
		portalCells = [];
	}
	
	function setupPortalCell(cell, zoneId) {
		cell.classList.add('portal-cell');
		cell.classList.add('portal-anchor');
		cell.classList.add('bold-cell'); // Maak het een bold-cell zodat je vanaf hier kunt plaatsen!
		
		// Voeg portal symbool toe
		const portalSymbol = document.createElement('div');
		portalSymbol.classList.add('portal-symbol');
		portalSymbol.textContent = 'ðŸŒ';
		cell.appendChild(portalSymbol);
		
	}

	// Mega Bonus systeem - random spawning vanaf level 4
	let megaBonusActive = false;
	let megaBonusCell = null;
	
	// Unified Shop systeem - no longer cell-based, always accessible from level 5
	// (Removed old cell-based shop placement logic)

	// Removed placeMegaBonus - merged into unified shop system

	function openBonusShopModal(specificColor = null) {
		// Toon de bonus sectie als modal
		showObjectiveToast('â™¦ Mega Bonus Shop geopend!');
		// We hergebruiken de bestaande shop modal maar tonen alleen bonussen
		const shopModalLayer = document.getElementById('shop-modal-layer');
		const shopModalTitle = document.getElementById('shop-modal-title');
		const shopModalMessage = document.getElementById('shop-modal-message');
		const shopCardOptions = document.getElementById('shop-card-options');
		const upgradesSection = document.querySelector('.shop-upgrades-section');
		const bonusSection = document.querySelector('.shop-bonus-section');
		const shopBonusContainer = document.getElementById('shop-bonus-container');
		
		if (!shopModalLayer || !shopBonusContainer) return;
		
		// Verberg kaarten en upgrades volledig in bonus shop
		if (shopCardOptions) shopCardOptions.closest('.shop-cards-section').style.display = 'none';
		if (upgradesSection) upgradesSection.style.display = 'none';
		
		// Toon alleen bonussen - zet parent grid om naar single column
		const shopContentGrid = document.querySelector('.shop-content-grid');
		if (shopContentGrid) {
			shopContentGrid.style.gridTemplateColumns = '1fr';
		}
		if (bonusSection) {
			bonusSection.style.display = '';
			const shopLowerGrid = bonusSection.closest('.shop-lower-grid');
			if (shopLowerGrid) shopLowerGrid.style.display = 'none';
			const parent = bonusSection.parentElement;
			if (parent && parent.classList.contains('shop-lower-grid')) {
				shopContentGrid.appendChild(bonusSection);
			}
		}
		
		// Update bonus UI om bonussen te tonen
		updateShopBonusUI();
		updateShopCoinDisplay();
		if (shopModalTitle) shopModalTitle.innerHTML = '<span class="diamond-glyph">â™¦</span> Mega Bonus Shop';
		if (shopModalMessage) {
			const coins = getSpendableCoinCount();
			shopModalMessage.textContent = coins >= 5
				? `Koop een bonus upgrade voor 5 munten!`
				: 'Je hebt niet genoeg munten (5 ðŸª™ nodig).';
		}
		
		// Filter bonus container om alleen de specifieke kleur te tonen als opgegeven
		if (specificColor) {
			shopBonusContainer.innerHTML = '';
			const meta = getBonusMeta(specificColor);
			if (!meta) return;
			
			const coins = getSpendableCoinCount();
			const bonusCard = document.createElement('div');
			bonusCard.classList.add('shop-bonus-card');
			
			const bonusHeader = document.createElement('div');
			bonusHeader.classList.add('shop-bonus-header');
			bonusHeader.innerHTML = `<span class="bonus-icon" style="background-color: ${meta.bgColor}">${meta.icon}</span><span class="bonus-name">${meta.name}</span>`;
			
			const bonusDesc = document.createElement('p');
			bonusDesc.classList.add('shop-bonus-desc');
			bonusDesc.textContent = `Krijg 1 bonus ${meta.name.toLowerCase()} blok.`;
			
			const bonusActions = document.createElement('div');
			bonusActions.classList.add('shop-bonus-actions');
			
			const buyBtn = document.createElement('button');
			const megaBonusCost = 5;
			buyBtn.innerHTML = `Kopen (${megaBonusCost} ${coinIcon()})`;
			buyBtn.disabled = coins < megaBonusCost;
			buyBtn.title = coins < megaBonusCost ? 'Onvoldoende munten' : `Koop ${meta.name} bonus`;
			buyBtn.addEventListener('click', () => {
				if (spendCoins(megaBonusCost)) {
					grantBonusCharge(specificColor);
					shopModalMessage.textContent = `${meta.icon} ${meta.name} bonus gekocht!`;
					updateShopCoinDisplay();
					buyBtn.disabled = true;
					setTimeout(() => {
						shopModalLayer.classList.remove('show');
						// Herstel visibility
						if (shopCardOptions) shopCardOptions.closest('.shop-cards-section').style.display = '';
						if (shopModalTitle) shopModalTitle.textContent = 'Kaarten & Upgrades';
					}, 1000);
				}
			});
			
			bonusActions.appendChild(buyBtn);
			bonusCard.append(bonusHeader, bonusDesc, bonusActions);
			shopBonusContainer.appendChild(bonusCard);
		} else {
			updateShopBonusUI();
		}
		
		updateShopCoinDisplay();
		shopModalLayer.classList.add('show');
		
		// Herstel normale shop bij sluiten
		const shopSkipBtn = document.getElementById('shop-modal-skip');
		if (shopSkipBtn) {
			const originalText = shopSkipBtn.textContent;
			shopSkipBtn.textContent = 'Sluiten';
			const handleClose = () => {
				shopModalLayer.classList.remove('show');
				shopSkipBtn.textContent = originalText;
				// Herstel visibility
				if (shopCardOptions) shopCardOptions.closest('.shop-cards-section').style.display = '';
				if (shopModalTitle) shopModalTitle.textContent = 'Kaarten & Upgrades';
				shopSkipBtn.removeEventListener('click', handleClose);
			};
			shopSkipBtn.addEventListener('click', handleClose, { once: true });
		}
	}

	// Objective templates - each level has 5 random candidates
	const OBJECTIVE_TEMPLATES = {
		0: [ // Intro level: focus op paars
			{
				id: 'intro-purple-8',
				description: 'Haal 8 punten in paars.',
				short: 'Intro',
				check: scores => scores.purple >= 8,
				progress: scores => `${Math.min(scores.purple || 0, 8)}/8`
			}
		],
		1: [ // Level 1: Simple totals and single colors
			{
				id: 'level-1-total-10',
				description: 'Haal 12 punten totaal.',
				short: 'Level 1',
				check: scores => scores.total >= 12
			},
			{
				id: 'level-1-blue-8',
				description: 'Scoor 8 punten in blauw.',
				short: 'Level 1',
				check: scores => scores.blue >= 8
			},
			{
				id: 'level-1-yellow-6',
				description: 'Voltooi 1 kolom in geel.',
				short: 'Level 1',
				check: () => checkYellowFullRows(1)
			},
			{
				id: 'level-1-green-8',
				description: 'Scoor 8 punten in groen.',
				short: 'Level 1',
				check: scores => scores.green >= 8
			},
			{
				id: 'level-1-purple-6',
				description: 'Scoor 8 punten in paars.',
				short: 'Level 1',
				check: scores => scores.purple >= 8
			}
		],
		2: [ // Level 2: Higher totals and two-color combinations
			{
				id: 'level-2-total-20',
				description: 'Haal 20 punten totaal.',
				short: 'Level 2',
				check: scores => scores.total >= 20
			},
			{
				id: 'level-2-blue-yellow',
				description: 'Scoor 12 punten in geel en 6 in blauw.',
				short: 'Level 2',
				check: scores => scores.blue >= 6 && scores.yellow >= 12
			},
			{
				id: 'level-2-green-purple',
				description: 'Scoor 8 punten in groen en paars.',
				short: 'Level 2',
				check: scores => scores.green >= 8 && scores.purple >= 8
			},
			{
				id: 'level-2-bonus-collect-6',
				description: 'Verzamel 6 bonussen.',
				short: 'Level 2',
				check: scores => (scores?.bonusesCollected || 0) >= 6,
				progress: scores => {
					const collected = Math.max(0, Math.min(6, (scores?.bonusesCollected || 0)));
					return `${collected}/6`;
				}
			}
		],
		3: [ // Level 3: Three colors and specific patterns
			{
				id: 'level-3-tricolor',
				description: 'Level 3: Scoor 8 punten in paars, blauw Ã©n geel.',
				short: 'Level 3',
				check: scores => scores.purple >= 8 && scores.blue >= 8 && scores.yellow >= 8
			},
			{
				id: 'level-3-total-30',
				description: 'Level 3: Haal 30 punten totaal.',
				short: 'Level 3',
				check: scores => scores.total >= 30
			},
			{
				id: 'level-3-yellow-rows-2',
				description: 'Level 3: Voltooi 2 gele kolommen.',
				short: 'Level 3',
				check: () => checkYellowFullRows(2),
				progress: () => {
					const yellowConfig = window.yellowGridConfig || {};
					const set = yellowConfig.scoreMode === 'diagonal'
						? (window.scoredYellowSegments || window.scoredYellowDiagonals)
						: window.scoredYellowColumns;
					const current = (set instanceof Set) ? set.size : 0;
					const capped = Math.max(0, Math.min(2, current));
					return `${capped}/2`;
				}
			},
			{
				id: 'level-3-green',
				description: 'Level 3: Scoor 16 punten in groen.',
				short: 'Level 3',
				check: scores => scores.green >= 16
			},
			{
				id: 'level-3-blue-14',
				description: 'Level 3: Scoor 20 punten in blauw',
				short: 'Level 3',
				check: scores => scores.blue >= 20
			}
		],
		4: [ // Level 4: Higher targets and complexity
			{
				id: 'level-4-total-40',
				description: 'Level 4: Haal 35 punten totaal.',
				short: 'Level 4',
				check: scores => scores.total >= 35
			},
			{
				id: 'level-4-all-colors-6',
				description: 'Level 4: Scoor minstens 6 punten in de kleuren geel, groen, paars en blauw.',
				short: 'Level 4',
				check: scores => scores.yellow >= 6 && scores.green >= 6 && scores.purple >= 6 && scores.blue >= 6,
				progress: scores => {
					const parts = [
						(scores.yellow >= 6 ? 'âœ”geel' : ''),
						(scores.green >= 6 ? 'âœ”groen' : ''),
						(scores.purple >= 6 ? 'âœ”paars' : ''),
						(scores.blue >= 6 ? 'âœ”blauw' : '')
					];
					return parts.join(' ');
				}
			},
			{
				id: 'level-4-bonus-12',
			description: 'Level 4: Verzamel 12 bonussen.',
				short: 'Level 4',
				check: scores => (scores?.bonusesCollected || 0) >= 12,
				progress: scores => {
					const collected = Math.max(0, Math.min(12, (scores?.bonusesCollected || 0)));
					return `${collected}/12`;
				}
			},
			{
				id: 'level-4-purple-yellow',
				description: 'Level 4: Scoor 8 in paars en 12 in geel.',
				short: 'Level 4',
				check: scores => scores.purple >= 8 && scores.yellow >= 12
			}
		],
		5: [ // Level 5: Pattern-based challenges
			{
				id: 'level-5-total-50',
				description: 'Level 5: Haal 40 punten totaal.',
				short: 'Level 5',
				check: scores => scores.total >= 40
			},
			{
				id: 'level-5-yellow-rows-3',
				description: 'Level 5: Scoor 16 punten in geel.',
				short: 'Level 5',
				check: scores => scores.yellow >= 16
			},
			{
				id: 'level-5-blue-18',
				description: 'Level 5: Scoor 30 punten in blauw.',
				short: 'Level 5',
				check: scores => scores.blue >= 30
			},
			{
				id: 'level-5-red-20',
				description: 'Level 5: Scoor 20 punten in rood.',
				short: 'Level 5',
				check: scores => scores.red >= 20
			}
		],
		6: [ // Level 6: Complex combinations
			{
				id: 'level-6-total-60',
				description: 'Level 6: Haal 50 punten totaal.',
				short: 'Level 6',
				check: scores => scores.total >= 50
			},
			{
				id: 'level-6-green-20',
				description: 'Level 6: Scoor 24 punten in groen en 12 in geel.',
				short: 'Level 6',
				check: scores => scores.green >= 24 && scores.yellow >= 12
			},
			{
				id: 'level-6-tricolor-advanced',
				description: 'Level 6: Scoor 12 punten in paars, blauw en geel.',
				short: 'Level 6',
				check: scores => scores.purple >= 12 && scores.blue >= 12 && scores.yellow >= 12
			},
			{
				id: 'level-6-bonus-18',
				description: 'Level 6: Verzamel 18 bonussen.',
				short: 'Level 6',
				check: scores => (scores?.bonusesCollected || 0) >= 18,
				progress: scores => {
					const collected = Math.max(0, Math.min(18, (scores?.bonusesCollected || 0)));
					return `${collected}/18`;
				}
			},
			{
				id: 'level-6-purple-18',
				description: 'Level 6: Scoor 18 punten in paars.',
				short: 'Level 6',
				check: scores => scores.purple >= 18
			},
		],
		7: [ // Level 7: Advanced patterns
			{
				id: 'level-7-total-70',
				description: 'Level 7: Haal 60 punten totaal.',
				short: 'Level 7',
				check: scores => scores.total >= 60
			},
			{
				id: 'level-7-yellow-rows-5',
				description: 'Level 7: Voltooi 3 gele kolommen.',
				short: 'Level 7',
				check: () => checkYellowFullRows(3),
				progress: () => {
					const yellowConfig = window.yellowGridConfig || {};
					const set = yellowConfig.scoreMode === 'diagonal'
						? (window.scoredYellowSegments || window.scoredYellowDiagonals)
						: window.scoredYellowColumns;
					const current = (set instanceof Set) ? set.size : 0;
					const capped = Math.max(0, Math.min(3, current));
					return `${capped}/3`;
				}
			},
			{
				id: 'level-7-all-colors-10',
				description: 'Level 7: Scoor minstens 10 punten in elke kleur.',
				short: 'Level 7',
				check: scores => scores.yellow >= 10 && scores.red >= 10 && scores.green >= 10 && scores.purple >= 10 && scores.blue >= 10,
				progress: scores => {
					const parts = [
						(scores.yellow >= 10 ? 'âœ”geel' : ''),
						(scores.red >= 10 ? 'âœ”rood' : ''),
						(scores.green >= 10 ? 'âœ”groen' : ''),
						(scores.purple >= 10 ? 'âœ”paars' : ''),
						(scores.blue >= 10 ? 'âœ”blauw' : '')
					];
					return parts.join(' ');
				}
			},
			{
				id: 'level-7-blue-purple',
				description: 'Level 7: Scoor 50 punten in blauw',
				short: 'Level 7',
				check: scores => scores.blue >= 50
			},
			{
				id: 'level-7-red-35',
				description: 'Level 7: Scoor 35 punten in rood.',
				short: 'Level 7',
				check: scores => scores.red >= 35
			}
		],
		8: [ // Level 8: Very challenging
			{
				id: 'level-8-total-85',
				description: 'Level 8: Haal 85 punten totaal.',
				short: 'Level 8',
				check: scores => scores.total >= 85
			},
			{
				id: 'level-8-yellow-rows-6',
				description: 'Level 8: Voltooi 3 gele kolommen.',
				short: 'Level 8',
				check: () => checkYellowFullRows(3),
				progress: () => {
					const yellowConfig = window.yellowGridConfig || {};
					const set = yellowConfig.scoreMode === 'diagonal'
						? (window.scoredYellowSegments || window.scoredYellowDiagonals)
						: window.scoredYellowColumns;
					const current = (set instanceof Set) ? set.size : 0;
					const capped = Math.max(0, Math.min(3, current));
					return `${capped}/3`;
				}
			},
			{
				id: 'level-8-green-purple-ring',
				description: 'Level 8: Scoor 24 punten in paars.',
				short: 'Level 8',
				check: scores => scores.purple >= 24
			},
			{
				id: 'level-8-bonus-24',
				description: 'Level 8: Verzamel 24 bonussen.',
				short: 'Level 8',
				check: scores => (scores?.bonusesCollected || 0) >= 24,
				progress: scores => {
					const collected = Math.max(0, Math.min(24, (scores?.bonusesCollected || 0)));
					return `${collected}/24`;
				}
			},
			{
				id: 'level-8-quad-color',
				description: 'Level 8: Scoor 14 punten in geel, groen, paars Ã©n blauw.',
				short: 'Level 8',
				check: scores => scores.yellow >= 14 && scores.green >= 14 && scores.purple >= 14 && scores.blue >= 14,
				progress: scores => {
					const parts = [
						(scores.yellow >= 14 ? 'âœ”geel' : ''),
						(scores.green >= 14 ? 'âœ”groen' : ''),
						(scores.purple >= 14 ? 'âœ”paars' : ''),
						(scores.blue >= 14 ? 'âœ”blauw' : '')
					];
					return parts.join(' ');
				}
			}
		],
		9: [ // Level 9: Expert level
			{
				id: 'level-9-total-100',
				description: 'Level 9: Haal 100 punten totaal.',
				short: 'Level 9',
				check: scores => scores.total >= 100
			},
			{
				id: 'level-9-yellow-rows-7',
				description: 'Level 9: Voltooi 4 gele kolommen.',
				short: 'Level 9',
				check: () => checkYellowFullRows(4),
				progress: () => {
					const yellowConfig = window.yellowGridConfig || {};
					const set = yellowConfig.scoreMode === 'diagonal'
						? (window.scoredYellowSegments || window.scoredYellowDiagonals)
						: window.scoredYellowColumns;
					const current = (set instanceof Set) ? set.size : 0;
					const capped = Math.max(0, Math.min(4, current));
					return `${capped}/4`;
				}
			},
			{
				id: 'level-9-all-colors-15',
				description: 'Level 9: Scoor minstens 12 punten in elke kleur.',
				short: 'Level 9',
				check: scores => scores.yellow >= 12 && scores.red >= 12 && scores.green >= 12 && scores.purple >= 12 && scores.blue >= 12,
				progress: scores => {
					const parts = [
						(scores.yellow >= 12 ? 'âœ”geel' : ''),
						(scores.red >= 12 ? 'âœ”rood' : ''),
						(scores.green >= 12 ? 'âœ”groen' : ''),
						(scores.purple >= 12 ? 'âœ”paars' : ''),
						(scores.blue >= 12 ? 'âœ”blauw' : '')
					];
					return parts.join(' ');
				}
			},
			{
				id: 'level-9-blue-25',
				description: 'Level 9: Scoor 75 punten in blauw.',
				short: 'Level 9',
				check: scores => scores.blue >= 75
			},
			{
				id: 'level-9-combo-master',
				description: 'Level 9: Scoor 20 punten in rood, 2 gele kolommen en 18 bonussen.',
				short: 'Level 9',
				check: scores => scores.red >= 20 && checkYellowFullRows(2) && ((scores?.bonusesCollected || 0) >= 18),
				progress: scores => {
					const yellowConfig = window.yellowGridConfig || {};
					const set = yellowConfig.scoreMode === 'diagonal'
						? (window.scoredYellowSegments || window.scoredYellowDiagonals)
						: window.scoredYellowColumns;
					const rowsDone = (set instanceof Set) ? set.size : 0;
					const rowsCapped = Math.max(0, Math.min(2, rowsDone));
					const bonusesDone = Math.max(0, (scores?.bonusesCollected || 0));
					const bonusesCapped = Math.max(0, Math.min(18, bonusesDone));
					return `geel: ${rowsCapped}/2, bonussen: ${bonusesCapped}/18`;
				}
			}
		],
		10: [ // Level 10: Ultimate challenge
			{
				id: 'level-10-total-120',
				description: 'Level 10: Haal 120 punten totaal.',
				short: 'Level 10',
				check: scores => scores.total >= 120
			},
			{
				id: 'level-10-yellow-rows-8',
				description: 'Level 10: Scoor 70 punten in geel.',
				short: 'Level 10',
				check: scores => scores.yellow >= 70
			},
			{
				id: 'level-10-perfect-balance',
				description: 'Level 10: Scoor minstens 20 punten in elke kleur.',
				short: 'Level 10',
				check: scores => scores.yellow >= 20 && scores.red >= 20 && scores.green >= 20 && scores.purple >= 20 && scores.blue >= 20
			},
			{
				id: 'level-10-purple-ring',
				description: 'Level 10: Vul de volledige buitenrand van het paarse veld.',
				short: 'Level 10',
				check: () => checkPurpleOuterRingComplete()
			}
		],
		
		// WORLD 2 OBJECTIVES (Levels 11-20) - Complexere uitdagingen!
		11: [
			{
				id: 'level-11-world2-intro',
				description: 'Level 11: Welkom in Wereld 2! Scoor 40 punten totaal.',
				short: 'Level 11',
				check: scores => ((scores.yellow + scores.red + scores.green + scores.purple + scores.blue) + (scores?.bonus || 0)) >= 40
			},
			{
				id: 'level-11-shape-master',
				description: 'Level 11: Voltooi 1 diagonale lijn van minstens 5 cellen in geel.',
				short: 'Level 11',
				check: () => {
					// Check of er een diagonaal van 5+ cellen volledig actief is
					const yellowZone = document.getElementById('yellow-zone');
					if (!yellowZone) return false;
					const grid = yellowZone.querySelector('.grid');
					if (!grid) return false;
					const cells = Array.from(grid.querySelectorAll('.cell:not(.void-cell)'));
					// Group cells by diagonal index
					const diagGroups = {};
					cells.forEach(cell => {
						const diag = cell.dataset.diag;
						if (diag !== undefined) {
							if (!diagGroups[diag]) diagGroups[diag] = [];
							diagGroups[diag].push(cell);
						}
					});
					// Check if any diagonal has 5+ cells all active
					for (const diag of Object.keys(diagGroups)) {
						const diagCells = diagGroups[diag];
						if (diagCells.length >= 5) {
							const allActive = diagCells.every(c => c.classList.contains('active'));
							if (allActive) return true;
						}
					}
					return false;
				}
			},
			{
				id: 'level-11-long-path',
				description: 'Level 11: Scoor 50 punten in blauw.',
				short: 'Level 11',
				check: scores => scores.blue >= 50
			},
			{
				id: 'level-11-purple-expansion',
				description: 'Level 11: Scoor 40 punten in paars.',
				short: 'Level 11',
				check: scores => scores.purple >= 40
			},
		],
		12: [
			{
				id: 'level-12-deep-roots',
				description: 'Level 12: Scoor 50 punten in groen.',
				short: 'Level 12',
				check: scores => scores.green >= 50
			},
			{
				id: 'level-12-red-connection',
				description: 'Level 12: Scoor 45 punten in rood.',
				short: 'Level 12',
				check: scores => scores.red >= 45
			},
			{
				id: 'level-12-yellow-precision',
				description: 'Level 12: Voltooi 2 diagonale lijnen van minimaal 5 cellen in geel.',
				short: 'Level 12',
				check: () => {
					const yellowZone = document.getElementById('yellow-zone');
					if (!yellowZone) return false;
					const grid = yellowZone.querySelector('.grid');
					if (!grid) return false;
					const yellowConfig = window.yellowGridConfig || {};
					const minLen = Math.max(1, Number(yellowConfig.minDiagonalLength) || 4);
					const requiredLen = Math.max(minLen, 5);
					const allowToCenter = yellowConfig.allowDiagonalToCenter === true;
					const cells = Array.from(grid.querySelectorAll('.cell:not(.void-cell)'));
					if (!cells.length) return false;
					const cellByCoord = new Map();
					cells.forEach(c => {
						const x = Number(c.dataset.x);
						const y = Number(c.dataset.y);
						if (Number.isFinite(x) && Number.isFinite(y)) cellByCoord.set(`${x},${y}`, c);
					});
					const tryGet = (x, y) => cellByCoord.get(`${x},${y}`) || null;
					const collectSegments = (dx, dy) => {
						const segments = [];
						for (const startCell of cellByCoord.values()) {
							const x0 = Number(startCell.dataset.x);
							const y0 = Number(startCell.dataset.y);
							if (!Number.isFinite(x0) || !Number.isFinite(y0)) continue;
							if (tryGet(x0 - dx, y0 - dy)) continue; // only start at true segment start
							const segCells = [];
							let x = x0;
							let y = y0;
							while (true) {
								const here = tryGet(x, y);
								if (!here) break;
								segCells.push(here);
								x += dx;
								y += dy;
							}
							if (segCells.length) segments.push(segCells);
						}
						return segments;
					};
					const segments = [...collectSegments(1, 1), ...collectSegments(1, -1)];
					let completed = 0;
					segments.forEach(seg => {
						if (seg.length < requiredLen) return;
						const fullActive = seg.every(c => c.classList.contains('active'));
						if (fullActive) {
							completed += 1;
							return;
						}
						if (!allowToCenter) return;
						const mid = Math.floor(seg.length / 2);
						const boldIdxs = [];
						for (let i = 0; i < seg.length; i++) {
							if (seg[i].classList.contains('bold-cell')) boldIdxs.push(i);
						}
						let pivot = mid;
						if (boldIdxs.length) {
							boldIdxs.sort((a, b) => Math.abs(a - mid) - Math.abs(b - mid));
							pivot = boldIdxs[0];
						}
						const left = seg.slice(0, pivot + 1);
						const right = seg.slice(pivot);
						if (left.length >= requiredLen && left.every(c => c.classList.contains('active'))) completed += 1;
						if (right.length >= requiredLen && right.every(c => c.classList.contains('active'))) completed += 1;
					});
					return completed >= 2;
				}
			},
			{
				id: 'level-12-bonus-rush',
				description: 'Level 12: Verzamel 30 bonussen.',
				short: 'Level 12',
				check: scores => (scores?.bonusesCollected || 0) >= 30,
				progress: scores => {
					const collected = Math.max(0, Math.min(30, (scores?.bonusesCollected || 0)));
					return `${collected}/30`;
				}
			},
			{
				id: 'level-12-rainbow',
				description: 'Level 12: Scoor 23 punten in elke kleur.',
				short: 'Level 12',
				check: scores => scores.yellow >= 23 && scores.red >= 23 && scores.green >= 23 && scores.purple >= 23 && scores.blue >= 23
			}
		],
		13: [
			{
				id: 'level-13-mega-blue',
				description: 'Level 13: Scoor 70 punten in blauw.',
				short: 'Level 13',
				check: scores => scores.blue >= 70
			},
			{
				id: 'level-13-purple-perfect',
				description: 'Level 13: Scoor 70 punten in paars.',
				short: 'Level 13',
				check: scores => scores.purple >= 70
			},
			{
				id: 'level-13-green-giant',
				description: 'Level 13: Scoor 70 punten in groen.',
				short: 'Level 13',
				check: scores => scores.green >= 70
			},
			{
				id: 'level-13-red-master',
				description: 'Level 13: Scoor 58 punten in rood.',
				short: 'Level 13',
				check: scores => scores.red >= 58
			},
			{
				id: 'level-13-yellow-artisan',
				description: 'Level 13: Maak een kruis tussen de dikgedrukte cellen in geel.',
				short: 'Level 13',
				check: () => {
					const yellowZone = document.getElementById('yellow-zone');
					if (!yellowZone) return false;

					const boldCells = Array.from(yellowZone.querySelectorAll('.cell.bold-cell:not(.void-cell)'))
						.map(el => ({ el, x: Number(el.dataset.x), y: Number(el.dataset.y) }))
						.filter(({ x, y }) => Number.isFinite(x) && Number.isFinite(y));
					if (boldCells.length < 3) return false;

					const minX = Math.min(...boldCells.map(c => c.x));
					const maxX = Math.max(...boldCells.map(c => c.x));
					const minY = Math.min(...boldCells.map(c => c.y));
					const maxY = Math.max(...boldCells.map(c => c.y));
					const targetCenterX = Math.round((minX + maxX) / 2);
					const targetCenterY = Math.round((minY + maxY) / 2);

					const centerCell = boldCells.reduce((best, cur) => {
						if (cur.x === targetCenterX && cur.y === targetCenterY) return cur;
						const dist = Math.abs(cur.x - targetCenterX) + Math.abs(cur.y - targetCenterY);
						if (!best) return { ...cur, dist };
						if (best.x === targetCenterX && best.y === targetCenterY) return best;
						return dist < (best.dist || Infinity) ? { ...cur, dist } : best;
					}, null);
					if (!centerCell || !centerCell.el.classList.contains('active')) return false;

					const allCells = Array.from(yellowZone.querySelectorAll('.cell:not(.void-cell)'))
						.filter(el => Number.isFinite(Number(el.dataset.x)) && Number.isFinite(Number(el.dataset.y)));
					const diagKeyPrimary = centerCell.x - centerCell.y;
					const diagKeySecondary = centerCell.x + centerCell.y;

					const primaryDiag = allCells.filter(c => (Number(c.dataset.x) - Number(c.dataset.y)) === diagKeyPrimary);
					const secondaryDiag = allCells.filter(c => (Number(c.dataset.x) + Number(c.dataset.y)) === diagKeySecondary);

					const hasActiveLineThroughBold = (cells) => {
						const boldOnLine = cells.filter(c => c.classList.contains('bold-cell'));
						if (boldOnLine.length < 2) return false;
						if (!boldOnLine.some(c => c !== centerCell.el)) return false;
						const xs = boldOnLine.map(c => Number(c.dataset.x));
						const ys = boldOnLine.map(c => Number(c.dataset.y));
						const minLX = Math.min(...xs);
						const maxLX = Math.max(...xs);
						const minLY = Math.min(...ys);
						const maxLY = Math.max(...ys);
						return cells.every(cell => {
							const x = Number(cell.dataset.x);
							const y = Number(cell.dataset.y);
							if (x < minLX || x > maxLX || y < minLY || y > maxLY) return true;
							return cell.classList.contains('active');
						});
					};

					return hasActiveLineThroughBold(primaryDiag) && hasActiveLineThroughBold(secondaryDiag);
				}
			}
		],
		14: [
			{
				id: 'level-14-total-score',
				description: 'Level 14: Scoor 200 punten in totaal.',
				short: 'Level 14',
				check: scores => ((scores.yellow + scores.red + scores.green + scores.purple + scores.blue) + (scores?.bonus || 0)) >= 200
			},
			{
				id: 'level-14-balanced-power',
				description: 'Level 14: Scoor 32 punten in 4 verschillende kleuren.',
				short: 'Level 14',
				check: scores => {
					const colorScores = [scores.yellow, scores.red, scores.green, scores.purple, scores.blue];
					return colorScores.filter(s => s >= 32).length >= 4;
				}
			},
			{
				id: 'level-14-blue-marathon',
				description: 'Level 14: Scoor 90 punten in blauw.',
				short: 'Level 14',
				check: scores => scores.blue >= 90
			},
			{
				id: 'level-14-multi-color-focus',
				description: 'Level 14: Scoor 60 punten in groen en paars.',
				short: 'Level 14',
				check: scores => scores.green >= 60 && scores.purple >= 60
			}
		],
		15: [
			{
				id: 'level-15-green-legend',
				description: 'Level 15: Scoor 80 punten in groen.',
				short: 'Level 15',
				check: scores => scores.green >= 80
			},
			{
				id: 'level-15-red-network',
				description: 'Level 15: Scoor 70 punten in rood.',
				short: 'Level 15',
				check: scores => scores.red >= 70
			},
			{
				id: 'level-15-yellow-perfect',
				description: 'Level 15: Scoor 80 punten in geel.',
				short: 'Level 15',
				check: scores => scores.yellow >= 80
			},
			{
				id: 'level-15-ultimate-balance',
				description: 'Level 15: Scoor 25 punten in elke kleur.',
				short: 'Level 15',
				check: scores => scores.yellow >= 25 && scores.red >= 25 && scores.green >= 25 && scores.purple >= 25 && scores.blue >= 25
			}
		],
		16: [
			{
				id: 'level-16-total-domination',
				description: 'Level 16: Scoor 280 punten totaal.',
				short: 'Level 16',
				check: scores => ((scores.yellow + scores.red + scores.green + scores.purple + scores.blue) + (scores?.bonus || 0)) >= 280
			},
			{
				id: 'level-16-blue-epic',
				description: 'Level 16: Scoor 120 punten in blauw.',
				short: 'Level 16',
				check: scores => scores.blue >= 120
			},
			{
				id: 'level-16-purple-titan',
				description: 'Level 16: Scoor 110 punten in paars.',
				short: 'Level 16',
				check: scores => scores.purple >= 110
			},
			{
				id: 'level-16-green-depths',
				description: 'Level 16: Scoor 120 punten in groen.',
				short: 'Level 16',
				check: scores => scores.green >= 120
			},
			{
				id: 'level-16-bonus-legend',
				description: 'Level 16: Haal 40 bonussen.',
				short: 'Level 16',
				check: scores => (scores?.bonusesCollected || 0) >= 40,
				progress: scores => {
					const collected = Math.max(0, Math.min(40, (scores?.bonusesCollected || 0)));
					return `${collected}/40`;
				}
			}
		],
		17: [
			{
				id: 'level-17-red-empire',
				description: 'Level 17: Scoor 78 punten in rood.',
				short: 'Level 17',
				check: scores => scores.red >= 78
			},
			{
				id: 'level-17-four-pillars',
				description: 'Level 17: Scoor 48 punten in 4 verschillende kleuren.',
				short: 'Level 17',
				check: scores => {
					const colorScores = [scores.yellow, scores.red, scores.green, scores.purple, scores.blue];
					return colorScores.filter(s => s >= 48).length >= 4;
				}
			},
			{
				id: 'level-17-yellow-architect',
				description: 'Level 17: Scoor 140 punten in geel.',
				short: 'Level 17',
				check: scores => scores.yellow >= 140
			},
			{
				id: 'level-17-blue-odyssey',
				description: 'Level 17: Scoor 150 punten in blauw.',
				short: 'Level 17',
				check: scores => scores.blue >= 150
			},
			{
				id: 'level-17-complete-mastery',
				description: 'Level 17: Scoor 35 punten elke kleur.',
				short: 'Level 17',
				check: scores => scores.yellow >= 35 && scores.red >= 35 && scores.green >= 35 && scores.purple >= 35 && scores.blue >= 35
			}
		],
		18: [
			{
				id: 'level-18-mega-score',
				description: 'Level 18: Scoor 300 punten totaal.',
				short: 'Level 18',
				check: scores => ((scores.yellow + scores.red + scores.green + scores.purple + scores.blue) + (scores?.bonus || 0)) >= 300
			},
			{
				id: 'level-18-green-abyss',
				description: 'Level 18: Scoor 200 punten in groen.',
				short: 'Level 18',
				check: scores => scores.green >= 200
			},
			{
				id: 'level-18-purple-overlord',
				description: 'Level 18: Scoor 140 punten in paars.',
				short: 'Level 18',
				check: scores => scores.purple >= 140
			},
			{
				id: 'level-18-red-megagrid',
				description: 'Level 18: Voltooi minstens 3 van de 4 rode grids.',
				short: 'Level 18',
				check: () => {
					const redZones = ['red-grid1', 'red-grid2', 'red-grid3', 'red-grid4'];
					let complete = 0;
					for (const id of redZones) {
						const zone = document.getElementById(id);
						if (!zone) continue;
						const cells = zone.querySelectorAll('.cell:not(.void-cell)');
						const active = zone.querySelectorAll('.cell.active:not(.void-cell)');
						if (cells.length > 0 && cells.length === active.length) complete += 1;
					}
					return complete >= 3;
				}
			},
			{
				id: 'level-18-bonus-titan',
				description: 'Level 18: Haal 35 bonussen.',
				short: 'Level 18',
				check: scores => (scores?.bonusesCollected || 0) >= 35,
				progress: scores => {
					const collected = Math.max(0, Math.min(35, (scores?.bonusesCollected || 0)));
					return `${collected}/35`;
				}
			}
		],
		19: [
			{
				id: 'level-19-blue-legend',
				description: 'Level 19: Scoor 250 punten in blauw.',
				short: 'Level 19',
				check: scores => scores.blue >= 250
			},
			{
				id: 'level-19-all-pillars',
				description: 'Level 19: Scoor 50 punten in elke kleur.',
				short: 'Level 19',
				check: scores => scores.yellow >= 50 && scores.red >= 50 && scores.green >= 50 && scores.purple >= 50 && scores.blue >= 50
			},
			{
				id: 'level-19-red-completion',
				description: 'Level 19: Scoor 120 punten in rood.',
				short: 'Level 19',
				check: scores => scores.red >= 120
			},
			{
				id: 'level-19-perfect-world',
				description: 'Level 19: Voltooi Ã©Ã©n zone perfect (alle cellen actief).',
				short: 'Level 19',
				check: () => {
					const zoneIds = ['yellow-zone', 'purple-zone', 'blue-zone', 'green-zone'];
					return zoneIds.some(id => {
						const zone = document.getElementById(id);
						if (!zone) return false;
						const cells = zone.querySelectorAll('.cell:not(.void-cell)');
						const active = zone.querySelectorAll('.cell.active:not(.void-cell)');
						return cells.length > 0 && cells.length === active.length;
					});
				}
			}
		],
		20: [
			{
				id: 'level-20-ultimate',
				description: 'Level 20: Scoor 400 punten totaal.',
				short: 'Level 20',
				check: scores => ((scores.yellow + scores.red + scores.green + scores.purple + scores.blue) + (scores?.bonus || 0)) >= 400
			},
			{
				id: 'level-20-perfect-balance',
				description: 'Level 20: Scoor 58 punten in elke kleur.',
				short: 'Level 20',
				check: scores => scores.yellow >= 58 && scores.red >= 58 && scores.green >= 58 && scores.purple >= 58 && scores.blue >= 58,
				progress: scores => {
					const parts = [
						(scores.yellow >= 58 ? 'âœ”geel' : ''),
						(scores.red >= 58 ? 'âœ”rood' : ''),
						(scores.green >= 58 ? 'âœ”groen' : ''),
						(scores.purple >= 58 ? 'âœ”paars' : ''),
						(scores.blue >= 58 ? 'âœ”blauw' : '')
					];
					return parts.join(' ');
				}
			},
			{
				id: 'level-20-bonus-god',
				description: 'Level 20: Haal 40 bonussen.',
				short: 'Level 20',
				check: scores => (scores?.bonusesCollected || 0) >= 40,
				progress: scores => {
					const collected = Math.max(0, Math.min(40, (scores?.bonusesCollected || 0)));
					return `${collected}/40`;
				}
			},
			{
				id: 'level-20-complete-all',
				description: 'Level 20: Voltooi minstens 2 zones volledig (alle cellen actief).',
				short: 'Level 20',
				check: () => {
					const colorZones = ['yellow-zone', 'purple-zone', 'blue-zone', 'green-zone'];
					const redZones = ['red-grid1', 'red-grid2', 'red-grid3', 'red-grid4'];
					let complete = 0;
					const isComplete = (zone) => {
						if (!zone) return false;
						const cells = zone.querySelectorAll('.cell:not(.void-cell)');
						const active = zone.querySelectorAll('.cell.active:not(.void-cell)');
						return cells.length > 0 && cells.length === active.length;
					};
					for (const id of colorZones) {
						const zone = document.getElementById(id);
						if (isComplete(zone)) complete += 1;
					}
					const redComplete = redZones.every(id => isComplete(document.getElementById(id)));
					if (redComplete) complete += 1;
					return complete >= 2;
				}
			},
			{
				id: 'level-20-world2-master',
				description: 'Level 20: Meester van Wereld 2 - Scoor 100 punten in elke kleur.',
				short: 'Level 20',
				check: scores => {
					const colorScores = [scores.yellow, scores.red, scores.green, scores.purple, scores.blue];
					return colorScores.filter(s => s >= 100).length === 5;
				},
				progress: scores => {
					const parts = [
						(scores.yellow >= 100 ? 'âœ”geel' : ''),
						(scores.red >= 100 ? 'âœ”rood' : ''),
						(scores.green >= 100 ? 'âœ”groen' : ''),
						(scores.purple >= 100 ? 'âœ”paars' : ''),
						(scores.blue >= 100 ? 'âœ”blauw' : '')
					];
					return parts.join(' ');
				}
			}
		],
		// ========== WORLD 3: ULTIMATE CHALLENGE (Levels 21-30) ==========
		21: [
			{
				id: 'level-21-world3-intro',
				description: 'Level 21: Welkom in Wereld 3! Scoor 100 punten totaal.',
				short: 'Level 21',
				check: scores => ((scores.yellow + scores.red + scores.green + scores.purple + scores.blue) + (scores?.bonus || 0)) >= 100
			},
			{
				id: 'level-21-blue-marathon',
				description: 'Level 21: Scoor 75 punten in blauw.',
				short: 'Level 21',
				check: scores => scores.blue >= 75
			},
			{
				id: 'level-21-green-explorer',
				description: 'Level 21: Scoor 72 punten in groen.',
				short: 'Level 21',
				check: scores => scores.green >= 72
			},
			{
				id: 'level-21-balanced-champion',
				description: 'Level 21: Scoor 45 punten elke kleur.',
				short: 'Level 21',
				check: scores => scores.yellow >= 45 && scores.red >= 45 && scores.green >= 45 && scores.purple >= 45 && scores.blue >= 45,
				progress: scores => {
					const parts = [
						(scores.yellow >= 45 ? 'âœ”geel' : ''),
						(scores.red >= 45 ? 'âœ”rood' : ''),
						(scores.green >= 45 ? 'âœ”groen' : ''),
						(scores.purple >= 45 ? 'âœ”paars' : ''),
						(scores.blue >= 45 ? 'âœ”blauw' : '')
					];
					return parts.join(' ');
				}
			},
		],
		22: [
			{
				id: 'level-22-purple-domination',
				description: 'Level 22: Scoor 100 punten in paars.',
				short: 'Level 22',
				check: scores => scores.purple >= 100
			},
			{
				id: 'level-22-red-network',
				description: 'Level 22: Scoor 55 punten in rood.',
				short: 'Level 22',
				check: scores => scores.red >= 55
			},
			{
				id: 'level-22-yellow-diamond',
				description: 'Level 22: Scoor 75 punten in geel.',
				short: 'Level 22',
				check: scores => scores.yellow >= 75
			},
			{
				id: 'level-22-coin-master',
				description: 'Level 22: Verzamel 15+ munten in dit level.',
				short: 'Level 22',
				check: scores => getCollectedCoinCount(scores) >= 15,
				progress: scores => {
					const collected = Math.max(0, Math.min(15, getCollectedCoinCount(scores)));
					return `${collected}/15`;
				}
			},
			{
				id: 'level-22-dual-focus',
				description: 'Level 22: Scoor 100 punten in groen en blauw.',
				short: 'Level 22',
				check: scores => scores.green >= 100 && scores.blue >= 100
			}
		],
		23: [
			{
				id: 'level-23-total-power',
				description: 'Level 23: Scoor 300 punten totaal.',
				short: 'Level 23',
				check: scores => ((scores.yellow + scores.red + scores.green + scores.purple + scores.blue) + (scores?.bonus || 0)) >= 300
			},
			{
				id: 'level-23-blue-split-master',
				description: 'Level 23: Scoor 250 punten in blauw.',
				short: 'Level 23',
				check: scores => scores.blue >= 250
			},
			{
				id: 'level-23-green-depth',
				description: 'Level 23: Scoor 200 punten in groen.',
				short: 'Level 23',
				check: scores => scores.green >= 200
			},
			{
				id: 'level-23-triple-threat',
				description: 'Level 23: Scoor 75 punten in 3 kleuren.',
				short: 'Level 23',
				check: scores => {
					const colorScores = [scores.yellow, scores.red, scores.green, scores.purple, scores.blue];
					return colorScores.filter(s => s >= 75).length >= 3;
				}
			},
		],
		24: [
			{
				id: 'level-24-extreme-balance',
				description: 'Level 24: Scoor 65 punten in elke kleur',
				short: 'Level 24',
				check: scores => scores.yellow >= 65 && scores.red >= 65 && scores.green >= 65 && scores.purple >= 65 && scores.blue >= 65,
				progress: scores => {
					const parts = [
						(scores.yellow >= 65 ? 'âœ”geel' : ''),
						(scores.red >= 65 ? 'âœ”rood' : ''),
						(scores.green >= 65 ? 'âœ”groen' : ''),
						(scores.purple >= 65 ? 'âœ”paars' : ''),
						(scores.blue >= 65 ? 'âœ”blauw' : '')
					];
					return parts.join(' ');
				}
			},
			{
				id: 'level-24-yellow-mastery',
				description: 'Level 24: Scoor 120 punten in geel.',
				short: 'Level 24',
				check: scores => scores.yellow >= 120
			},
			{
				id: 'level-24-red-empire',
				description: 'Level 24: Voltooi 3 van de 4 rode grids volledig.',
				short: 'Level 24',
				check: () => {
					const redZones = ['red-grid1', 'red-grid2', 'red-grid3', 'red-grid4'];
					let complete = 0;
					redZones.forEach(id => {
						const zone = document.getElementById(id);
						if (!zone) return;
						const cells = zone.querySelectorAll('.cell:not(.void-cell)');
						const active = zone.querySelectorAll('.cell.active:not(.void-cell)');
						if (cells.length > 0 && cells.length === active.length) complete++;
					});
					return complete >= 3;
				}
			},
			{
				id: 'level-24-bonus-rush',
				description: 'Level 24: Verzamel 40 bonussen.',
				short: 'Level 24',
				check: scores => (scores?.bonusesCollected || 0) >= 40,
				progress: scores => {
					const collected = Math.max(0, Math.min(40, (scores?.bonusesCollected || 0)));
					return `${collected}/40`;
				}
			},
			{
				id: 'level-24-blue-depths',
				description: 'Level 24: Scoor 300 punten in blauw.',
				short: 'Level 24',
				check: scores => scores.blue >= 300
			}
		],
		25: [
			{
				id: 'level-25-halfway-champion',
				description: 'Level 25: Scoor 450 punten totaal.',
				short: 'Level 25',
				check: scores => ((scores.yellow + scores.red + scores.green + scores.purple + scores.blue) + (scores?.bonus || 0)) >= 450
			},
			{
				id: 'level-25-purple-complete',
				description: 'Level 25: Verbind de vier buitenste dikgedrukte paarse cellen  met elkaar.',
				short: 'Level 25',
				check: () => {
					const purpleZone = document.getElementById('purple-zone');
					if (!purpleZone) return false;
					// Find bold corner cells by extremes of bold-cell coordinates
					const boldCells = Array.from(purpleZone.querySelectorAll('.cell.bold-cell:not(.void-cell)'));
					if (boldCells.length === 0) return false;
					const coords = boldCells.map(c => ({ x: Number(c.dataset.x), y: Number(c.dataset.y), el: c }));
					const xs = coords.map(c => c.x);
					const ys = coords.map(c => c.y);
					const minX = Math.min(...xs);
					const maxX = Math.max(...xs);
					const minY = Math.min(...ys);
					const maxY = Math.max(...ys);
					const cornerCoords = [[minX, minY], [minX, maxY], [maxX, minY], [maxX, maxY]];
					const cornerCells = cornerCoords.map(([x, y]) => purpleZone.querySelector(`.cell[data-x="${x}"][data-y="${y}"]`)).filter(Boolean);
					if (cornerCells.length !== 4) return false;
					// Require corner bold-cells to be active
					for (const c of cornerCells) if (!c.classList.contains('active')) return false;
					// Build set of active cell coordinates for BFS
					const activeSet = new Set(Array.from(purpleZone.querySelectorAll('.cell.active:not(.void-cell)')).map(c => `${c.dataset.x},${c.dataset.y}`));
					if (activeSet.size === 0) return false;
					const start = cornerCells[0];
					const startKey = `${start.dataset.x},${start.dataset.y}`;
					const queue = [startKey];
					const visited = new Set([startKey]);
					const neigh = [[1,0],[-1,0],[0,1],[0,-1]];
					while (queue.length) {
						const cur = queue.shift();
						const [cx, cy] = cur.split(',').map(Number);
						for (const [dx, dy] of neigh) {
							const nx = cx + dx;
							const ny = cy + dy;
							const key = `${nx},${ny}`;
							if (visited.has(key)) continue;
							if (!activeSet.has(key)) continue;
							visited.add(key);
							queue.push(key);
						}
					}
					// Ensure all other corner cells are reachable
					for (let i = 1; i < cornerCells.length; i++) {
						const k = `${cornerCells[i].dataset.x},${cornerCells[i].dataset.y}`;
						if (!visited.has(k)) return false;
					}
					return true;
				}
			},
			{
				id: 'level-25-coin-hoarder',
				description: 'Level 25: Verzamel 25+ munten.',
				short: 'Level 25',
				check: scores => getCollectedCoinCount(scores) >= 25,
				progress: scores => {
					const collected = Math.max(0, Math.min(25, getCollectedCoinCount(scores)));
					return `${collected}/25`;
				}
			}
		],
		26: [
			{
				id: 'level-26-all-reds',
				description: 'Level 26: Voltooi alle 4 rode grids volledig.',
				short: 'Level 26',
				check: () => {
					const redZones = ['red-grid1', 'red-grid2', 'red-grid3', 'red-grid4'];
					return redZones.every(id => {
						const zone = document.getElementById(id);
						if (!zone) return false;
						const cells = zone.querySelectorAll('.cell:not(.void-cell)');
						const active = zone.querySelectorAll('.cell.active:not(.void-cell)');
						return cells.length > 0 && cells.length === active.length;
					});
				}
			},
			{
				id: 'level-26-five-colors',
				description: 'Level 26: Scoor 70 punten in elke kleur.',
				short: 'Level 26',
				check: scores => scores.yellow >= 70 && scores.red >= 70 && scores.green >= 70 && scores.purple >= 70 && scores.blue >= 70,
				progress: scores => {
					const parts = [
						(scores.yellow >= 70 ? 'âœ”geel' : ''),
						(scores.red >= 70 ? 'âœ”rood' : ''),
						(scores.green >= 70 ? 'âœ”groen' : ''),
						(scores.purple >= 70 ? 'âœ”paars' : ''),
						(scores.blue >= 70 ? 'âœ”blauw' : '')
					];
					return parts.join(' ');
				}
			}
		],
		27: [
			{
				id: 'level-27-purple-ring',
				description: 'Level 27: Voltooi de buitenste ring van paars.',
				short: 'Level 27',
				check: scores => checkPurpleOuterRingComplete()
			},
			{
				id: 'level-27-mega-total',
				description: 'Level 27: Scoor 450 punten totaal.',
				short: 'Level 27',
				check: scores => ((scores.yellow + scores.red + scores.green + scores.purple + scores.blue) + (scores?.bonus || 0)) >= 450
			}
		],
		28: [
			{
				id: 'level-28-blue-master',
				description: 'Level 28: Scoor 350 punten in blauw.',
				short: 'Level 28',
				check: scores => scores.blue >= 350
			},
			{
				id: 'level-28-yellow-emperor',
				description: 'Level 28: Scoor 200 punten in geel.',
				short: 'Level 28',
				check: scores => scores.yellow >= 200
			},
			{
				id: 'level-28-zone-complete',
				description: 'Level 28: Voltooi een zone volledig (alle cellen in geel, paars of groen).',
				short: 'Level 28',
				check: () => {
					const zones = ['yellow-zone', 'purple-zone', 'green-zone'];
					let complete = 0;
					zones.forEach(id => {
						const zone = document.getElementById(id);
						if (!zone) return;
						const cells = zone.querySelectorAll('.cell:not(.void-cell)');
						const active = zone.querySelectorAll('.cell.active:not(.void-cell)');
						if (cells.length > 0 && cells.length === active.length) complete++;
					});
					return complete >= 1;
				}
			},
			{
				id: 'level-28-coin-emperor',
				description: 'Level 28: Verzamel 35+ munten.',
				short: 'Level 28',
				check: scores => getCollectedCoinCount(scores) >= 35,
				progress: scores => {
					const collected = Math.max(0, Math.min(35, getCollectedCoinCount(scores)));
					return `${collected}/35`;
				}
			}
		],
		29: [
			{
				id: 'level-29-penultimate',
				description: 'Level 29: Op naar de finale! Scoor 600 punten totaal.',
				short: 'Level 29',
				check: scores => ((scores.yellow + scores.red + scores.green + scores.purple + scores.blue) + (scores?.bonus || 0)) >= 600
			},
			{
				id: 'level-29-all-zones-active',
				description: 'Level 29: Activeer minstens 75% van alle zones.',
				short: 'Level 29',
				check: () => {
					const zones = ['yellow-zone', 'purple-zone', 'blue-zone', 'green-zone', 
							   'red-grid1', 'red-grid2', 'red-grid3', 'red-grid4', 'red-grid5', 'red-grid6'];
					let totalCells = 0;
					let activeCells = 0;
					zones.forEach(id => {
						const zone = document.getElementById(id);
						if (!zone) return;
						const cells = zone.querySelectorAll('.cell:not(.void-cell)');
						const active = zone.querySelectorAll('.cell.active:not(.void-cell)');
						totalCells += cells.length;
						activeCells += active.length;
					});
					return totalCells > 0 && (activeCells / totalCells) >= 0.75;
				}
			}
		],
		30: [
			{
				id: 'level-30-ultimate-champion',
				description: 'Level 30: FINALE! Scoor 750 punten totaal.',
				short: 'Level 30',
				check: scores => ((scores.yellow + scores.red + scores.green + scores.purple + scores.blue) + (scores?.bonus || 0)) >= 750
			}
		]
		,
		// WORLD 4 OBJECTIVES (Levels 31-40) - Deuren & sleutels + actieve zones
		31: [
			{
				id: 'level-31-first-key',
				description: 'Level 31: Ontgrendel 1 deurkleur.',
				short: 'Level 31',
				check: () => {
					try { return (window.world4UnlockedColors instanceof Set) && window.world4UnlockedColors.size >= 1; } catch (e) { return false; }
				}
			},
			{
				id: 'level-31-active-total',
				description: 'Level 31: Scoor 520 punten in de actieve zones.',
				short: 'Level 31',
				check: scores => getWorld4ActiveScoreTotal(scores) >= 520
			},
			{
				id: 'level-31-open-door',
				description: 'Level 31: Open 1 deur.',
				short: 'Level 31',
				check: () => countWorld4OpenDoors() >= 1
			}
		],
		32: [
			{
				id: 'level-32-two-keys',
				description: 'Level 32: Ontgrendel 2 deurkleuren.',
				short: 'Level 32',
				check: () => {
					try { return (window.world4UnlockedColors instanceof Set) && window.world4UnlockedColors.size >= 2; } catch (e) { return false; }
				}
			},
			{
				id: 'level-32-active-total',
				description: 'Level 32: Scoor 560 punten in de actieve zones.',
				short: 'Level 32',
				check: scores => getWorld4ActiveScoreTotal(scores) >= 560
			},
			{
				id: 'level-32-open-door',
				description: 'Level 32: Open 1 deur.',
				short: 'Level 32',
				check: () => countWorld4OpenDoors() >= 1
			}
		],
		33: [
			{
				id: 'level-33-open-doors',
				description: 'Level 33: Open 2 deuren.',
				short: 'Level 33',
				check: () => countWorld4OpenDoors() >= 2
			},
			{
				id: 'level-33-two-active-colors',
				description: 'Level 33: Scoor 220 punten in 2 actieve kleuren.',
				short: 'Level 33',
				check: scores => countWorld4ActiveColorsAtLeast(scores, 220) >= 2,
				progress: scores => `${Math.min(2, countWorld4ActiveColorsAtLeast(scores, 220))}/2`
			},
			{
				id: 'level-33-active-total',
				description: 'Level 33: Scoor 620 punten in de actieve zones.',
				short: 'Level 33',
				check: scores => getWorld4ActiveScoreTotal(scores) >= 620
			}
		],
		34: [
			{
				id: 'level-34-three-keys',
				description: 'Level 34: Ontgrendel 3 deurkleuren.',
				short: 'Level 34',
				check: () => {
					try { return (window.world4UnlockedColors instanceof Set) && window.world4UnlockedColors.size >= 3; } catch (e) { return false; }
				}
			},
			{
				id: 'level-34-coins',
				description: 'Level 34: Verzamel 28+ munten.',
				short: 'Level 34',
				check: scores => getCollectedCoinCount(scores) >= 28,
				progress: scores => {
					const collected = Math.max(0, Math.min(28, getCollectedCoinCount(scores)));
					return `${collected}/28`;
				}
			},
			{
				id: 'level-34-active-total',
				description: 'Level 34: Scoor 680 punten in de actieve zones.',
				short: 'Level 34',
				check: scores => getWorld4ActiveScoreTotal(scores) >= 680
			}
		],
		35: [
			{
				id: 'level-35-open-doors',
				description: 'Level 35: Open 2 deuren.',
				short: 'Level 35',
				check: () => countWorld4OpenDoors() >= 2
			},
			{
				id: 'level-35-one-color',
				description: 'Level 35: Scoor 260 punten in 1 actieve kleur.',
				short: 'Level 35',
				check: scores => countWorld4ActiveColorsAtLeast(scores, 260) >= 1
			},
			{
				id: 'level-35-active-total',
				description: 'Level 35: Scoor 740 punten in de actieve zones.',
				short: 'Level 35',
				check: scores => getWorld4ActiveScoreTotal(scores) >= 740
			}
		],
		36: [
			{
				id: 'level-36-three-keys',
				description: 'Level 36: Ontgrendel 3 deurkleuren.',
				short: 'Level 36',
				check: () => {
					try { return (window.world4UnlockedColors instanceof Set) && window.world4UnlockedColors.size >= 3; } catch (e) { return false; }
				}
			},
			{
				id: 'level-36-open-doors',
				description: 'Level 36: Open 3 deuren.',
				short: 'Level 36',
				check: () => countWorld4OpenDoors() >= 3
			},
			{
				id: 'level-36-active-total',
				description: 'Level 36: Scoor 780 punten in de actieve zones.',
				short: 'Level 36',
				check: scores => getWorld4ActiveScoreTotal(scores) >= 780
			}
		],
		37: [
			{
				id: 'level-37-two-active-colors',
				description: 'Level 37: Scoor 280 punten in 2 actieve kleuren.',
				short: 'Level 37',
				check: scores => countWorld4ActiveColorsAtLeast(scores, 280) >= 2,
				progress: scores => `${Math.min(2, countWorld4ActiveColorsAtLeast(scores, 280))}/2`
			},
			{
				id: 'level-37-open-doors',
				description: 'Level 37: Open 3 deuren.',
				short: 'Level 37',
				check: () => countWorld4OpenDoors() >= 3
			},
			{
				id: 'level-37-active-total',
				description: 'Level 37: Scoor 820 punten in de actieve zones.',
				short: 'Level 37',
				check: scores => getWorld4ActiveScoreTotal(scores) >= 820
			}
		],
		38: [
			{
				id: 'level-38-active-total',
				description: 'Level 38: Scoor 850 punten in de actieve zones.',
				short: 'Level 38',
				check: scores => getWorld4ActiveScoreTotal(scores) >= 850
			},
			{
				id: 'level-38-open-doors',
				description: 'Level 38: Open 3 deuren.',
				short: 'Level 38',
				check: () => countWorld4OpenDoors() >= 3
			},
			{
				id: 'level-38-activation',
				description: 'Level 38: Activeer 70% van de actieve zones.',
				short: 'Level 38',
				check: () => getWorld4ActiveZoneCompletionRatio() >= 0.70
			}
		],
		39: [
			{
				id: 'level-39-activation',
				description: 'Level 39: Activeer 75% van de actieve zones.',
				short: 'Level 39',
				check: () => getWorld4ActiveZoneCompletionRatio() >= 0.75
			},
			{
				id: 'level-39-active-total',
				description: 'Level 39: Scoor 880 punten in de actieve zones.',
				short: 'Level 39',
				check: scores => getWorld4ActiveScoreTotal(scores) >= 880
			},
			{
				id: 'level-39-open-doors',
				description: 'Level 39: Open 3 deuren.',
				short: 'Level 39',
				check: () => countWorld4OpenDoors() >= 3
			}
		],
		40: [
			{
				id: 'level-40-world4-finale',
				description: 'Level 40: Wereld 4 finale! Scoor 920 punten in de actieve zones.',
				short: 'Level 40',
				check: scores => getWorld4ActiveScoreTotal(scores) >= 920
			},
			{
				id: 'level-40-activation',
				description: 'Level 40: Activeer 80% van de actieve zones.',
				short: 'Level 40',
				check: () => getWorld4ActiveZoneCompletionRatio() >= 0.80
			},
			{
				id: 'level-40-open-doors',
				description: 'Level 40: Open 3 deuren en ontgrendel 3 deurkleuren.',
				short: 'Level 40',
				check: () => {
					try {
						const unlockedOk = (window.world4UnlockedColors instanceof Set) && window.world4UnlockedColors.size >= 3;
						return unlockedOk && countWorld4OpenDoors() >= 3;
					} catch (e) { return false; }
				}
			}
		]
	};

	// Generate objectives array with random selection per level
	const OBJECTIVES = [];
	for (let level = 0; level <= 40; level++) { // Uitgebreid naar level 40 voor World 4
		const templates = OBJECTIVE_TEMPLATES[level] || [];
		if (templates.length > 0) {
			// Pick a random objective from the 5 available for this level
			const randomIndex = Math.floor(Math.random() * templates.length);
			const selected = templates[randomIndex];
			OBJECTIVES.push({
				...selected,
				level: level
			});
		}
	}

	let currentObjectiveId = null;
	const completedObjectives = [];
	const completedObjectiveIds = new Set();

	/* ============================================
	   DOELEN (OBJECTIVES) FUNCTIES
	   ============================================
	   Houdt bij welke doelen actief/voltooid zijn
	   Doelen geven extra uitdaging en structuur aan het spel
	*/
	function getObjectiveById(id) {
		if (!id) return null;
		// Primary lookup: the generated OBJECTIVES list (one randomly selected objective per level).
		const direct = OBJECTIVES.find(obj => obj.id === id) || null;
		if (direct) return direct;
		// Back-compat / save-compat:
		// Saved objective IDs refer to OBJECTIVE_TEMPLATES entries, but OBJECTIVES is randomized per page load.
		// Fall back to searching the templates so saved objectives can be restored deterministically.
		try {
			if (typeof OBJECTIVE_TEMPLATES === 'object' && OBJECTIVE_TEMPLATES) {
				for (const [lvlKey, templates] of Object.entries(OBJECTIVE_TEMPLATES)) {
					if (!Array.isArray(templates)) continue;
					const found = templates.find(t => t && t.id === id);
					if (found) {
						const lvl = Number(lvlKey);
						return { ...found, level: Number.isFinite(lvl) ? lvl : undefined };
					}
				}
			}
		} catch (e) {}
		return null;
	}

	// Parse a Dutch free-text objective (e.g. "Haal 50 punten bij geel" or "Haal 10 punten bij alle kleuren")
	// and return an objective-like object with a `.check(scores)` function.
	function parseObjectiveTextToObjective(text) {
		const raw = (text == null) ? '' : String(text || '').trim();
		const s = raw.toLowerCase();
		// detect numeric target
		const numMatch = s.match(/(\d{1,5})/);
		const target = numMatch ? parseInt(numMatch[1], 10) : null;
		const colorMap = { 'geel':'yellow', 'rood':'red', 'groen':'green', 'paars':'purple', 'blauw':'blue' };
		// find mentioned colors
		const colors = [];
		if (/alle kleuren|bij alle kleuren|alle kleur/.test(s)) {
			Object.keys(colorMap).forEach(k => colors.push(colorMap[k]));
		} else {
			Object.keys(colorMap).forEach(dutch => { if (s.indexOf(dutch) !== -1) colors.push(colorMap[dutch]); });
		}
		// determine if this is a total-target (in totaal) or per-color
		const wantsTotal = /totaal|in totaal|samen|alles samen/.test(s) && !!target;

		const id = `custom:${Date.now().toString(36)}:${Math.random().toString(36).slice(2,8)}`;
		const description = raw || '';
		const short = raw.length > 40 ? raw.slice(0,40) + '...' : raw;

		// Helper: produce a live snapshot of scores from provided object or from the DOM if omitted
		function getCurrentScores(provided) {
			const dutchToKey = { 'geel':'yellow', 'rood':'red', 'groen':'green', 'paars':'purple', 'blauw':'blue' };
			const snapshot = { yellow:0, red:0, green:0, purple:0, blue:0, bonus: (typeof bonus === 'number' ? bonus : 0), bonusesCollected: (typeof totalBonusesCollected === 'number' ? totalBonusesCollected : 0) };
			// If caller provided explicit snapshot, merge it over defaults
			if (provided && typeof provided === 'object') {
				Object.keys(snapshot).forEach(k => { if (provided[k] != null) snapshot[k] = provided[k]; });
				if (provided.total != null) snapshot.total = provided.total;
				return snapshot;
			}
			// Fallback to global numeric variables if present (these are updated during score calc)
			try {
				if (typeof yellow === 'number') snapshot.yellow = yellow;
				if (typeof red === 'number') snapshot.red = red;
				if (typeof green === 'number') snapshot.green = green;
				if (typeof purple === 'number') snapshot.purple = purple;
				if (typeof blue === 'number') snapshot.blue = blue;
			} catch (e) {}
			// If globals are zero-ish, try DOM counts (useful in some edge cases)
			try {
				Object.keys(dutchToKey).forEach(dutch => {
					const key = dutchToKey[dutch];
					if (snapshot[key] && snapshot[key] > 0) return;
					let count = 0;
					const nodes = document.querySelectorAll(`.zone[data-color="${dutch}"] .cell.active`);
					if (nodes && nodes.length) count = nodes.length;
					if (!count) {
						const alt = document.querySelectorAll(`#${key}-grid .cell.active`);
						if (alt && alt.length) count = alt.length;
					}
					if (count) snapshot[key] = count;
				});
			} catch (e) {}
			snapshot.total = (typeof snapshot.total === 'number') ? snapshot.total : (snapshot.yellow + snapshot.red + snapshot.green + snapshot.purple + snapshot.blue + (snapshot.bonus || 0));
			return snapshot;
		}

		function computeTotalFromScores(scores) {
			const s = getCurrentScores(scores);
			return (typeof s.total === 'number') ? s.total : 0;
		}

		// build check function
		let check;
		if (!target) {
			check = () => false;
		} else if (wantsTotal || colors.length === 0) {
			check = (scores) => {
				const total = computeTotalFromScores(scores);
				return total >= target;
			};
		} else {
			// per-color: ensure all mentioned colors meet the target
			const uniqColors = Array.from(new Set(colors));
			check = (scores) => {
				const s = getCurrentScores(scores);
				return uniqColors.every(c => (s[c] || 0) >= target);
			};
		}

		// progress helper returns a short progress string
		function progress(scores) {
			if (!target) return '';
			const s = getCurrentScores(scores);
			if (wantsTotal || colors.length === 0) {
				const total = computeTotalFromScores(s);
				return `${Math.min(total, target)}/${target}`;
			}
			const cols = Array.from(new Set(colors));
			const vals = cols.map(c => (s[c] || 0));
			const minv = Math.min.apply(null, vals.concat([0]));
			return `${Math.min(minv, target)}/${target}`;
		}

		return {
			id,
			description,
			short,
			check,
			progress
		};
	}

	function getObjectiveForLevel(level) {
		return OBJECTIVES.find(obj => obj.level === level) || null;
	}

	function isObjectiveCompleted(id) {
		return !!(id && completedObjectiveIds.has(id));
	}

	function isCurrentObjectiveCompleted() {
		const objective = getObjectiveById(currentObjectiveId);
		if (!objective) return true;
		const snapshot = latestScoreSnapshot || {
			yellow,
			red,
			green,
			purple,
			blue,
			bonus,
			bonusesCollected: totalBonusesCollected,
			total: yellow + red + green + purple + blue + bonus
		};
		try {
			return !!objective.check(snapshot);
		} catch (error) {
			console.warn('Objective check failed', objective.id, error);
			return false;
		}
	}

	function setCurrentObjectiveForLevel(level) {
		const objective = getObjectiveForLevel(level);
		currentObjectiveId = objective ? objective.id : null;
		renderObjectivePanel();
	}

	function isAllColorObjective(objective) {
		if (!objective || !objective.description) return false;
		const desc = String(objective.description || '');
		return /(elke\s*kleur|alle\s*kleuren|in\s*de\s*kleuren)/i.test(desc);
	}

	function grantAllColorObjectiveBonuses(objective) {
		if (!isAllColorObjective(objective)) return;
		BONUS_ORDER.forEach(key => {
			try { addBonusCharge(key, 2, { trackCollection: true }); } catch (e) {}
		});
	}
	let objectiveToastTimeout = null;
	let objectivePopupTimeout = null;

	/* ============================================
	   DRAG & DROP VARIABELEN
	   ============================================
	   Globale state voor het slepen van kaarten/bonussen
	*/
	let draggedBlock = null;
	// Version marker to help verify deployed updates on GitHub Pages
	window.__locusVersion = window.__locusVersion || '2025-12-29-patch1';
	console.debug && console.debug('Locus version:', window.__locusVersion);
	let GRID_VERSION = 0;
	function bumpGridVersion() {
		GRID_VERSION += 1;
		return GRID_VERSION;
	}
	function getGridVersion() {
		return GRID_VERSION;
	}
	let draggedShape = null;
	let draggedColor = null;
	let isPointerDragging = false;
	let dragPointerId = null;
	let dragStartClientX = 0;
	let dragStartClientY = 0;
	let dragHasMoved = false;
	let rotateButton = null;
	let mirrorButton = null;
	let startX = 0;
	let startY = 0;
	let offsetX = 0; 
	let offsetY = 0;
	let lastZone = null;
	let lastBaseX = null;
	let lastBaseY = null;
	let skipNextZoneClick = false;
	let bonusCoinMilestones = 0;
	let activeTraps = [];
	let trapIdCounter = 0;
	let blackHoleTrapPlaced = false;
	let lastTrapHighlightId = null;
	let lastTrapPenaltyBreakdown = {
		yellow: 0,
		red: 0,
		green: 0,
		purple: 0,
		blue: 0,
		other: 0,
		total: 0
	};
	let trapPenaltyByKey = new Map();
	let dragGapMode = 'default';
	// Drag move throttling (reduces CPU/battery drain on high-frequency pointermove events)
	let dragMovePending = null;
	let dragMoveRafId = null;
	let lastProcessedDragClientX = null;
	let lastProcessedDragClientY = null;
	let lastProcessedDragAtMs = 0;
	function cancelPendingDragMoveFrame() {
		try {
			if (dragMoveRafId) cancelAnimationFrame(dragMoveRafId);
		} catch (_) {}
		dragMoveRafId = null;
		dragMovePending = null;
	}

	// Touch UX: lift the dragged block slightly above the finger.
	// Keep this small; it only applies to real touch/pen pointer events.
	const TOUCH_FINGER_LIFT_PX = 28;
	function getFingerLiftOffsetY(ev) {
		try {
			const pointerType = ev && ev.pointerType;
			const isTouchPointer = (pointerType === 'touch' || pointerType === 'pen');
			if (isTouchPointer) return TOUCH_FINGER_LIFT_PX;

			// Fallback: some mobile browsers can surface touch interactions as mouse-like events.
			// Guard this strongly so Windows desktops with touch support don't get the lift.
			const isMobileLayout = (typeof MOBILE_BREAKPOINT !== 'undefined')
				? (window.innerWidth <= MOBILE_BREAKPOINT)
				: (window.innerWidth <= 650);
			const touchCapable = (('ontouchstart' in window) || (navigator && navigator.maxTouchPoints > 0));
			let coarse = false;
			try { coarse = !!(window.matchMedia && window.matchMedia('(pointer: coarse)').matches); } catch (e) { coarse = false; }
			if (isMobileLayout && touchCapable && coarse) return TOUCH_FINGER_LIFT_PX;
			return 0;
		} catch (e) {
			return 0;
		}
	}

	function getBoardCellMetrics() {
		// Measure the *rendered* board cell size (accounts for transforms / scaling).
		let cellSizePx = 26;
		try {
			const sampleCell = document.querySelector('#board .grid .cell:not(.void-cell)');
			if (sampleCell) {
				const rect = sampleCell.getBoundingClientRect();
				cellSizePx = Math.min(rect.width, rect.height) || cellSizePx;
			} else {
				cellSizePx = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--cell-size')) || cellSizePx;
			}
		} catch {
			// keep default
		}

		let gapPx = 0;
		try {
			gapPx = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--board-grid-gap')) || 0;
		} catch {
			gapPx = 0;
		}

		return {
			cellSize: cellSizePx,
			gap: gapPx,
			step: cellSizePx + gapPx
		};
	}

	// Helper: meet cel-grootte en gap van een draggable blok element
	function getDragBlockCellMetrics(block) {
		let cellSize = 26;
		let gap = 0;
		try {
			if (!block) return { cellSize, gap };
			const sampleCell = block.querySelector('.preview-cell-wrap') || block.querySelector('div');
			if (sampleCell) {
				const r = sampleCell.getBoundingClientRect();
				cellSize = Math.min(r.width, r.height) || cellSize;
			}
			const blockStyle = getComputedStyle(block);
			const gapRaw = blockStyle.gap || blockStyle.columnGap || '0px';
			gap = parseFloat(gapRaw) || 0;
		} catch (_) {}
		return { cellSize, gap };
	}



	function computeShapeCenterOffsets(shape, cellSize = null, gapOverride = null) {
		try {
			if (!shape || !shape.length || !shape[0] || !shape[0].length) {
				return { offsetX: 0, offsetY: 0 };
			}
			const metrics = getBoardCellMetrics();
			let overrideCellSize = null;
			let overrideGap = null;
			if (cellSize && typeof cellSize === 'object') {
				overrideCellSize = Number(cellSize.cellSize);
				overrideGap = Number(cellSize.gap);
			} else if (Number.isFinite(cellSize)) {
				overrideCellSize = Number(cellSize);
			}
			if (Number.isFinite(gapOverride)) {
				overrideGap = Number(gapOverride);
			}
			// If a specific cellSize was passed, use it (gap assumed 0). Otherwise
			// when zoomed-in measure the actual cell size from the active zoom
			// zone so offsets align with the rendered draggable.
			const measuredRoot = (document.body.classList.contains('zoomed-in') && typeof activeZoomZone !== 'undefined' && activeZoomZone) ? activeZoomZone : null;
				const resolvedCellSize = Number.isFinite(overrideCellSize) ? overrideCellSize : (getActualCellSize(measuredRoot) || metrics.cellSize);
				const resolvedGap = Number.isFinite(overrideGap) ? overrideGap : metrics.gap;
			const resolvedStep = resolvedCellSize + resolvedGap;

			const shapeHeight = shape.length;
			const shapeWidth = shape[0].length;
			let minX = shapeWidth, maxX = -1, minY = shapeHeight, maxY = -1;
			let solidMinX = shapeWidth, solidMaxX = -1, solidMinY = shapeHeight, solidMaxY = -1;
			for (let y = 0; y < shapeHeight; y++) {
				for (let x = 0; x < shapeWidth; x++) {
					const val = shape[y][x];
					if (!val) continue;
					minX = Math.min(minX, x);
					maxX = Math.max(maxX, x);
					minY = Math.min(minY, y);
					maxY = Math.max(maxY, y);
					if (isSolidShapeCell(val)) {
						solidMinX = Math.min(solidMinX, x);
						solidMaxX = Math.max(solidMaxX, x);
						solidMinY = Math.min(solidMinY, y);
						solidMaxY = Math.max(solidMaxY, y);
					}
				}
			}
			// When optional cells exist, center on the solid footprint so the optional
			// extension sits "off" the anchor instead of pulling the drag anchor away.
			const hasSolid = Number.isFinite(solidMinX) && solidMaxX >= 0 && solidMaxY >= 0;
			const hasOptional = hasOptionalCells(shape);
			const useSolidBounds = hasOptional && hasSolid;
			const boundMinX = useSolidBounds ? solidMinX : minX;
			const boundMaxX = useSolidBounds ? solidMaxX : maxX;
			const boundMinY = useSolidBounds ? solidMinY : minY;
			const boundMaxY = useSolidBounds ? solidMaxY : maxY;
			if (boundMaxX < 0 || boundMaxY < 0) {
				return { offsetX: (shapeWidth * resolvedStep) / 2, offsetY: (shapeHeight * resolvedStep) / 2 };
			}
			const width = boundMaxX - boundMinX + 1;
			const height = boundMaxY - boundMinY + 1;
			// Calculate offset to the visual center of the solid shape cells.
			// Cell i starts at: i * step, ends at: i * step + cellSize
			// For cells from boundMinX to boundMaxX:
			//   Left edge = boundMinX * step
			//   Right edge = boundMaxX * step + cellSize
			//   Center X = (boundMinX * step + boundMaxX * step + cellSize) / 2
			//            = ((boundMinX + boundMaxX) * step + cellSize) / 2
			// Similarly for Y
			const centerX = ((boundMinX + boundMaxX) * resolvedStep + resolvedCellSize) / 2;
			const centerY = ((boundMinY + boundMaxY) * resolvedStep + resolvedCellSize) / 2;
			return {
				offsetX: centerX,
				offsetY: centerY
			};
		} catch {
			return { offsetX: 0, offsetY: 0 };
		}
	}

	function beginPointerDrag({ clientX = 0, clientY = 0, pointerId = null } = {}) {
		isPointerDragging = true;
		dragPointerId = (pointerId !== undefined && pointerId !== null) ? pointerId : null;
		dragStartClientX = Number(clientX) || 0;
		dragStartClientY = Number(clientY) || 0;
		dragHasMoved = false;
		// Clear any stale hover/placement state so pointerup can't place immediately.
		lastZone = null;
		lastBaseX = lastBaseY = null;
	}

	function endPointerDragTracking() {
		isPointerDragging = false;
		dragPointerId = null;
		dragHasMoved = false;
		cancelPendingDragMoveFrame();
	}

	/* ============================================
	   BONUS SYSTEEM
	   ============================================
	   Bonussen zijn speciale power-ups per kleur
	   Elk 10 punten op een kleur = 1 bonus
	   Bonussen kunnen gebruikt worden voor extra plaatsingen
	*/
	const BONUS_ORDER = ['yellow', 'red', 'green', 'purple', 'blue'];
	const BONUS_COLOR_CONFIG = {
		yellow: { label: 'Geel', colorName: 'geel', colorCode: '#cfba51' },
		red: { label: 'Rood', colorName: 'rood', colorCode: '#b56069' },
		green: { label: 'Groen', colorName: 'groen', colorCode: '#92c28c' },
		purple: { label: 'Paars', colorName: 'paars', colorCode: '#8f76b8' },
		blue: { label: 'Blauw', colorName: 'blauw', colorCode: '#5689b0' }
	};
	const BONUS_UPGRADE_COSTS = {
		yellow: 6,
		red: 6,
		green: 6,
		purple: 6,
		blue: 6
	};
	const bonusInventory = BONUS_ORDER.reduce((acc, key) => {
		acc[key] = 0;
		return acc;
	}, {});
	const bonusMasteryState = BONUS_ORDER.reduce((acc, key) => {
		acc[key] = false;
		return acc;
	}, {});
	const BONUS_SHAPES = {
		default: [[1], [1]],
		red: [[1]]
	};
	let activeBonusPlacement = null;
	// Per-level: set of bonus colors that are boosted to 2Ã— by playing a Bonus Boost card
	let bonusBoostActiveColors = new Set();
	
	// Free placement system
	let freePlacementsRemaining = 0;

	function isBonusUpgraded(colorKey) {
		return !!bonusMasteryState[colorKey];
	}

	function setBonusUpgraded(colorKey, upgraded = true) {
		if (!BONUS_COLOR_CONFIG[colorKey]) return;
		bonusMasteryState[colorKey] = !!upgraded;
	}

	function getBonusMeta(colorKey) {
		return BONUS_COLOR_CONFIG[colorKey] || null;
	}

	function getBonusShape(colorKey) {
		const upgraded = isBonusUpgraded(colorKey);
		if (colorKey && BONUS_SHAPES[colorKey]) {
			const base = cloneShape(BONUS_SHAPES[colorKey]);
			if (upgraded) {
				base.push([2]);
			}
			return base;
		}
		const base = cloneShape(BONUS_SHAPES.default);
		if (upgraded) {
			base.push([2]);
		}
		return base;
	}

	function checkPurpleOuterRingComplete() {
			const grid = document.getElementById('purple-grid');
			if (!grid) return false;
			const cells = Array.from(grid.querySelectorAll('.cell'));
			if (!cells.length) return false;
			const cols = parseInt(grid.dataset.cols || '0', 10) || (() => {
				const computed = getComputedStyle(grid).gridTemplateColumns;
				return computed ? computed.split(/\s+/).length : Math.round(Math.sqrt(cells.length)) || 1;
			})();
			const rows = parseInt(grid.dataset.rows || '0', 10) || Math.ceil(cells.length / cols);
			if (!cols || !rows) return false;
			for (let index = 0; index < cells.length; index += 1) {
				const row = Math.floor(index / cols);
				const col = index % cols;
				if (row === 0 || col === 0 || row === rows - 1 || col === cols - 1) {
					if (!cells[index].classList.contains('active')) {
						return false;
					}
				}
			}
			return true;
		}

		function checkYellowFullRows(targetColumns = 1) {
			const yellowConfig = window.yellowGridConfig || {};
			if (yellowConfig.scoreMode === 'diagonal') {
				const scoredSegments = window.scoredYellowSegments || window.scoredYellowDiagonals;
				return scoredSegments instanceof Set && scoredSegments.size >= targetColumns;
			}
			const scoredColumns = window.scoredYellowColumns;
			return scoredColumns instanceof Set && scoredColumns.size >= targetColumns;
		}

		function showObjectiveToast(message) {
			if (!message) return;
			let toast = document.querySelector('.objective-toast');
			if (!toast) {
				toast = document.createElement('div');
				toast.className = 'objective-toast';
				document.body.appendChild(toast);
			}
			// Render diamond glyph with special styling when present
			try {
				const safe = String(message).replace(/â™¦/g, '<span class="diamond-glyph">â™¦</span>');
				toast.innerHTML = safe;
			} catch (e) {
				toast.textContent = message;
			}
			toast.classList.add('show');
			if (objectiveToastTimeout) clearTimeout(objectiveToastTimeout);
			objectiveToastTimeout = setTimeout(() => {
				toast.classList.remove('show');
			}, 2400);
		}

		function showObjectiveCompletionPopup(message) {
			const levelNum = (typeof currentLevel !== 'undefined') ? Number(currentLevel) : null;
			// Only show this popup during the intro tutorial (level 0) and only if the tutorial is not completed.
			if (levelNum !== 0) return;
			if (typeof isTutorialCompleted === 'function' && isTutorialCompleted()) return;
			let popup = document.querySelector('.objective-popup');
			if (!popup) {
				popup = document.createElement('div');
				popup.className = 'objective-popup';
				const title = document.createElement('div');
				title.className = 'objective-popup-title';
				const body = document.createElement('div');
				body.className = 'objective-popup-body';
				popup.append(title, body);
				document.body.appendChild(popup);
			}
			const titleEl = popup.querySelector('.objective-popup-title');
			const bodyEl = popup.querySelector('.objective-popup-body');
			if (titleEl) titleEl.textContent = 'Goed gedaan!';
			if (bodyEl) {
				const safeMessage = stripObjectiveSymbols ? stripObjectiveSymbols(message || '') : (message || '');
				bodyEl.textContent = 'Nu kan je het level verder spelen om munten te halen die je zometeen kan gebruiken.';
				if (safeMessage) bodyEl.dataset.detail = safeMessage;
			}
			popup.classList.add('show');
			if (objectivePopupTimeout) clearTimeout(objectivePopupTimeout);
			objectivePopupTimeout = setTimeout(() => {
				popup.classList.remove('show');
			}, 5200);
		}

		function stripObjectiveSymbols(text) {
			if (text == null) return '';
			let t = String(text);
			// Remove common emoji/symbol ranges + variation selectors.
			try {
				t = t.replace(/[\uFE0E\uFE0F]/g, '');
				t = t.replace(/[\u200D]/g, '');
				t = t.replace(/[\u2600-\u27BF]/g, '');
				t = t.replace(/[\u{1F000}-\u{1FAFF}]/gu, '');
			} catch {
				t = t.replace(/[\uFE0E\uFE0F\u200D\u2600-\u27BF]/g, '');
			}
			return t.replace(/\s{2,}/g, ' ').trim();
		}

		function normalizeObjectiveProgress(progressText) {
			let p = stripObjectiveSymbols(progressText);
			if (!p) return '';
			// If progress starts with "n/m ...", keep only "n/m".
			const m = p.match(/^\s*(\d+)\s*\/\s*(\d+)(?:\s+.*)?$/);
			if (m) return `${m[1]}/${m[2]}`;
			return p;
		}

		// Objective-driven bonus bias:
		// If the current objective focuses on a color (e.g. "Scoor 15 punten in rood"),
		// increase the chance that bonus symbols of that color appear across the grids.
		function computeObjectiveDrivenBonusColorChances() {
			try {
				const colors = ['blue', 'green', 'red', 'purple', 'yellow'];
				const defaultChances = colors.map(c => ({ color: c, weight: 1 }));
				const getObjectiveText = () => {
					// Prefer a loaded custom objective when present.
					try {
						if (window && window.loadedCustomObjectiveCompiled) {
							return String(window.loadedCustomObjectiveCompiled.description || window.loadedCustomObjectiveCompiled.short || '').trim();
						}
					} catch (_) {}
					const obj = (typeof getObjectiveById === 'function' ? getObjectiveById(currentObjectiveId) : null)
						|| (typeof getObjectiveForLevel === 'function' ? getObjectiveForLevel(currentLevel) : null);
					return obj ? String(obj.description || obj.short || '').trim() : '';
				};

				const raw = getObjectiveText();
				if (!raw) return null;
				const s = raw.toLowerCase();

				// If objective is explicitly "all colors" / rainbow / multicolor: do NOT bias.
				if (/(?:alle\s+kleur|alle\s+kleuren|elke\s+kleur|regenboog|multikleur)/i.test(s)) return null;

				// Detect mentioned colors (Dutch base + common adjective forms).
				const mentioned = new Set();
				const patterns = [
					{ key: 'yellow', re: /\b(?:geel|gele)\b/i },
					{ key: 'red', re: /\b(?:rood|rode)\b/i },
					{ key: 'green', re: /\b(?:groen|groene)\b/i },
					{ key: 'purple', re: /\b(?:paars|paarse)\b/i },
					{ key: 'blue', re: /\b(?:blauw|blauwe)\b/i }
				];
				for (const p of patterns) {
					if (p.re.test(s)) mentioned.add(p.key);
				}

				// If objective is diagonal/column-based and no color is mentioned (fallback): assume yellow.
				if (mentioned.size === 0 && /diagona|kolom|segment/i.test(s)) {
					mentioned.add('yellow');
				}

				// No clear color focus (e.g. total score / coins / collect bonuses): keep uniform.
				if (mentioned.size === 0) return null;
				// If it's basically "many colors", biasing is not helpful.
				if (mentioned.size >= 4) return null;

				const boost = (mentioned.size === 1) ? 3 : (mentioned.size === 2) ? 2.3 : 1.8;
				const weights = {
					blue: 1,
					green: 1,
					red: 1,
					purple: 1,
					yellow: 1
				};
				for (const k of mentioned) {
					if (weights[k] != null) weights[k] = weights[k] * boost;
				}

				const out = defaultChances.map(entry => ({ color: entry.color, weight: weights[entry.color] || 1 }));
				// Sanity clamp
				return out.map(e => ({ color: e.color, weight: Math.max(0.01, Number(e.weight) || 1) }));
			} catch (e) {
				return null;
			}
		}

		function refreshObjectiveDrivenBonusBias() {
			try {
				const chances = computeObjectiveDrivenBonusColorChances();
				if (typeof window !== 'undefined') {
					window.__objectiveBonusColorChances = Array.isArray(chances) ? chances : null;
				}
			} catch (_) {
				try { if (typeof window !== 'undefined') window.__objectiveBonusColorChances = null; } catch (e) {}
			}
		}

		function renderObjectivePanel(snapshot = latestScoreSnapshot) {
			// Keep objective-driven bonus bias in sync whenever the objective UI is rendered.
			refreshObjectiveDrivenBonusBias();
			// If a custom board with metadata was loaded, show a compiled objective and its progress
			if (window && window.loadedCustomLevelMeta && (window.loadedCustomLevelMeta.name || window.loadedCustomLevelMeta.objective)) {
				const titleEl = document.querySelector('#objective-zone h2');
				const currentEl = document.getElementById('objective-current');
				if (titleEl && window.loadedCustomLevelMeta.name) titleEl.textContent = window.loadedCustomLevelMeta.name;
				const objText = (window.loadedCustomLevelMeta.objective || '').trim() || 'Haal 100 punten';
				const compiled = window.loadedCustomObjectiveCompiled || parseObjectiveTextToObjective(objText);
				const progressSource = snapshot || {
					yellow,
					red,
					green,
					purple,
					blue,
					bonus,
					bonusesCollected: totalBonusesCollected,
					total: yellow + red + green + purple + blue + bonus
				};
				let done = false;
				try { done = !!compiled.check(progressSource); } catch (e) { done = false; }
				if (currentEl) {
					currentEl.classList.toggle('objective-empty-state', false);
					if (done) {
						currentEl.innerHTML = `<strong>Doel:</strong> ${stripObjectiveSymbols(compiled.description)} <span style="opacity: 0.85;">(voltooid)</span>`;
					} else {
						let desc = stripObjectiveSymbols(compiled.description);
						if (typeof compiled.progress === 'function') {
							try {
								const p = normalizeObjectiveProgress(compiled.progress(progressSource));
								if (p) desc = `${desc} (${p})`;
							} catch (err) { /* ignore */ }
						}
						currentEl.innerHTML = `<strong>Doel:</strong> ${desc}`;
					}
				}
				return;
			}
			const currentEl = document.getElementById('objective-current');
			const historyEl = document.getElementById('objective-history');
			const titleEl = document.querySelector('#objective-zone h2');
			if (!currentEl || !historyEl) return;
			
			// Update titel met level nummer EN world indicator
			if (titleEl) {
				const { world, subLevel, intro } = getWorldAndSubLevel(currentLevel);
				if (currentLevel === 0 || intro) {
					titleEl.textContent = 'Intro';
					titleEl.style.background = '';
					titleEl.style.webkitBackgroundClip = '';
					titleEl.style.webkitTextFillColor = '';
				} else if (world === 1) {
					titleEl.textContent = `Level ${currentLevel}`;
					titleEl.style.background = '';
					titleEl.style.webkitBackgroundClip = '';
					titleEl.style.webkitTextFillColor = '';
				} else if (world === 2) {
					titleEl.textContent = `Wereld ${world} - Level ${world}.${subLevel}`;
					titleEl.style.background = 'linear-gradient(135deg, #5689b0, #8f76b8)';
					titleEl.style.webkitBackgroundClip = 'text';
					titleEl.style.webkitTextFillColor = 'transparent';
				} else if (world === 3) {
					titleEl.textContent = `Wereld ${world} - Level ${world}.${subLevel}`;
					titleEl.style.background = 'linear-gradient(135deg, #ff6b35, #f7931e, #ffcc02)';
					titleEl.style.webkitBackgroundClip = 'text';
					titleEl.style.webkitTextFillColor = 'transparent';
				} else {
					titleEl.textContent = `Wereld ${world} - Level ${world}.${subLevel}`;
					titleEl.style.background = 'linear-gradient(135deg, #5689b0, #8f76b8)';
					titleEl.style.webkitBackgroundClip = 'text';
					titleEl.style.webkitTextFillColor = 'transparent';
				}
			}

			historyEl.innerHTML = '';
			const objective = getObjectiveById(currentObjectiveId);
			if (!objective) {
				currentEl.classList.add('objective-empty-state');
				currentEl.textContent = 'Geen actief doel voor dit level.';
			} else {
				const progressSource = snapshot || {
					yellow,
					red,
					green,
					purple,
					blue,
					bonus,
					bonusesCollected: totalBonusesCollected,
					total: yellow + red + green + purple + blue + bonus
				};
				let isDone = false;
				try {
					isDone = !!objective.check(progressSource);
				} catch (error) {
					console.warn('Objective check failed', objective.id, error);
					isDone = false;
				}
				currentEl.classList.toggle('objective-empty-state', false);
				if (isDone) {
					// Voeg vinkje toe voor voltooide doelen, verwijder "Level X:" uit description
					let desc = objective.description.replace(/^Level\s+\d+:\s*/i, '');
					desc = stripObjectiveSymbols(desc);
					currentEl.innerHTML = `<strong>Doel:</strong> ${desc} <span style="opacity: 0.85;">(voltooid)</span>`;
				} else {
					let description = objective.description.replace(/^Level\s+\d+:\s*/i, '');
					description = stripObjectiveSymbols(description);
					if (typeof objective.progress === 'function') {
						try {
							const progressText = normalizeObjectiveProgress(objective.progress(progressSource));
							if (progressText) description = `${description} (${progressText})`;
						} catch (error) { /* ignore */ }
					}
					currentEl.innerHTML = `<strong>Doel:</strong> ${description}`;
				}
			}
			// Verberg "nog geen doelen voltooid" op desktop
			if (completedObjectives.length === 0) {
				// Laat leeg op desktop
				historyEl.innerHTML = '';
			} else {
				completedObjectives.forEach(obj => {
					const item = document.createElement('li');
					const raw = obj.short || obj.description;
					item.textContent = stripObjectiveSymbols(String(raw || '').replace(/^Level\s+\d+:\s*/i, ''));
					historyEl.appendChild(item);
				});
			}
		}

		function resetObjectives() {
			currentObjectiveId = null;
			completedObjectives.length = 0;
			completedObjectiveIds.clear();
			latestScoreSnapshot = null;
			if (objectiveToastTimeout) {
				clearTimeout(objectiveToastTimeout);
				objectiveToastTimeout = null;
			}
			const toast = document.querySelector('.objective-toast');
			if (toast) toast.classList.remove('show');
			if (objectivePopupTimeout) {
				clearTimeout(objectivePopupTimeout);
				objectivePopupTimeout = null;
			}
			const popup = document.querySelector('.objective-popup');
			if (popup) popup.classList.remove('show');
			// Reset UI visueel
			const checkmark = document.querySelector('#objective-status');
			if (checkmark) checkmark.textContent = '';
			// Reset objective highlights
			clearObjectiveHighlights();
			renderObjectivePanel();
		}

		function updateObjectives(scores) {
			// If a custom board was loaded with a free-text objective, evaluate that first
			if (window && window.loadedCustomLevelMeta && window.loadedCustomLevelMeta.objective) {
				const compiled = window.loadedCustomObjectiveCompiled || parseObjectiveTextToObjective(window.loadedCustomLevelMeta.objective || '');
				const snapshotCustom = scores || latestScoreSnapshot || {
					yellow,
					red,
					green,
					purple,
					blue,
					bonus,
					bonusesCollected: totalBonusesCollected,
					total: yellow + red + green + purple + blue + bonus
				};
				latestScoreSnapshot = snapshotCustom;
				let achievedCustom = false;
				try { achievedCustom = !!compiled.check(snapshotCustom); } catch (e) { achievedCustom = false; }
				if (achievedCustom) {
					if (!window.loadedCustomLevelMetaCompleted) {
						window.loadedCustomLevelMetaCompleted = true;
						showObjectiveToast(`Doel behaald: ${compiled.short || compiled.description}`);
						showObjectiveCompletionPopup(compiled.short || compiled.description);
						// Intro tutorial: stop highlighting card picker once the objective is achieved.
						try {
							if (tutorialState.active && currentLevel === 0) {
								stopCardPickerHighlight();
								try { highlightIntroPurpleCard(); } catch (_) {}
							}
						} catch (_) {}
					}
				} else if (window.loadedCustomLevelMetaCompleted) {
					window.loadedCustomLevelMetaCompleted = false;
				}
				renderObjectivePanel(snapshotCustom);
				return;
			}
			const objective = getObjectiveById(currentObjectiveId);
			if (!objective) {
				renderObjectivePanel();
				return;
			}
			if (objective.level && objective.level !== currentLevel) {
				renderObjectivePanel();
				return;
			}
			const snapshot = scores || latestScoreSnapshot || {
				yellow,
				red,
				green,
				purple,
				blue,
				bonus,
				bonusesCollected: totalBonusesCollected,
				total: yellow + red + green + purple + blue + bonus
			};
			latestScoreSnapshot = snapshot;
			let achieved = false;
			try {
				achieved = !!objective.check(snapshot);
			} catch (error) {
				console.warn('Objective check failed', objective.id, error);
				return;
			}
			if (achieved) {
				if (!completedObjectiveIds.has(objective.id)) {
					completedObjectiveIds.add(objective.id);
					completedObjectives.push(objective);
					showObjectiveToast(`Doel behaald: ${objective.short || objective.description}`);
					showObjectiveCompletionPopup(objective.short || objective.description);
					// Intro tutorial: stop highlighting card picker once the objective is achieved.
					try {
						if (tutorialState.active && currentLevel === 0) {
							stopCardPickerHighlight();
							try { highlightIntroPurpleCard(); } catch (_) {}
						}
					} catch (_) {}
				}
			} else if (completedObjectiveIds.has(objective.id)) {
				// Objective can become un-achieved (e.g. undo). Keep UI/state in sync.
				completedObjectiveIds.delete(objective.id);
				const idx = completedObjectives.findIndex(obj => obj && obj.id === objective.id);
				if (idx >= 0) completedObjectives.splice(idx, 1);
			}
			renderObjectivePanel(snapshot);
		}

	function highlightAchievedObjectiveScores(scores) {
		// If a custom loaded objective exists, use that description for highlighting
		let objectiveDesc = null;
		let objectiveId = null;
		let currentObjective = null;
		if (window && window.loadedCustomLevelMeta && window.loadedCustomLevelMeta.objective) {
			objectiveDesc = window.loadedCustomLevelMeta.objective || '';
			objectiveId = window.loadedCustomLevelMeta.name || 'custom';
		} else {
			currentObjective = getObjectiveById(currentObjectiveId);
			if (!currentObjective) { clearObjectiveHighlights(); return; }
			objectiveDesc = currentObjective.description || '';
			objectiveId = currentObjective.id || '';
		}
		
		// Eerst alle highlights verwijderen
		clearObjectiveHighlights();
		
		const extractMentionedColors = (descText, idText) => {
			const out = new Set();
			const patterns = [
				{ key: 'yellow', re: /\b(?:geel|gele)\b/i },
				{ key: 'red', re: /\b(?:rood|rode)\b/i },
				{ key: 'green', re: /\b(?:groen|groene)\b/i },
				{ key: 'purple', re: /\b(?:paars|paarse)\b/i },
				{ key: 'blue', re: /\b(?:blauw|blauwe)\b/i }
			];
			patterns.forEach(p => { if (p.re.test(descText || '')) out.add(p.key); });
			if (out.size === 0 && /diagona|kolom|segment/i.test(descText || '')) out.add('yellow');
			const lid = String(idText || '').toLowerCase();
			if (out.size === 0) {
				if (lid.includes('yellow') || lid.includes('geel')) out.add('yellow');
				else if (lid.includes('red') || lid.includes('rood')) out.add('red');
				else if (lid.includes('green') || lid.includes('groen')) out.add('green');
				else if (lid.includes('purple') || lid.includes('paars')) out.add('purple');
				else if (lid.includes('blue') || lid.includes('blauw')) out.add('blue');
			}
			return out;
		};

		const mentionedColors = extractMentionedColors(objectiveDesc, objectiveId);
		let objectiveMet = false;
		try {
			if (window && window.loadedCustomObjectiveCompiled && typeof window.loadedCustomObjectiveCompiled.check === 'function') {
				objectiveMet = !!window.loadedCustomObjectiveCompiled.check(scores);
			} else if (currentObjective && typeof currentObjective.check === 'function') {
				objectiveMet = !!currentObjective.check(scores);
			}
		} catch (_) {
			objectiveMet = false;
		}

		// Controleer welke scores voldoen aan de objective eisen
		// Parse de objective beschrijving om score eisen te vinden
		// Check voor totaal score eisen (meer varianten ondersteunen)
		const extractMinTotal = (desc) => {
			if (!desc) return null;
			const s = String(desc);
			let m;
			m = s.match(/(\d+)\s*(?:punten|pt)\s*(?:totaal|in\s*totaal)/i);
			if (m) return parseInt(m[1], 10);
			m = s.match(/(?:totaal|in\s*totaal|totale\s*score|score\s*totaal|totaalscore)\s*(?:van\s*)?(\d+)/i);
			if (m) return parseInt(m[1], 10);
			return null;
		};
		const minTotal = extractMinTotal(objectiveDesc);
		if (Number.isFinite(minTotal) && scores.total >= minTotal) {
			const totalEl = document.querySelector('#scoreboard .score-total');
			if (totalEl) totalEl.classList.add('objective-achieved');
		}
		
		// Check voor kleur specifieke eisen (ondersteunt ook: "paarse zone", "gele" etc)
		const pickNumber = (m) => {
			if (!m) return null;
			const raw = (m[1] != null ? m[1] : null) || (m[2] != null ? m[2] : null);
			const n = raw != null ? parseInt(raw, 10) : NaN;
			return Number.isFinite(n) ? n : null;
		};
		const colorPatterns = [
			{ name: 'yellow', regex: /(?:in\s*(?:de\s*)?(?:gele|geel)(?:\s*zone)?\s*(?:minstens\s*)?(\d+)\s*(?:punten|pt)?)|(\d+)\s*(?:punten|pt)?\s*(?:in\s*)?(?:de\s*)?(?:gele|geel)(?:\s*zone)?/i },
			{ name: 'red', regex: /(?:in\s*(?:de\s*)?(?:rode|rood)(?:\s*zone)?\s*(?:minstens\s*)?(\d+)\s*(?:punten|pt)?)|(\d+)\s*(?:punten|pt)?\s*(?:in\s*)?(?:de\s*)?(?:rode|rood)(?:\s*zone)?/i },
			{ name: 'green', regex: /(?:in\s*(?:de\s*)?(?:groene|groen)(?:\s*zone)?\s*(?:minstens\s*)?(\d+)\s*(?:punten|pt)?)|(\d+)\s*(?:punten|pt)?\s*(?:in\s*)?(?:de\s*)?(?:groene|groen)(?:\s*zone)?/i },
			{ name: 'purple', regex: /(?:in\s*(?:de\s*)?(?:paarse|paars)(?:\s*zone)?\s*(?:minstens\s*)?(\d+)\s*(?:punten|pt)?)|(\d+)\s*(?:punten|pt)?\s*(?:in\s*)?(?:de\s*)?(?:paarse|paars)(?:\s*zone)?/i },
			{ name: 'blue', regex: /(?:in\s*(?:de\s*)?(?:blauwe|blauw)(?:\s*zone)?\s*(?:minstens\s*)?(\d+)\s*(?:punten|pt)?)|(\d+)\s*(?:punten|pt)?\s*(?:in\s*)?(?:de\s*)?(?:blauwe|blauw)(?:\s*zone)?/i }
		];
		
		colorPatterns.forEach(({ name, regex }) => {
			const match = objectiveDesc.match(regex);
			const minScore = pickNumber(match);
			if (Number.isFinite(minScore) && scores[name] >= minScore) {
				const row = document.querySelector(`.score-row.${name}`);
				if (row) row.classList.add('objective-achieved');
			}
		});
		
		// Check voor "minstens X in elke kleur" patronen
		const allColorsMatch = objectiveDesc.match(/minstens\s*(\d+)\s*(?:punten|pt)?\s*(?:in\s*)?(?:de\s*kleuren|elke\s*kleur)/i);
		if (allColorsMatch) {
			const minScore = parseInt(allColorsMatch[1], 10);
			['yellow', 'red', 'green', 'purple', 'blue'].forEach(color => {
				if (scores[color] >= minScore) {
					const row = document.querySelector(`.score-row.${color}`);
					if (row) row.classList.add('objective-achieved');
				}
			});
		}
		
		// Check voor specifieke patronen zoals "8 punten in paars Ã©n 6 in geel"
		// Ook ondersteund: "8 punten in groen Ã©n in paars" (zelfde drempel voor meerdere kleuren)
		const sharedThresholdMultiColorPattern = /(\d+)\s*(?:punten|pt)?\s*(?:in\s*)?(?:de\s*)?(gele|geel|rode|rood|groene|groen|paarse|paars|blauwe|blauw)\s*(?:zone)?\s*(?:Ã©n|en)\s*(?:in\s*)?(?:de\s*)?(gele|geel|rode|rood|groene|groen|paarse|paars|blauwe|blauw)/gi;
		let sharedMatch;
		while ((sharedMatch = sharedThresholdMultiColorPattern.exec(objectiveDesc)) !== null) {
			const minScore = parseInt(sharedMatch[1], 10);
			const color1Name = sharedMatch[2];
			const color2Name = sharedMatch[3];
			const colorMap = { 'geel': 'yellow', 'gele': 'yellow', 'rood': 'red', 'rode': 'red', 'groen': 'green', 'groene': 'green', 'paars': 'purple', 'paarse': 'purple', 'blauw': 'blue', 'blauwe': 'blue' };
			const color1 = colorMap[color1Name];
			const color2 = colorMap[color2Name];
			if (color1 && scores[color1] >= minScore) {
				const row = document.querySelector(`.score-row.${color1}`);
				if (row) row.classList.add('objective-achieved');
			}
			if (color2 && scores[color2] >= minScore) {
				const row = document.querySelector(`.score-row.${color2}`);
				if (row) row.classList.add('objective-achieved');
			}
		}

		const multiColorPattern = /(\d+)\s*(?:punten|pt)?\s*(?:in\s*)?(?:de\s*)?(gele|geel|rode|rood|groene|groen|paarse|paars|blauwe|blauw)\s*(?:zone)?\s*(?:Ã©n|en)\s*(\d+)\s*(?:punten|pt)?\s*(?:in\s*)?(?:de\s*)?(gele|geel|rode|rood|groene|groen|paarse|paars|blauwe|blauw)\s*(?:zone)?/gi;
		let multiMatch;
		while ((multiMatch = multiColorPattern.exec(objectiveDesc)) !== null) {
			const score1 = parseInt(multiMatch[1], 10);
			const color1Name = multiMatch[2];
			const score2 = parseInt(multiMatch[3], 10);
			const color2Name = multiMatch[4];
			
			const colorMap = { 'geel': 'yellow', 'gele': 'yellow', 'rood': 'red', 'rode': 'red', 'groen': 'green', 'groene': 'green', 'paars': 'purple', 'paarse': 'purple', 'blauw': 'blue', 'blauwe': 'blue' };
			const color1 = colorMap[color1Name];
			const color2 = colorMap[color2Name];
			
			if (color1 && scores[color1] >= score1) {
				const row = document.querySelector(`.score-row.${color1}`);
				if (row) row.classList.add('objective-achieved');
			}
			if (color2 && scores[color2] >= score2) {
				const row = document.querySelector(`.score-row.${color2}`);
				if (row) row.classList.add('objective-achieved');
			}
		}

		// Fallback: if the objective check is fulfilled (even for non-point goals like kolommen/diagonalen),
		// highlight the colors that the objective refers to.
		if (objectiveMet && mentionedColors.size > 0) {
			mentionedColors.forEach(color => {
				const row = document.querySelector(`.score-row.${color}`);
				if (row) row.classList.add('objective-achieved');
			});
		}
	}
	
	function clearObjectiveHighlights() {
		// Verwijder alle objective-achieved classes
		document.querySelectorAll('.score-row.objective-achieved').forEach(el => {
			el.classList.remove('objective-achieved');
		});
		const totalEl = document.querySelector('#scoreboard .score-total.objective-achieved');
		if (totalEl) totalEl.classList.remove('objective-achieved');
	}

	// ========== INTERACTIEVE TUTORIAL (EERSTE START) ==========
	const TUTORIAL_STORAGE_KEY = 'locus_tutorial_v1_done';
	const tutorialState = {
		active: false,
		cardSelected: false,
		cardPlaced: false,
		bonusPlaced: false,
		bonusReady: false,
		glowTargets: new Set(),
		timers: [],
		overlay: null,
		ghost: null
	};
	let keyboardRotateTipShown = false;

	function isTutorialCompleted() {
		try { return localStorage.getItem(TUTORIAL_STORAGE_KEY) === '1'; } catch (_) { return false; }
	}

	function markTutorialDone() {
		tutorialState.active = false;
		try { localStorage.setItem(TUTORIAL_STORAGE_KEY, '1'); } catch (_) {}
		clearTutorialHighlights();
		hideTutorialOverlay();
		hideTutorialGhost();
	}

	function ensureTutorialOverlay() {
		if (tutorialState.overlay && document.body.contains(tutorialState.overlay)) return tutorialState.overlay;
		const overlay = document.createElement('div');
		overlay.id = 'tutorial-overlay';
		const ghost = document.createElement('div');
		ghost.id = 'tutorial-ghost';
		ghost.innerHTML = `<div class="ghost-label"></div><div class="ghost-rotate-hint"></div><div class="ghost-shape"></div>`;
		overlay.dataset.tutorial = 'overlay';
		document.body.appendChild(overlay);
		document.body.appendChild(ghost);
		tutorialState.overlay = overlay;
		tutorialState.ghost = ghost;
		return overlay;
	}

	function showTutorialOverlay(contentHtml, buttonLabel, onStart) {
		const overlay = ensureTutorialOverlay();
		overlay.innerHTML = `<div class="tutorial-card">${contentHtml}<button type="button" id="tutorial-start-btn">${buttonLabel || 'Start!'}</button></div>`;
		overlay.style.display = 'flex';
		const btn = overlay.querySelector('#tutorial-start-btn');
		if (btn) btn.onclick = () => { overlay.style.display = 'none'; if (typeof onStart === 'function') onStart(); };
	}

	function hideTutorialOverlay() {
		if (tutorialState.overlay) tutorialState.overlay.style.display = 'none';
	}

	function addGlow(el, soft = false) {
		if (!el) return;
		el.classList.remove('tutorial-glow', 'tutorial-glow-soft');
		el.classList.add(soft ? 'tutorial-glow-soft' : 'tutorial-glow');
		tutorialState.glowTargets.add(el);
	}

	function removeGlow(el) {
		if (!el) return;
		el.classList.remove('tutorial-glow', 'tutorial-glow-soft');
		tutorialState.glowTargets.delete(el);
	}

	function clearTutorialHighlights() {
		tutorialState.glowTargets.forEach(el => el.classList.remove('tutorial-glow', 'tutorial-glow-soft'));
		tutorialState.glowTargets.clear();
		tutorialState.timers.forEach(id => clearTimeout(id));
		tutorialState.timers = [];
	}

	function hideTutorialGhost() {
		if (!tutorialState.ghost) return;
		tutorialState.ghost.style.display = 'none';
	}

	function findFirstPlayablePlacement(cardData) {
		if (!cardData) return null;
		const colorName = cardData.color?.name || null;
		const zones = getCandidateZonesForColor(colorName) || [];
		for (const zone of zones) {
			const rows = parseInt(zone.dataset.rows || '0', 10) || 0;
			const cols = parseInt(zone.dataset.cols || '0', 10) || 0;
			if (!rows || !cols) continue;
			for (let y = 0; y < rows; y += 1) {
				for (let x = 0; x < cols; x += 1) {
					if (canPlace(zone, x, y, cardData.matrix)) {
						const cell = getCell(zone, x, y);
						return { zone, x, y, cell };
					}
				}
			}
		}
		return null;
	}

	function renderTutorialGhostShape(ghostShapeEl, shape, color) {
		if (!ghostShapeEl) return;
		ghostShapeEl.innerHTML = '';
		if (!shape || !Array.isArray(shape) || !shape.length) return;
		// Normalize ragged shapes so the ghost preview matches the card shape.
		const cols = Math.max(...shape.map(row => (Array.isArray(row) ? row.length : 0)), 0);
		const rows = shape.length;
		if (!cols || !rows) return;
		const paddedShape = shape.map(row => {
			const copy = Array.isArray(row) ? row.slice() : [];
			while (copy.length < cols) copy.push(0);
			return copy;
		});

		// Keep the ghost roughly the same footprint as before (64x64),
		// but render multi-cell shapes by shrinking per-cell size.
		const maxBox = 64;
		const maxDim = Math.max(rows, cols);
		const gapPx = 4;
		let cellSize = Math.floor((maxBox - gapPx * (maxDim - 1)) / maxDim);
		cellSize = Math.max(10, Math.min(52, cellSize));
		const cellRadius = Math.max(4, Math.min(10, Math.round(cellSize / 3)));

		const colorCode = (typeof color === 'object' && color && color.code) ? color.code : null;
		const colorName = (typeof color === 'object' && color && color.name) ? String(color.name).toLowerCase() : '';
		let fillStyle = null;
		if (colorCode === 'rainbow' || colorName.includes('multikleur') || colorName.includes('rainbow')) {
			fillStyle = 'linear-gradient(45deg, #f06272, #fff25a, #4ed346, #5d90f0, #a35eff)';
		} else if (colorName.includes('paars') || colorName.includes('purple')) {
			// Preserve the existing tutorial purple look.
			fillStyle = 'linear-gradient(135deg, #b490dc, #8f76b8)';
		} else if (colorCode) {
			fillStyle = colorCode;
		} else {
			// Fallback: preserve the existing default ghost look.
			fillStyle = 'linear-gradient(135deg, rgba(59,130,246,0.95), rgba(16,185,129,0.95))';
		}

		const grid = document.createElement('div');
		grid.className = 'ghost-shape-grid';
		grid.style.gap = `${gapPx}px`;
		grid.style.gridTemplateColumns = `repeat(${cols}, ${cellSize}px)`;
		grid.style.gridTemplateRows = `repeat(${rows}, ${cellSize}px)`;

		paddedShape.forEach((row) => {
			row.forEach((val) => {
				const cell = document.createElement('div');
				cell.className = 'ghost-shape-cell';
				cell.style.width = `${cellSize}px`;
				cell.style.height = `${cellSize}px`;
				cell.style.borderRadius = `${cellRadius}px`;
				if (val) {
					cell.style.background = fillStyle;
				} else {
					cell.style.visibility = 'hidden';
					cell.style.boxShadow = 'none';
				}
				grid.appendChild(cell);
			});
		});

		ghostShapeEl.appendChild(grid);
	}

	function showTutorialGhost(cardEl, cardData) {
		const ghost = ensureTutorialOverlay() && tutorialState.ghost;
		if (!ghost || !cardEl) return;
		// If the intro objective is already met, do not show the ghost anymore.
		try {
			if (tutorialState.active && currentLevel === 0 && typeof isCurrentObjectiveCompleted === 'function' && isCurrentObjectiveCompleted()) {
				hideTutorialGhost();
				return;
			}
		} catch (_) {}
		const cardRect = cardEl.getBoundingClientRect();
		const placement = findFirstPlayablePlacement(cardData);
		const targetRect = placement?.cell?.getBoundingClientRect();
		const startX = cardRect.left + cardRect.width / 2;
		const startY = cardRect.top + cardRect.height / 2;
		let endX = targetRect ? (targetRect.left + targetRect.width / 2) : (window.innerWidth * 0.55);
		const endY = targetRect ? (targetRect.top + targetRect.height / 2) : (window.innerHeight * 0.55);
		const label = ghost.querySelector('.ghost-label');
		const rotateHint = ghost.querySelector('.ghost-rotate-hint');
		const colorName = (cardData?.color?.name || '').toLowerCase();
		const isTouch = (('ontouchstart' in window) || (navigator?.maxTouchPoints > 0));
		if (label) {
			if (colorName.includes('paars')) label.textContent = 'Sleep naar het paarse vlak';
			else if (colorName.includes('geel')) label.textContent = 'Sleep naar links in geel';
			else if (colorName.includes('blauw')) label.textContent = 'Start onderaan in blauw';
			else if (colorName.includes('groen')) label.textContent = 'Start bij de startcel in groen';
			else label.textContent = 'Sleep naar het bord';
		}
		if (rotateHint) {
			if (isTouch) {
				rotateHint.style.display = 'none';
			} else {
				rotateHint.textContent = 'Draai met R Â· Spiegel met T';
				rotateHint.style.display = 'block';
			}
		}
		const ghostShape = ghost.querySelector('.ghost-shape');
		if (colorName.includes('paars')) {
			// Trek de ghost iets meer richting links (paarse zone) als er geen specifiek doel is.
			if (!targetRect) endX = Math.max(30, endX - 200);
			else endX = Math.max(30, endX - 170);
			ghost.style.background = 'rgba(143, 118, 184, 0.15)';
			ghost.style.borderColor = '#8f76b8';
			if (ghostShape) renderTutorialGhostShape(ghostShape, cardData?.matrix, cardData?.color);
		} else {
			ghost.style.background = 'rgba(255, 255, 255, 0.12)';
			ghost.style.borderColor = 'rgba(255, 255, 255, 0.65)';
			if (ghostShape) renderTutorialGhostShape(ghostShape, cardData?.matrix, cardData?.color);
		}
		ghost.style.display = 'block';
		ghost.style.transition = 'none';
		ghost.style.transform = `translate(${startX - 32}px, ${startY - 32}px)`;
		requestAnimationFrame(() => {
			ghost.style.transition = 'transform 0.9s ease, opacity 0.9s ease';
			ghost.style.transform = `translate(${endX - 32}px, ${endY - 32}px)`;
		});
	}

	function highlightObjectiveBlock() {
		const objectiveZone = document.getElementById('objective-zone');
		if (!objectiveZone) return;
		addGlow(objectiveZone, true);
		const t = setTimeout(() => removeGlow(objectiveZone), 5000);
		tutorialState.timers.push(t);
	}

	function highlightCardPicker() {
		const cardZone = document.getElementById('card-choice-zone');
		if (!cardZone) return;
		// Intro tutorial: once the objective is achieved, don't keep highlighting "kies een kaart".
		try {
			if (tutorialState.active && currentLevel === 0 && typeof isCurrentObjectiveCompleted === 'function' && isCurrentObjectiveCompleted()) {
				removeGlow(cardZone);
				return;
			}
		} catch (_) {}
		addGlow(cardZone, false);
	}

	function highlightIntroPurpleCard() {
		if (!tutorialState.active || currentLevel !== 0) return;
		// If the intro objective is already met, do NOT keep nudging the player to play a second purple card.
		// This prevents the second purple tetris card from being highlighted after the goal is achieved.
		try {
			if (typeof isCurrentObjectiveCompleted === 'function' && isCurrentObjectiveCompleted()) {
				const container = document.getElementById('card-options');
				if (container) {
					container
						.querySelectorAll('.card-option[data-color="paars"], .card-option[data-color="purple"]')
						.forEach(el => removeGlow(el));
				}
				const purpleZone = document.getElementById('purple-zone');
				if (purpleZone) removeGlow(purpleZone);
				return;
			}
		} catch (_) {}
		const container = document.getElementById('card-options');
		if (!container) return;
		const purpleCard = container.querySelector('.card-option[data-color="paars"], .card-option[data-color="purple"]');
		if (purpleCard) addGlow(purpleCard, false);
		const purpleZone = document.getElementById('purple-zone');
		if (purpleZone) addGlow(purpleZone, true);
	}

	function stopCardPickerHighlight() {
		const cardZone = document.getElementById('card-choice-zone');
		removeGlow(cardZone);
	}

	function highlightNextTurnButton() {
		const btn = document.getElementById('new-cards-btn');
		if (!btn) return;
		addGlow(btn, false);
	}

	function stopNextTurnHighlight() {
		const btn = document.getElementById('new-cards-btn');
		removeGlow(btn);
	}

	function highlightBonusInventory() {
		const container = document.getElementById('bonus-inventory');
		if (!container) return;
		addGlow(container, true);
	}

	function clearPurplePairHighlight() {
		const zone = document.getElementById('purple-zone');
		if (!zone) return;
		zone.querySelectorAll('.purple-pair-cell.purple-highlight').forEach(el => el.classList.remove('purple-highlight'));
	}

	function highlightPurplePair() {
		const zone = document.getElementById('purple-zone');
		if (!zone) return;
		clearPurplePairHighlight();
		let targets = Array.from(zone.querySelectorAll('.purple-pair-cell'));
		if (targets.length < 2) {
			const bolds = Array.from(zone.querySelectorAll('.cell.bold-cell:not(.void-cell)'));
			let pair = null;
			for (let i = 0; i < bolds.length; i += 1) {
				for (let j = i + 1; j < bolds.length; j += 1) {
					const a = bolds[i];
					const b = bolds[j];
					if (!a || !b) continue;
					const dx = Math.abs(Number(a.dataset.x) - Number(b.dataset.x));
					const dy = Math.abs(Number(a.dataset.y) - Number(b.dataset.y));
					if (dx + dy === 1) { pair = [a, b]; break; }
				}
				if (pair) break;
			}
			if (pair) targets = pair;
		}
		targets.slice(0, 2).forEach(el => el.classList.add('purple-highlight'));
	}

	function stopBonusHighlight() {
		const container = document.getElementById('bonus-inventory');
		removeGlow(container);
	}

	function startInteractiveTutorial() {
		if (tutorialState.active) return;
		if (isTutorialCompleted()) return;
		tutorialState.active = true;
		const objective = getObjectiveById ? getObjectiveById(currentObjectiveId) : null;
		const desc = objective ? objective.description || objective.short || '' : 'Voltooi je eerste doel';
		const popupHtml = `
			<h3>Welkom in Locus!</h3>
			<p>Jouw eerste doel: ${stripObjectiveSymbols(desc)}</p>
			<p>Verbind twee dikgedrukte cellen met elkaar om punten te halen.</p>
		`;
		showTutorialOverlay(popupHtml, 'Start!', () => {
			highlightObjectiveBlock();
			const t = setTimeout(() => {
				highlightCardPicker();
				const inner = setTimeout(() => highlightIntroPurpleCard(), 600);
				tutorialState.timers.push(inner);
			}, 2000);
			tutorialState.timers.push(t);
		});
	}

	function scheduleTutorialOnFirstRun() {
		if (isTutorialCompleted()) return;
		if (currentLevel !== 0 || isLoadingGame) return;
		const t = setTimeout(() => startInteractiveTutorial(), 600);
		tutorialState.timers.push(t);
	}

	document.addEventListener('locus:tutorial-card-selected', event => {
		if (!tutorialState.active) return;
		stopCardPickerHighlight();
		const cardEl = event.detail?.element || null;
		const cardData = event.detail?.cardData || null;
		if (cardEl) removeGlow(cardEl);
		showTutorialGhost(cardEl, cardData);
	});

	document.addEventListener('locus:tutorial-card-selected', event => {
		const colorName = (event.detail?.cardData?.color?.name || '').toLowerCase();
		if (colorName.includes('paars') || colorName.includes('purple')) {
			highlightPurplePair();
		} else {
			clearPurplePairHighlight();
		}
	});

	document.addEventListener('locus:tutorial-card-selected', event => {
		if (keyboardRotateTipShown) return;
		try {
			const isTouch = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);
			if (isTouch) return;
			showObjectiveToast('Tip: draai met R, spiegel met T.');
			keyboardRotateTipShown = true;
		} catch (_) {}
	});

	document.addEventListener('locus:tutorial-card-selected', () => {
		try {
			const isTouch = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);
			if (!isTouch) return;
			const rotateBtn = document.getElementById('floating-preview-rotate');
			const mirrorBtn = document.getElementById('floating-preview-mirror');
			if (rotateBtn) addGlow(rotateBtn, false);
			if (mirrorBtn) addGlow(mirrorBtn, false);
			setTimeout(() => {
				if (rotateBtn) removeGlow(rotateBtn);
				if (mirrorBtn) removeGlow(mirrorBtn);
			}, 4200);
		} catch (_) {}
	});

	document.addEventListener('locus:tutorial-card-placed', () => {
		if (!tutorialState.active) return;
		hideTutorialGhost();
		highlightNextTurnButton();
	});

	document.addEventListener('click', evt => {
		if (!tutorialState.active) return;
		if (evt.target && evt.target.id === 'new-cards-btn') {
			stopNextTurnHighlight();
		}
	});

	document.addEventListener('locus:tutorial-bonus-available', () => {
		if (!tutorialState.active || tutorialState.bonusReady) return;
		const hasAnyBonus = BONUS_ORDER.some(key => (bonusInventory[key] || 0) > 0);
		if (!hasAnyBonus) return;
		tutorialState.bonusReady = true;
		highlightBonusInventory();
		showObjectiveToast('Klik op een verkregen bonus om een extra tetris blok te plaatsen.');
	});

	document.addEventListener('locus:tutorial-bonus-placed', () => {
		if (!tutorialState.active) return;
		stopBonusHighlight();
		tutorialState.bonusPlaced = true;
		markTutorialDone();
	});

	function updateBonusInventoryUI() {
		const container = document.getElementById('bonus-inventory');
		if (!container) return;
		container.innerHTML = '';

		// World 4: only show bonuses for active colors.
		let world4AllowedBonusKeys = null;
		try {
			const info = (typeof getWorldAndSubLevel === 'function') ? getWorldAndSubLevel(currentLevel) : null;
			const isWorld4 = !!(info && Number(info.world) === 4);
			if (isWorld4 && Array.isArray(world4AllowedColors) && world4AllowedColors.length) {
				world4AllowedBonusKeys = BONUS_ORDER.filter(key => {
					const colorNl = WORLD4_BONUS_KEY_TO_COLOR[key];
					return !!(colorNl && world4AllowedColors.includes(colorNl));
				});
			}
		} catch (_) {}
		
		// Voeg gratis plaatsingen toe (als er zijn)
		if (freePlacementsRemaining > 0) {
			const freePlaceButton = document.createElement('button');
			freePlaceButton.type = 'button';
			freePlaceButton.classList.add('bonus-badge', 'free-placement-badge');
			freePlaceButton.title = `Gratis plaatsing (${freePlacementsRemaining})`;
			freePlaceButton.setAttribute('aria-label', `Gratis plaatsing (${freePlacementsRemaining})`);
			freePlaceButton.dataset.bonusKey = 'free';
			freePlaceButton.style.background = 'linear-gradient(135deg, #FFD700, #FFA500)';
			
			const label = document.createElement('div');
			label.classList.add('bonus-label');
			label.textContent = 'Gratis';
			
			const countElem = document.createElement('div');
			countElem.classList.add('bonus-count');
			countElem.textContent = String(freePlacementsRemaining);
			
			freePlaceButton.append(label, countElem);
			freePlaceButton.addEventListener('pointerdown', onBonusPointerDown);
			container.appendChild(freePlaceButton);
		}
		
		const bonusKeysToRender = world4AllowedBonusKeys || BONUS_ORDER;
		bonusKeysToRender.forEach(colorKey => {
			const meta = getBonusMeta(colorKey);
			if (!meta) return;
			const count = bonusInventory[colorKey] || 0;
			const button = document.createElement('button');
			button.type = 'button';
			button.classList.add('bonus-badge');
			button.title = `${meta.label} (${count})`;
			button.setAttribute('aria-label', `${meta.label} (${count})`);
			const upgraded = isBonusUpgraded(colorKey);
			button.classList.toggle('bonus-mastered', upgraded);
			button.dataset.bonusMastered = upgraded ? 'true' : 'false';
			if (count <= 0) {
				button.classList.add('disabled');
				button.disabled = true;
				button.setAttribute('aria-disabled', 'true');
			} else {
				button.disabled = false;
				button.removeAttribute('aria-disabled');
			}
			button.classList.toggle('active', !!(activeBonusPlacement && activeBonusPlacement.colorKey === colorKey));
			if (activeBonusPlacement && activeBonusPlacement.colorKey === colorKey) button.classList.add('active');
			button.dataset.bonusKey = colorKey;
			button.dataset.bonusColor = meta.colorName;
			const label = document.createElement('span');
			label.classList.add('bonus-label');
			label.textContent = meta.label;
			const countEl = document.createElement('span');
			countEl.classList.add('bonus-count');
			countEl.textContent = String(count);
			button.append(label, countEl);
			container.appendChild(button);
		});

		// Tutorial hook: zodra er een bonus beschikbaar is, licht de bonusrij op.
		try {
			const hasAnyBonus = BONUS_ORDER.some(key => (bonusInventory[key] || 0) > 0);
			if (hasAnyBonus) {
				document.dispatchEvent(new CustomEvent('locus:tutorial-bonus-available'));
			}
		} catch (_) {}

		// Laat alleen in het intro-level de bonusbalk oplichten bij de laatste beurt zodra je een bonus ontvangt.
		try {
			const hasAnyBonus = BONUS_ORDER.some(key => (bonusInventory[key] || 0) > 0);
			const noCardsLeft = Array.isArray(currentHand) && currentHand.length === 0;
			const noDrawPile = Array.isArray(drawPile) && drawPile.length === 0;
			const levelNum = (typeof currentLevel !== 'undefined') ? Number(currentLevel) : null;
			const isIntroLevel = levelNum === 0;
			if (hasAnyBonus && noCardsLeft && noDrawPile && isIntroLevel) {
				addGlow(container, true);
				showObjectiveToast('Klik op een verkregen bonus om een extra tetris blok te plaatsen.');
			}
		} catch (_) {}
	}

	function getBonusChargeAmount(colorKey) {
		if (!BONUS_COLOR_CONFIG[colorKey]) return 0;
		let amount = 1;
		if (bonusBoostActiveColors instanceof Set && bonusBoostActiveColors.has(colorKey)) {
			amount = 2;
		}
		return amount;
	}	function markActiveBonusButton(colorKey) {
		const container = document.getElementById('bonus-inventory');
		if (!container) return;
		container.querySelectorAll('.bonus-badge').forEach(btn => {
			const key = btn.dataset.bonusKey;
			btn.classList.toggle('active', !!colorKey && key === colorKey);
		});
	}

	function addBonusCharge(colorKey, amount = 1, options = {}) {
		if (!BONUS_COLOR_CONFIG[colorKey]) return 0;
		const count = Math.max(0, Number(amount) || 0);
		if (count === 0) return 0;
		bonusInventory[colorKey] = (bonusInventory[colorKey] || 0) + count;
		if (options.trackCollection !== false) {
			totalBonusesCollected += count;
		}
		updateBonusInventoryUI();
		return count;
	}

	function grantBonusCharge(colorKey) {
		if (!BONUS_COLOR_CONFIG[colorKey]) return 0;
		const chargeAmount = getBonusChargeAmount(colorKey) || 1;
		return addBonusCharge(colorKey, chargeAmount, { trackCollection: true });
	}

	function spendBonusCharge(colorKey) {
		// Handle gratis plaatsing
		if (colorKey === 'free') {
			if (freePlacementsRemaining <= 0) return false;
			freePlacementsRemaining -= 1;
			updateBonusInventoryUI();
			return true;
		}
		
		// Handle gekochte plaatsing (munten al betaald)
		if (colorKey === 'purchased') {
			return true; // Munten zijn al afgeschreven bij aankoop
		}
		
		if (!BONUS_COLOR_CONFIG[colorKey]) return false;
		if ((bonusInventory[colorKey] || 0) <= 0) return false;
		bonusInventory[colorKey] -= 1;
		updateBonusInventoryUI();
		return true;
	}

	function restoreBonusCharge(colorKey) {
		// Handle gratis plaatsing
		if (colorKey === 'free') {
			freePlacementsRemaining += 1;
			updateBonusInventoryUI();
			return;
		}
		// Handle gekochte plaatsing - geef munten terug
		if (colorKey === 'purchased') {
			// Geef de 2 munten terug
			addCoin();
			addCoin();
			updateBuyPlacementButton();
			return;
		}
		if (!BONUS_COLOR_CONFIG[colorKey]) return;
		bonusInventory[colorKey] = (bonusInventory[colorKey] || 0) + 1;
		updateBonusInventoryUI();
	}

	function getBonusKeyFromSymbol(symbolEl) {
		if (!symbolEl) return null;
		return BONUS_ORDER.find(key => symbolEl.classList.contains(key)) || null;
	}

	function createBonusClaim(cell, symbolEl, colorKey, amount = 1) {
		return {
			colorKey,
			cell,
			symbol: symbolEl,
			amount: amount
		};
	}

	function revokeBonusClaim(claim) {
		if (!claim || !claim.colorKey) return;
		const amount = claim.amount || 1;
		totalBonusesCollected = Math.max(0, totalBonusesCollected - amount);
		if (bonusInventory[claim.colorKey] > 0) {
			bonusInventory[claim.colorKey] = Math.max(0, bonusInventory[claim.colorKey] - amount);
		}
		if (claim.cell) {
			delete claim.cell.dataset.bonusConsumed;
		}
		if (claim.symbol && claim.symbol.classList) {
			claim.symbol.classList.remove('bonus-used');
		}
		updateBonusInventoryUI();
	}

	function resetBonusState() {
		cancelActiveBonusPlacement({ updateInventory: false });
		BONUS_ORDER.forEach(key => {
			bonusInventory[key] = 0;
		});
		document.querySelectorAll('.cell[data-bonus-consumed]').forEach(cell => {
			delete cell.dataset.bonusConsumed;
		});
		document.querySelectorAll('.symbol.bonus-used').forEach(symbol => {
			symbol.classList.remove('bonus-used');
		});
		// reset collected counter as well
		totalBonusesCollected = 0;
		updateBonusInventoryUI();
	}

	function grantRandomBonusUpgrade({ silent = false } = {}) {
		const available = BONUS_ORDER
			.filter(key => BONUS_COLOR_CONFIG[key])
			.filter(key => !isBonusUpgraded(key));
		if (!available.length) {
			if (!silent) {
				const fallback = offerFreeRandomLevel2UpgradeFromBonusShop();
				if (!fallback) showObjectiveToast('âœ¨ Alle bonus upgrades zijn al actief.');
			}
			return null;
		}
		const key = available[Math.floor(Math.random() * available.length)];
		setBonusUpgraded(key, true);
		updateBonusInventoryUI();
		if (!silent) {
			const meta = BONUS_COLOR_CONFIG[key];
			showObjectiveToast(`ðŸª Gratis bonus upgrade: ${meta?.colorName || key}!`);
		}
		return key;
	}

	function offerFreeRandomLevel2UpgradeFromBonusShop() {
		try {
			if (typeof getLevel2UpgradeCandidates !== 'function' || typeof applyBonusEchoUpgradeToBlueprint !== 'function') return null;
			const candidates = getLevel2UpgradeCandidates();
			if (!candidates || !candidates.length) {
				showObjectiveToast('âœ¨ Alle kaarten hebben al een Level 2 upgrade.');
				return null;
			}
			const variant = pickBonusEchoVariant();
			openLevel2UpgradeModal(candidates, (pickedBlueprint) => {
				if (!pickedBlueprint) return;
				if (!applyBonusEchoUpgradeToBlueprint(pickedBlueprint, variant)) return;
				const variantLabel = (getBonusEchoUiCopy(variant).sub || variant).toUpperCase();
				showObjectiveToast(`ðŸ” Gratis Level 2 (${variantLabel}) toegevoegd aan je kaart!`);
				updateDeckPreview();
				renderCurrentHand();
				try { updateShopCoinDisplay(); } catch (_) {}
				try { saveGameState(); } catch (_) {}
			}, variant);
			return variant;
		} catch (_) {
			return null;
		}
	}

	function openRandomFreeBonusUpgradeModal() {
		const available = BONUS_ORDER
			.filter(key => BONUS_COLOR_CONFIG[key])
			.filter(key => !isBonusUpgraded(key));
		if (!available.length) {
			showObjectiveToast('âœ¨ Alle bonus upgrades zijn al actief.');
			return null;
		}
		const colorKey = available[Math.floor(Math.random() * available.length)];
		const meta = getBonusMeta(colorKey);
		if (!meta) {
			// Fallback: behave like the old field event.
			return grantRandomBonusUpgrade();
		}

		const shopModalLayer = document.getElementById('shop-modal-layer');
		const shopModalTitle = document.getElementById('shop-modal-title');
		const shopModalMessage = document.getElementById('shop-modal-message');
		const shopCardOptions = document.getElementById('shop-card-options');
		const upgradesSection = document.querySelector('.shop-upgrades-section');
		const bonusSection = document.querySelector('.shop-bonus-section');
		const freePlaceSection = document.querySelector('.shop-freeplace-section');
		const shopBonusContainer = document.getElementById('shop-bonus-container');
		const shopContentGrid = document.querySelector('.shop-content-grid');
		const shopLowerGrid = document.querySelector('.shop-lower-grid');

		if (!shopModalLayer || !shopBonusContainer || !bonusSection) {
			return grantRandomBonusUpgrade();
		}

		// Snapshot current layout so we can restore on close.
		const cardsSection = shopCardOptions ? shopCardOptions.closest('.shop-cards-section') : null;
		const original = {
			gridTemplateColumns: shopContentGrid ? shopContentGrid.style.gridTemplateColumns : '',
			cardsDisplay: cardsSection ? cardsSection.style.display : '',
			upgradesDisplay: upgradesSection ? upgradesSection.style.display : '',
			bonusDisplay: bonusSection ? bonusSection.style.display : '',
			freePlaceDisplay: freePlaceSection ? freePlaceSection.style.display : '',
			lowerGridDisplay: shopLowerGrid ? shopLowerGrid.style.display : '',
			bonusParent: bonusSection.parentElement,
			bonusNext: bonusSection.nextSibling
		};

		const restoreLayout = () => {
			if (shopContentGrid) shopContentGrid.style.gridTemplateColumns = original.gridTemplateColumns;
			if (cardsSection) cardsSection.style.display = original.cardsDisplay;
			if (upgradesSection) upgradesSection.style.display = original.upgradesDisplay;
			if (bonusSection) bonusSection.style.display = original.bonusDisplay;
			if (freePlaceSection) freePlaceSection.style.display = original.freePlaceDisplay;
			if (shopLowerGrid) shopLowerGrid.style.display = original.lowerGridDisplay;
			try {
				if (original.bonusParent && bonusSection.parentElement !== original.bonusParent) {
					original.bonusParent.insertBefore(bonusSection, original.bonusNext || null);
				}
			} catch {}
		};

		// Show ONLY bonus upgrades with one free offer.
		if (cardsSection) cardsSection.style.display = 'none';
		if (upgradesSection) upgradesSection.style.display = 'none';
		if (freePlaceSection) freePlaceSection.style.display = 'none';
		if (shopLowerGrid) shopLowerGrid.style.display = 'none';
		if (shopContentGrid) shopContentGrid.style.gridTemplateColumns = '1fr';
		if (bonusSection) bonusSection.style.display = '';
		if (shopContentGrid && bonusSection.parentElement !== shopContentGrid) {
			shopContentGrid.appendChild(bonusSection);
		}

		shopBonusContainer.innerHTML = '';
		const card = document.createElement('div');
		card.classList.add('shop-bonus-card');
		const info = document.createElement('div');
		info.classList.add('shop-bonus-info');
		const label = document.createElement('span');
		label.textContent = meta.label;
		info.append(label);

		const actions = document.createElement('div');
		actions.classList.add('shop-bonus-actions');
		const claimBtn = document.createElement('button');
		claimBtn.type = 'button';
		claimBtn.classList.add('shop-bonus-upgrade-btn');
		claimBtn.textContent = 'Gratis claimen';
		claimBtn.addEventListener('click', () => {
			if (isBonusUpgraded(colorKey)) return;
			setBonusUpgraded(colorKey, true);
			updateBonusInventoryUI();
			try { updateShopBonusUI(); } catch {}
			try { updateShopCoinDisplay(); } catch {}
			showObjectiveToast(`ðŸª Bonus upgrade geclaimd: ${meta.colorName}!`);
			claimBtn.disabled = true;
			setTimeout(() => {
				// Do NOT trigger the global close handler (it calls skipShop()).
				// We close + restore layout directly to prevent the old shop flashing.
				try { close(); } catch {
					shopModalLayer.classList.remove('show');
					restoreLayout();
				}
			}, 250);
		});
		actions.appendChild(claimBtn);
		card.append(info, actions);
		shopBonusContainer.appendChild(card);

		if (shopModalLayer) shopModalLayer.dataset.mode = 'bonus-only';
		if (shopModalTitle) shopModalTitle.textContent = 'ðŸª Bonus upgrade';
		if (shopModalMessage) shopModalMessage.textContent = 'Je hebt 1 gratis bonus-upgrade gevonden!';
		try { updateShopCoinDisplay(); } catch {}
		shopModalLayer.classList.add('show');

		const shopSkipBtn = document.getElementById('shop-modal-skip');
		const shopCloseBtn = document.getElementById('shop-modal-close');
		let skipOriginalText = null;
		const close = () => {
			if (shopSkipBtn && skipOriginalText !== null) {
				shopSkipBtn.textContent = skipOriginalText;
			}
			if (shopModalLayer) {
				shopModalLayer.classList.remove('show');
				delete shopModalLayer.dataset.mode;
			}
			setTimeout(restoreLayout, 220);
		};
		if (shopSkipBtn) {
			skipOriginalText = shopSkipBtn.textContent;
			shopSkipBtn.textContent = 'Sluiten';
			shopSkipBtn.addEventListener('click', (e) => {
				e.preventDefault();
				e.stopImmediatePropagation();
				close();
			}, { once: true, capture: true });
			shopSkipBtn.addEventListener('touchend', (e) => {
				e.preventDefault();
				e.stopImmediatePropagation();
				close();
			}, { once: true, capture: true });
		}
		if (shopCloseBtn) {
			// Capture phase + stopImmediatePropagation so the global handler (skipShop) won't run.
			shopCloseBtn.addEventListener('click', (e) => {
				e.preventDefault();
				e.stopImmediatePropagation();
				close();
			}, { once: true, capture: true });
			shopCloseBtn.addEventListener('touchend', (e) => {
				e.preventDefault();
				e.stopImmediatePropagation();
				close();
			}, { once: true, capture: true });
		}

		return colorKey;
	}

	function placeBonusUpgradeFieldEvent_World2() {
		const worldInfo = (typeof getWorldAndSubLevel === 'function')
			? getWorldAndSubLevel(currentLevel)
			: { world: Number(currentWorld || 1) || 1 };
		const world = Number(worldInfo?.world || 1) || 1;
		if (world < 2) return false;

		// Prefer blue/green; small chance yellow.
		const zoneRoll = Math.random();
		const preferred = zoneRoll < 0.45 ? 'blue' : (zoneRoll < 0.90 ? 'green' : 'yellow');
		const zoneOrder = preferred === 'yellow'
			? ['yellow', 'blue', 'green']
			: (preferred === 'blue'
				? ['blue', 'green', 'yellow']
				: ['green', 'blue', 'yellow']);

		const pickCandidateCell = (gridId, { preferTop = false } = {}) => {
			const grid = document.getElementById(gridId);
			if (!grid) return null;
			const candidates = Array.from(grid.querySelectorAll('.cell:not(.void-cell)'))
				.filter(cell => cell.dataset.disabled !== 'true')
				.filter(cell => !cell.classList.contains('active'))
				.filter(cell => !cell.classList.contains('bold-cell'))
				.filter(cell => !cell.classList.contains('gold-cell'))
				.filter(cell => !cell.classList.contains('trap-cell'))
				.filter(cell => !cell.querySelector('.symbol'));
			if (!candidates.length) return null;
			if (!preferTop) return candidates[Math.floor(Math.random() * candidates.length)];

			let bestCell = null;
			let bestScore = { y: Infinity, x: Infinity, idx: Infinity };
			const scoreCell = (cell, idx) => {
				const y = Number(cell.dataset.y);
				const x = Number(cell.dataset.x);
				return {
					y: Number.isFinite(y) ? y : Infinity,
					x: Number.isFinite(x) ? x : Infinity,
					idx
				};
			};
			candidates.forEach((cell, idx) => {
				const score = scoreCell(cell, idx);
				if (!bestCell || score.y < bestScore.y || (score.y === bestScore.y && (score.x < bestScore.x || (score.x === bestScore.x && score.idx < bestScore.idx)))) {
					bestCell = cell;
					bestScore = score;
				}
			});
			return bestCell || candidates[0];
		};

		const zoneToGridId = {
			blue: 'blue-grid',
			green: 'green-grid',
			yellow: 'yellow-grid'
		};

		let target = null;
		let chosenZone = null;
		for (const z of zoneOrder) {
			target = pickCandidateCell(zoneToGridId[z], { preferTop: false });
			if (target) {
				chosenZone = z;
				break;
			}
		}
		if (!target) return false;

		target.dataset.bonusUpgradeEvent = 'true';
		const sym = document.createElement('div');
		sym.classList.add('symbol', 'upgrade-shop-symbol');
		// Use the editor's diamond glyph for consistency
		sym.textContent = 'â™¦';
		sym.setAttribute('aria-label', 'Bonus upgrade');
		target.appendChild(sym);
		return true;
	}

	function onBonusPointerDown(event) {
		const badge = event.target.closest('.bonus-badge');
		if (!badge) return;
		const colorKey = badge.dataset.bonusKey;
		
		// Handle gratis plaatsing
		if (colorKey === 'free') {
			if (freePlacementsRemaining <= 0) return;
			if (event.button !== undefined && event.button !== 0) return;
			event.preventDefault();
			event.stopPropagation();
			
			if (activeBonusPlacement && activeBonusPlacement.colorKey === 'free') {
				cancelActiveBonusPlacement();
				return;
			}
			cancelActiveBonusPlacement({ updateInventory: false });
			
			// Gebruik 'multikleur' voor universele plaatsing
			const shape = [[1]]; // 1x1 blok
			const colorObj = { name: 'multikleur', code: 'rainbow' };
			
			const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
			if (isTouchDevice && window.innerWidth <= MOBILE_BREAKPOINT) {
				activeBonusPlacement = {
					colorKey: 'free',
					pointerId: event.pointerId || null,
					sticky: true,
					shape: cloneShape(shape)
				};
				selectedShape = shape;
				selectedColor = colorObj;
				if (rotateButton) rotateButton.disabled = false;
				if (mirrorButton) mirrorButton.disabled = false;
				markActiveBonusButton('free');
				
				badge.setPointerCapture(event.pointerId);
				const freeBlock = makeDraggable(shape, colorObj);
				freeBlock.classList.add('bonus-draggable');
				const overlay = document.getElementById('drag-overlay');
				if (overlay && !overlay.contains(freeBlock)) {
					overlay.appendChild(freeBlock);
					overlay.style.display = 'block';
				}
				draggedBlock = freeBlock;
				draggedShape = freeBlock._shape || shape;
				draggedColor = colorObj;
				beginPointerDrag({ clientX: event.clientX, clientY: event.clientY, pointerId: event.pointerId || null });
				startGlobalDragVisuals();
				// MOBILE FIX: Use actual rendered cell size with gap
				const m = getDragBlockCellMetrics(freeBlock);
				({ offsetX, offsetY } = computeShapeCenterOffsets(shape, m));
				const touchOffsetY = getFingerLiftOffsetY(event);
				setElPos(draggedBlock, event.clientX - offsetX, event.clientY - offsetY - touchOffsetY);
				addCardControlButtons();
			} else {
				activeBonusPlacement = {
					colorKey: 'free',
					pointerId: event.pointerId || null,
					sticky: false,
					shape: cloneShape(shape)
				};
				selectedShape = shape;
				selectedColor = colorObj;
				if (rotateButton) rotateButton.disabled = false;
				if (mirrorButton) mirrorButton.disabled = false;
				markActiveBonusButton('free');
				showFloatingPreview(shape, colorObj);
			}
			return;
		}
		
		if (!colorKey || !BONUS_COLOR_CONFIG[colorKey]) return;
		if ((bonusInventory[colorKey] || 0) <= 0 && (!activeBonusPlacement || activeBonusPlacement.colorKey !== colorKey)) {
			// Even when empty, selecting a bonus badge on mobile should open the zoomed zone.
			event.preventDefault();
			event.stopPropagation();
			if (window.innerWidth <= MOBILE_BREAKPOINT) {
				const meta = BONUS_COLOR_CONFIG[colorKey];
				if (meta) {
					autoZoomToColorZone({ name: meta.colorName, code: meta.colorCode });
				}
			}
			return;
		}
		if (event.button !== undefined && event.button !== 0) return;
		event.preventDefault();
		event.stopPropagation();
		if (activeBonusPlacement && activeBonusPlacement.colorKey === colorKey) {
			cancelActiveBonusPlacement();
			return;
		}
		cancelActiveBonusPlacement({ updateInventory: false });
		const meta = BONUS_COLOR_CONFIG[colorKey];
		const shape = getBonusShape(colorKey);
		const colorObj = { name: meta.colorName, code: meta.colorCode };

		// Auto-zoom naar de juiste zone op basis van kleur (altijd op mobiel)
		if (window.innerWidth <= MOBILE_BREAKPOINT) {
			autoZoomToColorZone(colorObj);
		}

	// Voor touch devices: direct draggable maken (geen floating preview)
	const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
	if (isTouchDevice && window.innerWidth <= MOBILE_BREAKPOINT) {
		// Zet bonus placement variabelen
		activeBonusPlacement = {
			colorKey,
			pointerId: event.pointerId || null,
			sticky: true,
			shape: cloneShape(shape)
		};
		selectedShape = shape;
		selectedColor = colorObj;
		if (rotateButton) rotateButton.disabled = false;
		if (mirrorButton) mirrorButton.disabled = false;
		markActiveBonusButton(colorKey);

		// Maak het blok direct draggable vanaf pointer positie (niet op de badge),
		// zodat het niet direct "op de badge" lijkt te staan en overlap/annuleer-gevoel voorkomt.
		const block = makeDraggable(shape, colorObj);
		block.classList.add('bonus-draggable');
		// MOBILE FIX: Use getDragBlockCellMetrics for consistent offset
		const m = getDragBlockCellMetrics(block);
		({ offsetX, offsetY } = computeShapeCenterOffsets(shape, m));
		const touchOffsetY = getFingerLiftOffsetY(event);
		setElPos(block, event.clientX - offsetX, event.clientY - offsetY - touchOffsetY);

		// Ensure block immediately matches zoomed cell size if a zoom/lift occurred
		requestAnimationFrame(() => {
			try {
				renderBlock(block, block._shape || shape, colorObj);
				const mAfter = getDragBlockCellMetrics(block);
				({ offsetX, offsetY } = computeShapeCenterOffsets(block._shape || shape, mAfter));
				setElPos(block, event.clientX - offsetX, event.clientY - offsetY - touchOffsetY);
			} catch (e) {}
		});
		const overlay = document.getElementById('drag-overlay');
		if (overlay && !overlay.contains(block)) {
			overlay.appendChild(block);
			overlay.style.display = 'block';
		}
		draggedBlock = block;
		resetDragBlockGap();
		draggedShape = block._shape || shape;
		draggedColor = colorObj;
		try { badge.setPointerCapture(event.pointerId); } catch {}
		beginPointerDrag({ clientX: event.clientX, clientY: event.clientY, pointerId: event.pointerId || null });
		startGlobalDragVisuals();
		addCardControlButtons();

			return;
	} else if (window.innerWidth <= MOBILE_BREAKPOINT) {
		// Niet-touch mobiel: maak blok direct draggable
		// Buttons worden getoond zodra het blok wordt opgepakt
		activeBonusPlacement = {
			colorKey,
			pointerId: event.pointerId || null,
			sticky: true,
			shape: cloneShape(shape)
		};
		selectedShape = shape;
		selectedColor = colorObj;
		if (rotateButton) rotateButton.disabled = false;
		if (mirrorButton) mirrorButton.disabled = false;
		markActiveBonusButton(colorKey);
		
		// Maak het blok direct draggable
		const block = makeDraggable(shape, colorObj);
		block.classList.add('bonus-draggable');
		const overlay = document.getElementById('drag-overlay');
		if (overlay && !overlay.contains(block)) overlay.appendChild(block);
		draggedBlock = block;
		resetDragBlockGap();
		draggedShape = block._shape || shape;
		draggedColor = colorObj;
		beginPointerDrag({ clientX: event.clientX, clientY: event.clientY, pointerId: event.pointerId || null });
		startGlobalDragVisuals();
		const m = getDragBlockCellMetrics(block);
		({ offsetX, offsetY } = computeShapeCenterOffsets(shape, m));
		setElPos(block, event.clientX - offsetX, event.clientY - offsetY);
		// visuals handled by startGlobalDragVisuals()
		if (overlay) overlay.style.display = 'block';
			// After possible zoom/DOM-lift, re-render to pick up zoomed cell size
			requestAnimationFrame(() => {
				try {
					renderBlock(block, block._shape || shape, colorObj);
					const mAfter = getDragBlockCellMetrics(block);
					({ offsetX, offsetY } = computeShapeCenterOffsets(block._shape || shape, mAfter));
					setElPos(block, event.clientX - offsetX, event.clientY - offsetY);
				} catch (e) {}
			});
			return;
	}
		// Desktop (mouse): click-to-pickup -> hover-follow -> click-to-drop
		const isMobileLayout = window.innerWidth <= MOBILE_BREAKPOINT;
		if (!isMobileLayout && !isTouchDevice) {
			activeBonusPlacement = {
				colorKey,
				pointerId: null,
				sticky: false,
				shape: cloneShape(shape),
				desktopHover: true
			};
			lastZone = null;
			lastBaseX = null;
			lastBaseY = null;
			selectedCardId = null;
			if (selectedCardElement) {
				selectedCardElement.classList.remove('selected');
			}
			selectedCardElement = null;
			selectedShape = shape;
			selectedColor = colorObj;
			if (rotateButton) rotateButton.disabled = false;
			if (mirrorButton) mirrorButton.disabled = false;
			markActiveBonusButton(colorKey);
			badge.blur();
			startDesktopHoverDragFromSelection(badge, shape, colorObj);
			return;
		}

		// Desktop (touch) fallback: keep original drag behavior
		const block = makeDraggable(shape, colorObj);
		block.classList.add('bonus-draggable');
		const overlay = document.getElementById('drag-overlay');
		if (overlay && !overlay.contains(block)) overlay.appendChild(block);
		draggedBlock = block;
		resetDragBlockGap();
		draggedShape = block._shape || shape;
		draggedColor = colorObj;
		beginPointerDrag({ clientX: event.clientX, clientY: event.clientY, pointerId: event.pointerId || null });
		startGlobalDragVisuals();

		// Compute offsets based on the *actual rendered* block cell size + gap.
		const m = getDragBlockCellMetrics(block);
		({ offsetX, offsetY } = computeShapeCenterOffsets(draggedShape, m));
		const touchOffsetY = getFingerLiftOffsetY(event);
		setElPos(block, event.clientX - offsetX, event.clientY - offsetY - touchOffsetY);
		activeBonusPlacement = {
			colorKey,
			pointerId: event.pointerId || null,
			sticky: true,
			shape: cloneShape(shape)
		};
		lastZone = null;
		lastBaseX = null;
		lastBaseY = null;
		selectedCardId = null;
		selectedCardElement = null;
		selectedShape = null;
		selectedColor = null;
		if (rotateButton) rotateButton.disabled = false;
		// visuals handled by startGlobalDragVisuals()
		if (overlay) overlay.style.display = 'block';
		badge.blur();
		markActiveBonusButton(colorKey);
	}
	
	// Dark mode is now the base styling â€” no class toggle needed.

	// Prevent pinch-zoom gestures on mobile Safari/iOS
	['gesturestart', 'gesturechange', 'gestureend'].forEach(type => {
		document.addEventListener(type, (e) => {
			try { e.preventDefault(); } catch (_) {}
		}, { passive: false });
	});



	 // ---------- CREATE GRID (general) ----------
	function createGrid(containerId, rows, cols, options = {}) {
		options = Object.assign({
			boldBottom: false,
			goldCells: false,
			symbols: false,
			symbolChance: 0.3,
			minSymbols: 0,
			maxSymbols: 0,
			coinChance: 0.0,
			maxCoins: 0,
			trapChance: 0,
			maxTraps: 0,
			blackHoleChance: BLACK_HOLE_DEFAULT_CHANCE,
			rowLengths: null,
			rowOffsets: null,
			voidCells: null,
			boldRows: [],
			randomBoldCount: null,
			includeDefaultBlueBold: true,
			colorChances: null,
					pointsPerWidthMap: null,
					pointsPerColumn: null,
					avoidAdjacentBold: false,
					diagonalShading: false,
					diagonalLegend: false,
					ringShading: false,
					columnShading: false,
					fixedBoldCells: null,
					outerRingShade: false,
					trimLeft: false,
					trimRight: false,
					randomBoldMinEdgeDistance: 0,
					ensureAdjacentBoldPair: false
		}, options);

		const container = document.getElementById(containerId);
		if (!container) return;

		const normalizedRowLengths = [];
		const normalizedRowOffsets = [];
		const hasCustomRowLengths = Array.isArray(options.rowLengths) && options.rowLengths.length;
		const hasCustomRowOffsets = Array.isArray(options.rowOffsets) && options.rowOffsets.length;

		let usedMaxCols = 0;
		for (let i = 0; i < rows; i++) {
			const lengthSourceIndex = hasCustomRowLengths
				? (i < options.rowLengths.length ? i : options.rowLengths.length - 1)
				: -1;
			const offsetSourceIndex = hasCustomRowOffsets
				? (i < options.rowOffsets.length ? i : options.rowOffsets.length - 1)
				: -1;

			const rawLength = lengthSourceIndex >= 0 ? options.rowLengths[lengthSourceIndex] : cols;
			const normalizedLength = Math.max(0, Number(rawLength) || 0);
			normalizedRowLengths.push(normalizedLength);

			const rawOffset = offsetSourceIndex >= 0 ? options.rowOffsets[offsetSourceIndex] : 0;
			const normalizedOffset = Math.max(0, Number(rawOffset) || 0);
			normalizedRowOffsets.push(normalizedOffset);

			if (normalizedLength > 0) {
				usedMaxCols = Math.max(usedMaxCols, normalizedOffset + normalizedLength);
			}
		}

		let maxCols = Math.max(cols, usedMaxCols);

		// Optional: trim empty leading columns when using rowOffsets.
		// Useful for World 2 blue path, where generation starts at offset>0 (otherwise you get lots of empty space on the left).
		let workingVoidCells = options.voidCells;
		if (options.trimLeft && hasCustomRowOffsets) {
			let minOffset = Infinity;
			for (let r = 0; r < rows; r++) {
				if (normalizedRowLengths[r] > 0) {
					minOffset = Math.min(minOffset, normalizedRowOffsets[r]);
				}
			}
			if (Number.isFinite(minOffset) && minOffset > 0) {
				for (let r = 0; r < rows; r++) {
					normalizedRowOffsets[r] = Math.max(0, (normalizedRowOffsets[r] || 0) - minOffset);
				}
				maxCols = Math.max(1, maxCols - minOffset);
				if (workingVoidCells && workingVoidCells instanceof Set) {
					const shifted = new Set();
					for (const key of workingVoidCells) {
						const parts = String(key).split(',');
						if (parts.length < 2) continue;
						const x = Number(parts[0]);
						const y = parts[1];
						if (!Number.isFinite(x)) continue;
						shifted.add(`${Math.max(0, x - minOffset)},${y}`);
					}
					workingVoidCells = shifted;
				}
			}
		}

		// Optional: trim empty trailing columns (right side). Useful when `cols` is larger than what the active rows actually use.
		if (options.trimRight) {
			let usedRight = 0;
			for (let r = 0; r < rows; r++) {
				const rowLen = normalizedRowLengths[r];
				if (rowLen > 0) {
					usedRight = Math.max(usedRight, (normalizedRowOffsets[r] || 0) + rowLen);
				}
			}
			if (Number.isFinite(usedRight) && usedRight > 0 && usedRight < maxCols) {
				maxCols = usedRight;
				if (workingVoidCells && workingVoidCells instanceof Set) {
					const trimmed = new Set();
					for (const key of workingVoidCells) {
						const parts = String(key).split(',');
						if (parts.length < 2) continue;
						const x = Number(parts[0]);
						if (!Number.isFinite(x)) continue;
						if (x >= 0 && x < maxCols) trimmed.add(key);
					}
					workingVoidCells = trimmed;
				}
			}
		}

		if (!Number.isFinite(maxCols) || maxCols <= 0) maxCols = Math.max(cols, 1);

		container.innerHTML = '';
	container.dataset.rows = String(rows);
	container.dataset.cols = String(maxCols);
		container.dataset.rowLengths = normalizedRowLengths.join(',');
		container.dataset.rowOffsets = normalizedRowOffsets.join(',');
		container.style.gridTemplateColumns = `repeat(${maxCols}, var(--cell-size))`;
		container.style.gridAutoRows = `var(--cell-size)`;

		const activeIndexOffsets = [];
		let activeCellCount = 0;
		for (let r = 0; r < rows; r++) {
			activeIndexOffsets[r] = activeCellCount;
			activeCellCount += normalizedRowLengths[r];
		}
		container.dataset.activeCells = String(activeCellCount);

		const allIdx = Array.from({ length: activeCellCount }, (_, i) => i);

		const indexToCoord = (index) => {
			if (index < 0 || index >= activeCellCount) return null;
			for (let r = rows - 1; r >= 0; r--) {
				const start = activeIndexOffsets[r];
				const rowLen = normalizedRowLengths[r];
				if (rowLen <= 0) continue;
				if (index >= start) {
					const within = index - start;
					if (within < rowLen) {
						const c = normalizedRowOffsets[r] + within;
						return { row: r, col: c };
					}
				}
			}
			return null;
		};

		const coordToIndex = (row, col) => {
			if (!Number.isFinite(row) || !Number.isFinite(col)) return null;
			if (row < 0 || row >= rows) return null;
			const rowLen = normalizedRowLengths[row];
			if (rowLen <= 0) return null;
			const rowStart = normalizedRowOffsets[row];
			const rel = col - rowStart;
			if (rel < 0 || rel >= rowLen) return null;
			return activeIndexOffsets[row] + rel;
		};

		const boldIndices = new Set();
		const boldRowsSet = new Set(Array.isArray(options.boldRows) ? options.boldRows : []);
		const includeDefaultBlue = options.includeDefaultBlueBold !== false;
		const fixedBoldCells = Array.isArray(options.fixedBoldCells) ? options.fixedBoldCells : [];

		for (let r = 0; r < rows; r++) {
			const rowLen = normalizedRowLengths[r];
			if (rowLen <= 0) continue;
			if (options.boldBottom && r === rows - 1) {
				for (let c = 0; c < rowLen; c++) boldIndices.add(activeIndexOffsets[r] + c);
			}
			if (boldRowsSet.has(r)) {
				for (let c = 0; c < rowLen; c++) boldIndices.add(activeIndexOffsets[r] + c);
			}
			if (includeDefaultBlue && containerId === 'blue-grid' && r % 4 === 0) {
				for (let c = 0; c < rowLen; c++) boldIndices.add(activeIndexOffsets[r] + c);
			}
		}

		// Fixed bold cells (used for World 2 purple corners)
		for (const entry of fixedBoldCells) {
			if (!Array.isArray(entry) || entry.length < 2) continue;
			const r = Number(entry[0]);
			const c = Number(entry[1]);
			if (!Number.isFinite(r) || !Number.isFinite(c)) continue;
			if (r < 0 || r >= rows) continue;
			const rowLen = normalizedRowLengths[r];
			if (!rowLen) continue;
			const rowStart = normalizedRowOffsets[r] || 0;
			const rel = c - rowStart;
			if (rel < 0 || rel >= rowLen) continue;
			boldIndices.add(activeIndexOffsets[r] + rel);
		}

				if (options.boldLeft) {
					for (let r = 0; r < rows; r++) {
						const rowLen = normalizedRowLengths[r];
						if (rowLen <= 0) continue;
						boldIndices.add(activeIndexOffsets[r]);
					}
				}

				if (Array.isArray(options.boldColumns)) {
					const numericColumns = options.boldColumns
						.map(value => Number(value))
						.filter(value => Number.isFinite(value));
							numericColumns.forEach(columnIndex => {
								for (let r = 0; r < rows; r++) {
									const rowLen = normalizedRowLengths[r];
									if (rowLen <= 0) continue;
									const rowStart = normalizedRowOffsets[r];
									const relativeIndex = columnIndex - rowStart;
									if (relativeIndex < 0 || relativeIndex >= rowLen) continue;
									boldIndices.add(activeIndexOffsets[r] + relativeIndex);
								}
							});
				}

		let randomBoldTarget = null;
		if (typeof options.randomBoldCount === 'number' && options.randomBoldCount > 0) {
			randomBoldTarget = Math.min(options.randomBoldCount, activeCellCount);
		} else if (containerId === 'purple-grid' && typeof options.randomBoldCount !== 'number') {
			randomBoldTarget = Math.min(5, activeCellCount);
		}

		const currentBoldCoords = [];
		for (const idx of boldIndices) {
			const coord = indexToCoord(idx);
			if (coord) currentBoldCoords.push(coord);
		}

		if (randomBoldTarget !== null) {
			const shuffled = allIdx.slice();
			shuffleArray(shuffled);
			for (let i = 0; boldIndices.size < randomBoldTarget && i < shuffled.length; i++) {
				const candidate = shuffled[i];
				if (boldIndices.has(candidate)) continue;
				const coord = indexToCoord(candidate);
				if (!coord) continue;
				// World 2 purple request: do not generate random bold cells in the outer rings.
				if (options.randomBoldMinEdgeDistance && options.randomBoldMinEdgeDistance > 0) {
					const edgeDist = Math.min(coord.row, coord.col, (rows - 1 - coord.row), (maxCols - 1 - coord.col));
					if (edgeDist < options.randomBoldMinEdgeDistance) continue;
				}
				if (options.avoidAdjacentBold) {
					let tooClose = false;
					for (const existing of currentBoldCoords) {
						const distance = Math.max(Math.abs(existing.row - coord.row), Math.abs(existing.col - coord.col));
						if (distance < 2) {
							tooClose = true;
							break;
						}
					}
					if (tooClose) continue;
				}
				boldIndices.add(candidate);
				currentBoldCoords.push(coord);
			}
		}

	let ensuredBoldPairCoords = [];
	if (options.ensureAdjacentBoldPair) {
		const findAdjacentPair = () => {
			for (let i = 0; i < currentBoldCoords.length; i += 1) {
				for (let j = i + 1; j < currentBoldCoords.length; j += 1) {
					const a = currentBoldCoords[i];
					const b = currentBoldCoords[j];
					if (!a || !b) continue;
					const dist = Math.abs(a.row - b.row) + Math.abs(a.col - b.col);
					if (dist === 1) return [a, b];
				}
			}
			return null;
		};

		let pair = findAdjacentPair();
		if (!pair) {
			const midRow = Math.floor(rows / 2);
			const startCol = Math.max(0, Math.floor((maxCols - 2) / 2));
			const idxA = coordToIndex(midRow, startCol);
			const idxB = coordToIndex(midRow, startCol + 1);
			if (idxA !== null && idxB !== null) {
				boldIndices.add(idxA);
				boldIndices.add(idxB);
				const coordA = indexToCoord(idxA);
				const coordB = indexToCoord(idxB);
				if (coordA) currentBoldCoords.push(coordA);
				if (coordB) currentBoldCoords.push(coordB);
				pair = [coordA, coordB].filter(Boolean);
			}
		}
		if (pair && pair.length === 2) {
			ensuredBoldPairCoords = pair;
		}
	}

		// IMPORTANT: ensure minSymbols/maxSymbols correspond to ACTUALLY PLACED symbols.
		// Previously we sampled from all active cells (including bold cells), but later we refuse to place symbols on bold
		// and coins could override symbols. That made the visible symbol count much lower than minSymbols.
		const shuffledIdx = allIdx.slice();
		shuffleArray(shuffledIdx);
		const symbolCandidates = shuffledIdx.filter(i => !boldIndices.has(i));
		const minSymbols = Math.max(0, Math.min(options.minSymbols || 0, symbolCandidates.length));
		const maxSymbols = Math.max(minSymbols, Math.min(options.maxSymbols || minSymbols, symbolCandidates.length));
		const symbolCount = maxSymbols > minSymbols
			? Math.floor(Math.random() * (maxSymbols - minSymbols + 1)) + minSymbols
			: minSymbols;
		const symbolIndices = new Set(symbolCandidates.slice(0, symbolCount));

		const coinCandidates = shuffledIdx.filter(i => {
			if (options.maxCoins && options.maxCoins <= 0) return false;
			if (options.goldCells === false && options.coinChance === 0) return false;
			// Never let coins replace symbols; symbols have their own min/max budget.
			if (symbolIndices.has(i)) return false;
			if (boldIndices.has(i)) return false;
			return true;
		});

		const coinIndices = new Set();
		const coinLimit = options.maxCoins > 0 ? options.maxCoins : Infinity;
		for (const idx of coinCandidates) {
			if (coinIndices.size >= coinLimit) break;
			if (Math.random() < (options.coinChance || 0)) {
				coinIndices.add(idx);
			}
		}

		const trapChance = Math.max(0, Math.min(1, Number(options.trapChance) || 0));
		const trapLimit = options.maxTraps > 0 ? options.maxTraps : 0;
		const trapIndices = new Set();
		if (trapChance > 0 && trapLimit !== 0) {
			const trapCandidates = shuffledIdx.filter(i => !symbolIndices.has(i) && !coinIndices.has(i) && !boldIndices.has(i));
			for (const idx of trapCandidates) {
				if (trapIndices.size >= trapLimit) break;
				if (Math.random() < trapChance) {
					trapIndices.add(idx);
				}
			}
		}
		trapIndices.forEach(idx => symbolIndices.delete(idx));

		const blackHoleChance = Math.max(0, Math.min(1, Number(options.blackHoleChance) || 0));
		const blackHoleLimit = Number(options.maxBlackHoles) > 0 ? Number(options.maxBlackHoles) : (blackHoleChance > 0 ? 1 : 0);
		const blackHoleIndices = new Set();
		if (blackHoleChance > 0 && blackHoleLimit !== 0) {
			const blackHoleCandidates = shuffledIdx.filter(i => !symbolIndices.has(i) && !coinIndices.has(i) && !boldIndices.has(i) && !trapIndices.has(i));
			for (const idx of blackHoleCandidates) {
				if (blackHoleIndices.size >= blackHoleLimit) break;
				if (Math.random() < blackHoleChance) blackHoleIndices.add(idx);
			}
		}
		blackHoleIndices.forEach(idx => symbolIndices.delete(idx));

		const ensuredPairSet = new Set((ensuredBoldPairCoords || []).map(coord => `${coord.col},${coord.row}`));
		if (ensuredPairSet.size > 0 && containerId === 'purple-grid') {
			container.dataset.purplePair = Array.from(ensuredPairSet).join('|');
		}

		const frag = document.createDocumentFragment();
			for (let r = 0; r < rows; r++) {
				const rowLen = normalizedRowLengths[r];
				const rowStart = normalizedRowOffsets[r];
				for (let c = 0; c < maxCols; c++) {
				const cell = document.createElement('div');
				cell.classList.add('cell');
			cell.dataset.x = String(c);
			cell.dataset.y = String(r);
			cell.dataset.zoneId = containerId;

					// Check of cell binnen row range valt
					const isOutsideRow = (c < rowStart) || (c >= rowStart + rowLen);
					
					// Check of cell expliciet als void gemarkeerd is (voor gaps in split)
					const cellKey = `${c},${r}`;
					const isMarkedVoid = workingVoidCells && workingVoidCells.has(cellKey);
					
					const isVoid = isOutsideRow || isMarkedVoid;
				if (isVoid) {
					cell.classList.add('void-cell');
					cell.dataset.disabled = 'true';
					frag.appendChild(cell);
					continue;
				}

				// World 2 purple UX: shade the outer 2 rings
				if (containerId === 'purple-grid' && options.outerRingShade) {
					const dist = Math.min(r, c, (rows - 1 - r), (maxCols - 1 - c));
					if (dist === 0) cell.classList.add('outer-ring-0');
					else if (dist === 1) cell.classList.add('outer-ring-1');
				}

					const idx = activeIndexOffsets[r] + (c - rowStart);

					// WORLD 2 (Yellow): tag cells by diagonal so we can style and score diagonals.
					if (containerId === 'yellow-grid' && options.diagonalShading) {
						const diagIndex = c - r; // NW-SE diagonals
						cell.dataset.diag = String(diagIndex);
						const parity = ((diagIndex % 2) + 2) % 2;
						if (parity === 1) cell.classList.add('diag-shade-odd');
						else cell.classList.add('diag-shade-even');
					}

					// WORLD 1 (Yellow): tag cells by column parity for alternating column shading.
					if (containerId === 'yellow-grid' && options.columnShading) {
						const colParity = ((c % 2) + 2) % 2;
						if (colParity === 1) cell.classList.add('col-shade-odd');
						else cell.classList.add('col-shade-even');
					}

				if (boldIndices.has(idx)) cell.classList.add('bold-cell');
				if (ensuredPairSet.has(`${c},${r}`)) cell.classList.add('purple-pair-cell');

				if (blackHoleIndices.has(idx)) {
					decorateTrapCell(cell, { forceType: 'blackHole', blackHoleChance: options.blackHoleChance });
				} else if (trapIndices.has(idx)) {
					decorateTrapCell(cell, { forceType: 'pit', blackHoleChance: 0 });
				} else if (coinIndices.has(idx)) {
					cell.classList.add('gold-cell');
				} else if (symbolIndices.has(idx) && !boldIndices.has(idx)) {
					const sym = document.createElement('div');
		  sym.classList.add('symbol', 'gray');

					const colorChances = options.colorChances || [
						{ color: 'blue', weight: 1 },
						{ color: 'green', weight: 1 },
						{ color: 'red', weight: 1 },
						{ color: 'purple', weight: 1 },
						{ color: 'yellow', weight: 1 }
					];
					const globalObjectiveChances = (typeof window !== 'undefined' && window && Array.isArray(window.__objectiveBonusColorChances))
						? window.__objectiveBonusColorChances
						: null;
					const effectiveColorChances = options.colorChances || globalObjectiveChances || colorChances;
					const totalWeight = effectiveColorChances.reduce((sum, entry) => sum + (Number(entry.weight) || 0), 0) || 1;
					let roll = Math.random() * totalWeight;
					for (const entry of effectiveColorChances) {
						if (roll < entry.weight) {
							sym.classList.add(entry.color);
							sym.style.setProperty('--symbol.color', entry.color);
							break;
						}
						roll -= entry.weight;
					}
					cell.appendChild(sym);
				}

				cell.addEventListener('pointerdown', (e) => {
					e.preventDefault();
					toggleCell(cell, containerId);
				});
				frag.appendChild(cell);
			}
		}
		container.appendChild(frag);

		// World 3 (Yellow): ring-based shading to match ring scoring (alternating light/dark per ring).
		if (containerId === 'yellow-grid' && options.ringShading) {
			const cells = Array.from(container.querySelectorAll('.cell:not(.void-cell)'));
			const cellByCoord = new Map();
			cells.forEach(c => {
				const x = Number(c.dataset.x);
				const y = Number(c.dataset.y);
				if (Number.isFinite(x) && Number.isFinite(y)) {
					cellByCoord.set(`${x},${y}`, c);
				}
			});
			const tryGet = (x, y) => cellByCoord.get(`${x},${y}`) || null;
			const boundary = [];
			for (const c of cellByCoord.values()) {
				const x = Number(c.dataset.x);
				const y = Number(c.dataset.y);
				if (!Number.isFinite(x) || !Number.isFinite(y)) continue;
				if (!tryGet(x - 1, y) || !tryGet(x + 1, y) || !tryGet(x, y - 1) || !tryGet(x, y + 1)) {
					boundary.push(c);
				}
			}
			const depthByCell = new Map();
			const q = [];
			boundary.forEach(c => {
				depthByCell.set(c, 0);
				q.push(c);
			});
			while (q.length) {
				const cur = q.shift();
				const curDepth = depthByCell.get(cur) || 0;
				const x = Number(cur.dataset.x);
				const y = Number(cur.dataset.y);
				const neigh = [tryGet(x - 1, y), tryGet(x + 1, y), tryGet(x, y - 1), tryGet(x, y + 1)].filter(Boolean);
				for (const n of neigh) {
					if (!depthByCell.has(n)) {
						depthByCell.set(n, curDepth + 1);
						q.push(n);
					}
				}
			}
			depthByCell.forEach((depth, cell) => {
				const parity = (Number(depth) || 0) % 2;
				cell.dataset.ringDepth = String(depth);
				cell.classList.toggle('ring-shade-odd', parity === 1);
				cell.classList.toggle('ring-shade-even', parity === 0);
			});
		}

			if (containerId === 'yellow-grid') {
				const puntenEl = document.getElementById('yellow-punten');
				if (puntenEl) {
					if (options.diagonalLegend) {
						puntenEl.innerHTML = [
							'<strong>Wereld 2: Diagonalen</strong>',
								'Voltooi diagonale rijen (NWâ†’SE Ã©n NEâ†’SW).',
								'Punten per diagonaal (lengte â†’ punten): <strong>4â†’8, 6â†’16, 8â†’32</strong>.'
						].join('<br>');
					} else if (Array.isArray(options.pointsPerColumn) && options.pointsPerColumn.length) {
						const columnTexts = options.pointsPerColumn.map((value, idx) => {
							if (!Number.isFinite(value) || value <= 0) return `Kolom ${idx + 1}`;
							return `Kolom ${idx + 1}: ${value}`;
						});
						puntenEl.innerHTML = columnTexts.join('<br>');
					} else if (normalizedRowLengths.length) {
						const map = options.pointsPerWidthMap || {};
						const rowsTexts = normalizedRowLengths.map((len, idx) => {
							const pts = map[len];
							return pts ? `Rij ${idx + 1}: ${pts}` : `Rij ${idx + 1}`;
						});
						puntenEl.innerHTML = rowsTexts.join('<br>');
					}
				}
			}

		updateScore();
	}


	// --- Zoom helpers ---
		const placeholderSyncQueue = new Set();
		let placeholderSyncFrame = null;
		let activeZoomZone = null;
		let zoneNavLeft = null;
		let zoneNavRight = null;
		let mobileZoomResizeBound = false;

		if (BATTERY_SAVER_ENABLED) {
			document.addEventListener('visibilitychange', () => {
				if (!document.hidden) return;
				// Stop any queued placeholder sync frames while hidden.
				try {
					if (placeholderSyncFrame) {
						cancelAnimationFrame(placeholderSyncFrame);
						placeholderSyncFrame = null;
						placeholderSyncQueue.clear();
					}
				} catch (_) {}
			});
		}

	function isMobileViewport() {
		try {
			const w = window.innerWidth;
			const h = window.innerHeight;
			if (w <= 650) return true;
			// Phone landscape often reports >650px width in CSS pixels.
			// Use coarse pointer + small min dimension to still apply mobile zoom sizing.
			const coarse = !!(window.matchMedia && window.matchMedia('(pointer: coarse)').matches);
			if (coarse && Math.min(w, h) < 700) return true;
		} catch (e) {}
		return false;
	}

	function applyMobileZoomSizing(zone) {
		if (!zone) return;
		if (!isMobileViewport()) return;
		if (!['yellow-zone', 'green-zone', 'blue-zone', 'purple-zone', 'red-zone'].includes(zone.id)) return;

		const viewportH = Math.round((window.visualViewport && window.visualViewport.height) ? window.visualViewport.height : window.innerHeight);
		const isShortViewport = viewportH <= 650;
		const objectiveBanner = document.getElementById('mobile-objective-banner');
		const bottomBar = document.getElementById('bottom-bar');
		const objectiveBottom = objectiveBanner ? objectiveBanner.getBoundingClientRect().bottom : 0;
		const bottomTop = bottomBar ? bottomBar.getBoundingClientRect().top : viewportH;
		const margin = isShortViewport ? 4 : 10;
		const available = Math.max(120, Math.floor(bottomTop - objectiveBottom - margin * 2));
		// Short screens: slightly smaller zoom height so everything fits without overlapping controls.
		const desired = Math.floor(viewportH * (isShortViewport ? 0.54 : 0.57));
		const height = Math.max(120, Math.min(desired, available));

		const minCenter = objectiveBottom + margin + height / 2;
		const maxCenter = bottomTop - margin - height / 2;
		// Minimize the gap above the zoomed zone: pin as high as allowed (still clamps to avoid overlap).
		let center = Math.round(minCenter + (isShortViewport ? 0 : 2));
		center = Math.max(minCenter, Math.min(maxCenter, center));

		zone.style.setProperty('--mobile-zoom-height', `${Math.round(height + 12)}px`);
		zone.style.setProperty('--mobile-zoom-center', `${Math.round(center)}px`);

		// Keep grid sizing untouched in zoomed view (mobile matches default cell size).
	}

	function bindMobileZoomResizeHandler() {
		if (mobileZoomResizeBound) return;
		mobileZoomResizeBound = true;
		window.addEventListener('resize', () => {
			try { if (typeof scheduleLayoutReflow === 'function') scheduleLayoutReflow(60); } catch (_) {}
		}, { passive: true });
		if (window.visualViewport) {
			window.visualViewport.addEventListener('resize', () => {
				try { if (typeof scheduleLayoutReflow === 'function') scheduleLayoutReflow(60); } catch (_) {}
			}, { passive: true });
		}
	}

	function resetGreenZoomScroll(greenZone, options = {}) {
		if (!greenZone) return;
		const { force = false } = options || {};
		try {
			if (!force && document.body.classList.contains('zoomed-in') && greenZone.classList.contains('zoom-focus')) {
				const mem = getZoneScrollMemory('green-zone');
				if (mem && mem.zoom && mem.zoom.initialized) return;
			}
		} catch (_) {}
		const grid = document.getElementById('green-grid');
		if (!grid) return;
		const sx = Number(grid.dataset.startX);
		const sy = Number(grid.dataset.startY);
		let startCell = null;
		if (Number.isFinite(sx) && Number.isFinite(sy)) {
			startCell = getCell(greenZone, sx, sy);
		}
		if (!startCell) {
			startCell = greenZone.querySelector('#green-grid .cell.bold-cell:not(.void-cell)') || null;
		}
		if (!startCell) return;
		
		// Force layout reflow to ensure dimensions are accurate
		greenZone.offsetHeight;
		grid.offsetHeight;
		startCell.offsetHeight;
		
		// Wait for zone to have valid dimensions
		const zoneWidth = greenZone.clientWidth;
		const zoneHeight = greenZone.clientHeight;
		if (!zoneWidth || !zoneHeight) {
			// Zone not ready yet, retry after a frame
			requestAnimationFrame(() => resetGreenZoomScroll(greenZone, options));
			return;
		}
		
		const maxLeft = Math.max(0, greenZone.scrollWidth - zoneWidth);
		const maxTop = Math.max(0, greenZone.scrollHeight - zoneHeight);
		
		// Use offset-based centering for reliability.
		// For grids inside the zone, we need to calculate the cell position relative to the zone's scroll content.
		const gridOffsetLeft = Number(grid.offsetLeft || 0);
		const gridOffsetTop = Number(grid.offsetTop || 0);
		const cellCenterX = gridOffsetLeft + startCell.offsetLeft + startCell.offsetWidth / 2;
		const cellCenterY = gridOffsetTop + startCell.offsetTop + startCell.offsetHeight / 2;
		const desiredLeft = cellCenterX - (zoneWidth / 2);
		const desiredTop = cellCenterY - (zoneHeight / 2);
		greenZone.scrollLeft = Math.max(0, Math.min(maxLeft, desiredLeft));
		greenZone.scrollTop = Math.max(0, Math.min(maxTop, desiredTop));
	}

	function resetBlueZoomScroll(blueZone) {
		if (!blueZone) return;
		const blueGrid = document.getElementById('blue-grid');
		if (!blueGrid) return;

		// Start at the bottom.
		blueZone.getBoundingClientRect();
		blueZone.scrollTop = blueZone.scrollHeight;

		// Center on the bottom "start" group (prefer bold-cells) at the lowest row.
		let bestY = -Infinity;
		const allCells = Array.from(blueGrid.querySelectorAll('.cell:not(.void-cell)'));
		for (const cell of allCells) {
			const y = Number(cell.dataset.y);
			if (!Number.isFinite(y)) continue;
			if (y > bestY) bestY = y;
		}
		const bottomRowCells = allCells.filter(c => Number(c.dataset.y) === bestY);
		const bottomBold = bottomRowCells.filter(c => c.classList.contains('bold-cell'));
		const anchorCells = bottomBold.length ? bottomBold : bottomRowCells;

		let targetCenter = null;
		if (anchorCells.length) {
			const centers = anchorCells.map(c => c.offsetLeft + c.offsetWidth / 2);
			const minC = Math.min(...centers);
			const maxC = Math.max(...centers);
			targetCenter = (minC + maxC) / 2;
		}
		const maxLeft = Math.max(0, blueZone.scrollWidth - blueZone.clientWidth);
		if (targetCenter !== null) {
			const desiredLeft = targetCenter - (blueZone.clientWidth / 2);
			blueZone.scrollLeft = Math.max(0, Math.min(maxLeft, desiredLeft));
		} else {
			blueZone.scrollLeft = maxLeft > 0 ? Math.round(maxLeft / 2) : 0;
		}
	}

	// --- Centralized green centering + one-time sizing flags ---
	let zoneSizingNeedsRun = true;
	function rafThrottle(fn) {
		let ticking = false;
		let lastArgs = null;
		return function(...args) {
			lastArgs = args;
			if (ticking) return;
			ticking = true;
			requestAnimationFrame(() => {
				ticking = false;
				if (lastArgs) fn.apply(this, lastArgs);
			});
		};
	}
	function markZoneSizingNeeded() {
		zoneSizingNeedsRun = true;
	}
	let greenCenterToken = 0;
	function scheduleGreenCenter(options = {}) {
		const opts = (options && typeof options === 'object') ? options : {};
		const greenZone = document.getElementById('green-zone');
		if (!greenZone) return;
		const allowZoom = !!opts.allowZoom;
		const force = !!opts.force;
		const fallback = !!opts.fallback;
		const fallbackDelay = Number.isFinite(opts.fallbackDelay) ? opts.fallbackDelay : 140;
		const mode = getZoneScrollMode(greenZone);
		if (!allowZoom && mode === 'zoom') return;
		const mem = getZoneScrollMemory('green-zone');
		if (!force && mem && mem[mode] && mem[mode].userSet) return;
		const token = ++greenCenterToken;
		const run = () => {
			if (token !== greenCenterToken) return;
			resetGreenZoomScroll(greenZone, { force: force || mode === 'zoom' });
			try {
				if (mem && mem[mode]) {
					mem[mode].left = greenZone.scrollLeft;
					mem[mode].top = greenZone.scrollTop;
					mem[mode].initialized = true;
					mem[mode].level = currentLevel;
					if (mode === 'zoom' && force) mem[mode].userSet = false;
				}
			} catch (_) {}
		};
		requestAnimationFrame(() => requestAnimationFrame(run));
		if (fallback) setTimeout(run, fallbackDelay);
	}

	// --- Per-zone scroll memory (normal vs zoom) ---
	const ZONE_SCROLL_MEMORY = window.__locusZoneScrollMemory || (window.__locusZoneScrollMemory = {});
	function getZoneScrollMemory(zoneId) {
		if (!ZONE_SCROLL_MEMORY[zoneId]) {
			ZONE_SCROLL_MEMORY[zoneId] = {
				normal: { left: 0, top: 0, initialized: false, userSet: false },
				zoom: { left: 0, top: 0, initialized: false, userSet: false }
			};
		}
		return ZONE_SCROLL_MEMORY[zoneId];
	}
	function resetZoneScrollMemory(zoneId) {
		if (!zoneId) return;
		const mem = getZoneScrollMemory(zoneId);
		['normal', 'zoom'].forEach(mode => {
			if (!mem[mode]) mem[mode] = { left: 0, top: 0, initialized: false, userSet: false };
			mem[mode].left = 0;
			mem[mode].top = 0;
			mem[mode].initialized = false;
			mem[mode].userSet = false;
			mem[mode].level = currentLevel;
		});
	}
	function resetZoneScrollState(zoneId, anchorFn) {
		resetZoneScrollMemory(zoneId);
		if (typeof anchorFn !== 'function') return;
		const zoneEl = document.getElementById(zoneId);
		if (!zoneEl) return;
		try { zoneEl.__userScrollIntent = false; } catch (_) {}
		try { anchorFn(zoneEl); } catch (_) {}
	}
	function getZoneScrollMode(zoneEl) {
		if (!zoneEl) return 'normal';
		return (document.body.classList.contains('zoomed-in') && zoneEl.classList.contains('zoom-focus')) ? 'zoom' : 'normal';
	}
	function clampZoneScroll(zoneEl) {
		if (!zoneEl) return;
		const maxLeft = Math.max(0, zoneEl.scrollWidth - zoneEl.clientWidth);
		const maxTop = Math.max(0, zoneEl.scrollHeight - zoneEl.clientHeight);
		zoneEl.scrollLeft = Math.max(0, Math.min(maxLeft, zoneEl.scrollLeft));
		zoneEl.scrollTop = Math.max(0, Math.min(maxTop, zoneEl.scrollTop));
	}
	function ensureZoneScrollTracking(zoneEl) {
		if (!zoneEl || zoneEl.__scrollTrackingBound) return;
		zoneEl.__scrollTrackingBound = true;
		if (!zoneEl.__userScrollIntentBound) {
			const markUserScrollIntent = () => {
				zoneEl.__userScrollIntent = true;
			};
			zoneEl.addEventListener('pointerdown', markUserScrollIntent, { passive: true });
			zoneEl.addEventListener('touchstart', markUserScrollIntent, { passive: true });
			zoneEl.addEventListener('wheel', markUserScrollIntent, { passive: true });
			zoneEl.addEventListener('keydown', markUserScrollIntent);
			zoneEl.__userScrollIntentBound = true;
		}
		const onZoneScroll = rafThrottle(() => {
			if (zoneEl.dataset.suppressScrollSave === 'true') return;
			const zoneId = zoneEl.id;
			const mode = getZoneScrollMode(zoneEl);
			const mem = getZoneScrollMemory(zoneId);
			const hasUserIntent = !!zoneEl.__userScrollIntent || zoneEl.dataset.dragScrolling === 'true';
			if (zoneId === 'green-zone' && !hasUserIntent && !(mem[mode] && mem[mode].userSet) && mode !== 'zoom') return;
			mem[mode].left = zoneEl.scrollLeft;
			mem[mode].top = zoneEl.scrollTop;
			mem[mode].initialized = true;
			if (zoneId === 'green-zone' && hasUserIntent) mem[mode].userSet = true;
		});
		zoneEl.addEventListener('scroll', onZoneScroll, { passive: true });
	}
	function restoreOrAnchorZoneScroll(zoneEl, anchorFn) {
		if (!zoneEl) return;
		ensureZoneScrollTracking(zoneEl);
		const mem = getZoneScrollMemory(zoneEl.id);
		const mode = getZoneScrollMode(zoneEl);
		requestAnimationFrame(() => {
			zoneEl.dataset.suppressScrollSave = 'true';
			try {
				clampZoneScroll(zoneEl);
				if (zoneEl.id === 'green-zone' && !(mem[mode] && mem[mode].userSet)) {
					if (mem[mode] && mem[mode].initialized) {
						zoneEl.scrollLeft = mem[mode].left || 0;
						zoneEl.scrollTop = mem[mode].top || 0;
						clampZoneScroll(zoneEl);
					} else if (typeof anchorFn === 'function') {
						anchorFn(zoneEl);
						clampZoneScroll(zoneEl);
						mem[mode].left = zoneEl.scrollLeft;
						mem[mode].top = zoneEl.scrollTop;
						mem[mode].initialized = true;
					}
				} else if (mem[mode].initialized) {
					zoneEl.scrollLeft = mem[mode].left || 0;
					zoneEl.scrollTop = mem[mode].top || 0;
					clampZoneScroll(zoneEl);
				} else if (typeof anchorFn === 'function') {
					anchorFn(zoneEl);
					clampZoneScroll(zoneEl);
					mem[mode].left = zoneEl.scrollLeft;
					mem[mode].top = zoneEl.scrollTop;
					mem[mode].initialized = true;
				}
			} finally {
				setTimeout(() => { zoneEl.dataset.suppressScrollSave = 'false'; }, 0);
			}
		});
	}

	// Sync zone heights: make green and blue zones at least as tall as purple+yellow combined.
	// Returns true if sync ran, false if skipped (e.g., hidden layout).
	function syncZoneHeights() {
		// World 4 uses a fixed 3-zone layout (yellow/green/blue); don't force World 2/3 height syncing.
		try {
			const info = (typeof getWorldAndSubLevel === 'function') ? getWorldAndSubLevel(currentLevel) : null;
			if (info && Number(info.world) === 4) return false;
		} catch (_) {}
		try {
			const purpleZone = document.getElementById('purple-zone');
			const yellowZone = document.getElementById('yellow-zone');
			const greenZone = document.getElementById('green-zone');
			const blueZone = document.getElementById('blue-zone');
			const redZone = document.getElementById('red-zone');
			const column1 = document.querySelector('.column:nth-child(1)');
			const column2 = document.querySelector('.column:nth-child(2)');

			if (!column1 || !purpleZone || !yellowZone) return false;
			if (column1.offsetParent === null) return false; // board hidden (e.g., mobile sidebar)

			const getNumber = (val, fallback = 0) => {
				const n = parseFloat(val);
				return Number.isFinite(n) ? n : fallback;
			};
			const getMarginY = (el) => {
				if (!el) return 0;
				const cs = getComputedStyle(el);
				return getNumber(cs.marginTop) + getNumber(cs.marginBottom);
			};
			const getInnerHeight = (el) => {
				if (!el) return 0;
				return Math.max(el.offsetHeight || 0, el.getBoundingClientRect().height || 0);
			};

			const columnStyles = getComputedStyle(column1);
			const gap = (() => {
				const rowGap = getNumber(columnStyles.rowGap);
				const anyGap = getNumber(columnStyles.gap, 12);
				return rowGap > 0 ? rowGap : anyGap;
			})();
			const column2Styles = column2 ? getComputedStyle(column2) : columnStyles;
			const interZoneGap = (() => {
				const rowGap = getNumber(column2Styles.rowGap);
				const anyGap = getNumber(column2Styles.gap, gap);
				return rowGap > 0 ? rowGap : anyGap;
			})();

			const purpleInner = getInnerHeight(purpleZone);
			const yellowInner = getInnerHeight(yellowZone);
			const column1ContentHeight = purpleInner + yellowInner + getMarginY(purpleZone) + getMarginY(yellowZone) + gap;

			if (greenZone && column1ContentHeight > 0) {
				const greenMargin = getMarginY(greenZone);
				const redOuter = redZone ? (getInnerHeight(redZone) + getMarginY(redZone)) : 0;
				const availableForGreen = column1ContentHeight - redOuter - interZoneGap - greenMargin;
				const targetGreenHeight = Math.max(purpleInner, availableForGreen);
				greenZone.style.minHeight = `${Math.round(targetGreenHeight)}px`;
			}

			if (blueZone && column1ContentHeight > 0) {
				const blueMargin = getMarginY(blueZone);
				const targetBlueHeight = Math.max(0, column1ContentHeight - blueMargin);
				blueZone.style.minHeight = `${Math.round(targetBlueHeight)}px`;
			}
			return true;
		} catch (e) { console.warn('syncZoneHeights error:', e); }
		return false;
	}

	// Auto-zoom naar de juiste zone op basis van card kleur
	function autoZoomToColorZone(color) {
		if (!color) return;
		
		const colorName = typeof color === 'object' ? color.name : color;
		let targetZoneId = null;
		
		// Bepaal de juiste zone op basis van kleur
		switch(colorName) {
			case 'geel':
				targetZoneId = 'yellow-zone';
				break;
			case 'groen':
				targetZoneId = 'green-zone';
				break;
			case 'paars':
				targetZoneId = 'purple-zone';
				break;
			case 'blauw':
				targetZoneId = 'blue-zone';
				break;
			case 'rood':
				// Rood heeft 4 subgrids, zoom naar de parent red-zone
				targetZoneId = 'red-zone';
				break;
			case 'multikleur':
				// Voor multikleur: houd huidige zone open, spring niet automatisch naar rood
				// Speler kan zelf kiezen waar te plaatsen
				return;
		}

		if (targetZoneId) {
			const targetZone = document.getElementById(targetZoneId);
			if (targetZone) {
				// World 4: never auto-zoom into inactive/hidden colors.
				try {
					const info = (typeof getWorldAndSubLevel === 'function') ? getWorldAndSubLevel(currentLevel) : null;
					const isWorld4 = !!(info && Number(info.world) === 4);
					if (isWorld4) {
						const zc = String(targetZone.dataset && targetZone.dataset.color || '').toLowerCase();
						if (Array.isArray(world4AllowedColors) && world4AllowedColors.length && zc && !world4AllowedColors.includes(zc)) return;
						const cs = window.getComputedStyle ? window.getComputedStyle(targetZone) : null;
						if (cs && (cs.display === 'none' || cs.visibility === 'hidden')) return;
					}
				} catch (_) {}
				// Open zoom ook als het dezelfde zone is (voor hernieuwde selectie)
				openZoom(targetZone);
			}
		}
	}

	const ZONE_ORDER = ['purple-zone','yellow-zone','green-zone','red-zone','blue-zone'];

	function renameIdsForClone(node, suffix) {
	  if (node.id) node.id = `${node.id}${suffix}`;
	  node.querySelectorAll('[id]').forEach(child => {
		child.id = `${child.id}${suffix}`;
	  });
	}

	function createZonePlaceholder(zone) {
	  const clone = zone.cloneNode(true);
	  renameIdsForClone(clone, '--placeholder');
	  clone.classList.remove('zoom-focus');
	  clone.removeAttribute('data-zoom-active');
	  clone.classList.add('zone-placeholder');
	  clone.setAttribute('aria-hidden', 'true');
	  clone.style.removeProperty('top');
	  clone.style.removeProperty('left');
	  clone.style.removeProperty('right');
	  clone.style.removeProperty('bottom');
	  clone.style.removeProperty('transform');
	  // Preserve scroll position so the unzoomed placeholder doesn't "jump" on mobile.
	  try {
		clone.scrollLeft = zone.scrollLeft || 0;
		clone.scrollTop = zone.scrollTop || 0;
	  } catch (_) {}
	  return clone;
	}

	function schedulePlaceholderSync(zone) {
	  if (!zone || !zone._placeholder) return;
	  if (BATTERY_SAVER_ENABLED && document.hidden) return;
	  placeholderSyncQueue.add(zone);
	  if (placeholderSyncFrame) return;
	  placeholderSyncFrame = requestAnimationFrame(() => {
		placeholderSyncQueue.forEach(z => {
		  const replacement = createZonePlaceholder(z);
		  z._placeholder.replaceWith(replacement);
		  z._placeholder = replacement;
		});
		placeholderSyncQueue.clear();
		placeholderSyncFrame = null;
	  });
	}

	function syncPlaceholderForCell(cell) {
	  if (!cell) return;
	  const zone = cell.closest('.zone.zoom-focus');
	  if (zone) {
		schedulePlaceholderSync(zone);
	  }
	}

	function liftToBody(el) {
	  if (el._placeholder) return;
	  const placeholder = createZonePlaceholder(el);
	  el._placeholder = placeholder;
	  if (el.parentNode) {
		el.parentNode.insertBefore(placeholder, el);
	  }
	  document.body.appendChild(el);
	}

	function restoreFromBody(el) {
	  const placeholder = el._placeholder;
	  if (placeholder && placeholder.parentNode) {
		placeholder.parentNode.insertBefore(el, placeholder);
		placeholder.remove();
	  }
	  delete el._placeholder;
	}

	function openZoom(zone) {
		// NOTE: Mobile zone zoom is enabled; only the placement zoom-lens is disabled elsewhere.
		if (!zone || excludedZones.includes(zone.id)) return;
		// Never allow zooming a hidden zone.
		try {
			const cs = window.getComputedStyle ? window.getComputedStyle(zone) : null;
			if (cs && (cs.display === 'none' || cs.visibility === 'hidden')) return;
		} catch (_) {}
		// World 4: disallow zoom into inactive/locked colors (prevents hidden zones from reappearing).
		try {
			const info = (typeof getWorldAndSubLevel === 'function') ? getWorldAndSubLevel(currentLevel) : null;
			const isWorld4 = !!(info && Number(info.world) === 4);
			if (isWorld4 && Array.isArray(world4AllowedColors) && world4AllowedColors.length) {
				const zc = String(zone.dataset && zone.dataset.color || '').toLowerCase();
				if (zc && !world4AllowedColors.includes(zc)) return;
			}
		} catch (_) {}
		// iPad/tablet UX: zoomed-in zones are unnecessary and can break layout.
		if (window.matchMedia && window.matchMedia('(pointer: coarse)').matches) {
			const w = window.innerWidth;
			const h = window.innerHeight;
			if (Math.min(w, h) >= 700) return;
		}
		if (activeZoomZone === zone) return;
		
		// IMPORTANT: Preserve green zone scroll position when opening OTHER zones
		// This prevents the green zone from jumping when you zoom into yellow/purple/blue/red on mobile
		const greenZone = document.getElementById('green-zone');
		if (greenZone && zone.id !== 'green-zone') {
			// Save the current green zone scroll before any DOM changes
			// Store in both local variable AND global memory for persistence
			const mem = getZoneScrollMemory('green-zone');
			mem.normal.left = greenZone.scrollLeft;
			mem.normal.top = greenZone.scrollTop;
			mem.normal.initialized = true;
			// Also store in a backup location for extra safety
			greenZone._savedScrollBeforeOtherZoom = {
				left: greenZone.scrollLeft,
				top: greenZone.scrollTop
			};
		}
		
		closeZoom();
		liftToBody(zone);
		document.body.classList.add('zoomed-in');
		zone.classList.add('zoom-focus');
		zone.setAttribute('data-zoom-active', 'true');
		activeZoomZone = zone;
		
		// Restore green zone scroll IMMEDIATELY after DOM changes (when opening a different zone)
		if (greenZone && zone.id !== 'green-zone' && greenZone._savedScrollBeforeOtherZoom) {
			const saved = greenZone._savedScrollBeforeOtherZoom;
			greenZone.scrollLeft = saved.left;
			greenZone.scrollTop = saved.top;
			// Also restore after a frame to handle any CSS layout shifts
			requestAnimationFrame(() => {
				greenZone.scrollLeft = saved.left;
				greenZone.scrollTop = saved.top;
			});
		}
		
		// Mobile/touch zoom: clear any world-specific inline sizing.
		// World 2/3 sizing code sets pixel widths/heights inline; those override the uniform mobile zoom CSS.
		try {
			const isMobileZoomSizing = (typeof window !== 'undefined' && window.matchMedia)
				? window.matchMedia('(max-width: 650px), (hover: none) and (pointer: coarse)').matches
				: (window.innerWidth <= 650);
			if (isMobileZoomSizing && zone && zone.style && ['yellow-zone','green-zone','blue-zone','purple-zone','red-zone'].includes(zone.id)) {
				zone._savedInlineSizing = {
					width: zone.style.getPropertyValue('width'),
					height: zone.style.getPropertyValue('height'),
					minWidth: zone.style.getPropertyValue('min-width'),
					maxWidth: zone.style.getPropertyValue('max-width'),
					minHeight: zone.style.getPropertyValue('min-height'),
					maxHeight: zone.style.getPropertyValue('max-height')
				};
				zone.style.removeProperty('width');
				zone.style.removeProperty('height');
				zone.style.removeProperty('min-width');
				zone.style.removeProperty('max-width');
				zone.style.removeProperty('min-height');
				zone.style.removeProperty('max-height');
			}
		} catch (e) {}
		addZoneNavArrows();
		bindMobileZoomResizeHandler();
		applyMobileZoomSizing(zone);
		if (zone.id === 'red-zone') {
			// Ensure World 3 red stage visibility is applied before showing the zoomed red zone.
			try {
				const info = (typeof getWorldAndSubLevel === 'function') ? getWorldAndSubLevel(currentLevel) : null;
				const isWorld3 = !!(info && Number(info.world) === 3);
				if (isWorld3) {
					applyWorld3RedStage(world3RedStage || 1);
					// Also explicitly ensure the subgrids are visible
					const gridsToShow = (world3RedStage === 2)
						? ['red-grid5', 'red-grid6']
						: ['red-grid1', 'red-grid2', 'red-grid3', 'red-grid4'];
					gridsToShow.forEach(id => {
						const el = document.getElementById(id);
						if (el) el.style.display = '';
					});
					// Force visibility in case CSS/inline styles accidentally hid it.
					zone.style.display = 'grid';
					zone.style.opacity = '1';
					zone.style.visibility = 'visible';
				}
			} catch (err) { console.error('Red zone stage error:', err); }
		}
		if (zone.id === 'green-zone') {
			// World 1: zoomed green should not scroll.
			try {
				const worldInfo = (typeof getWorldAndSubLevel === 'function') ? getWorldAndSubLevel(currentLevel) : null;
				if (worldInfo && worldInfo.world === 1) {
					zone.classList.add('no-scroll');
					zone.style.overflow = 'hidden';
					zone.scrollTop = 0;
					zone.scrollLeft = 0;
				} else {
					// Zoom: always center on the start cell via centralized scheduler.
					try { scheduleGreenCenter({ force: true, allowZoom: true, fallback: true, fallbackDelay: 180 }); } catch (_) {}
				}
			} catch (_) {
				try { scheduleGreenCenter({ force: true, allowZoom: true, fallback: true, fallbackDelay: 180 }); } catch (_) {}
			}
		}
		if (zone.id === 'blue-zone') {
			// Zoom: first time anchor to bottom start; subsequent opens restore last zoom position.
			restoreOrAnchorZoneScroll(zone, (z) => resetBlueZoomScroll(z));
		}
	}

	function closeZoom() {
		if (!activeZoomZone) return;
		const zone = activeZoomZone;
		// Persist zoom scroll position before tearing down zoom state.
		try {
			if (zone && (zone.id === 'green-zone' || zone.id === 'blue-zone')) {
				const mem = getZoneScrollMemory(zone.id);
				if (mem && mem.zoom) {
					mem.zoom.left = zone.scrollLeft;
					mem.zoom.top = zone.scrollTop;
					mem.zoom.initialized = true;
					if (zone.id === 'green-zone') {
						const hasUserIntent = !!zone.__userScrollIntent || zone.dataset.dragScrolling === 'true';
						if (hasUserIntent) mem.zoom.userSet = true;
					}
				}
			}
		} catch (_) {}
		
		// IMPORTANT: Preserve green zone scroll when closing OTHER zones
		const greenZone = document.getElementById('green-zone');
		let savedGreenScroll = null;
		if (greenZone && zone.id !== 'green-zone') {
			// Use saved backup if available, otherwise current scroll
			if (greenZone._savedScrollBeforeOtherZoom) {
				savedGreenScroll = greenZone._savedScrollBeforeOtherZoom;
			} else {
				savedGreenScroll = {
					left: greenZone.scrollLeft,
					top: greenZone.scrollTop
				};
			}
		}
		
		// Prevent zoom scroll values from being stored into the normal-mode memory during teardown.
		try { zone.dataset.suppressScrollSave = 'true'; } catch (_) {}
		// Scroll memory is handled via scroll listeners; no dataset storage.
		placeholderSyncQueue.delete(zone);
		zone.classList.remove('zoom-focus');
		zone.removeAttribute('data-zoom-active');
		// Restore world-specific inline sizing when leaving zoom.
		try {
			const saved = zone._savedInlineSizing;
			if (saved && zone && zone.style) {
				const restoreProp = (cssProp, val) => {
					if (val != null && String(val).length) zone.style.setProperty(cssProp, val);
					else zone.style.removeProperty(cssProp);
				};
				restoreProp('width', saved.width);
				restoreProp('height', saved.height);
				restoreProp('min-width', saved.minWidth);
				restoreProp('max-width', saved.maxWidth);
				restoreProp('min-height', saved.minHeight);
				restoreProp('max-height', saved.maxHeight);
				delete zone._savedInlineSizing;
			}
		} catch (e) {}
		// No zoom-specific cell sizing to restore.
		restoreFromBody(zone);
		activeZoomZone = null;
		document.body.classList.remove('zoomed-in');
		removeZoneNavArrows();
		
		// Restore green zone scroll if we saved it (when closing a different zone)
		if (savedGreenScroll && greenZone && zone.id !== 'green-zone') {
			// Restore immediately
			greenZone.scrollLeft = savedGreenScroll.left;
			greenZone.scrollTop = savedGreenScroll.top;
			// And after a frame to handle CSS layout shifts
			requestAnimationFrame(() => {
				greenZone.scrollLeft = savedGreenScroll.left;
				greenZone.scrollTop = savedGreenScroll.top;
			});
			// And after a short delay for any final layout adjustments
			setTimeout(() => {
				greenZone.scrollLeft = savedGreenScroll.left;
				greenZone.scrollTop = savedGreenScroll.top;
				// Clean up the backup
				delete greenZone._savedScrollBeforeOtherZoom;
			}, 50);
		}
		
		// Restore the unzoomed start position (green) / last known normal scroll (blue).
		try {
			if (zone.id === 'green-zone') {
				// When closing green zone itself, restore to normal scroll memory
				const mem = getZoneScrollMemory('green-zone');
				if (mem.normal.initialized) {
					requestAnimationFrame(() => {
						zone.scrollLeft = mem.normal.left || 0;
						zone.scrollTop = mem.normal.top || 0;
					});
				}
			} else if (zone.id === 'blue-zone') {
				restoreOrAnchorZoneScroll(zone, (z) => resetBlueZoomScroll(z));
			}
		} catch (_) {}
		setTimeout(() => {
			try { zone.dataset.suppressScrollSave = 'false'; } catch (_) {}
		}, 0);
	}

	function addZoneNavArrows() {
		removeZoneNavArrows();
		zoneNavLeft = document.createElement('div');
		zoneNavLeft.className = 'zone-nav-arrow zone-nav-arrow-left';
		zoneNavLeft.innerHTML = 'â—€';
		zoneNavLeft.addEventListener('click', e => { e.stopPropagation(); navigateToAdjacentZone(-1); });
		zoneNavRight = document.createElement('div');
		zoneNavRight.className = 'zone-nav-arrow zone-nav-arrow-right';
		zoneNavRight.innerHTML = 'â–¶';
		zoneNavRight.addEventListener('click', e => { e.stopPropagation(); navigateToAdjacentZone(1); });
		document.body.append(zoneNavLeft, zoneNavRight);
	}

	function removeZoneNavArrows() {
		if (zoneNavLeft && zoneNavLeft.parentNode) zoneNavLeft.parentNode.removeChild(zoneNavLeft);
		if (zoneNavRight && zoneNavRight.parentNode) zoneNavRight.parentNode.removeChild(zoneNavRight);
		zoneNavLeft = null; zoneNavRight = null;
	}

	function navigateToAdjacentZone(direction) {
		if (!activeZoomZone) return;
		const currentId = activeZoomZone.id;
		const order = (() => {
			try {
				const info = (typeof getWorldAndSubLevel === 'function') ? getWorldAndSubLevel(currentLevel) : null;
				const world = Number(info && info.world);
				const allowed = (world === 4 && Array.isArray(world4AllowedColors) && world4AllowedColors.length)
					? world4AllowedColors.slice()
					: null;
				const visible = ZONE_ORDER.filter(id => {
					const z = document.getElementById(id);
					if (!z) return false;
					try {
						const cs = window.getComputedStyle ? window.getComputedStyle(z) : null;
						if (cs && (cs.display === 'none' || cs.visibility === 'hidden')) return false;
					} catch (_) {}
					if (allowed) {
						const zc = String(z.dataset && z.dataset.color || '').toLowerCase();
						if (zc && !allowed.includes(zc)) return false;
					}
					return true;
				});
				return visible.length ? visible : ZONE_ORDER;
			} catch (e) {
				return ZONE_ORDER;
			}
		})();
		const idx = order.indexOf(currentId);
		if (idx === -1) return;
		let nextIdx = (idx + direction + order.length) % order.length;
		const nextId = order[nextIdx];
		const nextZone = document.getElementById(nextId);
		if (nextZone) {
			// close current and open next
			// Use longer delay to ensure previous zoom is fully closed and layout is stable
			setTimeout(() => openZoom(nextZone), 100);
		}
	}
	
	const excludedZones = ['scoreboard', 'gold-zone', 'card-choice-zone', 'controls', 'bonus-zone', 'bottom-bar'];

	document.querySelectorAll('.zone').forEach(zone => {
	  if (zone.classList.contains('zone-placeholder')) return;
	  zone.addEventListener('click', e => {
		// Allow zoom in mobile portrait AND mobile landscape sidebar mode
		const isMobileSidebarMode = document.body.classList.contains('mobile-sidebar-layout');
		if (window.innerWidth > MOBILE_BREAKPOINT && !isMobileSidebarMode) return;
		// Clicking the zone-info UI should not trigger zoom (prevents layout jump).
		if (e.target && e.target.closest && (e.target.closest('.zone-info-btn') || e.target.closest('.zone-info-popover'))) return;
		if (skipNextZoneClick) {
		  skipNextZoneClick = false;
		  return;
		}
		if (draggedBlock || draggedShape) return;
		const mainZone = zone.closest('.red-group') || zone;
		if (excludedZones.includes(zone.id) || (mainZone.id && excludedZones.includes(mainZone.id))) return;
		// Disallow zooming hidden zones (World 4 staging hides locked colors).
		try {
			const cs = window.getComputedStyle ? window.getComputedStyle(mainZone) : null;
			if (cs && (cs.display === 'none' || cs.visibility === 'hidden')) return;
		} catch (_) {}
		// World 4: disallow zoom into inactive/locked colors.
		try {
			const info = (typeof getWorldAndSubLevel === 'function') ? getWorldAndSubLevel(currentLevel) : null;
			const isWorld4 = !!(info && Number(info.world) === 4);
			if (isWorld4 && Array.isArray(world4AllowedColors) && world4AllowedColors.length) {
				const zc = String(mainZone.dataset && mainZone.dataset.color || '').toLowerCase();
				if (zc && !world4AllowedColors.includes(zc)) return;
			}
		} catch (_) {}
		if (e.pointerType === 'mouse' || e.pointerType === 'pen' || typeof e.pointerType === 'undefined') {
		  if (e.detail === 0 || e.detail > 1) return;
		}
		e.stopPropagation();
		openZoom(mainZone);
	  });
	});

	document.addEventListener('click', e => {
	  /*
		EN:
		- WHY: Clicking outside the focused zone closes the zoom view.
		- STATE: gated by `.zoomed-in` class on <body>.
		- OVERRIDE/DUPLICATE RISK: This is a global document click handler.
		  If other global click handlers exist (menu close, tap-to-place, etc.),
		  ordering + `stopPropagation()` decides which one â€œwinsâ€.
	*/
	  if (!document.body.classList.contains('zoomed-in')) return;
	  if (draggedBlock) return;
	  if (e.target.closest('.zone.zoom-focus')) return;
	  if (e.target.closest('.zone-placeholder')) return;
	  if (e.target.closest('#bottom-bar') || e.target.closest('#card-choice-zone') || e.target.closest('#controls') || e.target.closest('#gold-zone') || e.target.closest('#scoreboard') || e.target.closest('#menu-toggle')) return;
	  closeZoom();
	});

	document.addEventListener('keydown', e => {
	  /*
		EN:
		- WHY: Keyboard escape hatch for zoom mode.
		- DUPLICATE RISK: Escape is also handled in the drag/shape keydown handler below.
		  Make sure the combined behavior is intentional.
	*/
	  if (e.key === 'Escape') {
		closeZoom();
	  }
	  
	  // Ctrl+Z voor undo
	  if ((e.ctrlKey || e.metaKey) && e.key === 'z' && !e.shiftKey) {
		e.preventDefault();
		if (typeof undo === 'function') {
			undo();
		}
	  }
	});


  // ---------- GENERATE ROOTS (green + red variants) ----------
	function generateRoots(gridId, rows = 12, cols = 12, branchCount = 5, splitChance = 0.25, coinChance = 0.05, minSymbols = 3, maxSymbols = 6, maxCoins = 5, isRed = false, trapChance = 0, maxTraps = 0, blackHoleChance = BLACK_HOLE_DEFAULT_CHANCE, options = null) {
	  const container = document.getElementById(gridId);
	  
	  // Check of container bestaat
	  if (!container) {
		console.warn(`âš ï¸ Grid element with ID "${gridId}" not found, skipping generation`);
		return;
	  }
	  
	  container.innerHTML = '';

	  // Bepaal huidige world voor world-specifieke tuning
	  let worldNum = 1;
	  try {
		const info = (typeof getWorldAndSubLevel === 'function') ? getWorldAndSubLevel(typeof currentLevel !== 'undefined' ? currentLevel : 1) : null;
		worldNum = Number(info?.world || 1) || 1;
	  } catch (e) {}

	  // Red determinism: enforce a predictable number of active cells AND fixed points per subgrid.
	  // Note: points are NOT derived from cells; red subgrids award fixed points when fully filled.
	  const redTargetsById = {
		'red-grid1': { tier: 'klein', cells: 12, points: 20 },
		'red-grid2': { tier: 'midden', cells: 16, points: 35 },
		'red-grid3': { tier: 'groot', cells: 20, points: 45 },
		'red-grid4': { tier: 'mega', cells: 24, points: 58 },
		// World 3 uses 6 red grids; reuse the mega tier unless overridden.
		'red-grid5': { tier: 'mega', cells: 24, points: 80 },
		'red-grid6': { tier: 'mega', cells: 24, points: 80 }
	  };
	  const opts = (options && typeof options === 'object') ? options : null;
	  const preset = redTargetsById[gridId] || null;
	  let resolvedRedTargetCells = isRed
		? (Number(opts?.targetCells) || Number(preset?.cells) || 0)
		: 0;
	  let resolvedRedTargetPoints = isRed
		? (Number(opts?.targetPoints) || Number(preset?.points) || 0)
		: 0;
	  // Back-compat: if only points are provided, infer a cell target (legacy 2pt/cell rule).
	  if (isRed && !(resolvedRedTargetCells > 0) && (resolvedRedTargetPoints > 0)) {
		resolvedRedTargetCells = Math.max(1, Math.round(resolvedRedTargetPoints / 2));
	  }
	  const baseRedCells = resolvedRedTargetCells;
	  const baseRedPointRatio = (resolvedRedTargetCells > 0 && resolvedRedTargetPoints > 0)
		? (resolvedRedTargetPoints / resolvedRedTargetCells)
		: 2;
	const redDensityBoost = isRed && (worldNum <= 2 || worldNum === 3);
	  let redTargetActiveCells = (isRed && resolvedRedTargetCells > 0)
		? Math.max(1, Math.floor(resolvedRedTargetCells))
		: 0;
	if (redDensityBoost && redTargetActiveCells > 0) {
		const densityFactor = worldNum <= 2 ? 0.15 : 0.08;
		const extra = Math.max(2, Math.round(redTargetActiveCells * densityFactor));
		redTargetActiveCells += extra;
		if (baseRedPointRatio > 0) {
		  resolvedRedTargetPoints = Math.max(resolvedRedTargetPoints, Math.round(redTargetActiveCells * baseRedPointRatio));
		}
	  }
	  if (isRed && redTargetActiveCells > 0) {
		const maxCapacity = Math.max(1, Math.floor(rows) * Math.floor(cols));
		redTargetActiveCells = Math.min(redTargetActiveCells, maxCapacity);
		if (!(resolvedRedTargetPoints > 0)) resolvedRedTargetPoints = redTargetActiveCells * 2;
		try {
			container.dataset.redTargetCells = String(redTargetActiveCells);
			container.dataset.redTargetPoints = String(resolvedRedTargetPoints);
			if (preset && preset.tier) container.dataset.redTierName = String(preset.tier);
		} catch (e) {}
	  }
	container.dataset.rows = String(rows);
	container.dataset.cols = String(cols);
	  container.style.position = 'relative';
	  container.style.width = `calc(${cols} * var(--cell-size))`;
	  container.style.height = `calc(${rows} * var(--cell-size))`;
	
	  const toIndex = (r,c)=> r*cols + c;
	  const isInside = (r,c)=> r>=0 && r<rows && c>=0 && c<cols;

	  const clusterSet = new Set();
	  const clusterMap = {};
	  const dirs = [{r:-1,c:0},{r:1,c:0},{r:0,c:-1},{r:0,c:1}];

	  const defaultColorChances = [
		{ color: 'blue', weight: 1 },
		{ color: 'green', weight: 1 },
		{ color: 'red', weight: 1 },
		{ color: 'purple', weight: 1 },
		{ color: 'yellow', weight: 1 }
	  ];
	  const objectiveColorChances = (typeof window !== 'undefined' && window && Array.isArray(window.__objectiveBonusColorChances))
		? window.__objectiveBonusColorChances
		: null;
	  const colorChances = objectiveColorChances || defaultColorChances;
	  const totalWeight = colorChances.reduce((s, o) => s + (Number(o.weight) || 0), 0) || 1;

	  const centerR = Math.floor(rows/2);
	  const centerC = Math.floor(cols/2);
	  const centerIdx = toIndex(centerR, centerC);
	  container.dataset.startX = String(centerC);
	  container.dataset.startY = String(centerR);

	  // WORLD 2 green: special generator (mega root in center -> 4 arms with World 1-like branching).
	  const isWorld2Green = !isRed && gridId === 'green-grid' && (rows >= 24 || cols >= 24);

	  // Fallback for tall-green variants (older tuning): fewer, longer continuous branches.
	  const isTallGreen = !isWorld2Green && !isRed && gridId === 'green-grid' && rows >= 40;
	  let growthBudget = Math.max(0, Math.floor(branchCount));
	  const branchAttempts = isTallGreen ? Math.max(18, Math.floor(growthBudget / 10)) : Math.max(1, Math.floor(branchCount));
	  const minBranchLen = isTallGreen ? 8 : 2;
	  const maxBranchLen = isTallGreen ? 18 : 5;

		function makeCell(r,c,isCenter=false, isVoid=false){
		  const el = document.createElement('div');
		  el.classList.add('cell','root-cell');
		  if(isVoid) {
			el.classList.add('void-cell');
			el.style.opacity = '0';
			el.style.pointerEvents = 'none';
		  }
		  if(isCenter && !isRed && !isVoid) el.classList.add('bold-cell');
		  el.style.position = 'absolute';
		  el.style.left = `calc(${c} * var(--cell-size))`;
		  el.style.top  = `calc(${r} * var(--cell-size))`;
		  el.style.zIndex = isCenter ? 10 : 1;
		  // Sla r/c op als data-attributes â€” dit is cruciaal voor de edge-detectie
		  el.dataset.r = String(r);
		  el.dataset.c = String(c);
		  el.dataset.x = c; // kolomindex
		  el.dataset.y = r; // rijindex
		  el.dataset.zoneId = gridId;
	
		  if(!isVoid) {
			// World 2 green UX: allow dragging/panning the grid without accidentally toggling cells.
			// We toggle on pointerup and ignore it if the zone was drag-scrolled.
			if (gridId === 'green-grid' && (rows >= 24 || cols >= 24)) {
				el.addEventListener('pointerup', (e)=>{
					const zoneEl = container.closest('#green-zone');
					if (zoneEl && zoneEl.dataset.dragScrolling === 'true') return;
					e.preventDefault();
					toggleCell(el, gridId);
				});
			} else {
				el.addEventListener('pointerdown', (e)=>{ e.preventDefault(); toggleCell(el, gridId); });
			}
		  }
		  return el;
		}


	  // center
	  const centerCell = makeCell(centerR, centerC, true, false);
	  if (!isRed) centerCell.classList.add('bold-cell');
	  container.appendChild(centerCell);
	  clusterSet.add(centerIdx);
	  clusterMap[centerIdx] = centerCell;

	  // build branches first to determine which cells are active
	  // Verbeterde logica: creÃ«er bredere, speelbaardere gebieden
	  const endpoints = [{r:centerR,c:centerC}];
	  
	  // Helper functie om naburige cellen toe te voegen (voor breedte)
	  const addWidthCell = (r, c, dir) => {
		// Voeg een cel toe perpendiculair aan de richting voor breedte
		const perpendicular = [
		  {r: dir.c, c: -dir.r},  // 90 graden gedraaid
		  {r: -dir.c, c: dir.r}   // -90 graden gedraaid
		];
		const chosen = perpendicular[Math.floor(Math.random() * perpendicular.length)];
		const newR = r + chosen.r;
		const newC = c + chosen.c;
		if (isInside(newR, newC)) {
		  const idx = toIndex(newR, newC);
		  if (!clusterSet.has(idx)) {
			clusterSet.add(idx);
			if (isTallGreen && growthBudget > 0) growthBudget -= 1;
			return true;
		  }
		}
		return false;
	  };
	  
	  // Voor groen grid: zorg voor exact 8 eindpunten
	const targetEndpoints = !isRed ? 8 : Math.max(1, Math.floor(branchCount * splitChance));
	  
	  if (isWorld2Green) {
		// 1) Build a thick center "mega root" (2-3 wide).
		const thickness = Math.random() < 0.6 ? 2 : 3;
		const halfA = Math.floor((thickness - 1) / 2);
		const halfB = thickness - 1 - halfA;
		const top = Math.max(0, centerR - halfA);
		const bottom = Math.min(rows - 1, centerR + halfB);
		const left = Math.max(0, centerC - halfA);
		const right = Math.min(cols - 1, centerC + halfB);
		for (let rr = top; rr <= bottom; rr++) {
			for (let cc = left; cc <= right; cc++) {
				clusterSet.add(toIndex(rr, cc));
			}
		}

		// 2) Create 4 arms that branch like World 1.
		const armStarts = [];
		if (isInside(top - 1, centerC)) armStarts.push({ r: top - 1, c: centerC, primary: { r: -1, c: 0 } });
		if (isInside(bottom + 1, centerC)) armStarts.push({ r: bottom + 1, c: centerC, primary: { r: 1, c: 0 } });
		if (isInside(centerR, left - 1)) armStarts.push({ r: centerR, c: left - 1, primary: { r: 0, c: -1 } });
		if (isInside(centerR, right + 1)) armStarts.push({ r: centerR, c: right + 1, primary: { r: 0, c: 1 } });
		armStarts.forEach(s => clusterSet.add(toIndex(s.r, s.c)));

		const armBranches = Math.max(10, Math.floor(branchCount / 8));
		const chooseDirForArm = (primaryDir) => {
			// Bias outward + sideways, avoid going back toward the center.
			const weighted = [];
			for (const d of dirs) {
				let w = 1;
				if (d.r === primaryDir.r && d.c === primaryDir.c) w = 5;
				else if (d.r === -primaryDir.r && d.c === -primaryDir.c) w = 0.5;
				else w = 2;
				weighted.push({ d, w });
			}
			const total = weighted.reduce((s, x) => s + x.w, 0);
			let roll = Math.random() * total;
			for (const item of weighted) {
				roll -= item.w;
				if (roll <= 0) return item.d;
			}
			return primaryDir;
		};

		for (const arm of armStarts) {
			const armEndpoints = [{ r: arm.r, c: arm.c }];
			for (let b = 0; b < armBranches; b++) {
				const len = 2 + Math.floor(Math.random() * 4);
				const start = armEndpoints[Math.floor(Math.random() * armEndpoints.length)];
				let r = start.r;
				let c = start.c;
				const dir = chooseDirForArm(arm.primary);
				const makeWide = Math.random() < 0.20;
				for (let i = 0; i < len; i++) {
					r += dir.r;
					c += dir.c;
					if (!isInside(r, c)) break;
					const idx = toIndex(r, c);
					if (clusterSet.has(idx)) continue;
					clusterSet.add(idx);
					if (makeWide || Math.random() < 0.12) addWidthCell(r, c, dir);
					if (armEndpoints.length < targetEndpoints && i > 0 && Math.random() < splitChance) {
						armEndpoints.push({ r, c });
					}
				}
			}
		}
	  } else {
		for(let b=0;b<branchAttempts;b++){
		  if (isTallGreen && growthBudget <= 0) break;
		const len = minBranchLen + Math.floor(Math.random() * (maxBranchLen - minBranchLen + 1));
		  const start = endpoints[Math.floor(Math.random()*endpoints.length)];
		  let r = start.r, c = start.c;
		  const dir = dirs[Math.floor(Math.random()*dirs.length)];
		  
		const redWideBias = isRed && (worldNum <= 2 || worldNum === 3);
		const redWideChance = isRed ? (worldNum === 3 ? 0.35 : 0.55) : 0.25;
		// 25% kans op breedte voor niet-rood; voor wereld 1/2 (en milder bij 3) rood ook bredere takken
		const makeWide = (!isRed && Math.random() < 0.25) || (redWideBias && Math.random() < redWideChance);

		  for(let i=0;i<len;i++){
			if (isTallGreen && growthBudget <= 0) break;
			r += dir.r; c += dir.c;
			if(!isInside(r,c)) break;
			const idx = toIndex(r,c);
			if(clusterSet.has(idx)) continue;

			clusterSet.add(idx); // Markeer deze cel als actief (niet void)
			if (isTallGreen && growthBudget > 0) growthBudget -= 1;
			
			// Maak de tak breder op deze positie
			if (makeWide || Math.random() < 0.1) {
			  addWidthCell(r, c, dir);
			}

			// Voeg eindpunt toe als we er nog niet genoeg hebben (voor groen grid)
			if (!isRed && endpoints.length < targetEndpoints && i > 0) {
			  if (Math.random() < splitChance) endpoints.push({r,c});
			} else if (isRed && Math.random() < splitChance) {
			  endpoints.push({r,c});
			}
		  }
		}
	  }
	  
	  // Red determinism: enforce a fixed number of active (non-void) cells.
	  if (isRed && redTargetActiveCells > 0) {
		try {
			const distFromCenter = (idx) => {
				const r = Math.floor(idx / cols);
				const c = idx % cols;
				return Math.abs(r - centerR) + Math.abs(c - centerC);
			};
			const neighborIdxs = (idx, set) => {
				const r = Math.floor(idx / cols);
				const c = idx % cols;
				const out = [];
				for (const d of dirs) {
					const rr = r + d.r;
					const cc = c + d.c;
					if (!isInside(rr, cc)) continue;
					const nIdx = toIndex(rr, cc);
					if (set.has(nIdx)) out.push(nIdx);
				}
				return out;
			};
			const neighborCount = (idx, set) => neighborIdxs(idx, set).length;
			const isConnectedSet = (set) => {
				if (!set.size) return true;
				const it = set.values();
				const start = it.next().value;
				const q = [start];
				const seen = new Set([start]);
				while (q.length) {
					const cur = q.pop();
					for (const n of neighborIdxs(cur, set)) {
						if (seen.has(n)) continue;
						seen.add(n);
						q.push(n);
					}
				}
				return seen.size === set.size;
			};
			const canRemove = (idx) => {
				if (idx === centerIdx) return false;
				if (!clusterSet.has(idx)) return false;
				if (clusterSet.size <= 2) return false;
				const tmp = new Set(clusterSet);
				tmp.delete(idx);
				return isConnectedSet(tmp);
			};
			const frontierCells = () => {
				const frontierSet = new Set();
				clusterSet.forEach(idx => {
					const r = Math.floor(idx / cols);
					const c = idx % cols;
					for (const d of dirs) {
						const rr = r + d.r;
						const cc = c + d.c;
						if (!isInside(rr, cc)) continue;
						const nIdx = toIndex(rr, cc);
						if (!clusterSet.has(nIdx)) frontierSet.add(nIdx);
					}
				});
				return Array.from(frontierSet);
			};
			const pickFrontierToAdd = () => {
				const frontier = frontierCells();
				if (!frontier.length) return null;
				// Prefer further-out cells to avoid overly square blobs.
				frontier.sort((a, b) => distFromCenter(b) - distFromCenter(a));
				const pickPool = frontier.slice(0, Math.min(frontier.length, 6));
				return pickPool[Math.floor(Math.random() * pickPool.length)];
			};
			const pickInteriorToRemove = () => {
				const candidates = Array.from(clusterSet).filter(i => i !== centerIdx);
				// Prefer interior (higher degree), then closer-to-center (creates holes), then random.
				candidates.sort((a, b) => {
					const d = neighborCount(b, clusterSet) - neighborCount(a, clusterSet);
					if (d) return d;
					const dc = distFromCenter(a) - distFromCenter(b);
					if (dc) return dc;
					return Math.random() - 0.5;
				});
				for (const idx of candidates) {
					if (canRemove(idx)) return idx;
				}
				return null;
			};

			clusterSet.add(centerIdx);
			// Shrink to target (connectivity-safe)
			while (clusterSet.size > redTargetActiveCells) {
				const rem = pickInteriorToRemove();
				if (rem === null) break;
				clusterSet.delete(rem);
			}
			// Grow to target (prefer outward frontier)
			while (clusterSet.size < redTargetActiveCells) {
				const add = pickFrontierToAdd();
				if (add === null) break;
				clusterSet.add(add);
			}

			// Make the red shape more interesting: carve a few "holes" via swap operations
			// (remove an interior cell, add a frontier cell) while keeping connectivity.
			let swapAttempts = Math.max(3, Math.min(14, Math.floor(redTargetActiveCells * 0.8)));
			if (redDensityBoost) swapAttempts = Math.max(1, Math.floor(swapAttempts * 0.35));
			for (let k = 0; k < swapAttempts; k++) {
				const rem = pickInteriorToRemove();
				if (rem === null) break;
				clusterSet.delete(rem);
				const add = pickFrontierToAdd();
				if (add !== null) {
					clusterSet.add(add);
				} else {
					// revert
					clusterSet.add(rem);
					break;
				}
				// Ensure we didn't break connectivity (rare, but safe)
				if (!isConnectedSet(clusterSet)) {
					clusterSet.delete(add);
					clusterSet.add(rem);
				}
			}
		} catch (e) {}
	  }

	  // World 1 (green): avoid extremely tiny generations.
	  // We grow the non-void cluster by adding frontier-adjacent cells until a minimum is reached.
	  if (!isRed && gridId === 'green-grid' && worldNum === 1) {
		try {
			const maxCapacity = Math.max(1, Math.floor(rows) * Math.floor(cols));
			// Target: at least ~25% of the grid should be generated (15x15 => 56 cells).
			// This prevents rare cases where the cluster ends up as a very small cross.
			let minRootCells = Math.floor(maxCapacity * 0.25);
			minRootCells = Math.max(40, minRootCells);
			minRootCells = Math.min(maxCapacity, minRootCells);

			const frontierCells = () => {
				const frontierSet = new Set();
				clusterSet.forEach(idx => {
					const r = Math.floor(idx / cols);
					const c = idx % cols;
					for (const d of dirs) {
						const rr = r + d.r;
						const cc = c + d.c;
						if (!isInside(rr, cc)) continue;
						const nIdx = toIndex(rr, cc);
						if (!clusterSet.has(nIdx)) frontierSet.add(nIdx);
					}
				});
				return Array.from(frontierSet);
			};

			if (clusterSet.size < minRootCells) {
				let safety = 0;
				const safetyLimit = Math.min(5000, maxCapacity * 20);
				while (clusterSet.size < minRootCells && safety < safetyLimit) {
					safety++;
					const frontier = frontierCells();
					if (!frontier.length) break;
					const pick = frontier[Math.floor(Math.random() * frontier.length)];
					clusterSet.add(pick);
				}
			}
		} catch (e) {}
	  }
	  
	  // NU: Maak ALLE cellen aan - actieve EN void cellen
	  for(let r = 0; r < rows; r++) {
		for(let c = 0; c < cols; c++) {
		  const idx = toIndex(r, c);
		  const isActive = clusterSet.has(idx);
		  const isCenter = (idx === centerIdx);
		  
		  // Als de cel al bestaat (center), skip
		  if(clusterMap[idx]) continue;
		  
		  // Maak de cel - actief of void
		  const cell = makeCell(r, c, isCenter, !isActive);
		  container.appendChild(cell);
		  clusterMap[idx] = cell;
		}
	  }

	  // ---------- assign symbols & coins only to existing cells ----------
	  const clusterIndices = Array.from(clusterSet).filter(i => i !== centerIdx);
	  shuffleArray(clusterIndices);

	  // Voor groen grid: schaal symbolen en coins op basis van aantal actieve cellen
	  let finalMinSymbols = minSymbols;
	  let finalMaxSymbols = maxSymbols;
	  let finalMaxCoins = maxCoins;
	  let finalCoinChance = coinChance;
	  
	  if (!isRed) {
		const clusterSize = clusterIndices.length;
		// Bereken percentage van grid dat gevuld is (ongeveer 15-25% voor symbolen)
		const symbolPercentage = 0.20; // 20% van de cellen krijgen symbolen
		const coinPercentage = 0.08;   // 8% van de cellen krijgen coins
		
		// Voor kleine grids (<20 cellen): halveer de minimale EN maximale waardes
		const isSmallGrid = clusterSize < 20;
		const minSymbolBase = isSmallGrid ? 4 : 8;
		const maxSymbolBase = isSmallGrid ? 6 : 12;
		const maxCoinBase = isSmallGrid ? 2 : 3;
		
		finalMinSymbols = Math.max(minSymbolBase, Math.floor(clusterSize * (symbolPercentage - 0.05)));
		finalMaxSymbols = Math.max(maxSymbolBase, Math.floor(clusterSize * (symbolPercentage + 0.05)));
		finalMaxCoins = Math.max(maxCoinBase, Math.floor(clusterSize * coinPercentage));
		finalCoinChance = 0.15; // Hogere kans maar minder max coins

		// World 2/3 request: green has too many symbols/coins vs other grids.
		// Scale to ~60% of current density, but only for the green grid in World 2/3.
		try {
			const safeLevel = (typeof currentLevel !== 'undefined') ? currentLevel : 1;
			const worldInfo = (typeof getWorldAndSubLevel === 'function') ? getWorldAndSubLevel(safeLevel) : { world: 1 };
			const worldNum = Number(worldInfo?.world || 1);
			if (gridId === 'green-grid' && (worldNum === 2 || worldNum === 3)) {
				const SCALE = 0.6;
				finalMinSymbols = Math.max(0, Math.floor(finalMinSymbols * SCALE));
				finalMaxSymbols = Math.max(finalMinSymbols, Math.floor(finalMaxSymbols * SCALE));
				finalMaxCoins = Math.max(0, Math.floor(finalMaxCoins * SCALE));
				finalCoinChance = Math.max(0, Math.min(1, finalCoinChance * SCALE));
			}
		} catch (e) {}
	  }

	  // SYMBOLS
	  const symCount = Math.min(clusterIndices.length, Math.floor(Math.random()*(finalMaxSymbols-finalMinSymbols+1))+finalMinSymbols);
	  const symbolIndices = new Set(clusterIndices.slice(0, symCount));

	  // COINS
	  const remainingForCoins = clusterIndices.filter(i => !symbolIndices.has(i));
	  shuffleArray(remainingForCoins);
	  const coinSet = new Set();
	  for(const cand of remainingForCoins){
		if(coinSet.size >= finalMaxCoins) break;
		if(Math.random() < finalCoinChance) coinSet.add(cand);
	  }

	  const trapSet = new Set();
	  const trapChanceClamped = Math.max(0, Math.min(1, trapChance || 0));
	  const trapLimit = maxTraps > 0 ? maxTraps : 0;
	  if (trapChanceClamped > 0 && trapLimit !== 0) {
		const trapCandidates = clusterIndices.filter(i => !symbolIndices.has(i) && !coinSet.has(i));
		shuffleArray(trapCandidates);
		for (const cand of trapCandidates) {
		  if (trapSet.size >= trapLimit) break;
		  if (Math.random() < trapChanceClamped) trapSet.add(cand);
		}
	  }
	  trapSet.forEach(idx => {
		symbolIndices.delete(idx);
		coinSet.delete(idx);
	  });

	  const blackHoleSet = new Set();
	  const blackHoleChanceClamped = Math.max(0, Math.min(1, blackHoleChance || 0));
	  const blackHoleLimit = blackHoleChanceClamped > 0 ? 1 : 0;
	  if (blackHoleChanceClamped > 0 && blackHoleLimit !== 0) {
		const blackHoleCandidates = clusterIndices.filter(i => !symbolIndices.has(i) && !coinSet.has(i) && !trapSet.has(i));
		shuffleArray(blackHoleCandidates);
		for (const cand of blackHoleCandidates) {
		  if (blackHoleSet.size >= blackHoleLimit) break;
		  if (Math.random() < blackHoleChanceClamped) blackHoleSet.add(cand);
		}
	  }
	  blackHoleSet.forEach(idx => {
		symbolIndices.delete(idx);
		coinSet.delete(idx);
	  });

	  // apply symbols & coins
	  for(const idx of clusterSet){
		const cell = clusterMap[idx];
		if(!cell) continue;

		if(blackHoleSet.has(idx)){
		  decorateTrapCell(cell, { forceType: 'blackHole', blackHoleChance });
		}

		else if(trapSet.has(idx)){
		  decorateTrapCell(cell, { forceType: 'pit', blackHoleChance: 0 });
		}

		else if(symbolIndices.has(idx)){
		  const sym = document.createElement('div');
		  sym.classList.add('symbol', 'gray');
		  let rr = Math.random()*totalWeight;
		  for(const cc of colorChances){
			if(rr < cc.weight){ sym.classList.add(cc.color); break; }
			rr -= cc.weight;
		  }
		  cell.appendChild(sym);
		}

		else if(coinSet.has(idx)){
		  cell.classList.add('gold-cell');
		}
	  }

	  // ---------- mark endpoints ----------
	  if (!isRed) {
		const greenCfg = (gridId === 'green-grid' && typeof window !== 'undefined') ? (window.greenGridConfig || null) : null;
		const targetMinEndpoints = Math.max(0, Number(greenCfg?.minEndPoints ?? 8) || 8);
		const targetMinEndCells = Math.max(0, Number(greenCfg?.minEndCellPoints ?? targetMinEndpoints) || targetMinEndpoints);
		const targetMaxEndCells = Math.max(targetMinEndCells, Number(greenCfg?.maxEndCellPoints ?? 30) || 30);
		// We want enough candidates to pick from.
		const desiredEndpointPool = Math.max(targetMinEndpoints, targetMinEndCells);
		// End-cell count: clamp to available endpoints, but allow >8 in World 2.
		const desiredEndCellCount = Math.min(targetMaxEndCells, Math.max(targetMinEndCells, desiredEndpointPool));

		// Verzamel alle potentiÃ«le eindpunten (cellen met max 1 buur)
		const potentialEndpoints = [];
		for(const idx of clusterSet){
		  const r = Math.floor(idx/cols), c = idx % cols;
		  let neighbors=0;
		  for(const d of dirs){
			const nr=r+d.r, nc=c+d.c;
			if(isInside(nr,nc) && clusterSet.has(toIndex(nr,nc))) neighbors++;
		  }
		  if(neighbors <= 1 && idx !== centerIdx){
			potentialEndpoints.push(idx);
		  }
		}
		
		// Als we niet genoeg eindpunten hebben, voeg cellen met 2 buren toe
		if (potentialEndpoints.length < desiredEndpointPool) {
		  const additionalEndpoints = [];
		  for(const idx of clusterSet){
			if (potentialEndpoints.includes(idx) || idx === centerIdx) continue;
			const r = Math.floor(idx/cols), c = idx % cols;
			let neighbors=0;
			for(const d of dirs){
			  const nr=r+d.r, nc=c+d.c;
			  if(isInside(nr,nc) && clusterSet.has(toIndex(nr,nc))) neighbors++;
			}
			if(neighbors === 2){
			  additionalEndpoints.push(idx);
			}
		  }
		  shuffleArray(additionalEndpoints);
		  const needed = desiredEndpointPool - potentialEndpoints.length;
		  potentialEndpoints.push(...additionalEndpoints.slice(0, needed));
		}
		
		// Als nog steeds niet genoeg, neem cellen met 3 buren
		if (potentialEndpoints.length < desiredEndpointPool) {
		  const moreEndpoints = [];
		  for(const idx of clusterSet){
			if (potentialEndpoints.includes(idx) || idx === centerIdx) continue;
			const r = Math.floor(idx/cols), c = idx % cols;
			let neighbors=0;
			for(const d of dirs){
			  const nr=r+d.r, nc=c+d.c;
			  if(isInside(nr,nc) && clusterSet.has(toIndex(nr,nc))) neighbors++;
			}
			if(neighbors === 3){
			  moreEndpoints.push(idx);
			}
		  }
		  shuffleArray(moreEndpoints);
		  const needed = desiredEndpointPool - potentialEndpoints.length;
		  potentialEndpoints.push(...moreEndpoints.slice(0, needed));
		}
		
		// Shuffle en selecteer een groter aantal eindpunten (World 2: meer end-cells)
		shuffleArray(potentialEndpoints);
		const selectedEndpoints = potentialEndpoints.slice(0, Math.min(desiredEndCellCount, potentialEndpoints.length));
		
		// Markeer de geselecteerde eindpunten
		for(const idx of selectedEndpoints){
		  const cell = clusterMap[idx];
		  if(cell){
			cell.querySelectorAll('.symbol').forEach(s=>s.remove());
			cell.classList.remove('gold-cell');
			if (trapSet.has(idx)) {
			  cell.classList.remove('trap-cell');
			  delete cell.dataset.trap;
			  cell.querySelectorAll('.trap-symbol').forEach(s => s.remove());
			}
			cell.classList.add('end-cell');
			cell.style.zIndex = 5;
		  }
		}
	  }

	  if (!isRed && gridId === 'green-grid') {
		try { requestAnimationFrame(() => { try { syncZoneHeights(); } catch (_) {} }); } catch (_) {}
	  }
	  updateScore();
	  return clusterSet;
	}

  // ---------- toggleCell / coins ----------
	function toggleCell(cell, zoneId, explicitColor = null, partOfShape = false){

	if(!cell) return;
	if(cell.classList.contains('void-cell') || cell.dataset.disabled === 'true') return;

	if (!partOfShape) {
		if (draggedBlock) return;
		const isClassicMode = document.body.classList.contains('classic-mode');
		// Classic mode: allow direct click/tap placement without debug mode and without requiring zoom.
		if (!debugMode && !isClassicMode) {
			if (window.innerWidth <= MOBILE_BREAKPOINT && !document.body.classList.contains('zoomed-in')) {
				return;
			}
			return;
		}
	}
	
    // bepaal of cel voorheen actief was
	  const was = cell.classList.contains('active');

	  // push history (zodat undo werkt)
	  if (!partOfShape) {
		const actionId = ++actionSequence;
		historyStack.push({cell:cell, wasActive: was, sequence: actionId});
		updateUndoButton();
	  }

	  // bepaal zone en zoneColor op een robuuste manier
	  let zone = null;
	  if (zoneId) zone = document.getElementById(zoneId);
	  if (!zone) zone = cell.closest('.zone');
	  
	  const zoneColor = explicitColor || zone?.dataset?.color || '';
			
	 if(was) {
		// --- DEACTIVEREN ---
		cell.classList.remove('active');
		cell.classList.remove('preview-allowed', 'preview-denied', 'edge-cell');

		// Cleanup dataset
		delete cell.dataset.clusterScore;
		delete cell.dataset.clusterPending;
		delete cell.dataset.activationSequence;
		delete cell.dataset.placementId;
	  } else {
		cell.classList.add('active');
		cellActivationSequence += 1;
		cell.dataset.activationSequence = String(cellActivationSequence);
		if (partOfShape && currentPlacementId) {
			cell.dataset.placementId = currentPlacementId;
		} else {
			delete cell.dataset.placementId;
		}
		
		// Clean up portal visual elements when portal cell becomes active
		// BUT keep the bold-cell class so portal remains a valid start point for future placements
		if (cell.classList.contains('portal-cell')) {
			const portalSymbol = cell.querySelector('.portal-symbol');
			if (portalSymbol) portalSymbol.remove();
			cell.classList.remove('portal-cell');
			// IMPORTANT: Keep bold-cell class so the portal remains usable as a start position
		}

		// World 4 (and scenarios): key unlocks a door color when activated
		try {
			const worldInfo = (typeof getWorldAndSubLevel === 'function') ? getWorldAndSubLevel(currentLevel) : null;
			const isWorld4 = !!(worldInfo && Number(worldInfo.world) === 4);
			const isScenario = !!(window && window._locusScenarioMode);
			const allowKeyDoorLogic = isWorld4 || isScenario;
			if (allowKeyDoorLogic && cell.classList.contains('key-cell') && cell.dataset.keyColor && cell.dataset.keyConsumed !== 'true') {
				const keyColor = String(cell.dataset.keyColor || '').toLowerCase();
				cell.dataset.keyConsumed = 'true';
				cell.classList.add('key-consumed');
				try { unlockWorld4Color(keyColor); } catch (e) {}
				// Remove the key glyph once consumed
				try {
					const sym = cell.querySelector('.key-symbol');
					if (sym) sym.remove();
				} catch (e) {}
				// World 4 upgrade: key grants a matching bonus
				try {
					if (hasUpgrade('world4KeyEcho')) {
						const bonusKey = WORLD4_COLOR_TO_BONUS_KEY[keyColor];
						if (bonusKey) {
							addBonusCharge(bonusKey, 1, { trackCollection: true });
							const label = BONUS_COLOR_CONFIG?.[bonusKey]?.label || bonusKey;
							showObjectiveToast(`ðŸ—ï¸ Bonus gekregen: ${label}`);
						}
					}
				} catch (e) {}
				try { showObjectiveToast(`ðŸ—ï¸ Sleutel gebruikt: ${keyColor} ontgrendeld!`); } catch (e) {}
			}
				// World 4 (and scenarios): doors only open when you have the key AND activate the door-cell.
				if (allowKeyDoorLogic && cell.classList.contains('door-cell') && cell.dataset.doorId && !cell.classList.contains('door-open')) {
					const doorColor = String(cell.dataset.doorColor || '').toLowerCase();
					if (doorColor && !isWorld4ColorUnlocked(doorColor)) {
						// In debug/click scenarios, refuse opening the door without the key.
						cell.classList.remove('active');
						try { showObjectiveToast('ðŸ”’ Je hebt eerst de sleutel nodig.'); } catch (e) {}
					} else {
						try { openWorld4Door(String(cell.dataset.doorId)); } catch (e) {}
					}
				}
		} catch (e) {}
				// zorg dat achtergrond consistent wordt gezet: expliciete kleur (bv. van placeShape) of zoneColor
				try {
					const rainbowGradient = 'linear-gradient(45deg, #f06272, #fff25a, #4ed346, #5d90f0, #a35eff)';
					let appliedBg = '';
					if (explicitColor) appliedBg = (explicitColor === 'rainbow') ? rainbowGradient : explicitColor;
					else if (zoneColor) appliedBg = (zoneColor === 'rainbow') ? rainbowGradient : zoneColor;

					// If this is a designated start-cell in the green zone, force the lighter green (do NOT use dark end-cell color)
					if (cell.classList.contains('start-cell')) {
						const zcol = String(zone && zone.dataset ? (zone.dataset.color || '') : '').toLowerCase();
						if (zcol === 'groen' || zcol === 'green') {
							appliedBg = '#92c28c';
							try { cell.style.borderColor = '#c1ffa8'; } catch (e) {}
						}
					}

					cell.style.background = appliedBg;
				} catch (e) { /* ignore styling errors */ }
	  }
    // If this cell is a coin and is activated, add coin; if deactivated, remove coin
	if(cell.classList.contains('gold-cell')){
      if(cell.classList.contains('active')) { 
	  const rect = cell.getBoundingClientRect();
		sparkleEffect(rect.left + rect.width / 2, rect.top);
	  addCoin(); 
	} else removeCoin();
    }
	
	let bonusClaim = null;
	hasSymbol = cell.querySelector('.symbol');
	if(hasSymbol && cell.classList.contains('active') && cell.dataset.bonusConsumed !== 'true'){
		// World 2 field event: bonus upgrade shop (grants 1 free random upgrade)
		if (hasSymbol.classList.contains('upgrade-shop-symbol') || cell.dataset.bonusUpgradeEvent === 'true') {
			cell.dataset.bonusConsumed = 'true';
			delete cell.dataset.bonusUpgradeEvent;
			hasSymbol.classList.add('bonus-used');
			try { hasSymbol.remove(); } catch {}
			// Directly grant the free upgrade without opening the shop modal
			grantRandomBonusUpgrade();
		} else if (hasSymbol.classList.contains('mega-bonus-symbol')) {
			const megaBonusColor = hasSymbol.dataset.megaBonusColor;
			cell.dataset.bonusConsumed = 'true';
			hasSymbol.classList.add('bonus-used');
			const rect = cell.getBoundingClientRect();
			const popupColor = megaBonusColor || zoneColor || 'white';
			showScoreAnimation(rect.left + rect.width/2, rect.top + rect.height/2, "MEGA BONUS!", popupColor);
			// Bonus shop is now a field event (no modal). Grant a free random upgrade.
			setTimeout(() => {
				grantRandomBonusUpgrade();
			}, 250);
		} else {
			// Normale bonus handling
			const bonusKey = getBonusKeyFromSymbol(hasSymbol);
			const grantedAmount = bonusKey ? grantBonusCharge(bonusKey) : 0;
			if (grantedAmount > 0) {
				cell.dataset.bonusConsumed = 'true';
				hasSymbol.classList.add('bonus-used');
				const rect = cell.getBoundingClientRect();
				const popupColor = bonusKey || zoneColor || 'white';
				showScoreAnimation(rect.left + rect.width/2, rect.top + rect.height/2, "BONUS", popupColor);
				bonusClaim = createBonusClaim(cell, hasSymbol, bonusKey, grantedAmount);
				if (!partOfShape) {
					const lastHistory = historyStack[historyStack.length - 1];
					if (lastHistory && lastHistory.cell === cell) {
						lastHistory.bonusClaims = lastHistory.bonusClaims || [];
						lastHistory.bonusClaims.push(bonusClaim);
					}
				}
			}
		}
	}

	// For shape placements, handle traps once per placement (see placeShape).
	if (!partOfShape) {
		ensureTrapState(cell, zone?.id || zoneId || '');
		ensureBlackHoleState(cell, zone?.id || zoneId || '');
	}

	updateScore(cell);
	syncPlaceholderForCell(cell);
	return bonusClaim ? { bonusClaim } : null;
	}

	function createCoinElement(index) {
		const coin = document.createElement('div');
		coin.classList.add('coin');
		coin.dataset.index = String(index);
		coin.addEventListener('pointerdown', (e) => {
			e.preventDefault();
			const isActive = coin.classList.contains('active');
			const isUsed = coin.classList.contains('used');
			if (!isActive && !isUsed) return;
			if (isUsed) {
				coin.classList.remove('used');
				coin.classList.add('active');
			} else {
				coin.classList.add('used');
				coin.classList.remove('active');
			}
			updateCoinCounter();
		});
		return coin;
	}

	function initialiseCoins(minCount = 50) {
		const container = document.getElementById('collected-coins');
		if (!container) return;
		const isClassicMode = document.body.classList.contains('classic-mode');
		const desired = isClassicMode ? 20 : Math.max(50, Number(minCount) || 0);
		const existing = container.children.length;
		if (existing >= desired) {
			updateCoinCounter();
			return;
		}
		for (let i = existing; i < desired; i++) {
			container.appendChild(createCoinElement(i));
		}
		updateCoinCounter();
	}

	function resetCoins() {
	  document.querySelectorAll('#collected-coins .coin').forEach(coin => {
		coin.classList.remove('active', 'used');
	  });
	  updateCoinCounter();
	}

	function resetScoreState() {
	  yellow = 0;
	  green = 0;
	  purple = 0;
	  blue = 0;
	  red = 0;
	  bonus = 0;
	  blackHoleBonus = 0;
	  totalBonusesCollected = 0;
	  latestScoreSnapshot = null;
	resetBonusEchoState();
	coinsAwardedFromScore = 0;
	coinsCollectedThisLevel = 0;
	cellActivationSequence = 0;
	placementSequence = 0;
	currentPlacementId = null;
	  resetBlackHoleState();
	  bonusCoinMilestones = 0;
	  window.scoredYellowColumns = new Set();
	  window.scoredYellowDiagonals = new Set();
	  window.scoredYellowSegments = new Set();
	window['blue-grid-scoredRows'] = new Map();
	window['blue-grid-scoredTargets'] = new Map();
	window['blue-grid-rowPlacements'] = new Map();
	window['blue-grid-placementScorings'] = new Map();
	  delete window.purpleConnections;
	  ['red-grid1', 'red-grid2', 'red-grid3', 'red-grid4'].forEach(id => {
		const grid = document.getElementById(id);
		if (grid) {
		  grid.dataset.completed = 'false';
		  grid.dataset.score = '0';
		}
	  });
	  const scoreIds = ['yellow-score','red-score','green-score','purple-score','blue-score'];
	  scoreIds.forEach(id => {
		const el = document.getElementById(id);
		if (el) el.textContent = '0';
	  });
	  const totalScoreEl = document.getElementById('total-score');
	  if (totalScoreEl) {
		totalScoreEl.textContent = '0';
		totalScoreEl.classList.remove('flash');
	  }
	  resetTrapState();
	  resetBonusState();
	  try { bonusBoostActiveColors = new Set(); } catch (e) {}
	}

	function addCoin(){
		const container = document.getElementById('collected-coins');
		if (!container) return;
		const coins = Array.from(container.querySelectorAll('.coin'));
		let next = coins.find(coin => !coin.classList.contains('active') && !coin.classList.contains('used'));
		if (!next) {
			next = createCoinElement(coins.length);
			container.appendChild(next);
		}
		next.classList.add('active');
		next.classList.remove('used');
		coinsCollectedThisLevel += 1;
		updateCoinCounter();
	}

	function removeCoin(){
	  const coins = Array.from(document.querySelectorAll('#collected-coins .coin.active'));
	  const last = coins.pop();
	  if(last) last.classList.remove('active', 'used');
	  updateCoinCounter();
	}

	const TRAP_ZONE_LABELS = {
	  'yellow-grid': 'Geel',
	  'purple-grid': 'Paars',
	  'green-grid': 'Groen',
	  'blue-grid': 'Blauw',
	  'gold-zone': 'Munten',
	  'red-zone': 'Rood'
	};

	function normalizeZoneId(zoneId = '') {
	  const normalized = String(zoneId || '').replace(/--placeholder$/, '');
	  if (normalized === 'yellow-zone') return 'yellow-grid';
	  if (normalized === 'green-zone') return 'green-grid';
	  if (normalized === 'blue-zone') return 'blue-grid';
	  if (normalized === 'purple-zone') return 'purple-grid';
	  return normalized;
	}

	function isBlackHoleCell(cell) {
		if (!cell) return false;
		if (cell.dataset?.blackHole === 'true') return true;
		if (cell.dataset?.trapType === 'blackHole') return true; // back-compat
		return false;
	}

	function buildBlackHoleRecord(cell, zoneId = '') {
		return {
			id: `bh-${nextTrapId()}`,
			cell,
			zoneId: normalizeZoneId(zoneId || cell?.dataset?.zoneId || cell?.closest?.('.grid')?.id || ''),
			penalty: 0,
			triggeredAt: Date.now(),
			type: 'blackHole'
		};
	}

	function nextTrapId() {
	  trapIdCounter += 1;
	  return `trap-${trapIdCounter}`;
	}

	function getTrapZoneLabel(zoneId = '') {
	  if (!zoneId) return 'Onbekend';
	  const normalized = normalizeZoneId(zoneId);
	  if (normalized.startsWith('red-grid')) return 'Rood';
	  return TRAP_ZONE_LABELS[normalized] || normalized;
	}

	function getTrapColorKey(zoneId = '') {
		const normalized = normalizeZoneId(String(zoneId || '')).toLowerCase();
		if (normalized.startsWith('red-grid') || normalized === 'red-zone') return 'red';
		if (normalized === 'yellow-grid' || normalized.indexOf('yellow') !== -1 || normalized.indexOf('geel') !== -1) return 'yellow';
		if (normalized === 'green-grid' || normalized.indexOf('green') !== -1 || normalized.indexOf('groen') !== -1) return 'green';
		if (normalized === 'blue-grid' || normalized.indexOf('blue') !== -1 || normalized.indexOf('blauw') !== -1) return 'blue';
		if (normalized === 'purple-grid' || normalized.indexOf('purple') !== -1 || normalized.indexOf('paars') !== -1) return 'purple';
		return 'other';
	}

	function getTrapKey(trap) {
		if (!trap) return null;
		try {
			const cell = trap.cell;
			const zone = normalizeZoneId(String(trap.zoneId || cell?.dataset?.zoneId || cell?.closest?.('.grid')?.id || ''));
			const x = cell?.dataset?.x;
			const y = cell?.dataset?.y;
			if (x !== undefined && y !== undefined) return `${zone}|${x}|${y}`;
			if (trap.id) return `id:${trap.id}`;
			if (cell?.dataset?.trapInstanceId) return `inst:${cell.dataset.trapInstanceId}`;
			if (cell) return `cell:${zone}|${cell}`;
		} catch (e) {}
		return trap && trap.id ? `id:${trap.id}` : null;
	}

	function getTrapCellKey(cell, zoneId = '') {
		if (!cell) return null;
		// CRITICAL: Use dataset.zoneId first (set at cell creation), then fall back to DOM traversal
		const zone = normalizeZoneId(zoneId || cell.dataset?.zoneId || cell.closest('.grid')?.id || '');
		const x = cell.dataset?.x;
		const y = cell.dataset?.y;
		if (x !== undefined && y !== undefined) return `${zone}|${x}|${y}`;
		return null;
	}

	function pruneTrapPenaltyByKey() {
		try {
			if (!(trapPenaltyByKey instanceof Map)) return;
			const toDelete = [];
			trapPenaltyByKey.forEach((_, key) => {
				try {
					const parts = String(key || '').split('|');
					if (parts.length < 3) { toDelete.push(key); return; }
					const zoneId = parts[0];
					const x = parts[1];
					const y = parts[2];
					const grid = document.getElementById(zoneId);
					if (!grid) { toDelete.push(key); return; }
					const selector = `.cell[data-x="${String(x)}"][data-y="${String(y)}"]`;
					const cell = grid.querySelector(selector);
					if (!cell || !cell.classList.contains('active') || cell.dataset.trapTriggered !== 'true') {
						if (cell) {
							delete cell.dataset.trapPenaltyApplied;
							delete cell.dataset.trapColorKey;
							delete cell.dataset.trapPenaltyKey;
						}
						toDelete.push(key);
					}
				} catch (e) { toDelete.push(key); }
			});
			if (toDelete.length) toDelete.forEach(k => trapPenaltyByKey.delete(k));
		} catch (e) {}
	}

	function pruneActiveTraps() {
		try {
			if (!Array.isArray(activeTraps)) return;
			activeTraps = activeTraps.filter(trap => {
				const cell = trap && trap.cell;
				if (!cell || !cell.isConnected) return false;
				if (!cell.classList || !cell.classList.contains('active')) return false;
				if (cell.dataset.trapTriggered !== 'true') return false;
				return true;
			});
		} catch (e) {}
	}

	function getOrCreatePlayerLogId() {
		try {
			let id = localStorage.getItem('locusPlayerId');
			if (!id) {
				id = `p-${Math.random().toString(36).slice(2, 10)}`;
				localStorage.setItem('locusPlayerId', id);
			}
			return id;
		} catch (e) {
			return 'anon';
		}
	}

	function logWorldProgress(payload = {}) {
		try {
			if (!WORLD_PROGRESS_LOG_ENABLED || !WORLD_PROGRESS_LOG_ENDPOINT) return;
			if (window._locusScenarioMode) return;
			const base = {
				event: payload.event || 'world_reached',
				playerId: getOrCreatePlayerLogId(),
				time: new Date().toISOString()
			};
			const body = JSON.stringify({ ...base, ...payload });
			if (navigator && typeof navigator.sendBeacon === 'function') {
				const blob = new Blob([body], { type: 'application/json' });
				navigator.sendBeacon(WORLD_PROGRESS_LOG_ENDPOINT, blob);
				return;
			}
			fetch(WORLD_PROGRESS_LOG_ENDPOINT, {
				method: 'POST',
				headers: { 'Content-Type': 'application/json' },
				body,
				keepalive: true
			}).catch(() => {});
		} catch (e) {}
	}

	function applyTrapPenaltyOnce(cell, normalizedZone, penaltyValue) {
		const penalty = Number(penaltyValue) || 0;
		if (!cell || penalty <= 0) return;
		const key = getTrapCellKey(cell, normalizedZone);
		if (!key || trapPenaltyByKey.has(key)) return;
		const colorKey = getTrapColorKey(normalizedZone);
		trapPenaltyByKey.set(key, { colorKey, penalty });
		cell.dataset.trapPenaltyApplied = 'true';
		cell.dataset.trapColorKey = colorKey;
		cell.dataset.trapPenaltyKey = key;
	}

	function ensureBlackHoleState(cell, zoneId = '', options = {}) {
		if (!cell || !isBlackHoleCell(cell)) return;
		if (cell.closest && cell.closest('.zone-placeholder')) return;
		const isActive = cell.classList.contains('active');
		const { silent = false } = options;
		if (isActive && cell.dataset.blackHoleTriggered !== 'true') {
			cell.dataset.blackHoleTriggered = 'true';
			const blackHoleUnlocked = hasUpgrade('blackHoleAccess');
			const blackHoleVisible = blackHoleUnlocked || isUpgradeAvailable('blackHoleAccess');
			if (!silent) {
				if (blackHoleUnlocked) {
					openBlackHoleChallenge(buildBlackHoleRecord(cell, zoneId));
				} else if (blackHoleVisible) {
					showObjectiveToast('ðŸŒ€ Koop de Zwart Gat Pas in de shop om dit speciale level te spelen.');
				}
			}
		} else if (!isActive && cell.dataset.blackHoleTriggered === 'true') {
			delete cell.dataset.blackHoleTriggered;
		}
	}

	function decorateTrapCell(cell, options = {}) {
	  if (!cell) return 'pit';
	  const { forceType = null, blackHoleChance = BLACK_HOLE_DEFAULT_CHANCE } = options;
	  const hasExistingBlackHole = blackHoleTrapPlaced || !!document.querySelector('.cell.trap-cell[data-trap-type="blackHole"]');
	  let trapType = forceType;
	  if (!trapType) {
		const chance = Math.max(0, Math.min(1, Number(blackHoleChance) || 0));
		trapType = chance > 0 && Math.random() < chance ? 'blackHole' : 'pit';
		if (trapType === 'blackHole' && hasExistingBlackHole) trapType = 'pit';
	  } else if (trapType === 'blackHole' && hasExistingBlackHole) {
		trapType = 'pit';
	  }
	  cell.classList.add('trap-cell');
	  cell.dataset.trapType = trapType;
	  if (trapType === 'blackHole') {
		cell.dataset.blackHole = 'true';
		delete cell.dataset.trap;
	  } else {
		cell.dataset.trap = 'true';
	  }
	const shouldRevealTrap = trapType !== 'blackHole' || hasUpgrade('blackHoleAccess') || isUpgradeAvailable('blackHoleAccess');
	if (shouldRevealTrap) {
		const symbol = document.createElement('div');
		symbol.classList.add('symbol', 'trap-symbol');
		if (trapType === 'blackHole') symbol.classList.add('trap-symbol--black-hole');
		else symbol.classList.add('trap-symbol--pit');
		cell.appendChild(symbol);
	}
	if (trapType === 'blackHole') blackHoleTrapPlaced = true;
	  return trapType;
	}

	function resetBlackHoleState() {
	  blackHoleState.trap = null;
	  blackHoleState.cards = [];
	  blackHoleState.selected = new Set();
	  blackHoleState.reward = 0;
	  blackHoleState.coins = 0;
	  blackHoleState.stake = 0;
	  blackHoleState.gameOver = false;
	  lastBlackHoleAutosave = 0;
	  if (blackHoleState.feedbackTimeout) {
		clearTimeout(blackHoleState.feedbackTimeout);
		blackHoleState.feedbackTimeout = null;
	  }
	}

	function getTrapPenaltyBreakdown() {
	  const out = {
		yellow: 0,
		red: 0,
		green: 0,
		purple: 0,
		blue: 0,
		other: 0,
		total: 0
	  };
	  try {
		pruneActiveTraps();
		pruneTrapPenaltyByKey();
		trapPenaltyByKey.forEach(({ colorKey, penalty }) => {
			const p = Number(penalty) || 0;
			if (p <= 0) return;
			if (colorKey === 'red') out.red += p;
			else if (colorKey === 'yellow') out.yellow += p;
			else if (colorKey === 'green') out.green += p;
			else if (colorKey === 'blue') out.blue += p;
			else if (colorKey === 'purple') out.purple += p;
			else out.other += p;
			out.total += p;
		});
	  } catch (e) {}
	  return out;
	}

	function showTrapPenaltyAtScoreRow(zoneId = '', penaltyValue = 0) {
	  const penalty = Number(penaltyValue) || 0;
	  if (penalty <= 0) return;
	  const normalized = normalizeZoneId(String(zoneId || '')).toLowerCase();
	  let scoreElId = null;
	  if (normalized.startsWith('red-grid') || normalized === 'red-zone') scoreElId = 'red-score';
	  else if (normalized === 'yellow-grid' || normalized.indexOf('yellow') !== -1 || normalized.indexOf('geel') !== -1) scoreElId = 'yellow-score';
	  else if (normalized === 'green-grid' || normalized.indexOf('green') !== -1 || normalized.indexOf('groen') !== -1) scoreElId = 'green-score';
	  else if (normalized === 'blue-grid' || normalized.indexOf('blue') !== -1 || normalized.indexOf('blauw') !== -1) scoreElId = 'blue-score';
	  else if (normalized === 'purple-grid' || normalized.indexOf('purple') !== -1 || normalized.indexOf('paars') !== -1) scoreElId = 'purple-score';
	  else scoreElId = 'total-score';
	  const el = document.getElementById(scoreElId);
	  if (!el) return;
	  const rect = el.getBoundingClientRect();
	  showScoreAnimation(
		rect.left + rect.width / 2,
		rect.top + rect.height / 2,
		`-${penalty}`,
		'rgba(196,56,56,0.9)'
	  );
	}

	function renderTrapSummary(options = {}) {
	  const { highlightId = null } = options;
	  const preview = document.getElementById('scoreboard-trap-preview');
	  const countEl = document.getElementById('trap-count-label');
	  
	  // Als trap-summary niet bestaat (verwijderd uit HTML), stop functie
	  if (!preview || !countEl) return;
	  
	const trapCount = activeTraps.length;
	
	// Set data attribute op body voor CSS styling (voor toekomstig gebruik)
	if (currentLevel >= 5) {
		document.body.setAttribute('data-traps-active', 'true');
	} else {
		document.body.removeAttribute('data-traps-active');
	}
	
	const totalPenalty = activeTraps.reduce((sum, trap) => {
		const penalty = Number(trap.penalty) || 0;
		return penalty > 0 ? sum + penalty : sum;
	}, 0);
	const scoreboardEl = document.getElementById('scoreboard');
	const isScoreboardInBottomBar = !!(scoreboardEl && scoreboardEl.closest('#bottom-bar'));
	const isMobileView = isScoreboardInBottomBar || window.innerWidth <= MOBILE_BREAKPOINT;
	preview.classList.toggle('trap-preview--compact', isMobileView);
	preview.innerHTML = '';
	if (trapCount === 0) {
		countEl.textContent = '0 actief';
		return;
	}
	const summaryParts = [`${trapCount} actief`];
	if (totalPenalty > 0) summaryParts.push(`âˆ’${totalPenalty}`);
	if (isMobileView) {
		countEl.textContent = `âš ï¸ ${trapCount}`;
		const chip = document.createElement('span');
		chip.classList.add('trap-compact-chip');
		chip.dataset.symbol = 'âš ï¸';
		chip.innerHTML = `<span>${trapCount}</span>`;
		const penaltyLabel = totalPenalty > 0 ? `, -${totalPenalty} punten` : '';
		const label = `${trapCount} valkuil${trapCount === 1 ? '' : 'en'} actief${penaltyLabel}`;
		chip.setAttribute('aria-label', label);
		chip.title = label;
		preview.appendChild(chip);
		return;
	}
	countEl.textContent = summaryParts.join(' Â· ');
	const sortedTraps = [...activeTraps].sort((a, b) => a.triggeredAt - b.triggeredAt);
	  sortedTraps.forEach(trap => {
		const icon = document.createElement('div');
		icon.classList.add('trap-icon', 'trap-icon--penalty');
		icon.dataset.trapId = trap.id;
		icon.setAttribute('role', 'listitem');
		const penaltyValue = Number(trap.penalty) || 0;
		const labelBits = ['Valkuil', 'in', getTrapZoneLabel(trap.zoneId)];
		if (penaltyValue > 0) labelBits.push(`geeft -${penaltyValue} punten`);
		icon.setAttribute('aria-label', labelBits.join(' '));
		let markup = `<span>âš ï¸</span>`;
		if (penaltyValue > 0) {
		  markup += `<span class="penalty-chip">-${penaltyValue}</span>`;
		}
		icon.innerHTML = markup;
		preview.appendChild(icon);
	  });
	const highlightTarget = highlightId && activeTraps.some(trap => trap.id === highlightId) ? highlightId : null;
	if (highlightTarget) {
		requestAnimationFrame(() => {
			const highlightEl = preview.querySelector(`[data-trap-id="${highlightTarget}"]`);
		  if (highlightEl) {
			highlightEl.classList.add('highlight');
			setTimeout(() => {
			  highlightEl.classList.remove('highlight');
			}, 1600);
		  }
		});
	  }
	}

	function registerTrapTrigger(cell, zoneId = '', { silent = false } = {}) {
	  if (!cell || cell.dataset.trapTriggered === 'true') return;
	  // Skip cells inside placeholder zones (clones)
	  if (cell.closest && cell.closest('.zone-placeholder')) return;
	  const trapId = nextTrapId();
	  // CRITICAL: Use dataset.zoneId first (set at cell creation), then fall back to DOM traversal
	  const normalizedZone = normalizeZoneId(zoneId || cell.dataset?.zoneId || cell.closest('.grid')?.id || '');
	const trapType = cell.dataset.trapType || 'pit';
	if (trapType === 'blackHole' || isBlackHoleCell(cell)) {
		ensureBlackHoleState(cell, normalizedZone, { silent });
		return;
	}
	const penaltyValue = TRAP_PENALTY;
	const penaltyKey = getTrapCellKey(cell, normalizedZone);
	if (penaltyValue > 0 && penaltyKey && trapPenaltyByKey.has(penaltyKey)) {
		cell.dataset.trapTriggered = 'true';
		cell.dataset.trapInstanceId = trapId;
		cell.classList.add('trap-triggered');
		return;
	}
	  const prospective = {
		id: trapId,
		cell,
		zoneId: normalizedZone,
		penalty: penaltyValue,
		triggeredAt: Date.now(),
		type: trapType
	  };
	  // Guard: avoid duplicate registrations of the same trap cell
	  const dupKey = getTrapKey(prospective);
	  if (dupKey) {
		const hasDup = (activeTraps || []).some(t => getTrapKey(t) === dupKey);
		if (hasDup) return;
	  }
	  cell.dataset.trapTriggered = 'true';
	  cell.dataset.trapInstanceId = trapId;
	  cell.classList.add('trap-triggered');
	  if (penaltyValue > 0) {
		applyTrapPenaltyOnce(cell, normalizedZone, penaltyValue);
	  }
	  activeTraps.push(prospective);
	  lastTrapHighlightId = trapId;
	  if (!silent && penaltyValue > 0) {
		const rect = cell.getBoundingClientRect();
		showScoreAnimation(
		  rect.left + rect.width / 2,
		  rect.top + rect.height / 2,
		  `-${penaltyValue}`,
		  'rgba(196,56,56,0.9)'
		);
		// Also show the -points near the affected color score row (so it's clearly visible)
		showTrapPenaltyAtScoreRow(normalizedZone, penaltyValue);
	  }
	if (silent) renderTrapSummary();
	else renderTrapSummary({ highlightId: trapId });
	}

	function releaseTrap(cell) {
	  if (!cell || cell.dataset.trapTriggered !== 'true') return;
	  const trapId = cell.dataset.trapInstanceId;
	  const trapKey = getTrapKey({ cell, id: trapId, zoneId: cell.dataset?.zoneId });
	  // Always try to remove penalty from map (even if trapPenaltyApplied wasn't set on this cell)
	  const penaltyKey = cell.dataset.trapPenaltyKey || getTrapCellKey(cell, cell.dataset?.zoneId || cell.closest('.grid')?.id || '');
	  if (penaltyKey) trapPenaltyByKey.delete(penaltyKey);
	  delete cell.dataset.trapPenaltyApplied;
	  delete cell.dataset.trapColorKey;
	  delete cell.dataset.trapPenaltyKey;
	  cell.classList.remove('trap-triggered');
	  delete cell.dataset.trapTriggered;
	  delete cell.dataset.trapInstanceId;
	  // Remove any lingering entries that match by id or by trap key (covers stale duplicates)
	  activeTraps = (activeTraps || []).filter(trap => {
		if (trapId && trap.id === trapId) return false;
		const key = getTrapKey(trap);
		return !trapKey || key !== trapKey;
	  });
	  renderTrapSummary();
	}

	function ensureTrapState(cell, zoneId = '', options = {}) {
	  if (!cell || cell.dataset.trap !== 'true') return;
	  // Skip cells inside placeholder zones (clones)
	  if (cell.closest && cell.closest('.zone-placeholder')) return;
	  const normalizedZone = normalizeZoneId(zoneId || cell.dataset.zoneId || cell.closest('.grid')?.id || '');
	  const isActive = cell.classList.contains('active');
	  const triggered = cell.dataset.trapTriggered === 'true';
	  const { silent = false } = options;
	  if (isActive && !triggered) {
		registerTrapTrigger(cell, normalizedZone, { silent });
	  } else if (!isActive && triggered) {
		releaseTrap(cell);
	  }
	}

	function resetTrapState() {
	  activeTraps = [];
	  lastTrapHighlightId = null;
	  blackHoleTrapPlaced = false;
	  lastTrapPenaltyBreakdown = {
		yellow: 0,
		red: 0,
		green: 0,
		purple: 0,
		blue: 0,
		other: 0,
		total: 0
	  };
	  trapPenaltyByKey = new Map();
	  document.querySelectorAll('.cell.trap-triggered, .cell[data-trap-triggered="true"]').forEach(cell => {
		cell.classList.remove('trap-triggered');
		delete cell.dataset.trapTriggered;
		delete cell.dataset.trapInstanceId;
		delete cell.dataset.trapPenaltyApplied;
		delete cell.dataset.trapColorKey;
		delete cell.dataset.trapPenaltyKey;
	  });
	  document.querySelectorAll('.cell[data-black-hole-triggered="true"]').forEach(cell => {
		delete cell.dataset.blackHoleTriggered;
	  });
	  renderTrapSummary();
	}

  /* ============================================
     BONUS MUNT BELONINGEN
     ============================================
     World 1: Elke 10 punten bonus geeft 1 gratis munt
     World 2+: Elke 20 punten bonus geeft 1 gratis munt (50% minder)
     Houdt bij hoeveel milestones al bereikt zijn
  */
  function trackBonusCoinRewards(currentBonus) {
	if (typeof currentBonus !== 'number' || currentBonus <= 0) return;
	const worldInfo = (typeof getWorldAndSubLevel === 'function') ? getWorldAndSubLevel(currentLevel) : { world: 1 };
	const isWorld2Plus = Number(worldInfo?.world || 1) >= 2;
	const bonusPerCoin = isWorld2Plus ? 20 : 10; // World 2+: 50% minder coins
	const milestonesReached = Math.floor(currentBonus / bonusPerCoin);
	if (milestonesReached <= bonusCoinMilestones) return;
	const coinsToGrant = milestonesReached - bonusCoinMilestones;
	for (let i = 0; i < coinsToGrant; i += 1) addCoin();
	bonusCoinMilestones = milestonesReached;
  }

	/* Bereken hoeveel coins je krijgt voor een bepaalde score
	   World 1: 1 coin per 10 punten
	   World 2+: Getrapte schaal:
	     - 0-50 punten: 1 coin per 10 punten (max 5)
	     - 50-150 punten: 1 coin per 25 punten (max 4 extra = 9 totaal)
	     - 150+ punten: 1 coin per 50 punten
	*/
	function calculateCoinsForScore(score, isWorld2Plus = false) {
	  if (!isWorld2Plus) {
		return Math.floor(score / 10);
	  }
	  // World 2+ tiered system
	  let coins = 0;
	  if (score <= 50) {
		coins = Math.floor(score / 10);
	  } else if (score <= 150) {
		coins = 5 + Math.floor((score - 50) / 25);
	  } else {
		coins = 5 + 4 + Math.floor((score - 150) / 50);
	  }
	  return coins;
	}

	function grantRoundScoreCoins(finalScore) {
	  if (!Number.isFinite(finalScore) || finalScore <= 0) return;
	  const worldInfo = (typeof getWorldAndSubLevel === 'function') ? getWorldAndSubLevel(currentLevel) : { world: 1 };
	  const isWorld2Plus = Number(worldInfo?.world || 1) >= 2;
	  const targetCoins = calculateCoinsForScore(finalScore, isWorld2Plus);
	  if (targetCoins <= coinsAwardedFromScore) return;
	  const coinsToGrant = targetCoins - coinsAwardedFromScore;
	  for (let i = 0; i < coinsToGrant; i += 1) addCoin();
	  coinsAwardedFromScore = targetCoins;
	  if (coinsToGrant > 0) {
		const label = coinsToGrant === 1 ? 'munt' : 'munten';
		showObjectiveToast(`ðŸ’° +${coinsToGrant} ${label} voor je score!`);
	  }
	}

  /* ============================================
     SCORE BEREKENING - HOOFDFUNCTIE
     ============================================
     Berekent de totale score voor alle kleuren:
     - GROEN: 8 punten per ingevulde eindcel
     - BLAUW: Punten voor kolommen (4/8/12 voor 2/3/4 cellen)
	 - ROOD: Vaste punten per volledig gevuld subgrid
     - GEEL: Punten per volledig gevulde rij (10 + upgrades)
     - PAARS: Punten voor patronen (2x2, 3x3, lijn van 4+, enz)
     
     Toont ook animaties bij score veranderingen
  */

  /* ---------- Per-zone scoring helpers ---------- */

  /** Groen: distance-based end-cell scoring (World 2+) or flat 8pt (World 1). */
  function scoreGreen(cell) {
	const safeLevel = (typeof currentLevel !== 'undefined') ? currentLevel : 1;
	const worldInfo = (typeof getWorldAndSubLevel === 'function') ? getWorldAndSubLevel(safeLevel) : { world: 1 };
	const w = Number(worldInfo?.world || 1);
	const greenGrid = document.getElementById('green-grid');
	const activeEndCells = Array.from(document.querySelectorAll('#green-grid .cell.end-cell.active'));

	if (w < 2 || !greenGrid) {
		green = activeEndCells.length * 8;
		if (cell != null && cell.classList.contains('end-cell') && cell.classList.contains('active')) {
			const rect = cell.getBoundingClientRect();
			showScoreAnimation(rect.left + rect.width / 2, rect.top + rect.height / 2, "+ 8", "green");
		}
		return;
	}

	const greenCfg = window.greenGridConfig || {};
	const minPts = Math.max(0, Number(greenCfg.minEndCellPoints) || 8);
	const maxPts = Math.max(minPts, Number(greenCfg.maxEndCellPoints) || 30);
	const rows = Number(greenGrid.dataset.rows) || 0;
	const cols = Number(greenGrid.dataset.cols) || 0;
	const startX = Number(greenGrid.dataset.startX);
	const startY = Number(greenGrid.dataset.startY);
	const safeStartX = Number.isFinite(startX) ? startX : Math.floor(cols / 2);
	const safeStartY = Number.isFinite(startY) ? startY : Math.floor(rows / 2);
	const cornerDists = [
		Math.abs(0 - safeStartX) + Math.abs(0 - safeStartY),
		Math.abs((cols - 1) - safeStartX) + Math.abs(0 - safeStartY),
		Math.abs(0 - safeStartX) + Math.abs((rows - 1) - safeStartY),
		Math.abs((cols - 1) - safeStartX) + Math.abs((rows - 1) - safeStartY)
	];
	const maxDist = Math.max(1, ...cornerDists.filter(Number.isFinite));
	const pointsFor = (endCell) => {
		const x = Number(endCell.dataset.x ?? endCell.dataset.c);
		const y = Number(endCell.dataset.y ?? endCell.dataset.r);
		if (!Number.isFinite(x) || !Number.isFinite(y)) return minPts;
		const dist = Math.abs(x - safeStartX) + Math.abs(y - safeStartY);
		const t = Math.max(0, Math.min(1, dist / maxDist));
		return Math.round(minPts + t * (maxPts - minPts));
	};
	green = activeEndCells.reduce((sum, c) => sum + pointsFor(c), 0);

	if (cell != null && cell.classList.contains('end-cell') && cell.classList.contains('active')) {
		const rect = cell.getBoundingClientRect();
		const pts = pointsFor(cell);
		showScoreAnimation(rect.left + rect.width / 2, rect.top + rect.height / 2, `+ ${pts}`, "green");
	}
  }

  /** Rood: punten per volledig gevuld subgrid + World 3 stage gating. */
  function scoreRed(cell) {
	const safeLevel = (typeof currentLevel !== 'undefined') ? currentLevel : 1;
	const worldInfo = (typeof getWorldAndSubLevel === 'function') ? getWorldAndSubLevel(safeLevel) : { world: 1 };
	const isWorld3 = Number(worldInfo?.world || 1) === 3;
	let computedRed = 0;
	const allRedIds = ['red-grid1', 'red-grid2', 'red-grid3', 'red-grid4', 'red-grid5', 'red-grid6'];

	allRedIds.forEach(id => {
		const grid = document.getElementById(id);
		if (!grid) return;
		const allCells = grid.querySelectorAll('.cell:not(.void-cell)');
		const activeCells = grid.querySelectorAll('.cell.active:not(.void-cell)');
		const isFull = allCells.length > 0 && allCells.length === activeCells.length;
		const wasFull = grid.dataset.completed === 'true';
		const configuredPoints = Number(grid.dataset.redTargetPoints);
		const points = (Number.isFinite(configuredPoints) && configuredPoints > 0) ? configuredPoints : (allCells.length * 2);
		if (isFull) computedRed += points;

		if (isFull && !wasFull) {
			try { highlightEdgeCells(grid); } catch (e) {}
			grid.dataset.completed = 'true';
			grid.dataset.score = String(points);
			const middleIndex = Math.floor(allCells.length / 2);
			const anchor = allCells[middleIndex];
			if (anchor && anchor.getBoundingClientRect) {
				const rect = anchor.getBoundingClientRect();
				showScoreAnimation(rect.left + rect.width / 2, rect.top + rect.height / 2, `+${points}`, 'red');
			}
		} else if (!isFull && wasFull) {
			grid.dataset.completed = 'false';
			grid.dataset.score = '0';
		}
	});

	if (isWorld3 && Number(world3RedStage) !== 2) {
		try {
			const allFour = ['red-grid1', 'red-grid2', 'red-grid3', 'red-grid4'].every(id => isRedSubgridFull(id));
			if (allFour) {
				world3RedStage = 2;
				applyWorld3RedStage(2);
				try { saveGameState(); } catch (e) {}
			}
		} catch (e) {}
	}

	red = computedRed;
  }

  /** Geel: kolommen (World 1), diagonalen (World 2) of ringen (World 3). */
  function scoreYellow(cell) {
	const yellowContainer = document.getElementById('yellow-grid');
	const yellowConfig = window.yellowGridConfig || {};
	const fallbackRowCount = Number(yellowContainer?.dataset?.rows || yellowConfig.rows || 0);
	const parsedRowLengths = (() => {
	  if (Array.isArray(yellowConfig.rowLengths)) return yellowConfig.rowLengths;
	  const raw = yellowContainer?.dataset?.rowLengths;
	  if (!raw) return [];
	  return raw.split(',').map(val => Number(val) || 0);
	})();
	const rowLengths = parsedRowLengths.length ? parsedRowLengths : Array.from({ length: fallbackRowCount }, () => Number(yellowContainer?.dataset?.cols || yellowConfig.cols || 0));
	const parsedRowOffsets = (() => {
	  if (Array.isArray(yellowConfig.rowOffsets)) return yellowConfig.rowOffsets;
	  const rawOffsets = yellowContainer?.dataset?.rowOffsets;
	  if (!rawOffsets) return Array.from({ length: rowLengths.length }, () => 0);
	  return rawOffsets.split(',').map(val => Number(val) || 0);
	})();
	const yellowCols = Number(yellowConfig.cols) || Number(yellowContainer?.dataset?.cols || 0) || 0;
	const columnPoints = Array.isArray(yellowConfig.pointsByColumn) ? yellowConfig.pointsByColumn : [];
	const playableYellowCells = yellowContainer ? Array.from(yellowContainer.querySelectorAll('.cell:not(.void-cell)')) : [];

	const bumpYellowCompletionMark = (cells, delta) => {
		if (!Array.isArray(cells) || !cells.length || !delta) return;
		for (const c of cells) {
			if (!c || !c.classList || !c.classList.contains('cell')) continue;
			const prev = Number(c.dataset.yellowCompletedMarks || '0') || 0;
			const next = Math.max(0, prev + delta);
			c.dataset.yellowCompletedMarks = String(next);
			c.classList.toggle('yellow-completed-path', next > 0);
		}
	};

	const scoreYellowKey = (key, points, cells, full) => {
		if (!key) return;
		window.scoredYellowSegments = window.scoredYellowSegments || new Set();
		window.scoredYellowDiagonals = window.scoredYellowDiagonals || new Set();
		window.scoredYellowSegmentPoints = window.scoredYellowSegmentPoints || new Map();
		const scored = window.scoredYellowSegments;
		const pointsByKey = window.scoredYellowSegmentPoints;
		const wasFull = scored.has(key);
		if (full && !wasFull) {
			yellow += points;
			scored.add(key);
			window.scoredYellowDiagonals.add(key);
			pointsByKey.set(key, points);
			bumpYellowCompletionMark(cells, +1);
			const anchorCell = cells && cells[0];
			if (anchorCell) {
				const rect = anchorCell.getBoundingClientRect();
				showScoreAnimation(rect.left + rect.width / 2, rect.top + rect.height / 2, `+${points}`, "yellow");
			}
		} else if (!full && wasFull) {
			const lost = Number(pointsByKey.get(key));
			yellow -= Number.isFinite(lost) ? lost : points;
			scored.delete(key);
			window.scoredYellowDiagonals.delete(key);
			pointsByKey.delete(key);
			bumpYellowCompletionMark(cells, -1);
			const anchorCell = cells && cells[0];
			if (anchorCell) {
				const rect = anchorCell.getBoundingClientRect();
				showScoreAnimation(rect.left + rect.width / 2, rect.top + rect.height / 2, `âˆ’${Number.isFinite(lost) ? lost : points}`, "yellow");
			}
		}
	};

	if (yellowConfig.scoreMode === 'rings') {
		const ringMinPoints = Math.max(0, Number(yellowConfig.ringMinPoints) || 12);
		const ringMaxPoints = Math.max(ringMinPoints, Number(yellowConfig.ringMaxPoints) || 64);
		const cellByCoord = new Map();
		for (const c of playableYellowCells) {
			const x = Number(c.dataset.x);
			const y = Number(c.dataset.y);
			if (!Number.isFinite(x) || !Number.isFinite(y)) continue;
			cellByCoord.set(`${x},${y}`, c);
		}
		const tryGet = (x, y) => cellByCoord.get(`${x},${y}`) || null;
		const boundary = [];
		for (const c of cellByCoord.values()) {
			const x = Number(c.dataset.x);
			const y = Number(c.dataset.y);
			if (!Number.isFinite(x) || !Number.isFinite(y)) continue;
			if (!tryGet(x - 1, y) || !tryGet(x + 1, y) || !tryGet(x, y - 1) || !tryGet(x, y + 1)) {
				boundary.push(c);
			}
		}
		const depthByCell = new Map();
		const q = [];
		for (const c of boundary) {
			depthByCell.set(c, 0);
			q.push(c);
		}
		while (q.length) {
			const cur = q.shift();
			const curDepth = depthByCell.get(cur) || 0;
			const x = Number(cur.dataset.x);
			const y = Number(cur.dataset.y);
			const neigh = [tryGet(x - 1, y), tryGet(x + 1, y), tryGet(x, y - 1), tryGet(x, y + 1)].filter(Boolean);
			for (const n of neigh) {
				if (!depthByCell.has(n)) {
					depthByCell.set(n, curDepth + 1);
					q.push(n);
				}
			}
		}
		let maxDepth = 0;
		const rings = new Map();
		for (const [cell, depth] of depthByCell.entries()) {
			maxDepth = Math.max(maxDepth, Number(depth) || 0);
			if (!rings.has(depth)) rings.set(depth, []);
			rings.get(depth).push(cell);
		}
		window.scoredYellowRings = window.scoredYellowRings || new Map();
		const scoredRings = window.scoredYellowRings;
		for (const [depth, cells] of rings.entries()) {
			const denom = Math.max(1, maxDepth);
			const t = (denom - Number(depth)) / denom;
			const points = Math.round(ringMinPoints + t * (ringMaxPoints - ringMinPoints));
			const full = cells.every(c => c.classList.contains('active'));
			const key = `ring:${depth}`;
			const wasFull = scoredRings.has(key);
			if (full && !wasFull) {
				yellow += points;
				scoredRings.set(key, points);
				bumpYellowCompletionMark(cells, +1);
				const anchorCell = cells[0];
				if (anchorCell) {
					const rect = anchorCell.getBoundingClientRect();
					showScoreAnimation(rect.left + rect.width / 2, rect.top + rect.height / 2, `+${points}`, "yellow");
				}
			} else if (!full && wasFull) {
				const lost = Number(scoredRings.get(key));
				yellow -= Number.isFinite(lost) ? lost : points;
				scoredRings.delete(key);
				bumpYellowCompletionMark(cells, -1);
				const anchorCell = cells[0];
				if (anchorCell) {
					const rect = anchorCell.getBoundingClientRect();
					showScoreAnimation(rect.left + rect.width / 2, rect.top + rect.height / 2, `âˆ’${Number.isFinite(lost) ? lost : points}`, "yellow");
				}
			}
		}
	} else if (yellowConfig.scoreMode === 'diagonal') {
	  const minLen = Math.max(1, Number(yellowConfig.minDiagonalLength) || 4);
	  const computeSegmentPoints = (len) => {
		if (!Number.isFinite(len) || len < minLen) return 0;
		const halfSteps = Math.floor(len / 2) + 1;
		return Math.pow(2, halfSteps);
	  };
	  const allowToCenter = yellowConfig.allowDiagonalToCenter === true;
	  const cellByCoord = new Map();
	  for (const c of playableYellowCells) {
		const x = Number(c.dataset.x);
		const y = Number(c.dataset.y);
		if (!Number.isFinite(x) || !Number.isFinite(y)) continue;
		cellByCoord.set(`${x},${y}`, c);
	  }

	  const tryGet = (x, y) => cellByCoord.get(`${x},${y}`) || null;
	  const collectSegments = (dx, dy, prefix) => {
		const segments = [];
		for (const startCell of cellByCoord.values()) {
			const x0 = Number(startCell.dataset.x);
			const y0 = Number(startCell.dataset.y);
			if (!Number.isFinite(x0) || !Number.isFinite(y0)) continue;
			if (tryGet(x0 - dx, y0 - dy)) continue;
			const segmentCells = [];
			let x = x0;
			let y = y0;
			while (true) {
				const cellHere = tryGet(x, y);
				if (!cellHere) break;
				segmentCells.push(cellHere);
				x += dx;
				y += dy;
			}
			if (segmentCells.length) {
				segments.push({
					key: `${prefix}:${x0},${y0}`,
					cells: segmentCells,
					points: computeSegmentPoints(segmentCells.length)
				});
			}
		}
		return segments;
	  };

	  const segments = [
		...collectSegments(1, 1, 'segNWSE'),
		...collectSegments(1, -1, 'segNESW')
	  ];

	  for (const seg of segments) {
		const fullDiag = seg.cells.every(c => c.classList.contains('active'));
		const keyFull = `${seg.key}:full`;
		if (!allowToCenter) {
			if (seg.points > 0) scoreYellowKey(keyFull, seg.points, seg.cells, fullDiag);
			else scoreYellowKey(keyFull, seg.points, seg.cells, false);
			continue;
		}

		const mid = Math.floor(seg.cells.length / 2);
		const boldIdxs = [];
		for (let i = 0; i < seg.cells.length; i++) {
			if (seg.cells[i].classList.contains('bold-cell')) boldIdxs.push(i);
		}
		let pivot = mid;
		if (boldIdxs.length) {
			boldIdxs.sort((a, b) => Math.abs(a - mid) - Math.abs(b - mid));
			pivot = boldIdxs[0];
		}
		const cellsA = seg.cells.slice(0, pivot + 1);
		const cellsB = seg.cells.slice(pivot);
		const pointsA = computeSegmentPoints(cellsA.length);
		const pointsB = computeSegmentPoints(cellsB.length);
		const fullA = pointsA > 0 && cellsA.every(c => c.classList.contains('active'));
		const fullB = pointsB > 0 && cellsB.every(c => c.classList.contains('active'));
		const keyA = `${seg.key}:halfA`;
		const keyB = `${seg.key}:halfB`;

		if (seg.points > 0) scoreYellowKey(keyFull, seg.points, seg.cells, fullDiag);
		if (fullDiag) {
			if (pointsA > 0) scoreYellowKey(keyA, pointsA, cellsA, false);
			if (pointsB > 0) scoreYellowKey(keyB, pointsB, cellsB, false);
		} else {
			if (pointsA > 0) scoreYellowKey(keyA, pointsA, cellsA, fullA);
			if (pointsB > 0) scoreYellowKey(keyB, pointsB, cellsB, fullB);
		}
	  }
	} else {
	  const columnCellMap = new Map();
	  playableYellowCells.forEach(cell => {
		const colIndex = Number(cell.dataset.x);
		if (!Number.isFinite(colIndex)) return;
		if (!columnCellMap.has(colIndex)) columnCellMap.set(colIndex, []);
		columnCellMap.get(colIndex).push(cell);
	  });

	  let maxColumnIndex = -1;
	  columnCellMap.forEach((_, key) => { if (key > maxColumnIndex) maxColumnIndex = key; });
	  const effectiveColumnCount = Math.max(yellowCols, columnPoints.length, maxColumnIndex + 1);
	  const columnHeights = (() => {
		if (Array.isArray(yellowConfig.columnHeights) && yellowConfig.columnHeights.length >= effectiveColumnCount) {
		  return yellowConfig.columnHeights;
		}
		const heights = Array.from({ length: effectiveColumnCount }, () => 0);
		for (let row = 0; row < rowLengths.length; row++) {
		  const rowLen = rowLengths[row];
		  if (rowLen <= 0) continue;
		  const rowStart = parsedRowOffsets[row] || 0;
		  for (let col = rowStart; col < rowStart + rowLen; col++) {
			if (col >= heights.length) break;
			heights[col] += 1;
		  }
		}
		return heights;
	  })();

	  window.scoredYellowColumns = window.scoredYellowColumns || new Set();

	  for (let col = 0; col < effectiveColumnCount; col++) {
		const expectedHeight = columnHeights[col] || 0;
		if (expectedHeight <= 0) {
		  window.scoredYellowColumns.delete(col);
		  continue;
		}

		const colCells = (columnCellMap.get(col) || []).slice().sort((a, b) => Number(a.dataset.y) - Number(b.dataset.y));
		const full = colCells.length === expectedHeight && colCells.every(cell => cell.classList.contains('active'));
		const wasFull = window.scoredYellowColumns.has(col);
		const columnPairIndex = Math.floor(col / 2);
		const world1ColumnPairPoints = [12, 18, 30, 42, 60];
		const columnPointsValue = world1ColumnPairPoints[Math.min(columnPairIndex, world1ColumnPairPoints.length - 1)] || 0;
		if (!columnPointsValue || columnPointsValue <= 0) {
		  if (wasFull) window.scoredYellowColumns.delete(col);
		  continue;
		}

		if (full && !wasFull) {
		  yellow += columnPointsValue;
		  window.scoredYellowColumns.add(col);
		  bumpYellowCompletionMark(colCells, +1);
		  const anchorCell = colCells[0];
		  if (anchorCell) {
			const rect = anchorCell.getBoundingClientRect();
			showScoreAnimation(rect.left + rect.width / 2, rect.top + rect.height / 2, `+${columnPointsValue}`, "yellow");
		  }
		} else if (!full && wasFull) {
		  yellow -= columnPointsValue;
		  window.scoredYellowColumns.delete(col);
		  bumpYellowCompletionMark(colCells, -1);
		  const anchorCell = colCells[0];
		  if (anchorCell) {
			const rect = anchorCell.getBoundingClientRect();
			showScoreAnimation(rect.left + rect.width / 2, rect.top + rect.height / 2, `âˆ’${columnPointsValue}`, "yellow");
		  }
		}
	  }
	}
  }

  /** Paars: BFS floodfill clusters van actieve cellen, scored per bold-cell verbindingen. */
  function scorePurple(cell) {
	const purpleContainer = document.getElementById('purple-grid');
	if (!purpleContainer) { purple = 0; return; }

	if (!purpleContainer._clusterClickBound) {
		purpleContainer.addEventListener('click', (ev) => {
			const c = ev.target && ev.target.closest ? ev.target.closest('.cell.bold-cell.active') : null;
			if (!c || !purpleContainer.contains(c)) return;
			const storedScore = Number(c.dataset.clusterScore || '0');
			if (c.dataset.clusterPending === "true" && storedScore > 0) {
				const rect = c.getBoundingClientRect();
				showScoreAnimation(rect.left + rect.width / 2, rect.top + rect.height / 2, `+${storedScore}`, "purple");
				c.dataset.clusterPending = "false";
			}
		}, { passive: true });
		purpleContainer._clusterClickBound = true;
	}

	const purpleCells = Array.from(purpleContainer.querySelectorAll('.cell'));
	const totalPurple = purpleCells.length;
	let purpleCols = Number(purpleContainer.dataset.cols) || 0;
	const styleCols = purpleContainer.style.gridTemplateColumns;
	const repeatMatch = styleCols && styleCols.match(/repeat\(\s*(\d+)\s*,/i);
	if (!purpleCols && repeatMatch) purpleCols = parseInt(repeatMatch[1], 10);
	else if (!purpleCols) {
		const computed = getComputedStyle(purpleContainer).gridTemplateColumns;
		purpleCols = computed ? computed.split(/\s+/).length : Math.round(Math.sqrt(totalPurple)) || 1;
	}
	const purpleRows = Math.ceil(totalPurple / purpleCols);
	const visited = new Array(totalPurple).fill(false);
	const connections = [];
	const purpleConfig = window.purpleGridConfig || {};
	const isWorld2Purple = purpleConfig.world2 === true;
	const isWorld3Purple = purpleConfig.world3 === true;
	const useExpandedPurpleScoring = isWorld2Purple || isWorld3Purple;

	for (let i = 0; i < totalPurple; i++) {
		if (visited[i]) continue;
		if (!purpleCells[i].classList.contains('active')) { visited[i] = true; continue; }

		const stack = [i];
		visited[i] = true;
		const cluster = [];

		while (stack.length) {
		  const cur = stack.pop();
		  cluster.push(cur);
		  const r = Math.floor(cur / purpleCols), c = cur % purpleCols;
		  const neigh = [];
		  if (r > 0) neigh.push((r - 1) * purpleCols + c);
		  if (r < purpleRows - 1) neigh.push((r + 1) * purpleCols + c);
		  if (c > 0) neigh.push(r * purpleCols + (c - 1));
		  if (c < purpleCols - 1) neigh.push(r * purpleCols + (c + 1));
		  for (const n of neigh) {
			if (n < 0 || n >= totalPurple) continue;
			if (!visited[n] && purpleCells[n].classList.contains('active')) {
			  visited[n] = true;
			  stack.push(n);
			} else if (!visited[n] && !purpleCells[n].classList.contains('active')) visited[n] = true;
		  }
		}

		const boldCount = cluster.reduce(
		  (acc, idx) => acc + (purpleCells[idx].classList.contains('bold-cell') ? 1 : 0),
		  0
		);

		let clusterScore = 0;
		if (useExpandedPurpleScoring) {
		  const perOuterConn = Number(purpleConfig.outerRingBonusPerBold) || 25;
		  const perInnerConn = Number(purpleConfig.innerBoldConnectionPoints) || 8;
		  const perMixedConn = Number(purpleConfig.outerInnerConnectionPoints) || 10;
		  const outerBoldCount = cluster.reduce((acc, idx) => {
			const cell = purpleCells[idx];
			if (!cell.classList.contains('bold-cell') || !cell.classList.contains('active')) return acc;
			const isOuter = cell.classList.contains('outer-ring-0') || cell.classList.contains('outer-ring-1');
			return acc + (isOuter ? 1 : 0);
		  }, 0);
		  const innerBoldCount = Math.max(0, boldCount - outerBoldCount);
		  if (outerBoldCount >= 2) clusterScore += (outerBoldCount - 1) * perOuterConn;
		  if (innerBoldCount >= 2) clusterScore += (innerBoldCount - 1) * perInnerConn;
		  if (outerBoldCount > 0 && innerBoldCount > 0) {
			const mixedConnections = Math.min(outerBoldCount, innerBoldCount);
			clusterScore += mixedConnections * perMixedConn;
		  }
		} else {
		  if (boldCount >= 2) clusterScore = (boldCount - 1) * 8;
		}
		const hasClusterScore = clusterScore > 0;

		cluster.forEach(idx => {
		  const cell = purpleCells[idx];
		  if (cell.classList.contains('bold-cell') && cell.classList.contains('active')) {
			cell.dataset.clusterScore = String(clusterScore);
			cell.dataset.clusterPending = hasClusterScore ? "true" : "false";
		  }
		});

		connections.push({ indices: cluster, boldCount, score: clusterScore });
	}

	purple = connections.reduce((s, c) => s + c.score, 0);
	window.purpleConnections = connections;
  }

  /** Extra end-cells buiten het groene grid krijgen 8pt voor hun zone-kleur. */
  function scoreExtraEndCells() {
	try {
		const extraEndCells = Array.from(document.querySelectorAll('.cell.end-cell.active'));
		extraEndCells.forEach(c => {
			if (c.closest && c.closest('#green-grid')) return;
			let zone = c.closest && c.closest('.zone') ? c.closest('.zone') : null;
			let colorKey = zone && zone.dataset ? String(zone.dataset.color || '').toLowerCase() : '';
			if (!colorKey) {
				const g = c.closest && c.closest('.grid') ? c.closest('.grid') : null;
				if (g && g.id) {
					if (g.id.indexOf('yellow') !== -1) colorKey = 'geel';
					else if (g.id.indexOf('purple') !== -1 || g.id.indexOf('paars') !== -1) colorKey = 'paars';
					else if (g.id.indexOf('blue') !== -1) colorKey = 'blauw';
					else if (g.id.indexOf('red') !== -1) colorKey = 'rood';
				}
			}
			if (colorKey === 'geel' || colorKey === 'yellow') yellow += 8;
			else if (colorKey === 'paars' || colorKey === 'purple') purple += 8;
			else if (colorKey === 'blauw' || colorKey === 'blue') blue += 8;
			else if (colorKey === 'rood' || colorKey === 'red') red += 8;
		});
	} catch (e) {}
  }

  function updateScore(cell){
		try {
			if (window.debugScoreUpdates) {
				console.debug('updateScore:called', { cellId: cell ? (cell.id || null) : null, time: Date.now() });
			}
		} catch(e) {}

	/* Score per zone berekenen via helpers */
	scoreGreen(cell);
	blue = calculateBlueScore('blue-grid', 3, 4, 8, cell);
	scoreRed(cell);
	scoreYellow(cell);
	scorePurple(cell);
	scoreExtraEndCells();

	// Trap penalties should apply to the affected color and remain stable across updates.
	// Keep base color scores intact; apply penalties/bonuses to local display values.
	const trapPenaltyBreakdown = getTrapPenaltyBreakdown();
	const bonusScore = colorScoreBonuses || {};
	const yellowFinal = yellow - (Number(trapPenaltyBreakdown.yellow) || 0) + Number(bonusScore.yellow || 0);
	const greenFinal = green - (Number(trapPenaltyBreakdown.green) || 0) + Number(bonusScore.green || 0);
	const purpleFinal = purple - (Number(trapPenaltyBreakdown.purple) || 0) + Number(bonusScore.purple || 0);
	const blueFinal = blue - (Number(trapPenaltyBreakdown.blue) || 0) + Number(bonusScore.blue || 0);
	const redFinal = red - (Number(trapPenaltyBreakdown.red) || 0) + Number(bonusScore.red || 0);
	const waarden = [yellowFinal, greenFinal, purpleFinal, blueFinal, redFinal];
	// Bonus should never go negative.
	const baseBonus = Math.max(0, Math.min(...waarden));
	const totalBonusScore = baseBonus;
	bonus = totalBonusScore;
	trackBonusCoinRewards(totalBonusScore);

	
    // update DOM
	document.getElementById('yellow-score').textContent = yellowFinal;
	document.getElementById('green-score').textContent = greenFinal;
	document.getElementById('purple-score').textContent = purpleFinal;
	document.getElementById('blue-score').textContent = blueFinal;
	document.getElementById('red-score').textContent = redFinal;
	
	// element ophalen
	const totalScoreEl = document.getElementById('total-score');

	// bereken nieuwe total
	const newScore = (yellowFinal + greenFinal + purpleFinal + blueFinal + redFinal + totalBonusScore);
	const trapPenaltyOther = Number(trapPenaltyBreakdown.other) || 0;
	const trapPenaltyTotal = Number(trapPenaltyBreakdown.total) || 0;
	lastTrapPenaltyBreakdown = {
		yellow: Number(trapPenaltyBreakdown.yellow) || 0,
		red: Number(trapPenaltyBreakdown.red) || 0,
		green: Number(trapPenaltyBreakdown.green) || 0,
		purple: Number(trapPenaltyBreakdown.purple) || 0,
		blue: Number(trapPenaltyBreakdown.blue) || 0,
		other: trapPenaltyOther,
		total: trapPenaltyTotal
	};
	const displayScore = newScore - trapPenaltyOther;

	// huidige getoonde waarde (als number, fallback 0)
	const currentScore = Number(totalScoreEl.textContent) || 0;

	if (currentScore !== displayScore) {
	  // update waarde in DOM
	  totalScoreEl.textContent = displayScore;

	  // Check for High Score
	  if (typeof updateHighScore === 'function') {
		updateHighScore(displayScore);
	  }

	  // ---- restart animatie op een nette manier ----
	  // 1) verwijder class als die er is
	  totalScoreEl.classList.remove('flash');

	  // 2) force reflow om de class-add echt te "resetten"
	  void totalScoreEl.offsetWidth;

	  // 3) voeg class toe zodat animatie opnieuw start
	  totalScoreEl.classList.add('flash');

	  // 4) verwijder class wanneer de animatie klaar is.
	  // Token voorkomt dat een eerder 'animationend' een nieuwere flash stopt.
	  const token = ++totalScoreFlashToken;
	  const onEnd = () => {
		if (token !== totalScoreFlashToken) return;
		totalScoreEl.classList.remove('flash');
		totalScoreEl.removeEventListener('animationend', onEnd);
	  };
	  totalScoreEl.addEventListener('animationend', onEnd);
	}

	const scoreSnapshot = {
	  yellow: yellowFinal,
	  red: redFinal,
	  green: greenFinal,
	  purple: purpleFinal,
	  blue: blueFinal,
	  bonus: totalBonusScore,
	  blackHoleBonus,
	  baseBonus,
	  bonusesCollected: totalBonusesCollected,
	  total: displayScore,
	  trapPenalty: trapPenaltyOther,
	  trapPenaltyTotal,
	  trapPenaltyByColor: {
		yellow: Number(trapPenaltyBreakdown.yellow) || 0,
		red: Number(trapPenaltyBreakdown.red) || 0,
		green: Number(trapPenaltyBreakdown.green) || 0,
		purple: Number(trapPenaltyBreakdown.purple) || 0,
		blue: Number(trapPenaltyBreakdown.blue) || 0,
		other: trapPenaltyOther
	  },
	  baseTotal: newScore + trapPenaltyOther
	};
	latestScoreSnapshot = scoreSnapshot;
	updateObjectives(scoreSnapshot);
	highlightAchievedObjectiveScores(scoreSnapshot);
  }
	
	

	  // ---------- Blue score (per bold-row with >=1 active cell) ----------
	// FIX: Use dataset.y for proper visual row detection instead of index-based calculation
	function calculateBlueScore(gridId='blue-grid', cols=null, boldInterval=4, pointsPerBold=8) {
		try { console.debug('calculateBlueScore:called', { gridId, time: Date.now() }); } catch(e) {}
		const container = document.getElementById(gridId);
		if (!container) {
			try { console.debug('calculateBlueScore:no-container', { gridId }); } catch(e) {}
			return 0;
		}
		const cells = Array.from(container.querySelectorAll('.cell:not(.void-cell)'));
		if (cells.length === 0) return 0;

		// Determine number of columns used by the grid.
		// Prefer explicit `cols` param or `data-cols`, otherwise infer from data-x values
		// or fallback to a square-root heuristic.
		let deducedCols = 0;
		if (cols && Number.isFinite(Number(cols))) {
			deducedCols = Number(cols);
		} else if (container && container.dataset && container.dataset.cols) {
			deducedCols = Number(container.dataset.cols) || 0;
		}
		if (!deducedCols) {
			const xs = new Set();
			cells.forEach(c => {
				const vx = Number(c.dataset.x);
				if (Number.isFinite(vx)) xs.add(vx);
			});
			deducedCols = xs.size || Math.max(1, Math.round(Math.sqrt(cells.length)));
		}

		const scoredKey = `${gridId}-scoredRows`;
		let scoredRows = window[scoredKey];
		if (scoredRows instanceof Set) {
			const migrated = new Map();
			scoredRows.forEach(rowIdx => migrated.set(rowIdx, pointsPerBold));
			scoredRows = migrated;
		}
		if (!(scoredRows instanceof Map)) {
			scoredRows = new Map();
		}
		window[scoredKey] = scoredRows;

		// Build a map of visual rows (using dataset.y) to their bold cells
		const rowToBoldCells = new Map();
		const rowToActiveBoldCells = new Map();
		
		cells.forEach(cell => {
			if (!cell.classList.contains('bold-cell')) return;
			const visualRow = Number(cell.dataset.y);
			if (!Number.isFinite(visualRow)) return;
			
			if (!rowToBoldCells.has(visualRow)) {
				rowToBoldCells.set(visualRow, []);
				rowToActiveBoldCells.set(visualRow, []);
			}
			rowToBoldCells.get(visualRow).push(cell);
			if (cell.classList.contains('active')) {
				rowToActiveBoldCells.get(visualRow).push(cell);
			}
		});

		// Debug: report counts to help diagnose missing blue scoring
		try {
			console.debug('calculateBlueScore:start', {
				gridId,
				totalCells: cells.length,
				deducedCols,
				boldCells: Array.from(rowToBoldCells.entries()).reduce((sum, [, arr]) => sum + arr.length, 0),
				activeBoldCells: Array.from(rowToActiveBoldCells.entries()).reduce((sum, [, arr]) => sum + arr.length, 0)
			});
		} catch (e) {}
		
		// Get all unique visual rows sorted
		const allVisualRows = Array.from(rowToBoldCells.keys()).sort((a, b) => a - b);
		const rows = allVisualRows.length > 0 ? Math.max(...allVisualRows) + 1 : 0;

		// Blue scoring: allow all bold rows (not only the bottom-most one).
		let visualRowsToProcess = allVisualRows;

		const targetKey = `${gridId}-scoredTargets`;
		let rowTargets = window[targetKey];
		if (!(rowTargets instanceof Map)) {
			rowTargets = new Map();
			window[targetKey] = rowTargets;
		}

		const rowPlacementKey = `${gridId}-rowPlacements`;
		let rowPlacements = window[rowPlacementKey];
		if (!(rowPlacements instanceof Map)) {
			rowPlacements = new Map();
			window[rowPlacementKey] = rowPlacements;
		}

		const showChangePopup = (cell, diff) => {
			if (!cell || diff === 0) return;
			const rect = cell.getBoundingClientRect();
			const amountText = diff > 0 ? `+${diff}` : `-${Math.abs(diff)}`;
			showScoreAnimation(
				rect.left + rect.width / 2,
				rect.top + rect.height / 2,
				amountText,
				"blue"
			);
		};

		const scoredRowIndices = [];
		let positivePopupShown = false;
		const currentPlacementId = window.currentPlacementId || '';

		// Track welke placements al punten hebben toegekend voor welke rijen
		const placementScoringKey = `${gridId}-placementScorings`;
		let placementScorings = window[placementScoringKey];
		if (!(placementScorings instanceof Map)) {
			placementScorings = new Map();
			window[placementScoringKey] = placementScorings;
		}

		// Iterate over the visual rows we've chosen to process
		for (const r of visualRowsToProcess) {
			const boldCells = rowToBoldCells.get(r) || [];
			const activeBoldCells = rowToActiveBoldCells.get(r) || [];

			const previousPoints = scoredRows.get(r) || 0;
			const wasScored = scoredRows.has(r);
			const previousPlacement = rowPlacements.get(r) || '';

			if (boldCells.length === 0) {
				const previousTarget = rowTargets.get(r) || null;
				if (previousTarget && previousPoints > 0) {
					showChangePopup(previousTarget, -previousPoints);
				}
				rowTargets.delete(r);
				rowPlacements.delete(r);
				scoredRows.delete(r);
				placementScorings.delete(r);
				continue;
			}

			const activeCount = activeBoldCells.length;
			if (activeCount === 0) {
				const previousTarget = rowTargets.get(r) || boldCells[0] || null;
				if (previousTarget && previousPoints > 0) {
					showChangePopup(previousTarget, -previousPoints);
				}
				rowTargets.delete(r);
				rowPlacements.delete(r);
				scoredRows.delete(r);
				placementScorings.delete(r);
				continue;
			}

			let targetBoldCell = null;
			const storedTarget = rowTargets.get(r);
			if (storedTarget && storedTarget.classList.contains('active')) {
				targetBoldCell = storedTarget;
			} else {
				let bestSequence = Number.POSITIVE_INFINITY;
				activeBoldCells.forEach(cell => {
					const sequenceValue = Number(cell.dataset.activationSequence);
					if (Number.isFinite(sequenceValue) && sequenceValue < bestSequence) {
						bestSequence = sequenceValue;
						targetBoldCell = cell;
					}
				});
				if (!targetBoldCell && activeBoldCells.length > 0) {
					targetBoldCell = activeBoldCells[0];
				}
			}
			if (!targetBoldCell) {
				rowTargets.delete(r);
				rowPlacements.delete(r);
				scoredRows.delete(r);
				placementScorings.delete(r);
				continue;
			}

		rowTargets.set(r, targetBoldCell);
		
		// Verzamel ALLE placementIds van alle actieve bold-cells in deze rij
		const placementIds = new Set();
		activeBoldCells.forEach(cell => {
			const pid = cell.dataset.placementId;
			if (pid) placementIds.add(pid);
		});
		
		// Check of deze placement al heeft gescoord voor deze rij
		const previousScoredPlacement = placementScorings.get(r) || '';
		const currentPlacementId = Array.from(placementIds)[0] || ''; // Neem eerste placementId
		const hasPlacementScored = currentPlacementId && previousScoredPlacement === currentPlacementId;
		
		// Een rij is "nieuw gescoord" alleen als:
		// 1. De rij nog nooit eerder punten had (wasScored = false)
		// 2. EN deze placement heeft nog NIET gescoord voor deze rij
		const isNewScoring = !wasScored && currentPlacementId && !hasPlacementScored;
		
		if (isNewScoring) {
			// Mark placement als scored voor deze rij METEEN
			placementScorings.set(r, currentPlacementId);
			scoredRows.set(r, 0);
			scoredRowIndices.push(r);
		}
		
		if (currentPlacementId) {
			rowPlacements.set(r, currentPlacementId);
		}
	}		scoredRowIndices.sort((a, b) => a - b);
		
		const allScoredRows = Array.from(scoredRows.keys()).sort((a, b) => a - b);
		let runningTotal = 0;
		
		allScoredRows.forEach((r, idx) => {
			const basePoints = idx === 0 ? 6 : 8 + (idx - 1) * 2;
			const previousPoints = scoredRows.get(r) || 0;
			const diff = basePoints - previousPoints;
			scoredRows.set(r, basePoints);
			runningTotal += basePoints;
			
			if (scoredRowIndices.includes(r)) {
				const target = rowTargets.get(r);
				if (target && !positivePopupShown) {
					showChangePopup(target, basePoints);
					positivePopupShown = true;
				}
			} else if (diff !== 0) {
				const target = rowTargets.get(r);
				if (target) {
					showChangePopup(target, diff);
				}
			}
		});

		const rowsToRemove = [];
		scoredRows.forEach((pts, r) => {
			if (!allScoredRows.includes(r)) {
				const boldCells = [];
				const activeBoldCells = [];
				for (let c = 0; c < deducedCols; c++) {
					const idx = r * deducedCols + c;
					const cell = cells[idx];
					if (!cell || cell.classList.contains('void-cell')) continue;
					if (cell.classList.contains('bold-cell')) {
						boldCells.push(cell);
						if (cell.classList.contains('active')) {
							activeBoldCells.push(cell);
						}
					}
				}
				if (activeBoldCells.length === 0) {
					const previousTarget = rowTargets.get(r) || boldCells[0] || null;
					if (previousTarget && pts > 0) {
						showChangePopup(previousTarget, -pts);
					}
					rowsToRemove.push(r);
				}
			}
		});
		rowsToRemove.forEach(r => {
			scoredRows.delete(r);
			rowTargets.delete(r);
			rowPlacements.delete(r);
		});

		return runningTotal;
	}
	
	// showScoreAnimation: positioneert tov viewport (fixed) zodat getBoundingClientRect() direct werkt
	function showScoreAnimation(x, y, text = "+1", color = "white") {
	  const colorKeyMap = {
		yellow: '#cfba51',
		geel: '#cfba51',
		red: '#b56069',
		rood: '#b56069',
		green: '#92c28c',
		groen: '#92c28c',
		purple: '#8f76b8',
		paars: '#8f76b8',
		blue: '#5689b0',
		blauw: '#5689b0'
	  };
	  try {
		if (typeof color === 'string') {
			const normalized = color.trim().toLowerCase();
			if (colorKeyMap[normalized]) color = colorKeyMap[normalized];
		}
	  } catch (_) {}
	  try {
		if (window.debugScoreAnimations) {
			console.log('showScoreAnimation:call', { x, y, text, color, time: Date.now() });
		}
	  } catch (_) {}
	  const el = document.createElement("div");
	  el.className = "score-popup";
	  // Inline fallback styles in case CSS doesn't apply for any reason.
	  el.style.position = 'fixed';
	  el.style.pointerEvents = 'none';
	  el.style.fontSize = '1.2rem';
	  el.style.fontWeight = '700';
	  el.style.textShadow = '0 0 6px rgba(0,0,0,0.7), 0 0 12px rgba(255,255,255,0.5)';
	  el.style.whiteSpace = 'nowrap';
	  el.style.opacity = '1';
	  el.style.transform = 'translate(-50%, 0)';
	  el.style.zIndex = 'var(--z-score)';
	  el.style.left = `${x}px`;
	  el.style.top  = `${y}px`;
	  el.style.color = color;
	  el.textContent = text;
	  document.body.appendChild(el);
	  try {
		if (window.debugScoreAnimations) {
			const cs = window.getComputedStyle(el);
			const rect = el.getBoundingClientRect();
			console.log('showScoreAnimation:mounted', {
				zIndex: cs.zIndex,
				opacity: cs.opacity,
				display: cs.display,
				visibility: cs.visibility,
				position: cs.position,
				left: cs.left,
				top: cs.top,
				transform: cs.transform,
				animationName: cs.animationName,
				animationDuration: cs.animationDuration,
				rect: { x: rect.x, y: rect.y, w: rect.width, h: rect.height }
			});
			window.lastScorePopupRect = { x: rect.x, y: rect.y, w: rect.width, h: rect.height };
		}
	  } catch (_) {}
	  // Force reflow so animation plays reliably
	  void el.offsetWidth;
	  try {
		const cs = window.getComputedStyle(el);
		const prefersReduced = window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches;
		const batterySaver = document.body && document.body.classList.contains('battery-saver');
		const cssAnimActive = cs.animationName && cs.animationName !== 'none' && cs.animationDuration !== '0s';
		if (!prefersReduced && !batterySaver && !cssAnimActive && el.animate) {
			el.animate(
				[
					{ opacity: 1, transform: 'translate(-50%, 0px)' },
					{ opacity: 1, transform: 'translate(-50%, -18px)' },
					{ opacity: 0, transform: 'translate(-50%, -45px)' }
				],
				{ duration: 1200, easing: 'ease-out', fill: 'forwards' }
			);
		}
	  } catch (_) {}
	  setTimeout(() => el.remove(), 1200);
	}
	if (typeof window !== 'undefined' && !window.triggerScoreAnimation) {
		window.triggerScoreAnimation = function () {
			showScoreAnimation(window.innerWidth / 2, window.innerHeight / 2, '+TEST', 'lime');
		};
	}
	
	// Sparkle effect
	function sparkleEffect(x, y, count = 8) {
	  for (let i = 0; i < count; i++) {
		const s = document.createElement("div");
		s.className = "sparkle";
		const angle = Math.random() * 2 * Math.PI;
		const distance = 40 + Math.random() * 20;
		s.style.left = `${x}px`;
		s.style.top = `${y}px`;
		s.style.setProperty("--dx", `${Math.cos(angle) * distance}px`);
		s.style.setProperty("--dy", `${Math.sin(angle) * distance}px`);
		document.body.appendChild(s);
		setTimeout(() => s.remove(), 800);
	  }
	}
	
	
	function highlightEdgeCells(gridOrId) {
	const grid = typeof gridOrId === 'string' ? document.getElementById(gridOrId) : gridOrId;
	const gridLabel = typeof gridOrId === 'string' ? gridOrId : (gridOrId && gridOrId.id) || '(anonymous zone)';

	  if (!grid) return;

	  const cells = Array.from(grid.querySelectorAll('.cell'));
	  if (cells.length === 0) return;

	  // Haal gridafmetingen op uit dataset of bepaal automatisch
	  const rows = parseInt(grid.dataset.rows || '12', 10);
	  const cols = parseInt(grid.dataset.cols || '12', 10);

	  // Map opbouwen van "r,c" â†’ element
	  const map = new Map();
	  for (const cell of cells) {
		const r = parseInt(cell.dataset.r ?? "-1", 10);
		const c = parseInt(cell.dataset.c ?? "-1", 10);
		if (r >= 0 && c >= 0) map.set(`${r},${c}`, cell);
	  }

	  // Reset edge-styling
	  cells.forEach(c => c.classList.remove('edge-cell'));

	  const dirs = [
		{dr: -1, dc: 0},
		{dr: 1,  dc: 0},
		{dr: 0,  dc: -1},
		{dr: 0,  dc: 1},
	  ];

	  let edgeCount = 0;

	  for (const [key, cell] of map.entries()) {
		if (!cell.classList.contains('active')) continue;

		const [rStr, cStr] = key.split(',');
		const r = parseInt(rStr, 10);
		const c = parseInt(cStr, 10);

		let isEdge = false;

		for (const d of dirs) {
		  const nr = r + d.dr, nc = c + d.dc;
		  const neighbor = map.get(`${nr},${nc}`);
		  if (!neighbor || !neighbor.classList.contains('active')) {
			isEdge = true;
			break;
		  }
		}

		if (isEdge) {
		  cell.classList.add('edge-cell');
		  edgeCount++;
		}
	  }

	  // Debug info removed (was console.log for edge-cell count)

		  const zoomZone = grid.closest('.zone.zoom-focus');
		  if (zoomZone) schedulePlaceholderSync(zoomZone);
	}

	let lastTap = 0;

	const board = document.querySelector('.board');

	board.addEventListener('touchend', function(e) {
	  const currentTime = new Date().getTime();
	  const tapLength = currentTime - lastTap;
	  if (tapLength < 300 && tapLength > 0) {
		e.preventDefault(); // voorkomt dubbel-tap zoom
	  }
	  lastTap = currentTime;
	});


  // ---------- Undo / Clear ----------
  /** Update disabled state of the floating undo button. */
  function updateUndoButton() {
	const btn = document.getElementById('undo-floating-btn');
	if (!btn) return;
	const canUndo = (cardPlacementHistory && cardPlacementHistory.length > 0) ||
	                (historyStack && historyStack.length > 0);
	btn.disabled = !canUndo;
  }

  function undo(){
	const lastPlacement = cardPlacementHistory.length ? cardPlacementHistory[cardPlacementHistory.length - 1] : null;
	const lastToggle = historyStack.length ? historyStack[historyStack.length - 1] : null;
	const placementSeq = lastPlacement?.sequence ?? -Infinity;
	const toggleSeq = lastToggle?.sequence ?? -Infinity;
	if (placementSeq === -Infinity && toggleSeq === -Infinity) return;

	if (placementSeq >= toggleSeq) {
	  const placement = cardPlacementHistory.pop();
	  if (!placement) return;
	  const { cells = [], coinSnapshotBefore = [], handIndex = 0, cardState, cardRef, bonuses = [], isBonusPlacement = false, bonusKey = null, bonusSpent = false } = placement;
	  cells.forEach(cell => {
		if (!cell) return;
		cell.classList.remove('active', 'preview-allowed', 'preview-denied', 'edge-cell');
		cell.style.removeProperty('background');
		delete cell.dataset.clusterScore;
		delete cell.dataset.clusterPending;
		// IMPORTANT: undo must also revert trap activation/penalty
		try {
		  const zoneId = cell.dataset.zoneId || cell.closest('.grid')?.id || cell.closest('.zone')?.id || '';
		  ensureTrapState(cell, zoneId, { silent: true });
		} catch (e) {}
		syncPlaceholderForCell(cell);
	  });
	  // Safety: fully rebuild trap state from DOM so penalties disappear after undo
	  rehydrateTrapsFromDOM();
	  restoreCoinState(coinSnapshotBefore);
	  if (Array.isArray(bonuses) && bonuses.length) {
		bonuses.forEach(revokeBonusClaim);
	  }
	  if (placement && placement.bonusEchoPointsAdded && placement.bonusEchoColorKey) {
		const key = placement.bonusEchoColorKey;
		const current = Number(colorScoreBonuses[key] || 0);
		colorScoreBonuses[key] = Math.max(0, current - Number(placement.bonusEchoPointsAdded || 0));
		if (placement.bonusEchoExtraTurnGranted && bonusEchoExtraTurns > 0) {
			bonusEchoExtraTurns = Math.max(0, bonusEchoExtraTurns - 1);
		}
	  }
	  if (placement && Array.isArray(placement.bonusEchoBonusesGranted) && placement.bonusEchoBonusesGranted.length) {
		placement.bonusEchoBonusesGranted.forEach(entry => {
			const key = typeof entry === 'string' ? entry : entry?.key;
			const amount = typeof entry === 'object' && Number(entry.amount) ? Number(entry.amount) : 1;
			if (key && bonusInventory[key] > 0) {
				bonusInventory[key] = Math.max(0, bonusInventory[key] - amount);
				totalBonusesCollected = Math.max(0, totalBonusesCollected - amount);
			}
		});
		updateBonusInventoryUI();
	  }
	  updateScore();
	  recomputeBonusEchoSequenceState();
	  if (isBonusPlacement) {
		if (bonusSpent && bonusKey) restoreBonusCharge(bonusKey);
		selectedCardId = null;
		selectedCardElement = null;
		selectedShape = null;
		selectedColor = null;
		if (rotateButton) rotateButton.disabled = true;
		updateDrawButtonState();
		recomputeTurnCardFlags();
		applyTurnCardLocks();
		return;
	  }
	  const discardIdx = cardState ? discardPile.findIndex(card => card.id === cardState.id) : -1;
	  let restoredCard = null;
	  if (discardIdx !== -1) {
		restoredCard = discardPile.splice(discardIdx, 1)[0];
	  } else if (cardRef) {
		restoredCard = cardRef;
	  }
	  if (!restoredCard && cardState) {
		restoredCard = {
		  id: cardState.id,
		  blueprintId: cardState.blueprintId,
		  shapeName: cardState.shapeName,
		  matrix: cloneShape(cardState.matrix),
		  category: cardState.category,
		  color: cloneColor(cardState.color)
		};
	  } else if (restoredCard && cardState) {
		restoredCard.matrix = cloneShape(cardState.matrix);
		restoredCard.shapeName = cardState.shapeName;
		restoredCard.category = cardState.category;
		restoredCard.color = cloneColor(cardState.color);
	  }
	  if (restoredCard) {
		const insertIndex = Math.max(0, Math.min(handIndex, currentHand.length));
		currentHand.splice(insertIndex, 0, restoredCard);
	  }
	  cardsPlayedThisTurn = Math.max(0, cardsPlayedThisTurn - 1);
	  selectedCardId = null;
	  selectedCardElement = null;
	  selectedShape = null;
	  selectedColor = null;
	  if (rotateButton) rotateButton.disabled = true;
	  renderCurrentHand();
	  updateDrawButtonState();
	  recomputeTurnCardFlags();
	  applyTurnCardLocks();
	  updateUndoButton();
	  return;
	}

	const last = historyStack.pop();
	if(!last) return;
	if(last.wasActive) last.cell.classList.add('active'); else last.cell.classList.remove('active');
	ensureTrapState(last.cell, last.cell.dataset.zoneId || last.cell.closest('.grid')?.id || '', { silent: true });
	rehydrateTrapsFromDOM();
	if(last.cell.classList.contains('gold-cell')){
	  if(last.cell.classList.contains('active')) addCoin(); else removeCoin();
	}
	if (Array.isArray(last.bonusClaims) && last.bonusClaims.length) {
		last.bonusClaims.forEach(revokeBonusClaim);
	}
	updateScore(last.cell);
	syncPlaceholderForCell(last.cell);
	// Recompute per-turn flags after toggling a cell state which may have affected bonuses
	recomputeTurnCardFlags();
	applyTurnCardLocks();
	updateUndoButton();
  }
	function clearBoard(){
	  if (!debugMode) return;
	  document.querySelectorAll('.cell').forEach(c=>c.classList.remove('active'));
	  resetCoins();
	  addCoin();
	  historyStack.length = 0;
	  resetScoreState();
	  updateScore();
	  updateUndoButton();
	if (activeZoomZone) schedulePlaceholderSync(activeZoomZone);
	}
	
  
  // bewaar originele inline cursor instellingen zodat we ze kunnen herstellen
	let _origCursorHtml = null;
	let _origCursorBody = null;

	// helper: start dragging visuals (hide cursor globally)
	function startGlobalDragVisuals() {
	  document.body.classList.add('dragging');

	  // Sla inline stijl op en zet inline cursor: none (overruled bijna alles)
	  const html = document.documentElement;
	  const body = document.body;

	  // bewaar oude inline waarde
	  _origCursorHtml = html.style.getPropertyValue('cursor') || null;
	  _origCursorBody = body.style.getPropertyValue('cursor') || null;

	  // zet inline style met priority 'important'
	  html.style.setProperty('cursor', 'none', 'important');
	  body.style.setProperty('cursor', 'none', 'important');
	}

	// helper: stop dragging visuals (restore cursor)
	function stopGlobalDragVisuals() {
	  document.body.classList.remove('dragging');

	  const html = document.documentElement;
	  const body = document.body;

	  if (_origCursorHtml !== null) html.style.setProperty('cursor', _origCursorHtml);
	  else html.style.removeProperty('cursor');

	  if (_origCursorBody !== null) body.style.setProperty('cursor', _origCursorBody);
	  else body.style.removeProperty('cursor');

	  _origCursorHtml = _origCursorBody = null;
	}
  
  
	// ========================
	// DRAG & DROP LOGICA (verfijnd)
	// ========================

	function makeDraggable(shape, color) {
	  const block = document.createElement('div');
	  block.classList.add('draggable');
	  block.style.position = 'fixed';
	  block.style.left = '0px';
      block.style.top = '0px';
	  block.style.zIndex = 1000;


	
	  const allowedZones =
		color.name === 'rood'
		  ? ['red-grid1', 'red-grid2', 'red-grid3', 'red-grid4']
		  : [color.name];
	  block.dataset.allowedZones = JSON.stringify(allowedZones);

	  let currentShape = JSON.parse(JSON.stringify(shape));
	  block._shape = currentShape;
	  
	  
	  renderBlock(block, currentShape, color);
	  document.body.appendChild(block);

	  // ================
	  // START DRAG
	  // ================
	  block.addEventListener('pointerdown', ev => {
        ev.preventDefault();
		// If the block has been rotated/mirrored via buttons, use the updated shape.
		currentShape = block._shape || currentShape;
		beginPointerDrag({ clientX: ev.clientX, clientY: ev.clientY, pointerId: ev.pointerId });

        draggedBlock = block;
		resetDragBlockGap();
        draggedColor = color;
		draggedShape = currentShape;
		
		// Offsets based on the current shape and actual rendered block size.
		// MOBILE FIX: Measure a real cell + gap so offsets align on all layouts
		let actualCellSize = null;
		let actualGap = null;
		try {
			const sampleCell = block.querySelector('.preview-cell-wrap') || block.querySelector('div');
			if (sampleCell) {
				const r = sampleCell.getBoundingClientRect();
				actualCellSize = Math.min(r.width, r.height);
			}
			const blockStyle = getComputedStyle(block);
			const gapRaw = blockStyle.gap || blockStyle.columnGap || '0px';
			actualGap = parseFloat(gapRaw) || 0;
		} catch (_) {}
		({ offsetX, offsetY } = computeShapeCenterOffsets(currentShape, { cellSize: actualCellSize, gap: actualGap }));


		// For touch pointers only: add a small upward offset so the block is not under the finger.
		const touchOffsetY = getFingerLiftOffsetY(ev);

		// Start drag direct: plaats blok op cursor positie met offset
		const overlay = document.getElementById('drag-overlay');
		if (overlay) {
			overlay.appendChild(block);
			overlay.style.display = 'block';
		}
		startGlobalDragVisuals();

		// Positioneer blok direct op de pointer positie
		setElPos(block, ev.clientX - offsetX, ev.clientY - offsetY - touchOffsetY);

        block.setPointerCapture(ev.pointerId);
        block.style.transition = 'transform 0.1s ease';
        block.style.opacity = '0.3';
	  });

	  // ROTATIE VIA SCROLL
	  block.addEventListener('wheel', ev => {
		if (draggedBlock !== block) return;
		ev.preventDefault();
		currentShape = rotateShape(currentShape);
		block._shape = currentShape;
		draggedShape = currentShape;
		renderBlock(draggedBlock, currentShape, draggedColor);
		const m = getDragBlockCellMetrics(draggedBlock);
		({ offsetX, offsetY } = computeShapeCenterOffsets(currentShape, m));
	  });
	  
  return block;
}

// ROTATIE VIA R en SPIEGEL VIA T
/*
	EN:
	- WHY: Keyboard shortcuts while a shape exists (dragging OR selected card).
	- STATE: reads/writes `draggedBlock`, `draggedShape`, `selectedShape`, `selectedColor`, `offsetX/offsetY`.
	- DUPLICATE: Rotation/mirror also exists via buttons (floating preview buttons) and mouse wheel rotate.
	- NOTE: Offsets are based on measured board cell size + `--board-grid-gap` for consistent scaling.
	- Escape: cancels current drag OR cancels bonus placement.
*/
document.addEventListener('keydown', ev => {
  // Check of we een shape hebben (draggedBlock of selectedShape)
  const hasShape = draggedBlock || (selectedShape && selectedColor);
  if (!hasShape) return;
  
  if (ev.key === 'Escape' && draggedBlock) {
	ev.preventDefault();
	if (activeBonusPlacement) {
		cancelActiveBonusPlacement();
	} else {
		cleanupDragState({ clearBonus: false });
	}
	return;
  }
  
	// Rotatie met 'r'
	if (ev.key.toLowerCase() === 'r') {
		ev.preventDefault();
		if (draggedBlock) {
			draggedShape = rotateShape(draggedShape);
			draggedBlock._shape = draggedShape;
			renderBlock(draggedBlock, draggedShape, draggedColor);
			const m = getDragBlockCellMetrics(draggedBlock);
			({ offsetX, offsetY } = computeShapeCenterOffsets(draggedShape, m));
		} else if (selectedShape) {
			rotateSelectedCard();
		}
	}  // Spiegel met 't'
  if (ev.key.toLowerCase() === 't') {
	ev.preventDefault();
	if (draggedBlock) {
		draggedShape = mirrorShape(draggedShape);
		draggedBlock._shape = draggedShape;
		renderBlock(draggedBlock, draggedShape, draggedColor);
		const m = getDragBlockCellMetrics(draggedBlock);
		({ offsetX, offsetY } = computeShapeCenterOffsets(draggedShape, m));
	} else if (selectedShape) {
		mirrorSelectedCard();
	}
  }
});

// =============
// SLEPEN (drag)
// =============
/*
	EN:
	- WHY: This is the core â€œdrag the placed shape over the boardâ€ loop.
	- STATE: moves `draggedBlock` into `#drag-overlay` so it renders above everything.
	- COORDINATES: Uses `elementFromPoint()` per filled cell in the shape to find underlying grid cells.
	  This is more robust than only using the cursor point, but it is heavier.
	- OVERRIDE: Preview rendering is currently disabled (showPreview/clearPreview calls are commented out).
	- FIX NOTE: `showZoomLens(...)` uses `cursorX`/`cursorY` from the pointer event for correct positioning.
*/

function processDragPointerMove(ev) {
	if (!draggedBlock || !isPointerDragging) return;
	if (dragPointerId !== null && ev.pointerId !== dragPointerId) return;
	if (!draggedShape || !draggedColor) return;
	if (!Array.isArray(draggedShape) || !draggedShape.length || !Array.isArray(draggedShape[0])) return;

	const cursorX = Number(ev.clientX) || 0;
	const cursorY = Number(ev.clientY) || 0;

	// Skip redundant work when the cursor didn't really move.
	if (lastProcessedDragClientX === cursorX && lastProcessedDragClientY === cursorY) return;
	lastProcessedDragClientX = cursorX;
	lastProcessedDragClientY = cursorY;
	lastProcessedDragAtMs = (typeof performance !== 'undefined' && performance.now) ? performance.now() : Date.now();

	if (!dragHasMoved) {
		const isTouchPointer = (ev.pointerType === 'touch' || ev.pointerType === 'pen');
		const moveThreshold = isTouchPointer ? 10 : 5;
		const dx = Math.abs(cursorX - dragStartClientX);
		const dy = Math.abs(cursorY - dragStartClientY);
		if ((dx + dy) >= moveThreshold) {
			dragHasMoved = true;
		}
	}

	const overlay = document.getElementById('drag-overlay');
	if (overlay) {
		if (!document.body.classList.contains('dragging')) document.body.classList.add('dragging');
		if (overlay.style.display !== 'block') overlay.style.display = 'block';
		if (draggedBlock.parentNode !== overlay) overlay.appendChild(draggedBlock);
	}

	if (document.body.style.cursor !== 'none') document.body.style.cursor = 'none';
	if (document.documentElement.style.cursor !== 'none') document.documentElement.style.cursor = 'none';

	const isTouchPointer = (ev.pointerType === 'touch' || ev.pointerType === 'pen');
	if (window.innerWidth <= MOBILE_BREAKPOINT && !isTouchPointer) {
		const anyVisible = !!document.querySelector('.card-control-btn.visible');
		if (!anyVisible) addCardControlButtons();
	}

	const touchOffsetY = getFingerLiftOffsetY(ev);
	setElPos(draggedBlock, cursorX - offsetX, cursorY - offsetY - touchOffsetY);

	if (window.debugHoverPosition) {
		console.log('Hover Debug:', {
			cursorX, cursorY,
			offsetX, offsetY,
			touchOffsetY,
			resultLeft: (cursorX - offsetX),
			resultTop: (cursorY - offsetY - touchOffsetY)
		});
	}

	const prevPointerEvents = draggedBlock.style.pointerEvents;
	draggedBlock.style.pointerEvents = 'none';

	const centerElem = document.elementFromPoint(cursorX, cursorY);
	const detectedZone = centerElem ? centerElem.closest('.zone') : null;
	const shapeHeight = draggedShape.length;
	const shapeWidth = draggedShape[0].length;
	const gapChanged = applyDragBlockGap(detectedZone);
	if (gapChanged) {
		void draggedBlock.offsetHeight;
		try {
			const sampleCell = draggedBlock.querySelector('.preview-cell-wrap') || draggedBlock.querySelector('div');
			let cellSize = 0;
			if (sampleCell) {
				const r = sampleCell.getBoundingClientRect();
				cellSize = Math.min(r.width, r.height);
			}
			const blockStyle = getComputedStyle(draggedBlock);
			const gapRaw = blockStyle.gap || blockStyle.columnGap || '0px';
			const gap = parseFloat(gapRaw) || 0;
			const effectiveGap = (dragGapMode === 'gapless') ? 0 : gap;
			({ offsetX, offsetY } = computeShapeCenterOffsets(draggedShape, { cellSize, gap: effectiveGap }));
			setElPos(draggedBlock, cursorX - offsetX, cursorY - offsetY - touchOffsetY);
		} catch (e) {}
	}

	const blockRect = draggedBlock.getBoundingClientRect();
	let stepX = 0;
	let stepY = 0;
	let dragCellSize = 0;
	let dragOriginX = blockRect.left;
	let dragOriginY = blockRect.top;
	try {
		const sampleCell = draggedBlock.querySelector('.preview-cell-wrap') || draggedBlock.querySelector('div');
		const cellRect = sampleCell ? sampleCell.getBoundingClientRect() : null;
		const cellSize = cellRect ? Math.min(cellRect.width, cellRect.height) : 0;
		dragCellSize = cellSize;
		if (cellRect) {
			dragOriginX = cellRect.left;
			dragOriginY = cellRect.top;
		}
		const blockStyle = getComputedStyle(draggedBlock);
		const gapRaw = blockStyle.gap || blockStyle.columnGap || '0px';
		const gap = parseFloat(gapRaw) || 0;
		stepX = cellSize + gap;
		stepY = cellSize + gap;
	} catch (_) {
		stepX = shapeWidth > 0 ? (blockRect.width / shapeWidth) : 0;
		stepY = shapeHeight > 0 ? (blockRect.height / shapeHeight) : 0;
		dragCellSize = stepX;
	}

	const cellHits = [];
	for (let row = 0; row < shapeHeight; row++) {
		for (let col = 0; col < shapeWidth; col++) {
			if (!isSolidShapeCell(draggedShape[row][col])) continue;
			const cellX = dragOriginX + (col * stepX) + (dragCellSize / 2);
			const cellY = dragOriginY + (row * stepY) + (dragCellSize / 2);
			const elem = document.elementFromPoint(cellX, cellY);
			const gridCell = elem ? elem.closest('.cell') : null;
			if (!gridCell || gridCell.dataset.x === undefined || gridCell.dataset.y === undefined) continue;
			const cellZone = gridCell.closest('.zone');
			if (!cellZone || cellZone.classList.contains('zone-placeholder')) continue;
			cellHits.push({
				gridCell,
				zone: cellZone,
				shapeRow: row,
				shapeCol: col,
				gridX: parseInt(gridCell.dataset.x, 10),
				gridY: parseInt(gridCell.dataset.y, 10)
			});
		}
	}

	draggedBlock.style.pointerEvents = prevPointerEvents || '';

	if (cellHits.length === 0) {
		lastZone = null;
		lastBaseX = lastBaseY = null;
		return;
	}

	const zoneCounts = {};
	cellHits.forEach(hit => {
		const zoneId = hit.zone.id || '';
		if (!zoneId) return;
		zoneCounts[zoneId] = (zoneCounts[zoneId] || 0) + 1;
	});
	const bestZoneId = Object.keys(zoneCounts).reduce((a, b) => zoneCounts[a] > zoneCounts[b] ? a : b);
	let zone = document.getElementById(bestZoneId);
	if (!zone) zone = cellHits[0].zone;

	const zoneHits = cellHits.filter(hit => hit.zone === zone);
	if (zoneHits.length === 0) {
		lastZone = null;
		lastBaseX = lastBaseY = null;
		return;
	}

	const countOccurrences = (values) => {
		const counts = new Map();
		for (const v of values) counts.set(v, (counts.get(v) || 0) + 1);
		return counts;
	};
	const pickBest = (counts, previous) => {
		let bestVal = null;
		let bestCount = -Infinity;
		for (const [val, cnt] of counts.entries()) {
			if (cnt > bestCount) {
				bestCount = cnt;
				bestVal = val;
				continue;
			}
			if (cnt === bestCount) {
				if (Number.isFinite(previous)) {
					const curDist = Math.abs(val - previous);
					const bestDist = Math.abs(bestVal - previous);
					if (curDist < bestDist) bestVal = val;
				} else if (val < bestVal) {
					bestVal = val;
				}
			}
		}
		return bestVal;
	};

	const baseXCandidates = zoneHits.map(h => h.gridX - h.shapeCol);
	const baseYCandidates = zoneHits.map(h => h.gridY - h.shapeRow);
	let baseX = pickBest(countOccurrences(baseXCandidates), lastBaseX);
	let baseY = pickBest(countOccurrences(baseYCandidates), lastBaseY);
	if (!Number.isFinite(baseX)) baseX = baseXCandidates[0];
	if (!Number.isFinite(baseY)) baseY = baseYCandidates[0];

	lastZone = zone;
	lastBaseX = baseX;
	lastBaseY = baseY;

	const zoneColor =
		zone.dataset.color ||
		zone.closest('.zone')?.dataset.color ||
		(zone.id && zone.id.startsWith('red-grid') ? 'rood' : null);

	const colorOk =
		zoneColor === draggedColor.name ||
		draggedColor.name === 'multikleur' ||
		(draggedColor.name === 'rood' && zoneColor === 'rood');

	const allowed = colorOk && canPlace(zone, baseX, baseY, draggedShape);
	if (draggedBlock) draggedBlock.style.opacity = allowed ? '1' : '0.3';
	
	hideZoomLens();
}

document.addEventListener('pointermove', ev => {
	if (!draggedBlock || !isPointerDragging) return;
	if (dragPointerId !== null && ev.pointerId !== dragPointerId) return;

	// Capture only the fields we use; throttle heavy work to at most 1x per animation frame.
	dragMovePending = {
		clientX: ev.clientX,
		clientY: ev.clientY,
		pointerId: ev.pointerId,
		pointerType: ev.pointerType
	};
	if (dragMoveRafId) return;
	const tick = () => {
		// Clear the "scheduled" flag early so pointermove can queue the next frame.
		dragMoveRafId = null;
		const pending = dragMovePending;
		if (!pending) return;

		// Battery saver: throttle expensive hit-testing to ~30fps.
		try {
			if (BATTERY_SAVER_ENABLED && BATTERY_THROTTLE_DRAG) {
				const now = (typeof performance !== 'undefined' && performance.now) ? performance.now() : Date.now();
				if ((now - (lastProcessedDragAtMs || 0)) < 33) {
					dragMoveRafId = requestAnimationFrame(tick);
					return;
				}
			}
		} catch (_) {}

		dragMovePending = null;
		processDragPointerMove(pending);
	};
	dragMoveRafId = requestAnimationFrame(tick);
});

	// =============
	// LOSLATEN
	// =============
	document.addEventListener('pointerup', ev => {
			// If a pointer is captured (e.g. purchased preview in #gold-zone), ev.target can be misleading.
			// Use the real element under the pointer at release for drop logic.
			const releaseTarget = (typeof ev.clientX === 'number' && typeof ev.clientY === 'number')
				? (document.elementFromPoint(ev.clientX, ev.clientY) || ev.target)
				: ev.target;

		// Negeer als we op een control button klikken
			if (releaseTarget && releaseTarget.classList && releaseTarget.classList.contains('card-control-btn')) {
			return;
		}
		
		// Negeer clicks op gold-zone (buy button, coin display, etc.)
			if (releaseTarget && releaseTarget.closest && releaseTarget.closest('#gold-zone') && !draggedBlock) {
			return;
		}
		
		if (!draggedBlock) return;
		if (dragPointerId !== null && ev.pointerId !== dragPointerId) return;
		const bonusContext = activeBonusPlacement;
		const isMobileLayout = window.innerWidth <= MOBILE_BREAKPOINT;
		const isTouchDevice = ('ontouchstart' in window || navigator.maxTouchPoints > 0);
		// Desktop hover-drag: do not drop on pointerup (click-to-drop handles placement).
		if (desktopHoverDragActive && !isMobileLayout && !isTouchDevice && (!bonusContext || bonusContext.desktopHover)) {
			return;
		}
		// Mobile UX: a short tap should not instantly place a block.
		// Only allow placing on release if the user actually dragged (moved a bit).
		if (isMobileLayout && !dragHasMoved) {
			enterStickyDragPreview();
			return;
		}

		if (lastZone && lastBaseX !== null && lastBaseY !== null) {
			const zoneColor =
			  lastZone.dataset.color ||
			  lastZone.closest('.zone')?.dataset.color ||
			  (lastZone.id.startsWith('red-grid') ? 'rood' : null);
			const colorOk = zoneColor === draggedColor.name || draggedColor.name === 'multikleur' || (draggedColor.name === 'rood' && zoneColor === 'rood');
			const allowed = colorOk && canPlace(lastZone, lastBaseX, lastBaseY, draggedShape);

			clearPreview(lastZone);

			if (allowed) {
				const coinSnapshotBefore = getCoinStateSnapshot();
				const placementResult = placeShape(lastZone, lastBaseX, lastBaseY, draggedShape, draggedColor);
				if (bonusContext) {
					finalizeBonusPlacement(placementResult, coinSnapshotBefore, bonusContext);
					cleanupDragState({ clearBonus: true, updateInventory: false });
					hideFloatingPreview(); // Verberg na succesvolle plaatsing
					removeCardControlButtons(); // Verberg buttons na plaatsing
				} else {
					finalizeCardPlacement(placementResult, coinSnapshotBefore);
					cleanupDragState({ clearBonus: false });
					hideFloatingPreview(); // Verberg na succesvolle plaatsing
					removeCardControlButtons(); // Verberg buttons na plaatsing
				}
				return;
			}
		}

		if (bonusContext) {
			// Check of purchased placement buiten grid of op gold-zone is losgelaten
			if (bonusContext.colorKey === 'purchased') {
				const goldZone = document.getElementById('gold-zone');
				const previewDiv = document.getElementById('purchased-block-preview');
				const clickedOnGoldZone = goldZone && releaseTarget && goldZone.contains(releaseTarget);
				const clickedOnPreview = previewDiv && releaseTarget && previewDiv.contains(releaseTarget);
				
				// Als geklikt op gold-zone/preview, annuleer
				if (clickedOnGoldZone || clickedOnPreview) {
					cancelActiveBonusPlacement({ updateInventory: true });
					return;
				}
				
				// Als we GEEN lastZone hebben (echt buiten grid), annuleer
				if (!lastZone) {
					cancelActiveBonusPlacement({ updateInventory: true });
					return;
				}
				
				// We hebben een zone, probeer te plaatsen op laatste positie
				if (lastZone && lastBaseX !== null && lastBaseY !== null) {
					const zoneColor =
						lastZone.dataset.color ||
						lastZone.closest('.zone')?.dataset.color ||
						(lastZone.id.startsWith('red-grid') ? 'rood' : null);
					const colorOk = zoneColor === draggedColor.name || draggedColor.name === 'multikleur' || (draggedColor.name === 'rood' && zoneColor === 'rood');
					const allowed = colorOk && canPlace(lastZone, lastBaseX, lastBaseY, draggedShape);
					
					if (allowed) {
						const coinSnapshotBefore = getCoinStateSnapshot();
						const placementResult = placeShape(lastZone, lastBaseX, lastBaseY, draggedShape, draggedColor);
						finalizeBonusPlacement(placementResult, coinSnapshotBefore, bonusContext);
						cleanupDragState({ clearBonus: true, updateInventory: false });
						hideFloatingPreview();
						removeCardControlButtons();
						return;
					} else {
						// Plaatsing niet geldig, annuleer en geef munten terug
						cancelActiveBonusPlacement({ updateInventory: true });
						return;
					}
				}
				
				// Geen geldige positie gevonden, annuleer
				cancelActiveBonusPlacement({ updateInventory: true });
				return;
			}
			// Als sticky false is (touch mode) voor ANDERE bonussen, annuleer bij invalide plaatsing
			if (!bonusContext.sticky && bonusContext.colorKey !== 'purchased') {
				cancelActiveBonusPlacement({ updateInventory: true });
				return;
			}
			// Keep the bonus block visible so player can rotate/mirror or reposition after releasing.
			enterStickyDragPreview();
			return;
		}

		// Desktop: on invalid release, the piece disappears.
		if (!isMobileLayout) {
			const overlay = document.getElementById('drag-overlay');
			try { draggedBlock.remove(); } catch {}
			draggedBlock = null;
			draggedShape = null;
			draggedColor = null;
			lastZone = null;
			lastBaseX = lastBaseY = null;
			desktopHoverDragActive = false;
			suppressDesktopDropUntil = 0;
			endPointerDragTracking();
			if (overlay) overlay.style.display = 'none';
			document.body.classList.remove('dragging');
			document.body.style.cursor = '';
			document.documentElement.style.cursor = '';
			stopGlobalDragVisuals();
			removeCardControlButtons();
			return;
		}

		// Mobile: keep the card block on screen on invalid release.
		enterStickyDragPreview();
		// Floating preview blijft zichtbaar - alleen kruisje of succesvolle plaatsing verbergt het
	});

	// If the player right-clicks while dragging (desktop), the browser may open a context menu and
	// our normal pointerup flow may not run cleanup. Treat right-click as cancel and restore cursor.
	document.addEventListener('pointerdown', ev => {
		if (ev.button !== 2) return;
		if (!draggedBlock && !document.body.classList.contains('dragging')) return;
		try { ev.preventDefault(); } catch (e) {}
		try { ev.stopPropagation(); } catch (e) {}
		if (activeBonusPlacement) {
			cancelActiveBonusPlacement({ updateInventory: true, hidePreview: true });
		} else {
			cleanupDragState({ clearBonus: false, hidePreview: true });
		}
	}, true);

	// Also cancel on the actual context menu event (some browsers fire this without a pointerup).
	document.addEventListener('contextmenu', ev => {
		if (!draggedBlock && !document.body.classList.contains('dragging')) return;
		try { ev.preventDefault(); } catch (e) {}
		if (activeBonusPlacement) {
			cancelActiveBonusPlacement({ updateInventory: true, hidePreview: true });
		} else {
			cleanupDragState({ clearBonus: false, hidePreview: true });
		}
	}, true);

	// If a pointer gets canceled while dragging (e.g. OS gesture/context menu), ensure cursor restores.
	document.addEventListener('pointercancel', ev => {
		if (!draggedBlock && !document.body.classList.contains('dragging')) return;
		if (dragPointerId !== null && ev.pointerId !== dragPointerId) return;
		if (activeBonusPlacement) {
			cancelActiveBonusPlacement({ updateInventory: true, hidePreview: true });
		} else {
			cleanupDragState({ clearBonus: false, hidePreview: true });
		}
	}, true);

	// Desktop hover-drag: second click drops the piece.
	document.addEventListener('pointerdown', ev => {
		if (!desktopHoverDragActive) return;
		if (activeBonusPlacement && !activeBonusPlacement.desktopHover) return;
		if (ev.button !== 0) return;
		const isMobileLayout = window.innerWidth <= MOBILE_BREAKPOINT;
		const isTouchDevice = ('ontouchstart' in window || navigator.maxTouchPoints > 0);
		if (isMobileLayout || isTouchDevice) return;
		if (Date.now() < suppressDesktopDropUntil) return;

		// If the user clicks the hand/cards area while a sticky block is active, interpret that as
		// â€œlet goâ€ (otherwise it can feel like the block is stuck).
		// Allow clicks on cards to continue so the player can switch cards in one action.
		const clickedCard = ev.target.closest ? ev.target.closest('.card-option') : null;
		if (ev.target.closest && ev.target.closest('#card-choice-zone')) {
			if (clickedCard) {
				cleanupDragState({ clearBonus: false, hidePreview: true });
				return;
			}
			cleanupDragState({ clearBonus: false, hidePreview: true });
			ev.preventDefault();
			ev.stopPropagation();
			return;
		}

		// Ignore clicks on UI areas; drop should happen on the board.
		if (ev.target.closest('button') || ev.target.closest('#controls') || ev.target.closest('#floating-preview')) {
			return;
		}

		ev.preventDefault();
		ev.stopPropagation();

		if (lastZone && lastBaseX !== null && lastBaseY !== null) {
			const zoneColor =
				lastZone.dataset.color ||
				lastZone.closest('.zone')?.dataset.color ||
				(lastZone.id.startsWith('red-grid') ? 'rood' : null);
			const colorOk = zoneColor === draggedColor.name || draggedColor.name === 'multikleur' || (draggedColor.name === 'rood' && zoneColor === 'rood');
			const allowed = colorOk && canPlace(lastZone, lastBaseX, lastBaseY, draggedShape);
			clearPreview(lastZone);
			if (allowed) {
				const coinSnapshotBefore = getCoinStateSnapshot();
				const placementResult = placeShape(lastZone, lastBaseX, lastBaseY, draggedShape, draggedColor);
				if (activeBonusPlacement && activeBonusPlacement.desktopHover) {
					finalizeBonusPlacement(placementResult, coinSnapshotBefore, activeBonusPlacement);
					desktopHoverDragActive = false;
					suppressDesktopDropUntil = 0;
					cleanupDragState({ clearBonus: true, updateInventory: false });
					hideFloatingPreview();
					removeCardControlButtons();
					return;
				}
				finalizeCardPlacement(placementResult, coinSnapshotBefore);
				desktopHoverDragActive = false;
				suppressDesktopDropUntil = 0;
				cleanupDragState({ clearBonus: false });
				hideFloatingPreview();
				return;
			}
		}

		// Invalid drop: on desktop the piece disappears.
		if (activeBonusPlacement && activeBonusPlacement.colorKey === 'purchased') {
			cancelActiveBonusPlacement({ updateInventory: true, hidePreview: true });
			return;
		}
		cancelDesktopHoverDragKeepSelection({ showPreview: false });
	}, true);

	function enterStickyDragPreview() {
		if (!draggedBlock) return;
		// Pointer capture / touch can synthesize a click right after release.
		// Prevent that click from toggling card selection and calling cleanup.
		suppressCardSelectUntil = Date.now() + 650;
		endPointerDragTracking();
		lastZone = null;
		lastBaseX = lastBaseY = null;

		const overlay = document.getElementById('drag-overlay');
		if (overlay) {
			overlay.style.display = 'block';
			// Keep overlay transparent for hit-testing; block itself stays pickable.
			overlay.style.pointerEvents = 'none';
		}
		if (draggedBlock) {
			draggedBlock.style.opacity = '1';
			draggedBlock.style.pointerEvents = '';
		}

		document.body.classList.remove('dragging');
		document.body.style.cursor = '';
		document.documentElement.style.cursor = '';
		stopGlobalDragVisuals();

		// Ensure the rotate/mirror controls are available.
		if (rotateButton) rotateButton.disabled = false;
		if (mirrorButton) {
			// Only enable mirror now if controls were not intentionally delayed
			if (!activeBonusPlacement || !activeBonusPlacement.delayedControls) {
				mirrorButton.disabled = false;
			}
		}
		addCardControlButtons();
		// If mirror was delayed for this bonus drag, reveal it now and re-position
		try {
			// Only reveal delayed mirror if this was NOT a bonus placement
			if (activeBonusPlacement && activeBonusPlacement.delayedControls && !(activeBonusPlacement && activeBonusPlacement.colorKey)) {
				const mb = document.querySelector('.card-control-mirror');
				if (mb) {
					mb.disabled = false;
					mb.classList.add('visible');
					mb.removeAttribute('data-delayed');
					// Re-position buttons using the centralized positioning logic
					try { addCardControlButtons(); } catch (e) {}
				}
				activeBonusPlacement.delayedControls = false;
			}
		} catch (e) {}
	}

	function findCellInZone(zone, clientX, clientY) {
		if (!zone) return null;
		const cells = zone.querySelectorAll('.cell');
		for (const cell of cells) {
			const rect = cell.getBoundingClientRect();
			if (clientX >= rect.left && clientX <= rect.right && clientY >= rect.top && clientY <= rect.bottom) {
				return cell;
			}
		}
		return null;
	}

	function cleanupDragState({ clearBonus = false, updateInventory = false, hidePreview = false } = {}) {
		const overlay = document.getElementById('drag-overlay');
		endPointerDragTracking();
		desktopHoverDragActive = false;
		suppressDesktopDropUntil = 0;
		if (draggedBlock) {
			draggedBlock.remove();
		}
		draggedBlock = null;
		draggedShape = null;
		draggedColor = null;
		lastZone = null;
		lastBaseX = lastBaseY = null;
		if (overlay) overlay.style.display = 'none';
		document.body.classList.remove('dragging');
		document.body.style.cursor = '';
		document.documentElement.style.cursor = '';
		
		// Verberg control buttons altijd als drag/selection wordt opgeruimd.
		removeCardControlButtons();
		
	// Verwijder kaart selectie
	if (selectedCardElement) {
		selectedCardElement.classList.remove('selected');
		selectedCardElement = null;
	}
	selectedCardId = null;
	selectedShape = null;
	selectedColor = null;
	
	// Reset card locks zodat andere kaarten weer klikbaar zijn
	applyTurnCardLocks();
	
	// Verberg zoom-lens altijd
	hideZoomLens();
	
	// Verberg floating preview alleen als expliciet gevraagd
		if (hidePreview) {
			hideFloatingPreview();
		}
		
		if (clearBonus && activeBonusPlacement) {
			// Geef gekochte plaatsing munten terug bij annuleren
			if (updateInventory && activeBonusPlacement.colorKey === 'purchased') {
				addCoin();
				addCoin();
				clearPurchasedPlacement();
			}
			activeBonusPlacement = null;
			markActiveBonusButton(null);
			if (updateInventory) updateBonusInventoryUI();
		}
		skipNextZoneClick = true;
		setTimeout(() => { skipNextZoneClick = false; }, 80);
		stopGlobalDragVisuals();
		if (!selectedCardElement && !activeBonusPlacement && rotateButton) {
		  rotateButton.disabled = true;
		}
	}

	function cancelActiveBonusPlacement(options = {}) {
		const { updateInventory = true, hidePreview = false } = options;
		if (!activeBonusPlacement && !draggedBlock) return;
		cleanupDragState({ clearBonus: true, updateInventory, hidePreview });
	}
	

	// ========================
	// HELPER FUNCTIES
	// ========================

	function getOptionalCells(shape) {
	  const coords = [];
	  if (!shape || !shape.length) return coords;
	  for (let y = 0; y < shape.length; y++) {
		const row = shape[y];
		for (let x = 0; x < row.length; x++) {
		  if (row[x] === 2) {
			coords.push({ x, y });
		  }
		}
	  }
	  return coords;
	}

	function isOptionalShapeCell(value) {
	  return value === 2;
	}

	function isSolidShapeCell(value) {
	  return value === 1;
	}

	function getSolidShapeBounds(shape) {
	  let minX = Infinity;
	  let maxX = -Infinity;
	  let minY = Infinity;
	  let maxY = -Infinity;
	  if (!Array.isArray(shape) || !shape.length) {
		return { minX: 0, maxX: -1, minY: 0, maxY: -1, width: 0, height: 0 };
	  }
	  for (let y = 0; y < shape.length; y++) {
		const row = shape[y];
		if (!Array.isArray(row)) continue;
		for (let x = 0; x < row.length; x++) {
		  if (!isSolidShapeCell(row[x])) continue;
		  if (x < minX) minX = x;
		  if (x > maxX) maxX = x;
		  if (y < minY) minY = y;
		  if (y > maxY) maxY = y;
		}
	  }
	  if (!Number.isFinite(minX) || !Number.isFinite(minY)) {
		return { minX: 0, maxX: -1, minY: 0, maxY: -1, width: 0, height: 0 };
	  }
	  return {
		minX,
		maxX,
		minY,
		maxY,
		width: (maxX - minX + 1),
		height: (maxY - minY + 1)
	  };
	}

	function hasOptionalCells(shape) {
	  return getOptionalCells(shape).length > 0;
	}

	function trimOptionalCells(shape) {
	  if (!shape || !shape.length) return shape;
	  const optionalCells = getOptionalCells(shape);
	  if (!optionalCells.length) return shape;
	  const trimmed = shape.map(row => row.slice());
	  optionalCells.forEach(({ x, y }) => {
		if (trimmed[y] && typeof trimmed[y][x] === 'number') {
		  trimmed[y][x] = 0;
		}
	  });
	  // Verwijder lege rijen
	  let filtered = trimmed.filter(row => row.some(value => value !== 0));
	  if (!filtered.length) {
		return trimmed;
	  }
	  const colCount = filtered[0].length;
	  const activeCols = [];
	  for (let col = 0; col < colCount; col++) {
		if (filtered.some(row => row[col] !== 0)) {
		  activeCols.push(col);
		}
	  }
	  if (!activeCols.length) {
		return trimmed;
	  }
	  filtered = filtered.map(row => activeCols.map(index => row[index] || 0));
	  return filtered;
	}

	function rotateShape(shape) {
	  const rows = shape.length;
	  const cols = shape[0].length;
	  return Array.from({ length: cols }, (_, x) =>
		Array.from({ length: rows }, (_, y) => shape[rows - 1 - y][x])
	  );
	}

	function mirrorShape(shape) {
	  // Spiegel het blok horizontaal (flip left-right)
	  return shape.map(row => [...row].reverse());
	}

	function cloneShape(shape) {
	  return shape.map(row => row.slice());
	}

	function updateCardPattern(card, shape, color) {
	  if (!card || !shape || !shape.length) return;
	  color = color || {};
	  const cssCellSizeRaw = (card.style && card.style.getPropertyValue('--preview-cell')) || '';
	  const computedCellSizeRaw = !cssCellSizeRaw ? (getComputedStyle(card).getPropertyValue('--preview-cell') || '') : '';
	  const overrideCellSize = parseFloat((cssCellSizeRaw || computedCellSizeRaw || '').trim());
	  // On mobile, cards inside #bottom-bar must NOT fall back to board cell size;
	  // they use only their CSS --preview-cell value.
	  const isMobileBottomBar = (window.innerWidth <= (typeof MOBILE_BREAKPOINT !== 'undefined' ? MOBILE_BREAKPOINT : 650)) && card.closest && card.closest('#bottom-bar');
	  const { cellSize: defaultCellSize } = isMobileBottomBar ? { cellSize: 10 } : getCardSizing();
	  const cellSize = Number.isFinite(overrideCellSize) && overrideCellSize > 0 ? overrideCellSize : defaultCellSize;

	  // Normalize ragged shapes so previews keep all columns.
	  const cols = Math.max(...shape.map(row => (Array.isArray(row) ? row.length : 0)), 0);
	  const rows = shape.length;
	  const paddedShape = shape.map(row => {
		const copy = Array.isArray(row) ? row.slice() : [];
		while (copy.length < cols) copy.push(0);
		return copy;
	  });

	  card.dataset.shapeCols = String(cols);
	  card.dataset.shapeRows = String(rows);
	  const pattern = card.querySelector('.card-pattern');
	  if (pattern) {
		pattern.innerHTML = '';
		pattern.style.gridTemplateColumns = `repeat(${cols}, ${cellSize}px)`;
		pattern.style.gridTemplateRows = `repeat(${rows}, ${cellSize}px)`;
		// Gap is controlled via CSS (`--preview-gap`) so all previews stay consistent.
		pattern.style.removeProperty('gap');
		paddedShape.forEach(row => {
		  row.forEach(cell => {
			const div = document.createElement('div');
			div.classList.add('card-cell');
			div.style.width = `${cellSize}px`;
			div.style.height = `${cellSize}px`;
			// Keep the same rounding style as board cells
			div.style.borderRadius = `${Math.max(2, Math.min(6, cellSize / 6))}px`;
			if (cell) {
			  let background;
			  let shadow;
			  if (color.code === 'rainbow') {
				background = 'linear-gradient(45deg, #f06272, #fff25a, #4ed346, #5d90f0, #a35eff)';
				shadow = '0 2px 4px rgba(0,0,0,0.25), inset 0 1px 0 rgba(255,255,255,0.3)';
			  } else {
				// Golden is a card modifier; do not paint blocks gold.
				background = (color.code || '#a0a0a0');
				const isGradient = typeof background === 'string' && background.includes('gradient');
				shadow = '0 2px 4px rgba(0,0,0,0.2), inset 0 1px 0 rgba(255,255,255,0.25)';
			  }
			  div.style.background = background;
			  div.style.boxShadow = shadow;
			  div.style.border = '1px solid rgba(0,0,0,0.15)';
			} else {
			  // Empty cell - make completely invisible
			  div.style.background = 'transparent';
			  div.style.boxShadow = 'none';
			  div.style.border = 'none';
			  div.style.visibility = 'hidden';
			}
			pattern.appendChild(div);
		  });
		});
	  }
	const meta = card.querySelector('.card-meta');
	if (meta && !meta.classList.contains('card-meta--echo')) {
		meta.textContent = '';
		meta.classList.add('card-meta--empty');
	}
	  card.cardShape = paddedShape;
	}

	function getActualCellSize(root = null) {
		// Bereken de werkelijke cel-grootte op basis van een cel in het opgegeven root
		// (of het globale speelveld als geen root gegeven). Dit houdt rekening met
		// board/zone scaling and any DOM lifts performed during mobile zoom.
		
		// Performance: use cached value if available and window size hasn't changed
		if (_layoutCache.cellSize !== null && 
			_layoutCache.windowWidth === window.innerWidth && 
			_layoutCache.windowHeight === window.innerHeight &&
			root === null) {
			return _layoutCache.cellSize;
		}
		
		try {
			// Mobile behaviour: always prefer the unscaled CSS cell size (the
			// "zoomed-in" visual size) for mobile layouts so previews match the
			// zoomed experience even before the zone is opened.
			if (window && typeof window.innerWidth === 'number' && window.innerWidth <= (typeof MOBILE_BREAKPOINT !== 'undefined' ? MOBILE_BREAKPOINT : 650)) {
				const cssSize = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--cell-size')) || 26;
				if (root === null) _layoutCache.cellSize = cssSize;
				return cssSize;
			}

			let sampleCell = null;
			if (root instanceof Element) {
				sampleCell = root.querySelector('.grid .cell:not(.void-cell)');
			} else if (typeof root === 'string') {
				sampleCell = document.querySelector(root + ' .grid .cell:not(.void-cell)');
			} else {
				sampleCell = document.querySelector('#board .grid .cell:not(.void-cell)');
			}

			if (sampleCell) {
				const rect = sampleCell.getBoundingClientRect();
				const size = Math.min(rect.width, rect.height);
				if (root === null) {
					_layoutCache.cellSize = size;
					_layoutCache.windowWidth = window.innerWidth;
					_layoutCache.windowHeight = window.innerHeight;
				}
				return size;
			}
		} catch (e) {
			// ignore and fallback
		}
		const cssSize = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--cell-size')) || 26;
		if (root === null) _layoutCache.cellSize = cssSize;
		return cssSize;
	}

	function renderBlock(block, shape, color, useActualCellSize = true) {
	block.innerHTML = '';
	block.style.display = 'grid';
	// Ensure floating/draggable previews remain visible on top when rotated
	try {
		const isFloatingPreview = (block.id === 'floating-preview' || block.id === 'purchased-block-preview' || (block.classList && (block.classList.contains('draggable') || block.classList.contains('bonus-draggable'))));
		if (isFloatingPreview) {
			if (!block.style.position) block.style.position = 'fixed';
			block.style.zIndex = block.style.zIndex || '10000';
			const overlay = document.getElementById('drag-overlay') || document.body;
			if (overlay && !overlay.contains(block)) overlay.appendChild(block);
		}
	} catch (e) {}

	const isPreviewBlock = (block.id === 'floating-preview' || block.id === 'purchased-block-preview' || (block.classList && (block.classList.contains('draggable') || block.classList.contains('bonus-draggable'))));
	let previewGapPx = 0;
	if (isPreviewBlock) {
		try {
			previewGapPx = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--board-grid-gap')) || 0;
		} catch (e) {
			previewGapPx = 0;
		}
	}

	  
	  // Bepaal de cel-grootte: gebruik de werkelijke speelveld cel-grootte als niet ingezoomd
	  const isZoomed = document.body.classList.contains('zoomed-in');
	  let cellSize;
	  let cellSizeStr;
	  
	if (useActualCellSize) {
		// If a zoomed zone is active, measure cell size from that zone so
		// the draggable matches the zoomed-in cells exactly. Otherwise
		// measure from the default board.
		const measuredRoot = (document.body.classList.contains('zoomed-in') && typeof activeZoomZone !== 'undefined' && activeZoomZone) ? activeZoomZone : null;
		cellSize = getActualCellSize(measuredRoot);
		cellSizeStr = `${cellSize}px`;
	} else {
		// Fallback: use CSS variable when explicit actual sizing is not requested.
		cellSize = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--cell-size')) || 26;
		cellSizeStr = 'var(--cell-size)';
	}
	  
	  // Border-radius matches board cells (less round on small screens)
	  const borderRadius = `${Math.max(2, Math.min(6, cellSize / 6))}px`;
	  
	  block.style.gridTemplateColumns = `repeat(${shape[0].length}, ${cellSizeStr})`;
	  block.style.gridTemplateRows = `repeat(${shape.length}, ${cellSizeStr})`;
	  // Keep spacing consistent with the board grid.
	  if (isPreviewBlock && dragGapMode === 'gapless') {
		block.style.gap = '0px';
	  } else {
		block.style.gap = 'var(--board-grid-gap)';
	  }
	  block.style.opacity = '0.8';
	  const optionalSet = new Set(getOptionalCells(shape).map(({ x, y }) => `${x},${y}`));
	  
	  shape.forEach((row, rowIdx) => {
		row.forEach((cell, colIdx) => {
			const div = document.createElement('div');
			div.style.width = cellSizeStr;
			div.style.height = cellSizeStr;
			div.style.margin = '0px';
			// Border-radius consistent met speelveld
			div.style.borderRadius = borderRadius;
			div.style.boxSizing = 'border-box';
			if (isPreviewBlock) {
				div.classList.add('preview-cell-wrap');
				const pad = (dragGapMode === 'gapless') ? (previewGapPx / 2) : 0;
				div.style.padding = `${pad}px`;
			}
			const key = `${colIdx},${rowIdx}`;
			const isOptional = optionalSet.has(key);
			if (cell && !isOptional) {
			  let background;
			  let shadow;
			  if (color.code === 'rainbow') {
				background = 'linear-gradient(45deg, #f06272, #fff25a, #4ed346, #5d90f0, #a35eff)';
				shadow = '0 0 6px rgba(0,0,0,0.3)';
			  } else {
				// Golden is a card modifier; do not paint blocks gold.
				background = (color.code || '#a0a0a0');
				const isGradient = typeof background === 'string' && background.includes('gradient');
				shadow = isGradient ? '0 0 4px rgba(90,80,160,0.4)' : `0 0 4px ${background}`;
			  }
			  if (isPreviewBlock) {
				const inner = document.createElement('div');
				inner.style.width = '100%';
				inner.style.height = '100%';
				inner.style.borderRadius = borderRadius;
				inner.style.background = background;
				inner.style.boxShadow = shadow;
				div.appendChild(inner);
			  } else {
				div.style.background = background;
				div.style.boxShadow = shadow;
			  }
			} else if (isOptional) {
			  let background;
			  if (color.code === 'rainbow') {
				background = 'linear-gradient(45deg, #f06272, #fff25a, #4ed346, #5d90f0, #a35eff)';
			  } else {
				background = color.code || '#a0a0a0';
			  }
			  if (isPreviewBlock) {
				const inner = document.createElement('div');
				inner.style.width = '100%';
				inner.style.height = '100%';
				inner.style.borderRadius = borderRadius;
				inner.style.background = background;
				inner.style.opacity = '0.6';
				inner.style.border = '2px dashed rgba(255,255,255,0.85)';
				inner.style.boxShadow = 'none';
				div.appendChild(inner);
			  } else {
				div.style.background = background;
				div.style.opacity = '0.6';
				div.style.border = '2px dashed rgba(255,255,255,0.85)';
				div.style.boxShadow = 'none';
			  }
			} else {
			  div.style.visibility = 'hidden';
			}
			block.appendChild(div);
		});
	  });
	  if (isPreviewBlock) {
		updatePreviewGapStyles(block);
	  }
	}

	function hexToRGBA(hex, alpha = 1) {
	  if (!hex) return `rgba(0,0,0,${alpha})`;
	  let c = hex.replace('#','');
	  if (c.length === 3) c = c.split('').map(ch => ch+ch).join('');
	  const r = parseInt(c.substr(0,2),16);
	  const g = parseInt(c.substr(2,2),16);
	  const b = parseInt(c.substr(4,2),16);
	  return `rgba(${r},${g},${b},${alpha})`;
	}

	function clearPreview(zone) {
	  zone.querySelectorAll('.cell.preview-allowed, .cell.preview-denied').forEach(c=>{
		c.classList.remove('preview-allowed','preview-denied');
		if (!c.classList.contains('active')) c.style.background = '';
	  });
	}

	function getZoneMetrics(zone) {
	  const empty = {
		cols: 0,
		rows: 0,
		minX: 0,
		maxX: -1,
		minY: 0,
		maxY: -1
	  };
	  if (!zone) return empty;
	  const cacheVersion = getGridVersion();
	  if (zone._metricsCache && zone._metricsVersion === cacheVersion) return zone._metricsCache;
	  const cells = zone.querySelectorAll('.cell');
	  if (!cells.length) return empty;
	  let minX = Infinity;
	  let maxX = -Infinity;
	  let minY = Infinity;
	  let maxY = -Infinity;
	  cells.forEach(cell => {
		if (cell.classList.contains('void-cell') || cell.dataset.disabled === 'true') return;
		const col = Number(cell.dataset.x);
		const row = Number(cell.dataset.y);
		if (!Number.isNaN(col)) {
		  if (col < minX) minX = col;
		  if (col > maxX) maxX = col;
		}
		if (!Number.isNaN(row)) {
		  if (row < minY) minY = row;
		  if (row > maxY) maxY = row;
		}
	  });
	  if (!Number.isFinite(minX) || !Number.isFinite(maxX)) return empty;
	  if (!Number.isFinite(minY) || !Number.isFinite(maxY)) return empty;
	  const metrics = {
		cols: maxX - minX + 1,
		rows: maxY - minY + 1,
		minX,
		maxX,
		minY,
		maxY
	  };
	  zone._metricsCache = metrics;
	  zone._metricsVersion = cacheVersion;
	  return metrics;
	}

	function getZonePriority(zone) {
	  if (!zone || zone.classList.contains('zone-placeholder')) return -Infinity;
	  if (zone.classList.contains('zoom-focus')) return 1000;
	  const style = window.getComputedStyle(zone);
	  const zIndex = parseInt(style.zIndex, 10);
	  return Number.isFinite(zIndex) ? zIndex : 0;
	}


	// Helper om de juiste cell in een zone te pakken
	function getCell(zone, x, y) {
	  if (!zone) return null;
	  try {
		const cacheVersion = getGridVersion();
		if (!zone._cellMap || zone._cellMapVersion !== cacheVersion) {
			const map = new Map();
			const cells = zone.querySelectorAll('.cell');
			cells.forEach(cell => {
				if (cell.classList.contains('void-cell') || cell.dataset.disabled === 'true') return;
				const cx = cell.dataset.x;
				const cy = cell.dataset.y;
				if (cx === undefined || cy === undefined) return;
				map.set(`${cx},${cy}`, cell);
			});
			zone._cellMap = map;
			zone._cellMapVersion = cacheVersion;
		}
		const cached = zone._cellMap && zone._cellMap.get(`${x},${y}`);
		if (cached) return cached;
	  } catch (e) {}
	  const cell = zone.querySelector(`.cell[data-x="${x}"][data-y="${y}"]`);
	  if (!cell) return null;
	  if (cell.classList.contains('void-cell') || cell.dataset.disabled === 'true') return null;
	  return cell;
	}

	// --- Editor defaults / helpers (added to reduce duplicated checks) ---
	const ZONE_WIDTH = 320;      // px â€” default zone width
	const ZONE_HEIGHT = 200;     // px â€” default zone height
	const ZONE_GAP = 8;          // px â€” default gap
	const RESIZER_SIZE = 8;      // px â€” resizer handle size
	const HOVER_OFFSET_X = 0;    // px â€” hover X offset (user requested 0)
	const HOVER_OFFSET_Y = 0;    // px â€” hover Y offset (user requested 0)
	const Z_INDEX_HOVER = 9999;  // z-index for hovered blocks

	function isAbsolutePositionedGrid(el) {
		if (!el) return false;
		try {
			const grid = el.closest ? el.closest('.grid') : null;
			const zone = el.closest ? el.closest('.zone') : null;

			const isGreenGrid = (grid && grid.id === 'green-grid') || (zone && zone.dataset && String(zone.dataset.color || '').toLowerCase() === 'groen');
			const isRedGrid = (zone && zone.id && zone.id.startsWith('red-grid')) ||
															(zone && zone.dataset && String(zone.dataset.color || '').toLowerCase() === 'rood') ||
															(zone && zone.classList && zone.classList.contains('red-group')) ||
															(grid && grid.id && String(grid.id || '').startsWith('red-grid'));

			// If any element has an explicit inline position absolute/fixed/sticky, treat as absolute-positioned grid
			if (el.style && el.style.position) {
				const p = String(el.style.position || '').toLowerCase();
				if (p === 'absolute' || p === 'fixed' || p === 'sticky') return true;
			}
			if (grid && grid.style && grid.style.position) {
				const p = String(grid.style.position || '').toLowerCase();
				if (p === 'absolute' || p === 'fixed' || p === 'sticky') return true;
			}
			if (zone && zone.style && zone.style.position) {
				const p = String(zone.style.position || '').toLowerCase();
				if (p === 'absolute' || p === 'fixed' || p === 'sticky') return true;
			}

			// Fallback to computed style check (safer for styles coming from CSS rules)
			const target = grid || zone || el;
			if (window.getComputedStyle && target) {
				const computed = window.getComputedStyle(target);
				const pos = computed && computed.position ? String(computed.position || '').toLowerCase() : '';
				if (pos === 'absolute' || pos === 'fixed' || pos === 'sticky') return true;
			}



			return isGreenGrid || isRedGrid;
		} catch (e) {
			return false;
		}
	}

	function resetDragBlockGap() {
		dragGapMode = 'default';
		if (draggedBlock) {
			draggedBlock.style.gap = 'var(--board-grid-gap)';
		}
	}

	function updatePreviewGapStyles(block) {
		if (!block) return;
		const isPreviewBlock = (block.id === 'floating-preview' || block.id === 'purchased-block-preview' || (block.classList && (block.classList.contains('draggable') || block.classList.contains('bonus-draggable'))));
		if (!isPreviewBlock) return;
		let gapPx = 0;
		try {
			gapPx = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--board-grid-gap')) || 0;
		} catch (e) {
			gapPx = 0;
		}
		if (dragGapMode === 'gapless') {
			block.style.gap = '0px';
		} else {
			block.style.gap = 'var(--board-grid-gap)';
		}
		const pad = (dragGapMode === 'gapless') ? (gapPx / 2) : 0;
		const padStr = `${pad}px`;
		block.querySelectorAll('.preview-cell-wrap').forEach(cell => {
			cell.style.padding = padStr;
		});
	}

	function applyDragBlockGap(zoneCandidate) {
		if (!draggedBlock) return false;
		const zoneEl = zoneCandidate && zoneCandidate.classList && zoneCandidate.classList.contains('zone')
			? zoneCandidate
			: (zoneCandidate && typeof zoneCandidate.closest === 'function' ? zoneCandidate.closest('.zone') : null);
		const isPlaceholder = zoneEl && zoneEl.classList && zoneEl.classList.contains('zone-placeholder');
		const shouldBeGapless = !!zoneEl && !isPlaceholder && isAbsolutePositionedGrid(zoneEl);
		if (shouldBeGapless && dragGapMode !== 'gapless') {
			draggedBlock.style.gap = '0px';
			dragGapMode = 'gapless';
			updatePreviewGapStyles(draggedBlock);
			return true;
		} else if (!shouldBeGapless && dragGapMode !== 'default') {
			draggedBlock.style.gap = 'var(--board-grid-gap)';
			dragGapMode = 'default';
			updatePreviewGapStyles(draggedBlock);
			return true;
		}
		return false;
	}

		// Inject small helper CSS for class-based toggles (avoid inline styles for grid chrome)
		(function(){
			try {
				const css = '\n.grid--resizing{pointer-events:none;opacity:0.95;}\n.grid--hovered{transform:translate(var(--hover-x,0px),var(--hover-y,0px));z-index:' + Z_INDEX_HOVER + ';}\n.use-transform-pos{will-change:transform;transform:translate3d(var(--dx,0px),var(--dy,0px),0);}\n';
				const s = document.createElement('style');
				s.setAttribute('data-generated','locus-grid-helpers');
				s.textContent = css;
				document.head && document.head.appendChild(s);
			} catch (e) {}
		})();

// Helper to set element position using CSS variables + transform class
function setElPos(el, x, y) {
	if (!el) return;
	try {
		const xs = (typeof x === 'number') ? (x + 'px') : String(x || '0px');
		const ys = (typeof y === 'number') ? (y + 'px') : String(y || '0px');
		// Remove legacy left/top to avoid conflicts
		try { el.style.removeProperty('left'); } catch (e) {}
		try { el.style.removeProperty('top'); } catch (e) {}
		el.style.setProperty('--dx', xs);
		el.style.setProperty('--dy', ys);
		el.classList.add('use-transform-pos');
	} catch (e) {}
}

function clearElPos(el) {
	if (!el) return;
	try {
		el.classList.remove('use-transform-pos');
		el.style.removeProperty('--dx');
		el.style.removeProperty('--dy');
	} catch (e) {}
}

	function collectPlacementCells(zone, baseX, baseY, shape) {
	  if (!zone || !Array.isArray(shape) || !shape.length) return null;
	  const pending = [];
		const optionalCells = []; // Track optionele cellen voor adjacency check
	  window.lastPlacementFailure = null;
	  
	  // Gebruik gewoon de normale coÃ¶rdinaten-gebaseerde aanpak
	  // Nu werkt dit ook voor root-based grids omdat alle cellen bestaan!
	  for (let y = 0; y < shape.length; y++) {
		for (let x = 0; x < shape[y].length; x++) {
		  const cellVal = shape[y][x];
		  if (!cellVal) continue; // Skip lege posities in de shape
		  const isOptional = isOptionalShapeCell(cellVal);
		  const target = getCell(zone, baseX + x, baseY + y);
		  
		  if (!target) {
					if (isOptional) {
						// Optionele cel valt buiten bereik: negeer bij validatie.
						continue;
					}
			window.lastPlacementFailure = {
			  zoneId: zone?.id || null,
			  reason: 'missing-cell',
			  x: baseX + x,
			  y: baseY + y
			};
			return null;
		  }

			// World 4 (and scenarios): door-gated regions are unreachable until the door is opened.
			try {
				const worldInfo = (typeof getWorldAndSubLevel === 'function') ? getWorldAndSubLevel(currentLevel) : null;
				const isWorld4 = !!(worldInfo && Number(worldInfo.world) === 4);
				const isScenario = !!(window && window._locusScenarioMode);
				const allowKeyDoorLogic = isWorld4 || isScenario;
				if (allowKeyDoorLogic) {
					// Door cell itself: requires the key for its color (unless already open)
					if (target.dataset.doorId && target.dataset.doorColor && !target.classList.contains('door-open')) {
						const doorColor = String(target.dataset.doorColor || '').toLowerCase();
						if (doorColor && !isWorld4ColorUnlocked(doorColor)) {
							if (isOptional) continue;
							window.lastPlacementFailure = { zoneId: zone?.id || null, reason: 'door-needs-key', x: baseX + x, y: baseY + y, color: doorColor };
							return null;
						}
					}
					// Cells behind a door: require the door to be opened (key alone is not enough)
					if (target.dataset.lockedDoorId) {
						const doorId = String(target.dataset.lockedDoorId || '');
						if (doorId && !isWorld4DoorOpen(doorId)) {
							if (isOptional) continue;
							window.lastPlacementFailure = { zoneId: zone?.id || null, reason: 'behind-door', x: baseX + x, y: baseY + y, doorId };
							return null;
						}
					}
				}
			} catch (e) {}
				if (target.classList.contains('active')) {
					if (isOptional) {
						// Optionele cel mag overlappen met een bestaand blok; wel onthouden voor adjacency.
						optionalCells.push(target);
						continue;
					}
					window.lastPlacementFailure = {
						zoneId: zone?.id || null,
						reason: 'occupied',
						x: baseX + x,
						y: baseY + y
					};
					return null;
				}

				if (isOptional) {
					// Optionele cellen tellen niet mee voor validatie, maar wel voor adjacency.
					optionalCells.push(target);
					continue;
				}

				pending.push(target);
		}
	  }
	  
	  // Voeg optionele cellen toe aan pending voor adjacency validatie
	  // maar markeer ze zodat ze niet verplicht aangrenzend hoeven te zijn
		pending.optionalCells = optionalCells.filter(Boolean);
		pending.hasOptionalCells = pending.optionalCells.length > 0;
	  
	  return pending;
	}
	
	// Speciaal voor root-based grids: zoek cellen op fysieke positie op het scherm
	function collectPlacementCellsForRootGrid(zone, baseX, baseY, shape) {
	  
	  // Vind de eerste gevulde cel in de shape (anchor point)
	  let anchorShapeX = -1, anchorShapeY = -1;
	  for (let y = 0; y < shape.length && anchorShapeY === -1; y++) {
		for (let x = 0; x < shape[y].length; x++) {
		  if (shape[y][x]) {
			anchorShapeX = x;
			anchorShapeY = y;
			break;
		  }
		}
	  }
	  
	  // Probeer de anchor cell te vinden via coÃ¶rdinaten
	  const anchorX = baseX + anchorShapeX;
	  const anchorY = baseY + anchorShapeY;
	  const anchorCell = getCell(zone, anchorX, anchorY);
	  
	  if (!anchorCell || anchorCell.classList.contains('active')) return null;
	  
	  // Get de fysieke positie van de anchor cell
	  const anchorRect = anchorCell.getBoundingClientRect();
	  const cellSize = anchorRect.width;
	  
	  // Get alle beschikbare cellen in deze zone
	  const allCells = Array.from(zone.querySelectorAll('.cell:not(.void-cell)'))
		.filter(c => !c.classList.contains('active') && c.dataset.disabled !== 'true');
	  
	  // Bouw een map: fysieke positie (in grid units) -> cel
	  const positionMap = new Map();
	  for (const cell of allCells) {
		const rect = cell.getBoundingClientRect();
		// Bereken grid positie relatief tot anchor (in hele cellen)
		const gridX = Math.round((rect.left - anchorRect.left) / cellSize);
		const gridY = Math.round((rect.top - anchorRect.top) / cellSize);
		const key = `${gridX},${gridY}`;
		positionMap.set(key, cell);
	  }
	  
	  // Nu loop door de shape en zoek elke cel op basis van FYSIEKE positie
	  const result = [];
	  for (let shapeY = 0; shapeY < shape.length; shapeY++) {
		for (let shapeX = 0; shapeX < shape[shapeY].length; shapeX++) {
		  if (!shape[shapeY][shapeX]) continue; // Skip lege posities
		  
		  // Bereken relatieve positie t.o.v. anchor
		  const relX = shapeX - anchorShapeX;
		  const relY = shapeY - anchorShapeY;
		  const key = `${relX},${relY}`;
		  
		  const cell = positionMap.get(key);
		  if (!cell) return null;
		  
		  result.push(cell);
		}
	  }
	  
	  return result;
	}
	
	// Bouw een grafiek van welke cellen fysiek aan elkaar grenzen
	function buildCellAdjacencyGraph(cells) {
	  const graph = new Map();
	  
	  for (const cell of cells) {
		const rect = cell.getBoundingClientRect();
		const centerX = rect.left + rect.width / 2;
		const centerY = rect.top + rect.height / 2;
		const cellSize = rect.width;
		
		const neighbors = [];
		
		for (const other of cells) {
		  if (cell === other) continue;
		  
		  const otherRect = other.getBoundingClientRect();
		  const otherCenterX = otherRect.left + otherRect.width / 2;
		  const otherCenterY = otherRect.top + otherRect.height / 2;
		  
		  const dx = Math.abs(centerX - otherCenterX);
		  const dy = Math.abs(centerY - otherCenterY);
		  
		  // Check of ze horizontaal of verticaal naast elkaar liggen
		  const isHorizontal = dx > cellSize * 0.8 && dx < cellSize * 1.2 && dy < cellSize * 0.3;
		  const isVertical = dy > cellSize * 0.8 && dy < cellSize * 1.2 && dx < cellSize * 0.3;
		  
		  if (isHorizontal || isVertical) {
			// Bepaal richting
			let direction = null;
			if (isHorizontal) {
			  direction = otherCenterX > centerX ? 'right' : 'left';
			} else {
			  direction = otherCenterY > centerY ? 'down' : 'up';
			}
			
			neighbors.push({ cell: other, direction });
		  }
		}
		
		graph.set(cell, neighbors);
	  }
	  
	  return graph;
	}
	
	// Vind cellen die de shape vorm volgen vanaf de anchor
	function findShapeCellsInGraph(anchorCell, shape, anchorShapeX, anchorShapeY, graph, allCells) {
	  const result = [];
	  const cellToShapePos = new Map();
	  
	  // Start met de anchor
	  cellToShapePos.set(anchorCell, { x: anchorShapeX, y: anchorShapeY });
	  result.push(anchorCell);
	  
	  // BFS om andere cellen te vinden
	  const queue = [anchorCell];
	  const visited = new Set([anchorCell]);
	  
	  while (queue.length > 0) {
		const current = queue.shift();
		const currentPos = cellToShapePos.get(current);
		
		const neighbors = graph.get(current) || [];
		
		for (const { cell: neighbor, direction } of neighbors) {
		  if (visited.has(neighbor)) continue;
		  
		  // Bereken waar deze neighbor zou zijn in de shape
		  let neighborShapeX = currentPos.x;
		  let neighborShapeY = currentPos.y;
		  
		  if (direction === 'right') neighborShapeX++;
		  else if (direction === 'left') neighborShapeX--;
		  else if (direction === 'down') neighborShapeY++;
		  else if (direction === 'up') neighborShapeY--;
		  
		  // Check of deze positie in de shape bestaat en gevuld is
		  if (neighborShapeY >= 0 && neighborShapeY < shape.length &&
			  neighborShapeX >= 0 && neighborShapeX < shape[neighborShapeY].length &&
			  shape[neighborShapeY][neighborShapeX]) {
			
			visited.add(neighbor);
			cellToShapePos.set(neighbor, { x: neighborShapeX, y: neighborShapeY });
			result.push(neighbor);
			queue.push(neighbor);
		  }
		}
	  }
	  
	  return result;
	}
	
	// Tel hoeveel cellen gevuld zijn in een shape
	function countFilledCells(shape) {
	  let count = 0;
	  for (let y = 0; y < shape.length; y++) {
		for (let x = 0; x < shape[y].length; x++) {
		  if (shape[y][x]) count++;
		}
	  }
	  return count;
	}
	
	// Check of cellen fysiek aangrenzend zijn volgens de shape structuur
	function areCellsPhysicallyConnected(cells, shape) {
	  if (cells.length <= 1) return true;
	  
	  // Bouw een map van x,y naar cel
	  const cellMap = new Map();
	  for (const cell of cells) {
		const x = parseInt(cell.dataset.x);
		const y = parseInt(cell.dataset.y);
		cellMap.set(`${x},${y}`, cell);
	  }
	  
	  // Start BFS vanaf de eerste cel
	  const visited = new Set();
	  const queue = [cells[0]];
	  visited.add(cells[0]);
	  
	  while (queue.length > 0) {
		const current = queue.shift();
		const cx = parseInt(current.dataset.x);
		const cy = parseInt(current.dataset.y);
		
		// Check alle 4 aangrenzende posities
		const neighbors = [
		  [cx - 1, cy],
		  [cx + 1, cy],
		  [cx, cy - 1],
		  [cx, cy + 1]
		];
		
		for (const [nx, ny] of neighbors) {
		  const key = `${nx},${ny}`;
		  const neighborCell = cellMap.get(key);
		  
		  if (neighborCell && !visited.has(neighborCell)) {
			// Check of deze neighbor ook aangrenzend is volgens de shape
			// (niet alleen in de grid, maar ook in de verwachte vorm)
			if (areCellsVisuallyAdjacent(current, neighborCell)) {
			  visited.add(neighborCell);
			  queue.push(neighborCell);
			}
		  }
		}
	  }
	  
	  return visited.size === cells.length;
	}
	
	// Check of twee cellen visueel aangrenzend zijn (binnen ~1 celgrootte afstand)
	function areCellsVisuallyAdjacent(cell1, cell2) {
	  const rect1 = cell1.getBoundingClientRect();
	  const rect2 = cell2.getBoundingClientRect();
	  
	  const center1X = rect1.left + rect1.width / 2;
	  const center1Y = rect1.top + rect1.height / 2;
	  const center2X = rect2.left + rect2.width / 2;
	  const center2Y = rect2.top + rect2.height / 2;
	  
	  const dx = Math.abs(center1X - center2X);
	  const dy = Math.abs(center1Y - center2Y);
	  
	  const cellSize = rect1.width; // Aanname: vierkante cellen
	  
	  // Cellen zijn aangrenzend als ze horizontaal OF verticaal naast elkaar liggen
	  // Tolerantie van 1.5x celgrootte voor kleine positioneringsverschillen
	  const isHorizontallyAdjacent = dx <= cellSize * 1.5 && dy <= cellSize * 0.5;
	  const isVerticallyAdjacent = dy <= cellSize * 1.5 && dx <= cellSize * 0.5;
	  
	  return isHorizontallyAdjacent || isVerticallyAdjacent;
	}
	
	// Check of alle cellen in een lijst met elkaar verbonden zijn (aangrenzend)
	function areCellsConnected(cells) {
	  if (cells.length <= 1) return true;
	  
	  const visited = new Set();
	  const queue = [cells[0]];
	  visited.add(cells[0]);
	  
	  while (queue.length > 0) {
		const current = queue.shift();
		const cx = parseInt(current.dataset.x);
		const cy = parseInt(current.dataset.y);
		
		// Check alle cellen in de lijst of ze aangrenzend zijn aan current
		for (const cell of cells) {
		  if (visited.has(cell)) continue;
		  
		  const x = parseInt(cell.dataset.x);
		  const y = parseInt(cell.dataset.y);
		  
		  // Check of deze cel aangrenzend is (Manhattan distance = 1)
		  if (Math.abs(x - cx) + Math.abs(y - cy) === 1) {
			visited.add(cell);
			queue.push(cell);
		  }
		}
	  }
	  
	  // Als alle cellen bezocht zijn, zijn ze verbonden
	  return visited.size === cells.length;
	}

	function cellsAreAdjacent(cellA, cellB) {
	  if (!cellA || !cellB) return false;
	  const ax = Number(cellA.dataset.x);
	  const ay = Number(cellA.dataset.y);
	  const bx = Number(cellB.dataset.x);
	  const by = Number(cellB.dataset.y);
	  if (!Number.isFinite(ax) || !Number.isFinite(ay) || !Number.isFinite(bx) || !Number.isFinite(by)) return false;
	  return Math.abs(ax - bx) + Math.abs(ay - by) === 1;
	}

	// ========================
	// CAN PLACE
	// ========================
	function canPlace(zone, baseX, baseY, shape) {
	  const pendingCells = collectPlacementCells(zone, baseX, baseY, shape);
	  // Optional cells (value 2) are allowed to be out-of-bounds or overlap active cells;
	  // they must never block placing the required cells.
	  return !!(pendingCells && pendingCells.length > 0 && passesPlacementRules(zone, pendingCells));
	}

	function passesPlacementRules(zone, pendingCells) {
	  if (!zone || !pendingCells.length) return false;
	  const zoneId = zone.id || '';
	if (zoneId === 'yellow-zone') return validateYellowPlacement(zone, pendingCells);
	if (zoneId === 'blue-zone') return validateBluePlacement(zone, pendingCells);
	if (zoneId === 'green-zone') return validateGreenPlacement(zone, pendingCells);
	if (zoneId.startsWith('red-grid')) return validateRedPlacement(zone, pendingCells);
	if (zoneId === 'purple-zone') return validatePurplePlacement(zone, pendingCells);
	  return true;
	}

	function zoneHasActiveCells(zone) {
	  return !!zone.querySelector('.cell.active');
	}

	function hasAdjacentActiveCell(zone, cell) {
	  if (!zone || !cell) return false;
	  const x = Number(cell.dataset.x);
	  const y = Number(cell.dataset.y);
	  if (!Number.isFinite(x) || !Number.isFinite(y)) return false;
	  const neighbors = [
		getCell(zone, x - 1, y),
		getCell(zone, x + 1, y),
		getCell(zone, x, y - 1),
		getCell(zone, x, y + 1)
	  ];
	  return neighbors.some(neighbor => neighbor && neighbor.classList.contains('active'));
	}

function optionalCellsTouchActive(zone, pendingCells) {
	const optionalList = pendingCells && Array.isArray(pendingCells.optionalCells)
		? pendingCells.optionalCells.filter(Boolean)
		: [];
	if (!optionalList.length) return true;
	return optionalList.some(cell => cell.classList.contains('active') || hasAdjacentActiveCell(zone, cell));
}

	function validateYellowPlacement(zone, pendingCells) {
	  const hasActive = zoneHasActiveCells(zone);
	  const touchesStartColumn = pendingCells.some(cell => cell.classList.contains('bold-cell'));
	  if (!hasActive) return touchesStartColumn;
	  if (touchesStartColumn) return true;
	  // Check ook optionele cellen voor adjacency
	  const allCells = pendingCells.optionalCells ? [...pendingCells, ...pendingCells.optionalCells] : pendingCells;
	  return allCells.some(cell => hasAdjacentActiveCell(zone, cell));
	}

	function validateBluePlacement(zone, pendingCells) {
	  const metrics = getZoneMetrics(zone);
	  const floorY = Number.isFinite(metrics.maxY) ? metrics.maxY : null;
	  const touchesFloor = floorY !== null && pendingCells.some(cell => Number(cell.dataset.y) === floorY);
	  let bottomBoldY = null;
	  try {
		const boldCells = Array.from(zone.querySelectorAll('.cell.bold-cell:not(.void-cell)'));
		const boldYs = boldCells.map(c => Number(c.dataset.y)).filter(v => Number.isFinite(v));
		if (boldYs.length) bottomBoldY = Math.max(...boldYs);
	  } catch (e) {}
	  const isBlueStartBold = (cell) => {
		if (!cell || !cell.classList) return false;
		if (!cell.classList.contains('bold-cell')) return false;
		if (!Number.isFinite(bottomBoldY)) return false;
		return Number(cell.dataset.y) === bottomBoldY;
	  };
	  
	  // Blue: portals zijn ALTIJD geldig als startpunt (direct erop plaatsen)
	  const touchesPortal = pendingCells.some(cell => {
		if (!cell || !cell.classList) return false;
		return cell.classList.contains('portal-cell') || cell.classList.contains('portal-anchor');
	  });
	  // Blue: alleen bold-startcells (onderste bold rij) zijn startpunten
	  const touchesStartBold = pendingCells.some(cell => isBlueStartBold(cell));
	  
	  // Check if adjacent to portal or bottom bold-start cells
	  const adjacentToStart = pendingCells.some(cell => {
		if (!cell || !cell.classList) return false;
		const x = Number(cell.dataset.x);
		const y = Number(cell.dataset.y);
		if (!Number.isFinite(x) || !Number.isFinite(y)) return false;
		const neighbors = [
			getCell(zone, x - 1, y),
			getCell(zone, x + 1, y),
			getCell(zone, x, y - 1),
			getCell(zone, x, y + 1)
		];
		return neighbors.some(n => n && (n.classList.contains('portal-anchor') || n.classList.contains('portal-cell') || isBlueStartBold(n)));
	  });
	  
	  const hasActive = zoneHasActiveCells(zone);
	  // Als er nog geen actieve cellen zijn (eerste plaatsing)
	  // Toegestaan: bodem raken OF start-bold/portal (direct of aangrenzend)
	  if (!hasActive) return touchesFloor || touchesPortal || touchesStartBold || adjacentToStart;
	  
	  // Als er wel actieve cellen zijn (volgende plaatsingen)
	  // Toegestaan: bodem, portal/start-bold (direct of aangrenzend), OF aangrenzend aan actieve cel
	  if (touchesFloor || touchesPortal || touchesStartBold || adjacentToStart) return true;
	  
	  // Check ook optionele cellen voor adjacency
	  const allCells = pendingCells.optionalCells ? [...pendingCells, ...pendingCells.optionalCells] : pendingCells;
	  return allCells.some(cell => hasAdjacentActiveCell(zone, cell));
	}

	function validateGreenPlacement(zone, pendingCells) {
	  const hasActive = zoneHasActiveCells(zone);
	  // Allow ANY bold-cell in the green zone to serve as a start anchor (not just the first match)
	  const boldCells = Array.from(zone.querySelectorAll('.cell.bold-cell:not(.void-cell)'));
	  const touchesAnchor = boldCells.length ? boldCells.some(b => pendingCells.includes(b)) : false;
	  
	  // Als er nog geen actieve cellen zijn
	  if (!hasActive) {
		if (!boldCells.length) return true;
		return touchesAnchor;
	  }
	  
	  // Als er wel actieve cellen zijn, check:
	  // 1. Touch anchor directly
	  if (touchesAnchor) return true;
	  
	  // 2. Adjacent to any active cell (including the anchor if it's active)
	  // Check ook optionele cellen voor adjacency
	  const allCells = pendingCells.optionalCells ? [...pendingCells, ...pendingCells.optionalCells] : pendingCells;
	  return allCells.some(cell => hasAdjacentActiveCell(zone, cell));
	}

	function validateRedPlacement(zone, pendingCells) {
	  // Rood: altijd vrij plaatsen, geen adjacency check nodig
	  return true;
	}

	function validatePurplePlacement(zone, pendingCells) {
	  // World 2/3 paars: plaatsingsregels
	  // 1. Je mag overal in de binnengrid plaatsen (niet outer-ring-0 of outer-ring-1)
	  // 2. Volgende plaatsingen: aangrenzend aan bestaande actieve cellen
	  // UITZONDERING: portal-cells (NIET bold-cells!) mogen altijd als startpunt
	  // Bold-cells zijn GEEN uitzondering bij paars!
	  
	  const hasActive = zoneHasActiveCells(zone);
	  
	  // Check of Ã©Ã©n van de pending cells een PORTAL is (portal-cell class, NIET bold-cell!)
	  // Alleen portals zijn een uitzondering, bold-cells niet
	  const touchesPortal = pendingCells.some(cell => {
		if (!cell || !cell.classList) return false;
		return cell.classList.contains('portal-cell') || cell.classList.contains('portal-anchor');
	  });
	  
	  // Als er nog geen actieve cellen zijn (eerste plaatsing)
	  if (!hasActive) {
		// Portal aanraken is altijd toegestaan (uitzondering)
		if (touchesPortal) return true;
		
		// Anders: check of alle pending cells NIET op de buitenste 2 ringen zitten
		// (dus alleen plaatsen in inner grid bij eerste plaatsing)
		const allInner = pendingCells.every(cell => {
		  return !cell.classList.contains('outer-ring-0') && !cell.classList.contains('outer-ring-1');
		});
		return allInner;
	  }
	  
	  // Als er wel actieve cellen zijn (volgende plaatsingen)
	  // Optie 1: Direct op portal plaatsen (uitzondering)
	  if (touchesPortal) return true;
	  
	  // Optie 2: Aangrenzend aan een actieve cel (normaal gedrag)
	  // Check ook optionele cellen voor adjacency
	  const allCells = pendingCells.optionalCells ? [...pendingCells, ...pendingCells.optionalCells] : pendingCells;
	  return allCells.some(cell => hasAdjacentActiveCell(zone, cell));
	}

	// ========================
	// SHOW PREVIEW
	// ========================
	function showPreview(zone, baseX, baseY, shape, color, allowed) {
	  clearPreview(zone);
	  const optionalCells = getOptionalCells(shape);
	  const optionalSet = new Set(optionalCells.map(({ x, y }) => `${x},${y}`));
	  let effectiveShape = shape;
	  let trimmedMode = false;
	  const fullCells = collectPlacementCells(zone, baseX, baseY, shape);
	  const fullValid = fullCells && fullCells.length > 0 && passesPlacementRules(zone, fullCells);
	  if (!fullValid && optionalCells.length) {
		const trimmed = trimOptionalCells(shape);
		if (trimmed.length > 0 && trimmed[0].length > 0) {
		  const trimmedCells = collectPlacementCells(zone, baseX, baseY, trimmed);
		  if (trimmedCells && trimmedCells.length > 0 && passesPlacementRules(zone, trimmedCells)) {
			effectiveShape = trimmed;
			trimmedMode = true;
		  }
		}
	  }
	  const highlightSet = trimmedMode ? new Set() : optionalSet;
	  effectiveShape.forEach((row, y) => {
		row.forEach((cell, x) => {
		  if (!cell) return;
		  const target = getCell(zone, baseX + x, baseY + y);
		  if (target) {
			const key = `${x},${y}`;
			const isOptional = highlightSet.has(key);
			target.classList.add(allowed ? 'preview-allowed' : 'preview-denied');
			if (allowed) {
			  const baseColor = color.name === 'multikleur'
				  ? 'linear-gradient(45deg, #f06272, #fff25a, #4ed346, #5d90f0, #a35eff)'
				  : hexToRGBA(color.code, isOptional ? 0.25 : 0.5);
			  target.style.background = baseColor;
			  if (isOptional) {
				target.style.border = '2px dashed rgba(255,255,255,0.6)';
			  }
			}
		  }
		});
	  });
	}
	
	// ========================
	// PLACE SHAPE
	// ========================
	const ZONE_COLOR_CODE_MAP = {
		geel: '#cfba51',
		yellow: '#cfba51',
		rood: '#b56069',
		red: '#b56069',
		groen: '#92c28c',
		green: '#92c28c',
		paars: '#8f76b8',
		purple: '#8f76b8',
		blauw: '#5689b0',
		blue: '#5689b0'
	};

	function resolveZoneColorCode(zone, fallbackColor) {
		try {
			const zoneKey = String(zone?.dataset?.color || '').toLowerCase();
			if (zoneKey && ZONE_COLOR_CODE_MAP[zoneKey]) return ZONE_COLOR_CODE_MAP[zoneKey];
		} catch (e) {}
		return fallbackColor || '';
	}

	function placeShape(zone, baseX, baseY, shape, color) {
	  if (!zone) return null;
	  const totalScoreEl = document.getElementById('total-score');
	  const scoreBefore = Number(totalScoreEl?.textContent || 0) || 0;
	  const rawColorCode = typeof color === 'string'
		? color
		: (color?.code);
	  const isMultikleur = (typeof color === 'object' && (color.name === 'multikleur' || color.code === 'rainbow')) || rawColorCode === 'rainbow';
	  const zoneColorCode = resolveZoneColorCode(zone, rawColorCode);
	  const colorCode = isMultikleur ? zoneColorCode : rawColorCode;
	  const effectiveShape = shape;
	  // Validate using the required cells only (optional cells are skipped by collectPlacementCells).
	  const pendingCells = collectPlacementCells(zone, baseX, baseY, effectiveShape);
	  if (!pendingCells || pendingCells.length <= 0 || !passesPlacementRules(zone, pendingCells)) {
		return null;
	  }
	  
	  const placements = [];
	  const bonuses = [];
	  const previousPlacementId = currentPlacementId;
	  placementSequence += 1;
	  currentPlacementId = `placement-${placementSequence}`;
	  
	effectiveShape.forEach((row, y) => {
		row.forEach((cellVal, x) => {
		  if (!cellVal) return;
		  const target = getCell(zone, baseX + x, baseY + y);
		  if (!target) return;
		  // Optional cells (value 2) are a bonus extension: place them only when they fit.
		  if (isOptionalShapeCell(cellVal) && target.classList.contains('active')) return;
		  if (!target.classList.contains('active')) {
			placements.push(target);
			const toggleInfo = toggleCell(target, zone.id, colorCode, true);
			if (toggleInfo && toggleInfo.bonusClaim) {
				bonuses.push(toggleInfo.bonusClaim);
			}
		  }
		});
	});
	
	// Portals blijven op hun plaats staan voor het hele level

	// Traps: apply at most one PIT trap trigger per placement (simplified behavior)
	try {
		const trapCell = placements.find(c => c && c.dataset?.trap === 'true' && c.dataset.trapType === 'pit' && c.dataset.trapTriggered !== 'true');
		if (trapCell) {
			// CRITICAL: Use trapCell.dataset.zoneId (set at cell creation) for consistent trap key generation
			const trapZoneId = trapCell.dataset?.zoneId || trapCell.closest('.grid')?.id || zone?.id || '';
			registerTrapTrigger(trapCell, trapZoneId, { silent: false });
			updateScore(trapCell);
		}
	} catch (e) {}

	// Black hole: trigger independently of traps (only once per placement)
	try {
		const blackHoleCell = placements.find(c => c && isBlackHoleCell(c) && c.dataset.blackHoleTriggered !== 'true');
		if (blackHoleCell) {
			const bhZoneId = blackHoleCell.dataset?.zoneId || blackHoleCell.closest('.grid')?.id || zone?.id || '';
			ensureBlackHoleState(blackHoleCell, bhZoneId, { silent: false });
		}
	} catch (e) {}
	
	currentPlacementId = previousPlacementId;
	const scoreAfter = Number(totalScoreEl?.textContent || 0) || 0;
	return {
		zoneId: zone.id,
		cells: placements,
		bonuses,
		scoreDelta: scoreAfter - scoreBefore
	};
}

// ========== KAARTEN SYSTEEM ==========
// Centraliseer card shapes zodat ze op Ã©Ã©n plek aanpasbaar zijn.
const BASE_SHAPES = {
	mini: [
		{ name: 'Domino', matrix: [[1],[1]], weight: 1 },
		{ name: 'Tri-bar', matrix: [[1],[1],[1]], weight: 1 },
		{ name: 'Mini L', matrix: [[1,0],[1,1]], weight: 1 }
	],
	standard: [
		{ name: 'I', matrix: [[1],[1],[1],[1]], weight: 1 },
		{ name: 'O', matrix: [[1,1],[1,1]], weight: 1 },
		{ name: 'T', matrix: [[1,0],[1,1],[1,0]], weight: 1 },
		{ name: 'L', matrix: [[1,0],[1,0],[1,1]], weight: 1 },
		{ name: 'S', matrix: [[0,1],[1,1],[1,0]], weight: 1 }
	],
	large: [
		{ name: 'Plus', matrix: [[0,1,0],[1,1,1],[0,1,0]], weight: 0.5 },
		{ name: 'U vorm', matrix: [[1,0,1],[1,1,1]], weight: 1 },
		{ name: 'L groot', matrix: [[1,0],[1,0],[1,0],[1,1]], weight: 0.5 },
		{ name: 'Kolom-L', matrix: [[1,0,0],[1,0,0],[1,1,1]], weight: 1 },
		{ name: 'T groot', matrix: [[1,1,1],[0,1,0],[0,1,1]], weight: 1 },
		{ name: 'Trap', matrix: [[1,0,0],[1,1,0],[0,1,1]], weight: 1 },
		{ name: 'Hoefijzer', matrix: [[1,1,0],[1,0,0],[1,1,0]], weight: 1 },
		{ name: 'Pijl', matrix: [[0,0,1],[1,1,1],[0,1,0]], weight: 1 },
		{ name: 'Lang 5', matrix: [[1],[1],[1],[1],[1]], weight: 1 },
		{ name: 'Z dubbel', matrix: [[0,1],[1,0],[1,1]], weight: 0.5 },
		{ name: 'Hoekspiegel', matrix: [[1,0,0],[1,1,1],[0,0,1]], weight: 1 }
	],
	// Upgrade-gated shapes (kept separate for clarity)
	xl6: [
		{ name: 'XL (6) - 2x3', matrix: [[1,1,1],[1,1,1]], weight: 1 },
		{ name: 'XL (6) - Lang 6', matrix: [[1],[1],[1],[1],[1],[1]], weight: 0.5 }
	],
	extra7: [
		{ name: 'Extra Groot (7) - Randhoek', matrix: [[1,1,1],[1,0,0],[1,1,1]], weight: 0.08 },
		{ name: 'Extra Groot (7) - Dubbele balk', matrix: [[1,1,1],[0,1,0],[1,1,1]], weight: 0.08 }
	]
};

// Gewicht per categorie voor willekeurige keuzes.
const SHAPE_CATEGORY_WEIGHTS = {
	mini: 0.35,
	standard: 1,
	large: 0.35
};

// Helper: maak golden varianten op basis van base shapes, behoud gewicht tenzij override.
function deriveGoldenShapes(baseShapes, overrides = {}) {
	return baseShapes.map(shape => {
		const override = overrides[shape.name];
		return {
			name: `Gouden ${shape.name}`,
			matrix: cloneShape(shape.matrix),
			weight: (override && override.weight != null) ? override.weight : shape.weight
		};
	});
}

// Verzamel alle blueprints op Ã©Ã©n plek.
const CARD_BLUEPRINTS = {
	mini: BASE_SHAPES.mini,
	standard: BASE_SHAPES.standard,
	large: BASE_SHAPES.large,
	// Golden worden afgeleid van alle vormen (inclusief upgradevormen) met speciale weight overrides voor zeldzame 7-blok varianten.
	golden: (() => {
		const rareOverrides = {
			'Extra Groot (7) - Randhoek': { weight: 0.08 },
			'Extra Groot (7) - Dubbele balk': { weight: 0.08 }
		};
		const source = [
			...BASE_SHAPES.mini,
			...BASE_SHAPES.standard,
			...BASE_SHAPES.large,
			...BASE_SHAPES.xl6,
			...BASE_SHAPES.extra7
		];
		return deriveGoldenShapes(source, rareOverrides);
	})()
};

// Losse lijsten voor upgrades worden behouden voor eenvoudige gating.
const EXTRA_LARGE_7_SHAPES = BASE_SHAPES.extra7;
const XL_6_SHAPES = BASE_SHAPES.xl6;

	// Bouw shapePool dynamisch op basis van upgrades
	function buildShapePool() {
		const pool = [];
		const weights = { ...SHAPE_CATEGORY_WEIGHTS };
		const effectiveLevel = Math.max(1, Number(currentLevel) || 1);
		
		// Pas weights aan op basis van upgrades
		if (hasUpgrade('miniPack34')) {
			weights.mini = 0.65;  // Meer mini kaarten
		}
		
		// Voeg alleen unlocked categories toe aan pool
		Object.entries(CARD_BLUEPRINTS).forEach(([category, cards]) => {
			if (category === 'golden') return; // Skip golden, die worden apart toegevoegd
			
			// Check of category unlocked is
			if (!UNLOCK_PROGRESSION.isCategoryUnlocked(category, effectiveLevel)) {
				return; // Skip niet-unlocked categorieÃ«n
			}
			
			cards.forEach(card => {
				const categoryWeight = weights[category] ?? 1;
				pool.push({
					name: card.name,
					category: category,
					weight: card.weight * categoryWeight,
					matrix: card.matrix
				});
			});
		});

		// Extra grote 7-blok vormen zijn upgrade-gated en zeldzaam.
		if (hasUpgrade('extraLargeBlocks')) {
			EXTRA_LARGE_7_SHAPES.forEach(card => {
				pool.push({
					name: card.name,
					category: 'large',
					weight: card.weight,
					matrix: card.matrix
				});
			});
		}

		// XL 6-blok vormen zijn upgrade-gated.
		if (hasUpgrade('xlBlocks')) {
			XL_6_SHAPES.forEach(card => {
				pool.push({
					name: card.name,
					category: 'large',
					weight: card.weight,
					matrix: card.matrix
				});
			});
		}
		
		return pool;
	}

	// shapePool wordt later geÃ¯nitialiseerd na currentLevel declaratie
	let shapePool = [];

	function getRandomShapeEntry() {
	  const totalWeight = shapePool.reduce((sum, entry) => {
		const categoryWeight = SHAPE_CATEGORY_WEIGHTS[entry.category] ?? 1;
		return sum + entry.weight * categoryWeight;
	  }, 0);
	  let target = Math.random() * totalWeight;
	  for (const entry of shapePool) {
		const categoryWeight = SHAPE_CATEGORY_WEIGHTS[entry.category] ?? 1;
		const adjustedWeight = entry.weight * categoryWeight;
		if (target < adjustedWeight) return entry;
		target -= adjustedWeight;
	  }
	  return shapePool[shapePool.length - 1];
	}

	// gewone kleuren + multikleur
	const colors = [
	  { name: 'rood',   code: '#b56069' },
	  { name: 'groen',  code: '#92c28c' },
	  { name: 'blauw',  code: '#5689b0' },
	  { name: 'geel',   code: '#cfba51' },
	  { name: 'paars',  code: '#8f76b8' },
	  { name: 'multikleur', code: 'rainbow' } // speciale wildcard
	];
	const NON_WILDCARD_COLORS = colors.filter(c => c.name !== 'multikleur').map(c => ({ ...c }));
	const EXTRA_HAND_BONUS = 1;
	const LUCKY_DRAW_COPY_CHANCE = 0.25;
	let goldenColorRotation = 0;

	// Wereld 2 kaart upgrade: Bonus Echo (3 varianten)
	const BONUS_ECHO_REQUIRED_BONUSES = 2;
	const BONUS_ECHO_SCORE_BONUS = 20;
	const BONUS_ECHO_CARD_COST_BONUS = 4;
	const BONUS_ECHO_UPGRADE_COST = 5;
	const BONUS_ECHO_BONUS_REWARD = 2;
	const BONUS_ECHO_VARIANTS = [
		{ key: 'points', tag: 'L2', sub: 'POINTS', desc: 'Plaats op 2 coins voor +20 punten in deze kleur.' },
		{ key: 'bonus', tag: 'L2', sub: 'BONUS', desc: 'Scoor punten met deze kaart voor +2 willekeurige bonussen.' },
		{ key: 'replay', tag: 'L2', sub: 'REPLAY', desc: 'Plaats op 2 bonussen om deze kaart dubbel te mogen spelen.' }
	];
	const BONUS_ECHO_BADGE_TEXT = { points: `+${BONUS_ECHO_SCORE_BONUS}`, bonus: `+${BONUS_ECHO_BONUS_REWARD}`, replay: 'â†»' };

	function pickBonusEchoVariant() {
		if (!Array.isArray(BONUS_ECHO_VARIANTS) || !BONUS_ECHO_VARIANTS.length) return 'replay';
		const pick = BONUS_ECHO_VARIANTS[Math.floor(Math.random() * BONUS_ECHO_VARIANTS.length)];
		return pick?.key || 'replay';
	}

	function getBonusEchoUiCopy(variantKey = 'replay', readyNote = '') {
		const meta = BONUS_ECHO_VARIANTS.find(v => v.key === variantKey) || BONUS_ECHO_VARIANTS[1];
		return {
			tag: meta.tag,
			sub: meta.sub || '',
			desc: meta.desc
		};
	}

	function createMetaIcon(type = 'bonus') {
		const span = document.createElement('span');
		span.className = type === 'coin' ? 'coin-icon' : 'bonus-mini-icon';
		return span;
	}

	function buildBonusEchoLabelMeta(labelEl, metaEl, variantKey = 'replay') {
		if (!labelEl || !metaEl) return;
		const variant = variantKey || 'replay';
		labelEl.classList.add('card-label--echo');
		metaEl.classList.add('card-meta--echo');
		labelEl.innerHTML = '';
		metaEl.innerHTML = '';
		const labelText = document.createElement('span');
		labelText.className = 'echo-icon';
		switch (variant) {
			case 'points': {
				labelText.textContent = `+${BONUS_ECHO_SCORE_BONUS}`;
				labelEl.append(labelText);
				const metaLine = document.createElement('span');
				metaLine.className = 'card-meta-line';
				metaLine.append(createMetaIcon('coin'), createMetaIcon('coin'));
				metaEl.append(metaLine);
				break;
			}
			case 'bonus': {
				const labelWrap = document.createElement('span');
				labelWrap.className = 'card-meta-line';
				const bonusText = document.createElement('span');
				bonusText.textContent = `+${BONUS_ECHO_BONUS_REWARD}`;
				labelWrap.append(bonusText, createMetaIcon('bonus'));
				labelEl.append(labelWrap);
				const metaLine = document.createElement('span');
				metaLine.className = 'card-meta-line card-meta-note';
				const targetIcon = document.createElement('span');
				targetIcon.className = 'meta-target-icon';
				targetIcon.textContent = 'ðŸŽ¯';
				const targetText = document.createElement('span');
				metaLine.append(targetIcon, targetText);
				metaEl.append(metaLine);
				break;
			}
			case 'replay':
			default: {
				labelText.textContent = 'â†»';
				labelEl.append(labelText);
				const metaLine = document.createElement('span');
				metaLine.className = 'card-meta-line';
				metaLine.append(createMetaIcon('bonus'), createMetaIcon('bonus'));
				metaEl.append(metaLine);
				break;
			}
		}
	}

	function buildBonusBoostLabelMeta(labelEl, metaEl, colorKey) {
		if (!labelEl || !metaEl) return;
		labelEl.classList.add('card-label--echo');
		metaEl.classList.add('card-meta--echo');
		labelEl.innerHTML = '';
		metaEl.innerHTML = '';
		const labelText = document.createElement('span');
		labelText.className = 'echo-icon';
		labelText.textContent = '2Ã—';
		labelEl.append(labelText);
		const metaLine = document.createElement('span');
		metaLine.className = 'card-meta-line';
		metaLine.textContent = 'BONUS BOOST';
		const subLine = document.createElement('span');
		subLine.className = 'card-meta-line card-meta-note';
		const labelColor = (colorKey && BONUS_COLOR_CONFIG[colorKey])
			? BONUS_COLOR_CONFIG[colorKey].label
			: '';
		subLine.textContent = labelColor ? `2Ã— ${labelColor}` : '2Ã— bonussen';
		metaEl.append(metaLine, subLine);
	}

	let colorScoreBonuses = { yellow: 0, red: 0, green: 0, purple: 0, blue: 0 };
	let bonusEchoExtraTurns = 0;
	let bonusEchoStreak = 0;
	let bonusEchoFreePlays = 0;
	let lastCardWasBonusEcho = false;
	let lastBonusEchoVariant = null;

	function resetBonusEchoState() {
		colorScoreBonuses = { yellow: 0, red: 0, green: 0, purple: 0, blue: 0 };
		bonusEchoExtraTurns = 0;
		bonusEchoStreak = 0;
		bonusEchoFreePlays = 0;
		lastCardWasBonusEcho = false;
		lastBonusEchoVariant = null;
	}

	// Variabelen die nodig zijn voor buildShapePool
	let currentLevel = 1;
	let currentWorld = 1; // Nieuwe variabele om bij te houden in welke wereld we zitten
	// World 3 red-zone progression: stage 1 = grids 1-4 + lock, stage 2 = grids 5-6 (bigger) + no lock
	let world3RedStage = 1;

	function applyWorld3RedStage(stage) {
		const redZone = document.getElementById('red-zone');
		const lockEl = document.getElementById('world3-red-lock');
		const isStage2 = Number(stage) === 2;
		const isWorld3 = (typeof getWorldAndSubLevel === 'function') ? (Number(getWorldAndSubLevel(currentLevel)?.world || 1) === 3) : false;
		const effectiveStage = (isWorld3 && isStage2) ? 2 : 1;
		if (!isWorld3) {
			// Outside World 3: keep classic layout (1-4 visible, 5-6 hidden) and hide lock.
			['red-grid1','red-grid2','red-grid3','red-grid4'].forEach(id => {
				const el = document.getElementById(id);
				if (el) el.style.display = '';
			});
			['red-grid5','red-grid6'].forEach(id => {
				const el = document.getElementById(id);
				if (el) el.style.display = 'none';
			});
			if (lockEl) lockEl.style.display = 'none';
			return;
		}

		world3RedStage = effectiveStage;
		if (effectiveStage === 1) {
			['red-grid1','red-grid2','red-grid3','red-grid4'].forEach(id => {
				const el = document.getElementById(id);
				if (el) el.style.display = '';
			});
			['red-grid5','red-grid6'].forEach(id => {
				const el = document.getElementById(id);
				if (el) el.style.display = 'none';
			});
			if (lockEl) lockEl.style.display = 'flex';
		} else {
			['red-grid1','red-grid2','red-grid3','red-grid4'].forEach(id => {
				const el = document.getElementById(id);
				if (el) el.style.display = 'none';
			});
			['red-grid5','red-grid6'].forEach(id => {
				const el = document.getElementById(id);
				if (el) el.style.display = '';
			});
			if (lockEl) lockEl.style.display = 'none';
		}
		// Recenter green after stage flips to prevent layout drift on World 3.
		try { scheduleGreenCenter({ force: false, allowZoom: false, fallback: true, fallbackDelay: 80 }); } catch (_) {}
		// Re-sync column heights after red-stage visibility changes.
		try { requestAnimationFrame(() => { try { syncZoneHeights(); } catch (_) {} }); } catch (_) {}
		// NOTE: Do NOT set position here - zoom mode needs position:fixed to work.
		// The lock overlay uses position:absolute which works fine with the parent's natural position.
	}

	function isRedSubgridFull(gridId) {
		const grid = document.getElementById(gridId);
		if (!grid || grid.style.display === 'none') return false;
		const allCells = grid.querySelectorAll('.cell:not(.void-cell)');
		const activeCells = grid.querySelectorAll('.cell.active:not(.void-cell)');
		return allCells.length > 0 && allCells.length === activeCells.length;
	}

	// World 4 state: allowed colors + locked door colors
	let world4AllowedColors = null;
	let world4UnlockedColors = new Set();
	const WORLD4_ALL_COLORS = ['geel', 'groen', 'blauw', 'paars', 'rood'];
	const WORLD4_COLOR_TO_SCORE_KEY = { geel: 'yellow', groen: 'green', blauw: 'blue', paars: 'purple', rood: 'red' };
	const WORLD4_BONUS_KEY_TO_COLOR = { yellow: 'geel', green: 'groen', blue: 'blauw', purple: 'paars', red: 'rood' };
	const WORLD4_COLOR_TO_BONUS_KEY = { geel: 'yellow', groen: 'green', blauw: 'blue', paars: 'purple', rood: 'red' };
	const world4ActiveColorsByLevel = new Map();

	function world4Mulberry32(seed) {
		let t = (seed >>> 0) || 1;
		return function() {
			t += 0x6D2B79F5;
			let r = Math.imul(t ^ (t >>> 15), 1 | t);
			r ^= r + Math.imul(r ^ (r >>> 7), 61 | r);
			return ((r ^ (r >>> 14)) >>> 0) / 4294967296;
		};
	}

	function shuffleWithRng(list, rng) {
		const arr = Array.isArray(list) ? list.slice() : [];
		for (let i = arr.length - 1; i > 0; i--) {
			const j = Math.floor(rng() * (i + 1));
			[arr[i], arr[j]] = [arr[j], arr[i]];
		}
		return arr;
	}

	function getWorld4ActiveColorsForLevel(level) {
		const lvl = Math.max(1, Number(level) || 1);
		if (world4ActiveColorsByLevel.has(lvl)) {
			return world4ActiveColorsByLevel.get(lvl).slice();
		}
		const rng = world4Mulberry32(0xA5A5A5 ^ (lvl * 7919));
		const pick = shuffleWithRng(WORLD4_ALL_COLORS, rng).slice(0, 3);
		world4ActiveColorsByLevel.set(lvl, pick);
		return pick.slice();
	}

	function getWorld4ActiveColors() {
		if (Array.isArray(world4AllowedColors) && world4AllowedColors.length) return world4AllowedColors.slice();
		return WORLD4_ALL_COLORS.slice();
	}

	function getWorld4ActiveScoreTotal(scores) {
		const active = getWorld4ActiveColors();
		let total = 0;
		active.forEach(c => {
			const key = WORLD4_COLOR_TO_SCORE_KEY[c];
			if (key && scores && Number.isFinite(scores[key])) total += scores[key];
		});
		return total;
	}

	function countWorld4ActiveColorsAtLeast(scores, threshold = 0) {
		const active = getWorld4ActiveColors();
		return active.reduce((acc, c) => {
			const key = WORLD4_COLOR_TO_SCORE_KEY[c];
			const val = scores && key ? Number(scores[key] || 0) : 0;
			return acc + (val >= threshold ? 1 : 0);
		}, 0);
	}

	function countWorld4OpenDoors() {
		try {
			const open = document.querySelectorAll('.cell.door-cell.door-open');
			return open ? open.length : 0;
		} catch (e) {
			return 0;
		}
	}

	function getWorld4ActiveZoneIds() {
		const active = getWorld4ActiveColors();
		const zones = [];
		active.forEach(c => {
			if (c === 'rood') {
				['red-grid1','red-grid2','red-grid3','red-grid4','red-grid5','red-grid6'].forEach(id => {
					const el = document.getElementById(id);
					if (el && el.style.display !== 'none') zones.push(id);
				});
				return;
			}
			const id = `${c}-zone`;
			const el = document.getElementById(id);
			if (el && el.style.display !== 'none') zones.push(id);
		});
		return zones;
	}

	function getWorld4ActiveZoneCompletionRatio() {
		const zones = getWorld4ActiveZoneIds();
		let totalCells = 0;
		let activeCells = 0;
		zones.forEach(id => {
			const zone = document.getElementById(id);
			if (!zone) return;
			const cells = zone.querySelectorAll('.cell:not(.void-cell)');
			const active = zone.querySelectorAll('.cell.active:not(.void-cell)');
			totalCells += cells.length;
			activeCells += active.length;
		});
		return totalCells > 0 ? (activeCells / totalCells) : 0;
	}

	// Helper functie om world en subLevel te bepalen
	function getWorldAndSubLevel(level) {
		const numericLevel = Number(level) || 0;
		if (numericLevel <= 0) return { world: 1, subLevel: 1, intro: true };
		if (numericLevel <= 10) return { world: 1, subLevel: numericLevel };
		if (numericLevel <= 20) return { world: 2, subLevel: numericLevel - 10 };
		if (numericLevel <= 30) return { world: 3, subLevel: numericLevel - 20 };
		return { world: Math.floor((numericLevel - 1) / 10) + 1, subLevel: ((numericLevel - 1) % 10) + 1 };
	}

	function isAtLeastWorldAndSubLevel(targetWorld, targetSubLevel, level = currentLevel) {
		const info = getWorldAndSubLevel(Number(level) || 1);
		const world = Number(info?.world || 1);
		const subLevel = Number(info?.subLevel || 1);
		if (world > targetWorld) return true;
		if (world < targetWorld) return false;
		return subLevel >= targetSubLevel;
	}

	// Vanaf level 1.7 (en later) zijn multikleur + gouden modifiers beschikbaar.
	function isSpecialModifiersUnlocked(level = currentLevel) {
		return isAtLeastWorldAndSubLevel(1, 7, level);
	}

	let ownedDeckBlueprints = [];
	let introDeckActive = false;
	let drawPile = [];
	let discardPile = [];
	let currentHand = [];
	// Tracks if the player already received the starter picks for a given world.
	// Keys are world numbers (1,2,3,...) stored as strings for safe serialization.
	let starterPicksDoneByWorld = {};
	let preLevelStarterPicksDone = false;
	let preLevelStarterPicksInProgress = false;
	let pendingShopCallback = null;
	let lastRoundWasSuccess = false;
	let lastRoundFailureReason = null;
	let selectedCardId = null;
	let selectedCardElement = null;
	let cardPlacementHistory = [];
	let cardsPlayedThisTurn = 0;
	let goldenCardPlayedThisTurn = false;
	let nonGoldenCardPlayedThisTurn = false;
	let actionSequence = 0;
	let cellActivationSequence = 0;
	let placementSequence = 0;
	let currentPlacementId = null;
	let coinsAwardedFromScore = 0;
	var coinsCollectedThisLevel = 0;
	let cardSelectionLocked = false;
	  // NOTE: Turn counter UI is handled via turnCount/updateTurnCounterDisplay().
	let debugMode = false;
	let isLoadingGame = false;
	let savedDeckState = null;

	// Battery saver toggle: flip to false to disable the low-power tweaks below.
	// Use var to avoid temporal dead zone when referenced earlier in the file.
	var BATTERY_SAVER_ENABLED = true;
	var BATTERY_SUPPRESS_LOGS = false;
	var BATTERY_THROTTLE_DRAG = true;
	var BATTERY_REDUCE_ANIM = false;

	// Layout cache for expensive getBoundingClientRect calls - invalidated on resize
	var _layoutCache = {
		cellSize: null,
		boardGridGap: null,
		windowWidth: null,
		windowHeight: null,
		lastUpdate: 0
	};
	
	function invalidateLayoutCache() {
		_layoutCache.cellSize = null;
		_layoutCache.boardGridGap = null;
		_layoutCache.windowWidth = window.innerWidth;
		_layoutCache.windowHeight = window.innerHeight;
		_layoutCache.lastUpdate = Date.now();
	}
	
	// Invalidate cache on resize
	window.addEventListener('resize', invalidateLayoutCache, { passive: true });

	// Apply battery-saver tweaks early (logs + reduced motion)
	(function applyBatterySaver() {
		if (!BATTERY_SAVER_ENABLED) return;
		try {
			if (BATTERY_SUPPRESS_LOGS && typeof console === 'object') {
				const noop = () => {};
				['log','info','debug'].forEach(fn => { try { console[fn] = noop; } catch (_) {} });
			}
			if (BATTERY_REDUCE_ANIM) {
				const style = document.createElement('style');
				style.id = 'battery-saver-style';
				style.textContent = 'body.battery-saver *, body.battery-saver *::before, body.battery-saver *::after { animation-duration: 0.01ms; animation-iteration-count: 1; transition-duration: 0.01ms; }';
				document.head && document.head.appendChild(style);
				document.addEventListener('DOMContentLoaded', () => {
					try { document.body.classList.add('battery-saver'); } catch (_) {}
				});
			}
		} catch (_) {}
	})();

	// Initialiseer shapePool nu currentLevel beschikbaar is
	shapePool = buildShapePool();

	let cardBlueprintCounter = 0;
	let cardInstanceCounter = 0;
	let bonusUseHintShown = false;

	function nextBlueprintId() {
	  cardBlueprintCounter += 1;
	  return `bp-${cardBlueprintCounter}`;
	}

	function nextCardInstanceId() {
	  cardInstanceCounter += 1;
	  return `card-${cardInstanceCounter}`;
	}

	function cloneColor(color) {
		if (!color) return { name: '', code: '#ffffff' };
		return { name: color.name, code: color.code, isGolden: !!color.isGolden };
	}

	function getColorDisplayName(color) {
		const name = String(color?.name || '').trim();
		if (!name) return '';
		if (name.toLowerCase() === 'multikleur') return 'multi';
		return name;
	}

	function createCardBlueprint(shapeEntry, colorOverride, extras = {}) {
		return {
			blueprintId: nextBlueprintId(),
			shapeName: shapeEntry.name,
			matrix: cloneShape(shapeEntry.matrix),
			category: shapeEntry.category,
			color: cloneColor(colorOverride),
			...extras
		};
	}

	function instantiateBlueprint(blueprint) {
		const safeColor = cloneColor(blueprint.color);
		// Backward compatible: old saves might mark golden on the color object.
		// Golden is a card modifier, NOT a block color.
		const isGolden = !!(blueprint && (blueprint.isGolden || blueprint.color?.isGolden));
		if (isGolden) safeColor.isGolden = false;
		const isEchoUpgrade = !!(blueprint.isBonusEcho || blueprint.isBonusEchoUpgrade);
		return {
			id: nextCardInstanceId(),
			blueprintId: blueprint.blueprintId,
			shapeName: blueprint.shapeName,
			matrix: cloneShape(blueprint.matrix),
			category: blueprint.category,
			color: safeColor,
			isGolden,
			isBonusBoost: !!blueprint.isBonusBoost,
			isBonusEcho: isEchoUpgrade,
			bonusEchoVariant: blueprint.bonusEchoVariant || 'replay',
			bonusEchoReplaysAvailable: Number(blueprint.bonusEchoReplaysAvailable || 0),
			isBonusEchoUpgrade: !!blueprint.isBonusEchoUpgrade
		};
	}

	function buildIntroTutorialDeckBlueprint() {
		const getColor = (name, fallback) => colors.find(c => c.name === name) || fallback || { name: name || 'grijs', code: '#a0a0a0' };
		const purple = getColor('paars');
		const blue = getColor('blauw');
		const yellow = getColor('geel');
		const green = getColor('groen');
		const red = getColor('rood');
		const introShapes = [
			{ name: 'Intro Domino Verticaal', matrix: [[1], [1]], category: 'mini' },
			{ name: 'Intro Domino Horizontaal', matrix: [[1, 1]], category: 'mini' },
			{ name: 'Intro Mini L', matrix: [[1, 0], [1, 1]], category: 'mini' },
			{ name: 'Intro Mini J', matrix: [[0, 1], [1, 1]], category: 'mini' },
			{ name: 'Intro L', matrix: [[1, 0], [1, 0], [1, 1]], category: 'standard' },
			{ name: 'Intro Vierkant', matrix: [[1, 1], [1, 1]], category: 'standard' }
		];
		const blueprintDefs = [
			{ shape: introShapes[0], color: purple },
			{ shape: introShapes[1], color: yellow },
			{ shape: introShapes[3], color: blue },
			{ shape: introShapes[2], color: purple },
			{ shape: introShapes[4], color: green },
			{ shape: introShapes[5], color: red }
		];
		return blueprintDefs.map(entry => createCardBlueprint(entry.shape, entry.color));
	}

	function buildStandardDeckBlueprint() {
	  const standardShapes = shapePool.filter(entry => entry.category === 'standard');
		  const desiredCount = 6;
	  
	  // Als shapePool leeg is of geen standard shapes heeft, rebuild de pool
	  if (standardShapes.length === 0) {
		console.warn('âš ï¸ No standard shapes in pool, rebuilding shapePool');
		shapePool = buildShapePool();
		const retryStandardShapes = shapePool.filter(entry => entry.category === 'standard');
		if (retryStandardShapes.length === 0) {
		  console.error('âŒ Still no standard shapes after rebuild!');
		  // Fallback: gebruik alle shapes als laatste redmiddel
			  return shapePool.slice(0, desiredCount).map((entry, idx) => {
			const color = NON_WILDCARD_COLORS[idx % NON_WILDCARD_COLORS.length];
			return createCardBlueprint(entry, color);
		  });
		}
	  }
	  
	  const shuffled = shuffleArray([...standardShapes]);
		  const picks = shuffled.slice(0, desiredCount);
		  // If too few standard shapes are available, top up with other unlocked shapes.
		  if (picks.length < desiredCount) {
			const already = new Set(picks.map(p => `${p.name}|${JSON.stringify(p.matrix)}`));
			const pool = shuffleArray(shapePool.filter(entry => {
				const key = `${entry.name}|${JSON.stringify(entry.matrix)}`;
				return !already.has(key);
			}));
			for (const entry of pool) {
				if (picks.length >= desiredCount) break;
				picks.push(entry);
			}
		  }
	  const baseColors = [...NON_WILDCARD_COLORS];
	  let colorIndex = 0;
	  return picks.map(entry => {
		const color = baseColors[colorIndex % baseColors.length];
		colorIndex += 1;
		return createCardBlueprint(entry, color);
	  });
	}

	function getRandomGoldenShape() {
		if (!GOLDEN_CARD_SHAPES.length) {
			return { name: 'Gouden Vierkant', matrix: [[1,1],[1,1]], category: 'golden' };
		}
		const index = Math.floor(Math.random() * GOLDEN_CARD_SHAPES.length);
		return GOLDEN_CARD_SHAPES[index];
	}

	function createGoldenCardBlueprint() {
		const shapeEntry = getRandomGoldenShape();
		const palette = [...NON_WILDCARD_COLORS];
		const baseColor = palette.length ? palette[goldenColorRotation % palette.length] : { name: 'multikleur', code: 'rainbow' };
		goldenColorRotation = palette.length ? (goldenColorRotation + 1) % palette.length : goldenColorRotation;
		// Golden card = golden frame; keep the block color the base color.
		return createCardBlueprint(shapeEntry, baseColor, { isGolden: true, category: 'golden' });
	}

	function addGoldenCardBlueprints(count = 1) {
		for (let i = 0; i < count; i += 1) {
			ownedDeckBlueprints.push(createGoldenCardBlueprint());
		}
	}

	function addMiniCardBlueprints(count = 1) {
		const miniShapes = CARD_BLUEPRINTS.mini || [];
		const palette = NON_WILDCARD_COLORS.length ? NON_WILDCARD_COLORS : [{ name: 'grijs', code: '#a0a0a0' }];
		if (!miniShapes.length || !palette.length) return;
		for (let i = 0; i < count; i += 1) {
			const shapeEntry = miniShapes[Math.floor(Math.random() * miniShapes.length)];
			const entryWithCategory = { ...shapeEntry, category: 'mini' };
			const baseColor = palette[Math.floor(Math.random() * palette.length)];
			const blueprint = createCardBlueprint(entryWithCategory, baseColor);
			ownedDeckBlueprints.push(blueprint);
		}
	}

	function getSpendableCoinCount() {
	  return document.querySelectorAll('#collected-coins .coin.active').length;
	}

// Return a coin count usable by objective checks/progress.
// Priority: explicit `scores.coins` or `scores.coinsCollected` if provided,
// then DOM `getSpendableCoinCount()`, then fallback to deriving from
// bonus points (1 coin per 3 bonus points) if available.
function getCollectedCoinCount(scores) {
	if (typeof coinsCollectedThisLevel === 'number') return coinsCollectedThisLevel;
	if (scores && typeof scores.coins === 'number') return scores.coins;
	if (scores && typeof scores.coinsCollected === 'number') return scores.coinsCollected;
	if (typeof getSpendableCoinCount === 'function') return getSpendableCoinCount();
	if (scores && typeof scores.bonusesCollected === 'number') return Math.floor(scores.bonusesCollected / 3);
	return 0;
}

	function updateShopCoinDisplay() {
		if (!window.updateShopCoinDisplayElement) {
			const balanceEl = document.getElementById('shop-coin-balance');
			const displayEl = document.getElementById('shop-coin-display');
			window.updateShopCoinDisplayElement = { balanceEl, displayEl };
		}
		const refs = window.updateShopCoinDisplayElement;
		if (!refs || !refs.balanceEl) return;
		const coins = getSpendableCoinCount();
		refs.balanceEl.textContent = String(coins);
		refs.balanceEl.setAttribute('data-coins', String(coins));
		if (refs.displayEl) {
			refs.displayEl.classList.toggle('is-empty', coins === 0);
		}
	}

	function updateCoinCounter() {
	  const goldZone = document.getElementById('gold-zone');
	  if (!goldZone) return;
	  const activeCoins = getSpendableCoinCount();
	  goldZone.setAttribute('data-coin-text', `${activeCoins}`);
	  updateShopCoinDisplay();
	  updateBuyPlacementButton();
	}

	function updateBuyPlacementButton() {
	  const btn = document.getElementById('buy-placement-btn');
	  const preview = document.getElementById('purchased-block-preview');
	  if (!btn) return;
	  
	  // Als er een gekochte plaatsing actief is, toon preview en verberg knop
	  if (window.hasPurchasedPlacement) {
		btn.style.display = 'none';
		if (preview) preview.style.display = 'flex';
		// Ensure preview cell matches zoomed cell size when zoomed
		try {
			if (document.body.classList.contains('zoomed-in')) {
				const cellSize = Math.round(getActualCellSize(typeof activeZoomZone !== 'undefined' && activeZoomZone ? activeZoomZone : null));
				const cellEl = preview.querySelector('.purchased-block-cell');
				if (cellEl && Number.isFinite(cellSize) && cellSize > 6) {
					cellEl.style.width = cellEl.style.height = `${cellSize}px`;
					cellEl.style.borderRadius = `${Math.max(2, Math.min(6, Math.round(cellSize / 6)))}px`;
				}
			} else {
				// restore default CSS sizing
				const cellEl = preview.querySelector('.purchased-block-cell');
				if (cellEl) {
					cellEl.style.removeProperty('width');
					cellEl.style.removeProperty('height');
					cellEl.style.removeProperty('border-radius');
				}
			}
		} catch (e) {}
		return;
	  }
	  
	  // Anders toon knop en verberg preview
	  btn.style.display = 'flex';
	  if (preview) preview.style.display = 'none';
	  
	  const coins = getSpendableCoinCount();
	  const cost = 2;
	  btn.disabled = coins < cost;
	  btn.title = coins < cost 
		? `Onvoldoende munten (${coins}/${cost})` 
		: 'Koop bonusblok (2 munten)';
	}

	function onBuyPlacementClick() {
	  const coins = getSpendableCoinCount();
	  const cost = 2;
	  if (coins < cost) {
		showObjectiveToast('âŒ Onvoldoende munten voor blokplaatsing');
		return;
	  }
	  
	  // Betaal de munten
	  if (!spendCoins(cost)) {
		showObjectiveToast('âŒ Kon munten niet afschrijven');
		return;
	  }
	  
	  // Markeer dat er een gekochte plaatsing klaar staat
	  window.hasPurchasedPlacement = true;
	  updateBuyPlacementButton();
	  
	  showObjectiveToast('ðŸŒˆ Blok gekocht! Sleep het icoon om te plaatsen.');
	}

	function onPurchasedBlockPreviewClick(event) {
	  if (!window.hasPurchasedPlacement) return;
	  const isMobileLayout = window.innerWidth <= MOBILE_BREAKPOINT;
	  const isTouchDevice = ('ontouchstart' in window || navigator.maxTouchPoints > 0);
	  const isPointerDown = !!(event && typeof event.type === 'string' && event.type.indexOf('pointer') === 0);
	  const preferDirectDrag = !!(event && event.type === 'pointerdown' && event.pointerType === 'mouse');
	  
	  // Als er al een purchased placement drag actief is, doe niets (voorkom toggle)
	  if (activeBonusPlacement && activeBonusPlacement.colorKey === 'purchased') {
		return;
	  }
	  
	  // Cancel eventuele actieve bonus plaatsing
	  cancelActiveBonusPlacement({ updateInventory: false });
	  
	  // Maak een 1x1 multikleur blok en start het slepen
	  const shape = [[1]];
	  const colorObj = { name: 'multikleur', code: 'rainbow' };
	  
	  // Stel de geselecteerde vorm in
	  selectedShape = shape;
	  selectedColor = colorObj;
	  
	  const previewEl = document.getElementById('purchased-block-preview');
	  // Touch devices and mobile: always use direct drag (no hover mode)
	  // Desktop mouse can also use direct drag for purchased blocks (simpler UX)
	  // Skip hover-follow mode for purchased placement entirely.

	  if (!isMobileLayout && !isTouchDevice) {
		activeBonusPlacement = {
			colorKey: 'purchased',
			pointerId: null,
			sticky: false,
			shape: cloneShape(shape),
			purchasedPlacement: true,
			desktopHover: true
		};
		lastZone = null;
		lastBaseX = null;
		lastBaseY = null;
		startDesktopHoverDragFromSelection(previewEl || document.getElementById('purchased-block-preview'), shape, colorObj);
		return;
	  }

	  // Touch: direct drag behavior - blok volgt de vinger
	  const block = makeDraggable(shape, colorObj);
	  block.classList.add('bonus-draggable', 'purchased-placement');
	  const overlay = document.getElementById('drag-overlay');
	  if (overlay && !overlay.contains(block)) overlay.appendChild(block);
	  if (overlay) overlay.style.display = 'block';
	  
	  draggedBlock = block;
	resetDragBlockGap();
	  draggedShape = block._shape || shape;
	  draggedColor = colorObj;
	  
	  // Start de pointer drag tracking
	  beginPointerDrag({ clientX: event.clientX, clientY: event.clientY, pointerId: event.pointerId || null });
	  
	  // Positioneer het blok bij de pointer positie (met touch offset)
	  const startX = event.clientX || window.innerWidth / 2;
	  const startY = event.clientY || window.innerHeight / 2;
	  const touchOffsetY = getFingerLiftOffsetY(event);
	{
		const m = getDragBlockCellMetrics(draggedBlock);
		({ offsetX, offsetY } = computeShapeCenterOffsets(draggedShape, m));
		setElPos(draggedBlock, startX - offsetX, startY - offsetY - touchOffsetY);
	}

	// Ensure the purchased draggable immediately measures zoomed cell size
	// (in case zoom/lift just occurred). Re-render on next frame.
	requestAnimationFrame(() => {
		try {
			renderBlock(block, block._shape || shape, colorObj);
			const mAfter = getDragBlockCellMetrics(block);
			({ offsetX, offsetY } = computeShapeCenterOffsets(block._shape || shape, mAfter));
			setElPos(block, startX - offsetX, startY - offsetY - touchOffsetY);
		} catch (e) {}
	});
	  
	  activeBonusPlacement = {
		colorKey: 'purchased',
		pointerId: event.pointerId || null,
		sticky: false, // Direct plaatsen bij release
		shape: cloneShape(shape),
		purchasedPlacement: true
	  };
	  
	  startGlobalDragVisuals();
	  // Don't show rotate/mirror buttons for purchased placement (1x1 block doesn't need them)
	  // addCardControlButtons() is skipped for purchased placement
	}

	function clearPurchasedPlacement() {
	  window.hasPurchasedPlacement = false;
	  updateBuyPlacementButton();
	}

	function setDebugMode(enabled) {
		debugMode = !!enabled;
		document.body.classList.toggle('debug-mode', debugMode);
		const toggleBtn = document.getElementById('debug-mode-toggle');
		if (toggleBtn) {
			toggleBtn.classList.toggle('debug-active', debugMode);
			toggleBtn.setAttribute('aria-pressed', String(debugMode));
			toggleBtn.textContent = debugMode ? 'Debug modus: aan' : 'Debug modus: uit';
		}
		const clearBtn = document.getElementById('clear-board-btn');
		if (clearBtn) {
			clearBtn.disabled = !debugMode;
			if (debugMode) clearBtn.removeAttribute('aria-disabled');
			else clearBtn.setAttribute('aria-disabled', 'true');
			clearBtn.title = debugMode ? 'Leeg het bord en reset munten (debug)' : 'Debug modus vereist om het bord te legen';
		}
		localStorage.setItem('debugModeEnabled', debugMode ? 'true' : 'false');
	}

	function toggleDebugMode() {
		setDebugMode(!debugMode);
	}

	const deckModalLayer = document.getElementById('deck-modal-layer');
	const deckModalContent = document.getElementById('deck-modal-content');
	const deckModalTitle = document.getElementById('deck-modal-title');
	const deckModalSubtext = document.getElementById('deck-modal-subtext');
	const deckModalClose = document.getElementById('deck-modal-close');
	const deckPreviewEl = document.getElementById('deck-preview');
	const goldenUnlockLayer = document.getElementById('golden-unlock-layer');
	const goldenUnlockModal = document.getElementById('golden-unlock-modal');
	const goldenUnlockTitle = document.getElementById('golden-unlock-title');
	const goldenUnlockContent = document.getElementById('golden-unlock-content');
	const goldenUnlockSubtext = document.getElementById('golden-unlock-subtext');
	const DECK_MODAL_DEFAULT_TITLE = deckModalTitle ? deckModalTitle.textContent : 'Deckoverzicht';
	const GOLDEN_UNLOCK_DEFAULT_TITLE = goldenUnlockTitle ? goldenUnlockTitle.textContent : 'âœ¨ Kies je eerste gouden kaart';
	const GOLDEN_UNLOCK_DEFAULT_SUBTEXT = goldenUnlockSubtext ? goldenUnlockSubtext.innerHTML : 'Je hebt <strong>Gouden Kaarten</strong> ontgrendeld. Kies er 1 uit 3.';
	const blackHoleModalLayer = document.getElementById('blackhole-modal-layer');
	const blackHoleModal = document.getElementById('blackhole-modal');
	const blackHoleSubtext = document.getElementById('blackhole-modal-subtext');
	const blackHoleCardGrid = document.getElementById('blackhole-card-grid');
	const blackHoleSelectionCount = document.getElementById('blackhole-selection-count');
	const blackHoleSelectionLimit = document.getElementById('blackhole-selection-limit');
	const blackHoleRewardEl = document.getElementById('blackhole-reward');
	const blackHoleStakeInput = document.getElementById('blackhole-stake');
	const blackHoleStakeValueEl = document.getElementById('blackhole-stake-value');
	const blackHoleStakeMultEl = document.getElementById('blackhole-stake-mult');
	const blackHoleClaimBtn = document.getElementById('blackhole-claim-btn');
	const blackHoleForfeitBtn = document.getElementById('blackhole-forfeit-btn');
	const blackHoleFeedbackEl = document.getElementById('blackhole-feedback');
	let deckModalMode = 'default';
	let pendingLevel2UpgradeHandler = null;

	if (blackHoleStakeInput) {
		blackHoleStakeInput.addEventListener('input', () => {
			const maxStake = Math.max(0, Number(blackHoleStakeInput.max) || 10);
			const raw = Number(blackHoleStakeInput.value) || 0;
			const minStake = maxStake > 0 ? 1 : 0;
			blackHoleState.stake = Math.max(minStake, Math.min(maxStake, raw));
			updateBlackHoleSelectionUI();
		});
	}

	function createBonusEchoBadge(variantKey = 'replay', ready = false) {
		const badge = document.createElement('div');
		badge.classList.add('card-echo-badge');
		badge.dataset.variant = variantKey;
		badge.textContent = BONUS_ECHO_BADGE_TEXT[variantKey] || 'L2';
		if (ready) badge.classList.add('card-echo-badge--ready');
		return badge;
	}

	function attachBonusEchoTooltip(cardEl, variantKey = 'replay') {
		if (!cardEl) return null;
		const meta = getBonusEchoUiCopy(variantKey);
		const desc = meta?.desc || 'Level 2 kaart';
		cardEl.dataset.bonusEchoDesc = desc;
		let tooltip = cardEl.querySelector('.card-echo-tooltip');
		if (!tooltip) {
			tooltip = document.createElement('div');
			tooltip.className = 'card-echo-tooltip';
			tooltip.textContent = desc;
			cardEl.appendChild(tooltip);
		} else {
			tooltip.textContent = desc;
		}

		let hideTimer = null;
		const showTooltip = (durationMs = 1800) => {
			cardEl.classList.add('card-echo-tooltip-active');
			if (hideTimer) clearTimeout(hideTimer);
			hideTimer = window.setTimeout(() => {
				cardEl.classList.remove('card-echo-tooltip-active');
				hideTimer = null;
			}, durationMs);
		};
		const hideTooltip = () => {
			cardEl.classList.remove('card-echo-tooltip-active');
			if (hideTimer) {
				clearTimeout(hideTimer);
				hideTimer = null;
			}
		};

		const badge = cardEl.querySelector('.card-echo-badge');
		if (badge) {
			badge.setAttribute('aria-label', desc);
			badge.tabIndex = 0;
			const stop = (ev) => { ev.stopPropagation(); };
			badge.addEventListener('pointerdown', stop);
			badge.addEventListener('pointerup', (ev) => {
				stop(ev);
				showTooltip(2000);
			});
			badge.addEventListener('click', (ev) => {
				stop(ev);
				showTooltip(2000);
			});
			badge.addEventListener('keydown', (ev) => {
				if (ev.key === 'Enter' || ev.key === ' ') {
					ev.preventDefault();
					showTooltip(2000);
				}
			});
		}

		cardEl.addEventListener('pointerleave', hideTooltip);
		cardEl.addEventListener('blur', hideTooltip, true);
		return tooltip;
	}

	function buildDeckModalCard(blueprint, index, options = {}) {
	  if (!blueprint || !deckModalContent) return null;
	  const interactive = !!options.interactive;
	  const rows = Array.isArray(blueprint.matrix) ? blueprint.matrix.length : 0;
	  const cols = rows > 0 && Array.isArray(blueprint.matrix[0]) ? blueprint.matrix[0].length : 0;
		const card = document.createElement('div');
		card.classList.add('card', 'card-option', 'deck-modal-card');
		card.setAttribute('role', 'listitem');
		card.dataset.shapeCols = String(cols);
		card.dataset.shapeRows = String(rows);
		if (blueprint.blueprintId) card.dataset.blueprintId = blueprint.blueprintId;
		if (blueprint.shapeName) card.dataset.shapeName = blueprint.shapeName;
	  card.tabIndex = interactive ? 0 : -1;
	  card.style.cursor = interactive ? 'pointer' : 'default';
	  card.style.pointerEvents = 'auto';
	const isGolden = !!(blueprint.isGolden || blueprint.color?.isGolden);
	const isBonusEcho = !!blueprint.isBonusEcho;
	const isBonusBoost = !!blueprint.isBonusBoost;
	  const colorObj = cloneColor(blueprint.color || { name: '', code: '#cccccc' });
	  const displayName = getColorDisplayName(colorObj);
	  // Golden is a card modifier; do not paint the blocks gold.
	  if (isGolden) colorObj.isGolden = false;
	  card.dataset.golden = isGolden ? 'true' : 'false';
	if (isBonusEcho) card.classList.add('card-bonus-echo');
		const baseLabel = blueprint.shapeName || (displayName ? `${displayName} kaart` : 'Kaart');
		card.dataset.cardLabel = baseLabel;
		card.setAttribute('aria-label', baseLabel);
	  if (isGolden) card.classList.add('card-golden');
	if (isBonusBoost) card.classList.add('card-bonus-boost');
	  const pattern = document.createElement('div');
	  pattern.classList.add('card-pattern');
	  card.appendChild(pattern);
	  updateCardPattern(card, blueprint.matrix, colorObj);
	  const label = document.createElement('div');
	  label.classList.add('card-label');
	  const labelText = document.createElement('span');
	  if (isBonusEcho || isBonusBoost) {
			labelText.textContent = '';
			label.append(labelText);
	  } else {
			label.classList.add('card-label--empty');
	  }
	const meta = document.createElement('div');
	meta.classList.add('card-meta');
	if (isBonusEcho) {
		const variant = blueprint.bonusEchoVariant || 'replay';
		buildBonusEchoLabelMeta(label, meta, variant);
	} else if (isBonusBoost) {
		const colorKey = getBonusKeyFromColorName(colorObj?.name);
		buildBonusBoostLabelMeta(label, meta, colorKey);
	} else {
		meta.classList.add('card-meta--empty');
	}
	// Always add meta trigger, meta and label so hover-to-show-meta works
	// everywhere. CSS makes them position:absolute so they never push the pattern.
	const metaTrigger = document.createElement('div');
	metaTrigger.className = 'card-meta-trigger';
	card.append(metaTrigger, meta, label);
	attachCardMetaHover(card, [metaTrigger]);

	if (isBonusEcho) {
		const variant = blueprint.bonusEchoVariant || 'replay';
		attachBonusEchoTooltip(card, variant);
	}
	if (interactive && typeof options.onSelect === 'function') {
		card.addEventListener('click', () => options.onSelect(blueprint));
		card.addEventListener('keypress', (e) => {
			if (e.key === 'Enter' || e.key === ' ') {
				e.preventDefault();
				options.onSelect(blueprint);
			}
		});
	}
	  return card;
	}

	let handScrollControlsInitialized = false;

	function updateHandScrollControls() {
	  const container = document.getElementById('card-options');
	  const cardControls = document.getElementById('card-controls');
	  const leftBtn = document.getElementById('hand-scroll-left');
	  const rightBtn = document.getElementById('hand-scroll-right');
	  if (!container || !cardControls || !leftBtn || !rightBtn) return;

	  const isMobile = window.innerWidth <= MOBILE_BREAKPOINT;
	  if (!isMobile) {
		cardControls.classList.remove('hand-scroll-enabled');
		leftBtn.disabled = true;
		rightBtn.disabled = true;
		return;
	  }

	  // UX rule: only show arrows when there are 5+ cards in hand.
	  const cardCount = container.querySelectorAll('.card-option').length;
	  if (cardCount < 5) {
		cardControls.classList.remove('hand-scroll-enabled');
		leftBtn.disabled = true;
		rightBtn.disabled = true;
		return;
	  }

	  const canScroll = container.scrollWidth > (container.clientWidth + 4);
	  cardControls.classList.toggle('hand-scroll-enabled', canScroll);

	  if (!canScroll) {
		leftBtn.disabled = true;
		rightBtn.disabled = true;
		return;
	  }

	  const maxScrollLeft = Math.max(0, container.scrollWidth - container.clientWidth);
	  const current = container.scrollLeft;
	  leftBtn.disabled = current <= 1;
	  rightBtn.disabled = current >= (maxScrollLeft - 1);
	}

	function initHandScrollControls() {
	  if (handScrollControlsInitialized) return;
	  handScrollControlsInitialized = true;

	  const container = document.getElementById('card-options');
	  const leftBtn = document.getElementById('hand-scroll-left');
	  const rightBtn = document.getElementById('hand-scroll-right');
	  if (!container || !leftBtn || !rightBtn) return;

	  const getScrollDelta = () => {
		const firstCard = container.querySelector('.card-option');
		const cardWidth = firstCard ? firstCard.getBoundingClientRect().width : 110;
		const gapRaw = getComputedStyle(container).gap || '0px';
		const gap = parseFloat(gapRaw) || 0;
		return Math.max(48, Math.round(cardWidth + gap));
	  };

	  leftBtn.addEventListener('click', (e) => {
		e.preventDefault();
		if (leftBtn.disabled) return;
		container.scrollBy({ left: -getScrollDelta(), behavior: 'smooth' });
	  });

	  rightBtn.addEventListener('click', (e) => {
		e.preventDefault();
		if (rightBtn.disabled) return;
		container.scrollBy({ left: getScrollDelta(), behavior: 'smooth' });
	  });

	  const onHandScroll = rafThrottle(() => {
		updateHandScrollControls();
	  });
	  container.addEventListener('scroll', onHandScroll, { passive: true });
	}

	function populateDeckModalContent() {
	  if (!deckModalContent) return;
	  deckModalContent.innerHTML = '';
	  const total = ownedDeckBlueprints.length;
	  // Respect scenario restrictions when present.
	  const allowedColors = Array.isArray(window.scenarioAllowedColors) ? window.scenarioAllowedColors : null;
	  if (deckModalSubtext) {
		deckModalSubtext.textContent = total === 1
		  ? 'Je hebt 1 kaart in je deck'
		  : `Je hebt ${total} kaarten in je deck`;
	  }
	  if (total === 0) {
		const empty = document.createElement('div');
		empty.classList.add('deck-modal-empty');
		empty.textContent = 'Je deck is leeg. Koop of verdien nieuwe kaarten om ze hier te zien.';
		deckModalContent.appendChild(empty);
		return;
	  }
		const getDeckKeyFromMatrix = matrix => {
			try {
				return JSON.stringify(matrix || []);
			} catch {
				return '[]';
			}
		};
		const getDeckSignature = (category, matrix, color, isGolden) => {
			// IMPORTANT: Use a deterministic signature that survives refresh/save/load.
			// We intentionally do NOT include blueprintId, shapeName, or color.code here,
			// because those can change or be missing across sessions.
			const safeColor = color || {};
			const golden = !!(isGolden || safeColor.isGolden);
			return [
				category || '',
				getDeckKeyFromMatrix(matrix),
				safeColor.name || '',
				golden ? 'gold' : 'normal'
			].join('|');
		};
		const getBlueprintKey = blueprint => {
			if (!blueprint) return 'sig|';
			return `sig|${getDeckSignature(blueprint.category, blueprint.matrix, blueprint.color, blueprint.isGolden)}`;
		};
		const getCardKey = card => {
			if (!card) return 'sig|';
			return `sig|${getDeckSignature(card.category, card.matrix, card.color, card.isGolden)}`;
		};
		const buildCountMap = (arr, keyFn) => {
			const map = new Map();
			(arr || []).forEach(item => {
				const k = keyFn(item);
				map.set(k, (map.get(k) || 0) + 1);
			});
			return map;
		};
		const dec = (map, key) => {
			const cur = map.get(key) || 0;
			if (cur <= 1) map.delete(key);
			else map.set(key, cur - 1);
		};
		// Use a filtered draw pile for availability calculations so inactive colors
		// (restricted by scenarios) are treated as 'not in draw'.
		const filteredDrawPile = allowedColors
			? drawPile.filter(c => c && (allowedColors.includes((c.color && c.color.name) || '') || (c.color && c.color.name) === 'multikleur'))
			: drawPile;
		const remainingCounts = buildCountMap(filteredDrawPile, getCardKey);
		const handCounts = buildCountMap(currentHand, getCardKey);
		const discardCounts = buildCountMap(discardPile, getCardKey);
		const statusOrder = {
			'available': 0,
			'in-hand': 1,
			'used': 2,
			'discarded': 3,
			'inactive': 99
		};
		const orderedBlueprints = ownedDeckBlueprints
			.map((blueprint, index) => {
				const key = getBlueprintKey(blueprint);
				let status = 'available';
				// If scenario restrictions exist, mark blueprints whose base color is
				// not allowed as 'inactive' so they are shown but marked unusable.
				const bpColorName = (blueprint && blueprint.color && blueprint.color.name) || '';
				const isBpAllowed = !allowedColors || allowedColors.includes(bpColorName) || bpColorName === 'multikleur';
				if (!isBpAllowed) {
					status = 'inactive';
				}
				let isInHand = false;
				let isInDrawPile = false;
				let isDiscarded = false;

				// IMPORTANT: Use counts so duplicates don't all get flagged.
				if ((handCounts.get(key) || 0) > 0) {
					status = 'in-hand';
					isInHand = true;
					dec(handCounts, key);
				} else if ((remainingCounts.get(key) || 0) > 0) {
					status = 'available';
					isInDrawPile = true;
					dec(remainingCounts, key);
				} else if ((discardCounts.get(key) || 0) > 0) {
					status = 'discarded';
					isDiscarded = true;
					dec(discardCounts, key);
				} else {
					status = 'used';
				}

				const sortKey = statusOrder[status] ?? 99;
				return { blueprint, index, status, isInDrawPile, isInHand, isDiscarded, sortKey };
			})
			.sort((a, b) => {
				if (a.sortKey !== b.sortKey) return a.sortKey - b.sortKey;
				return a.index - b.index;
			});
		orderedBlueprints.forEach(entry => {
			const { blueprint, index, status } = entry;
			const card = buildDeckModalCard(blueprint, index);
			if (!card) return;
			const baseLabel = card.dataset.cardLabel || blueprint.shapeName || 'Kaart';
			let statusText = 'Nog in deck';
			switch (status) {
				case 'in-hand':
					card.classList.add('deck-modal-card--depleted', 'deck-modal-card--in-hand');
					statusText = 'Nu in je hand';
					break;
				case 'available':
					statusText = 'Nog in deck';
					break;
				case 'inactive':
					card.classList.add('deck-modal-card--inactive');
					statusText = 'Niet bruikbaar voor dit niveau!';
					// Add an explicit badge element so it displays reliably over the card preview.
					try {
						const badge = document.createElement('div');
						badge.className = 'deck-modal-inactive-badge';
						badge.textContent = '?';
						// Avoid adding badge on multikleur cards (they have their own mark)
						const label = (card.dataset.cardLabel || '').toLowerCase();
						const isRainbow = (blueprint?.color?.name === 'multikleur') || label.includes('multikleur') || label.includes('rainbow') || label.includes('multi');
						if (!isRainbow) card.appendChild(badge);
					} catch (e) {}
					break;
				case 'used':
					card.classList.add('deck-modal-card--depleted');
					statusText = 'Al getrokken';
					break;
				case 'discarded':
					card.classList.add('deck-modal-card--depleted');
					statusText = 'Al gespeeld';
					break;
			}
			card.dataset.cardStatus = status;
			card.setAttribute('aria-label', `${baseLabel} â€“ ${statusText}`);
			card.title = `${baseLabel} â€¢ ${statusText}`;
			deckModalContent.appendChild(card);
		});
	  applyCardSizing();
	  deckModalContent.scrollTop = 0;
	}

	function openDeckModal() {
	  if (!deckModalLayer) return;
	  deckModalMode = 'default';
	  if (deckModalTitle) deckModalTitle.textContent = DECK_MODAL_DEFAULT_TITLE;
	  if (deckModalSubtext) deckModalSubtext.textContent = '';
	  populateDeckModalContent();
	  deckModalLayer.classList.add('show');
	  deckModalLayer.setAttribute('aria-hidden', 'false');
	}

	function closeDeckModal() {
	  if (deckModalLayer) {
		deckModalLayer.classList.remove('show');
		deckModalLayer.setAttribute('aria-hidden', 'true');
	  }
	  deckModalMode = 'default';
	  pendingLevel2UpgradeHandler = null;
	  if (deckModalTitle) deckModalTitle.textContent = DECK_MODAL_DEFAULT_TITLE;
	  if (deckPreviewEl) deckPreviewEl.focus();
	}

	function handleLevel2UpgradePick(blueprint) {
		if (deckModalMode === 'level2-upgrade' && typeof pendingLevel2UpgradeHandler === 'function') {
			pendingLevel2UpgradeHandler(blueprint);
		}
		pendingLevel2UpgradeHandler = null;
		deckModalMode = 'default';
		closeDeckModal();
	}

	function openLevel2UpgradeModal(candidates, onSelect, variantKey = null) {
		if (!deckModalLayer || !deckModalContent) return;
		deckModalMode = 'level2-upgrade';
		pendingLevel2UpgradeHandler = onSelect;
		deckModalContent.innerHTML = '';
		deckModalContent.classList.add('deck-modal-grid');
		const resolvedVariant = variantKey || shopLevel2Variant || pickBonusEchoVariant();
		const variantMeta = getBonusEchoUiCopy(resolvedVariant);
		const variantLabel = (variantMeta?.sub || resolvedVariant).toUpperCase();
		const variantDesc = variantMeta?.desc || 'Level 2 upgrade.';
		if (deckModalTitle) deckModalTitle.textContent = `Level 2 upgrade â€¢ ${variantLabel}`;
		if (deckModalSubtext) deckModalSubtext.textContent = `Type: ${variantLabel} â€” ${variantDesc} Kies een kaart zonder Level 2 upgrade.`;
		if (!Array.isArray(candidates) || candidates.length === 0) {
			const empty = document.createElement('p');
			empty.className = 'deck-modal-empty';
			empty.textContent = 'Alle kaarten hebben al een Level 2 upgrade.';
			deckModalContent.appendChild(empty);
			deckModalLayer.classList.add('show');
			deckModalLayer.setAttribute('aria-hidden', 'false');
			return;
		}
		candidates.forEach((bp, idx) => {
			const card = buildDeckModalCard(bp, idx, { interactive: true, onSelect: handleLevel2UpgradePick });
			if (card) deckModalContent.appendChild(card);
		});
		applyCardSizing();
		deckModalContent.scrollTop = 0;
		deckModalLayer.classList.add('show');
		deckModalLayer.setAttribute('aria-hidden', 'false');
	}

	function buildGoldenUnlockChoices(count = 3) {
		const candidates = shapePool.filter(e => e && (e.category === 'mini' || e.category === 'standard'));
		const pool = candidates.length ? shuffleArray([...candidates]) : shuffleArray([...shapePool]);
		const picks = pool.slice(0, Math.max(1, count));
		const palette = NON_WILDCARD_COLORS.length ? NON_WILDCARD_COLORS : colors;
		return picks.map(entry => {
			const baseColor = palette[Math.floor(Math.random() * palette.length)];
			const color = cloneColor(baseColor);
			const blueprint = createCardBlueprint(entry, color, { isGolden: true });
			return { blueprint, card: instantiateBlueprint(blueprint) };
		});
	}

	function setGoldenUnlockModalCopy(titleText, subtextHtml) {
		if (goldenUnlockTitle && typeof titleText === 'string') goldenUnlockTitle.textContent = titleText;
		if (goldenUnlockSubtext && typeof subtextHtml === 'string') goldenUnlockSubtext.innerHTML = subtextHtml;
	}

	function restoreGoldenUnlockModalCopy() {
		setGoldenUnlockModalCopy(GOLDEN_UNLOCK_DEFAULT_TITLE, GOLDEN_UNLOCK_DEFAULT_SUBTEXT);
	}

	function buildRewardChoices({ count = 3, filterFn = null, color = null, colorsPalette = null, blueprintOptions = null } = {}) {
		const fallbackColor = color || { name: 'grijs', code: '#a0a0a0' };
		const palette = Array.isArray(colorsPalette) && colorsPalette.length ? colorsPalette : null;
		const candidates = shapePool.filter(e => {
			if (!e || !e.matrix) return false;
			if (typeof filterFn === 'function' && !filterFn(e)) return false;
			return true;
		});
		const pool = candidates.length ? shuffleArray([...candidates]) : shuffleArray([...shapePool]);
		const picks = pool.slice(0, Math.max(1, count));
		return picks.map(entry => {
			const chosenColor = palette ? cloneColor(palette[Math.floor(Math.random() * palette.length)]) : fallbackColor;
			const extras = blueprintOptions ? { ...blueprintOptions } : undefined;
			if (extras && extras.isBonusEcho && !extras.bonusEchoVariant) {
				extras.bonusEchoVariant = pickBonusEchoVariant();
			}
			const blueprint = createCardBlueprint(entry, chosenColor, extras || undefined);
			return { blueprint, card: instantiateBlueprint(blueprint) };
		});
	}

	function populateRewardPickerModal(choices, onPick) {
		if (!goldenUnlockContent) return;
		goldenUnlockContent.innerHTML = '';
		goldenUnlockContent.classList.remove('selection-disabled');
		(choices || []).forEach(({ blueprint, card }) => {
			const el = createCardElement(card, true, {
				onSelect: (pickedCard) => {
					if (goldenUnlockContent.classList.contains('selection-disabled')) return;
					goldenUnlockContent.classList.add('selection-disabled');
					try {
						if (typeof onPick === 'function') onPick({ blueprint, card: pickedCard });
					} catch (err) {
						console.error('Reward selection failed:', err);
						goldenUnlockContent.classList.remove('selection-disabled');
						showObjectiveToast('âš ï¸ Kon selectie niet verwerken. Probeer opnieuw.');
					}
				}
			});
			el.setAttribute('role', 'listitem');
			el.tabIndex = 0;
			goldenUnlockContent.appendChild(el);
		});
		applyCardSizing();
		goldenUnlockContent.scrollTop = 0;
	}

	function showRewardPickerModal({ titleText, subtextHtml, choices, onPick }) {
		if (!goldenUnlockLayer) return;
		setGoldenUnlockModalCopy(titleText, subtextHtml);
		populateRewardPickerModal(choices, onPick);
		goldenUnlockLayer.classList.add('show');
		goldenUnlockLayer.setAttribute('aria-hidden', 'false');
		if (goldenUnlockModal) goldenUnlockModal.focus();
	}

	function grantPickedBlueprintReward({ blueprint, card }) {
		ownedDeckBlueprints.push(blueprint);
		currentHand.push(card);
		updateDeckPreview();
		saveGameState();
		renderCurrentHand();
	}

	function openMulticolorRewardPicker() {
		const rainbowColor = { name: 'multikleur', code: 'rainbow' };
		const choices = buildRewardChoices({
			count: 3,
			filterFn: (e) => e && (e.category === 'mini' || e.category === 'standard' || e.category === 'large'),
			color: rainbowColor
		});
		showRewardPickerModal({
			titleText: 'ðŸŒˆ Kies je multikleur kaart',
			subtextHtml: 'Je hebt <strong>Multikleur Kaarten</strong> ontgrendeld. Kies er 1 uit 3.',
			choices,
			onPick: ({ blueprint, card }) => {
				grantPickedBlueprintReward({ blueprint, card });
				closeGoldenUnlockModal();
				restoreGoldenUnlockModalCopy();
			}
		});
	}

	function buildFixedShapeRewardChoices(shapes, count = 3) {
		const list = Array.isArray(shapes) ? shapes.filter(s => s && s.matrix) : [];
		if (!list.length) return buildRewardChoices({ count });
		const palette = NON_WILDCARD_COLORS.length ? NON_WILDCARD_COLORS : colors;
		const pool = shuffleArray(list.map(entry => ({
			name: entry.name,
			matrix: cloneShape(entry.matrix),
			category: 'large'
		})));
		const picks = [];
		while (pool.length && picks.length < count) picks.push(pool.shift());
		while (picks.length < count) {
			picks.push(list[Math.floor(Math.random() * list.length)]);
		}
		return picks.map(entry => {
			const baseColor = palette[Math.floor(Math.random() * palette.length)] || { name: 'grijs', code: '#a0a0a0' };
			const color = cloneColor(baseColor);
			const blueprint = createCardBlueprint(entry, color);
			return { blueprint, card: instantiateBlueprint(blueprint) };
		});
	}

	function openXLRewardPicker(sizeKey = 'xl') {
		const isXXL = String(sizeKey).toLowerCase() === 'xxl';
		const label = isXXL ? 'XXL' : 'XL';
		const shapes = isXXL ? EXTRA_LARGE_7_SHAPES : XL_6_SHAPES;
		const choices = buildFixedShapeRewardChoices(shapes, 3);
		showRewardPickerModal({
			titleText: `ðŸ§± Kies je ${label} kaart`,
			subtextHtml: `Je hebt <strong>${label} blokken</strong> ontgrendeld. Kies 1 uit 3.`,
			choices,
			onPick: ({ blueprint, card }) => {
				grantPickedBlueprintReward({ blueprint, card });
				closeGoldenUnlockModal();
				restoreGoldenUnlockModalCopy();
			}
		});
	}

	function startMini34RewardSequence() {
		const steps = 3;
		let step = 1;
		const colorPalette = NON_WILDCARD_COLORS.length ? NON_WILDCARD_COLORS : colors;
		const pickColor = () => {
			const base = colorPalette[Math.floor(Math.random() * colorPalette.length)] || { name: 'grijs', code: '#a0a0a0' };
			return cloneColor(base);
		};
		const filterMini34 = (e) => {
			if (!e || !e.matrix) return false;
			const blocks = (typeof countShapeBlocks === 'function') ? countShapeBlocks(e.matrix) : null;
			if (!Number.isFinite(blocks)) return (e.category === 'mini' || e.category === 'standard');
			return blocks <= 3;
		};
		const showStep = () => {
			const choices = buildRewardChoices({
				count: 3,
				filterFn: filterMini34,
				colorsPalette: colorPalette
			});
			showRewardPickerModal({
				titleText: `ðŸ§© Kies je mini-kaart (${step}/${steps})`,
				subtextHtml: 'Je koopt een <strong>mini pakket</strong> (max. 3 blokjes). Kies 3 kaarten (telkens 1 uit 3).',
				choices,
				onPick: ({ blueprint, card }) => {
					grantPickedBlueprintReward({ blueprint, card });
					step += 1;
					if (step > steps) {
						closeGoldenUnlockModal();
						restoreGoldenUnlockModalCopy();
						return;
					}
					setTimeout(showStep, 60);
				}
			});
		};
		showStep();
	}

	function startStarterMiniRewardSequence(onComplete) {
		const steps = 3;
		let step = 1;
		const colorPalette = NON_WILDCARD_COLORS.length ? NON_WILDCARD_COLORS : colors;
		const filterMiniTiny = (e) => {
			if (!e || !e.matrix) return false;
			const blocks = (typeof countShapeBlocks === 'function') ? countShapeBlocks(e.matrix) : null;
			if (!Number.isFinite(blocks)) return (e.category === 'mini' || e.category === 'standard');
			return blocks <= 3;
		};
		const grantToDeck = (blueprint) => {
			ownedDeckBlueprints.push(blueprint);
			updateDeckPreview();
			saveGameState();
		};
		const showStep = () => {
			const choices = buildRewardChoices({
				count: 3,
				filterFn: filterMiniTiny,
				colorsPalette: colorPalette
			});
			showRewardPickerModal({
				titleText: `ðŸ§© Startpakket kaart (${step}/${steps})`,
				subtextHtml: 'Kies 1 uit 3 compacte kaarten (max. 3 blokjes). Je krijgt drie keuzes aan het begin van een wereld.',
				choices,
				onPick: ({ blueprint }) => {
					grantToDeck(blueprint);
					step += 1;
					if (step > steps) {
						closeGoldenUnlockModal();
						restoreGoldenUnlockModalCopy();
						if (typeof onComplete === 'function') onComplete();
						return;
					}
					setTimeout(showStep, 60);
				}
			});
		};
		showStep();
	}

	function populateGoldenUnlockModal() {
		if (!goldenUnlockContent) return;
		goldenUnlockContent.innerHTML = '';
		goldenUnlockContent.classList.remove('selection-disabled');
		const choices = buildGoldenUnlockChoices(3);
		choices.forEach(({ blueprint, card }) => {
			const el = createCardElement(card, true, {
				onSelect: (pickedCard) => {
					// Safety: prevent double selection (double-click / mobile tap quirks).
					if (goldenUnlockContent.classList.contains('selection-disabled')) return;
					goldenUnlockContent.classList.add('selection-disabled');
					// Permanent reward: add the picked golden card to your owned deck (and keep it in future saves).
					try {
						ownedDeckBlueprints.push(blueprint);
						// Immediate reward: also give an instantiated copy right now.
						currentHand.push(pickedCard);
						updateDeckPreview();
						saveGameState();
						renderCurrentHand();
						closeGoldenUnlockModal();
					} catch (err) {
						console.error('Golden card selection failed:', err);
						goldenUnlockContent.classList.remove('selection-disabled');
						showObjectiveToast('âš ï¸ Kon gouden kaart niet opslaan. Probeer opnieuw.');
					}
				}
			});
			el.setAttribute('role', 'listitem');
			el.tabIndex = 0;
			goldenUnlockContent.appendChild(el);
		});
		applyCardSizing();
		goldenUnlockContent.scrollTop = 0;
	}

	function openGoldenUnlockModal() {
		if (!goldenUnlockLayer) return;
		// Only meaningful if the upgrade is unlocked.
		if (!hasUpgrade('goldenCards')) return;
		restoreGoldenUnlockModalCopy();
		populateGoldenUnlockModal();
		goldenUnlockLayer.classList.add('show');
		goldenUnlockLayer.setAttribute('aria-hidden', 'false');
		if (goldenUnlockModal) {
			goldenUnlockModal.focus();
		}
	}

	function closeGoldenUnlockModal() {
		if (!goldenUnlockLayer) return;
		goldenUnlockLayer.classList.remove('show');
		goldenUnlockLayer.setAttribute('aria-hidden', 'true');
	}

	function showBlackHoleFeedback(message = '', tone = 'info', duration = 2000) {
	  if (!blackHoleFeedbackEl) return;
	  blackHoleFeedbackEl.textContent = message;
	  blackHoleFeedbackEl.dataset.tone = tone;
	  blackHoleFeedbackEl.classList.toggle('show', !!message);
	  if (blackHoleState.feedbackTimeout) {
		clearTimeout(blackHoleState.feedbackTimeout);
		blackHoleState.feedbackTimeout = null;
	  }
	  if (message && duration > 0) {
		blackHoleState.feedbackTimeout = setTimeout(() => {
		  blackHoleFeedbackEl.textContent = '';
		  blackHoleFeedbackEl.classList.remove('show');
		  blackHoleState.feedbackTimeout = null;
		}, duration);
	  }
	}

	function generateBlackHoleCards(count = BLACK_HOLE_CARD_COUNT) {
	  const cards = [];
	  const randInt = (min, max) => (min + Math.floor(Math.random() * (max - min + 1)));
	  // 1 Black Hole
	  cards.push({ type: 'blackhole', value: 0, label: 'âš«' });
	  
	  // 2 Multipliers
	  cards.push({ type: 'multiplier', value: 2, label: 'x2' });
	  cards.push({ type: 'multiplier', value: 2, label: 'x2' });
	  
	  // Remaining are small rewards: mostly 1-10 points, sometimes 1-3 coins.
	  const remaining = count - 3;
	  for (let i = 0; i < remaining; i++) {
		const roll = Math.random();
		if (roll < 0.18) {
			const coins = Math.random() < 0.65 ? 1 : (Math.random() < 0.85 ? 2 : 3);
			cards.push({ type: 'coins', value: coins, label: `<span class="coin-symbol">ðŸª™</span>+${coins}` });
		} else {
			const points = randInt(1, 10);
			cards.push({ type: 'points', value: points, label: `+${points}` });
		}
	  }
	  
	  return shuffleArray(cards);
	}

	function buildBlackHoleModalCard(cardData, index) {
	  if (!cardData) return null;
	  const card = document.createElement('div');
	  card.classList.add('card', 'blackhole-card');
	  card.dataset.cardIndex = String(index);
	  card.tabIndex = 0;

	  const inner = document.createElement('div');
	  inner.classList.add('blackhole-card-inner');
	  const front = document.createElement('div');
	  front.classList.add('blackhole-card-face', 'blackhole-card-front');
	  front.textContent = '?';
	  const back = document.createElement('div');
	  back.classList.add('blackhole-card-face', 'blackhole-card-back');
	  inner.appendChild(front);
	  inner.appendChild(back);
	  card.appendChild(inner);
	  
	  card.addEventListener('click', () => handleBlackHoleCardClick(index));
	  card.addEventListener('keydown', event => {
		if (event.key === 'Enter' || event.key === ' ') {
		  event.preventDefault();
		  handleBlackHoleCardClick(index);
		}
	  });
	  return card;
	}

	function revealCardVisuals(card, cardData) {
		if (!card || !cardData) return;
		const back = card.querySelector('.blackhole-card-back');
		if (back) back.innerHTML = cardData.label;
		card.classList.add('is-revealed');
		card.classList.remove('blackhole-card--points', 'blackhole-card--coins', 'blackhole-card--multiplier', 'blackhole-card--blackhole');
		card.classList.add(`blackhole-card--${cardData.type}`);
		card.style.cursor = 'default';
	}

	function renderBlackHoleCards() {
	  if (!blackHoleCardGrid) return;
	  blackHoleCardGrid.innerHTML = '';
	  blackHoleCardGrid.style.display = 'grid';
	  blackHoleCardGrid.style.gridTemplateColumns = 'repeat(5, 1fr)';
	  blackHoleCardGrid.style.gap = '8px';
	  
	  blackHoleState.cards.forEach((cardData, index) => {
		const card = buildBlackHoleModalCard(cardData, index);
		if (!card) return;
		if (blackHoleState.selected.has(index)) {
			revealCardVisuals(card, cardData);
		}
		blackHoleCardGrid.appendChild(card);
	  });
	}

	function updateBlackHoleSelectionStyles() {
		// No-op
	}

	function getBlackHoleStakeMultiplier(stake) {
		const s = Math.max(0, Math.min(10, Number(stake) || 0));
		// Map 0..10 stake -> 1..5 multiplier (0 means no stake).
		// 0-2 => x1, 3-4 => x2, 5-6 => x3, 7-8 => x4, 9-10 => x5
		if (s <= 2) return 1;
		return 1 + Math.floor((s - 1) / 2);
	}

	function syncBlackHoleStakeUI() {
		const stake = Math.max(0, Number(blackHoleState.stake) || 0);
		const mult = getBlackHoleStakeMultiplier(stake);
		if (blackHoleStakeInput) blackHoleStakeInput.value = String(stake);
		if (blackHoleStakeValueEl) blackHoleStakeValueEl.textContent = String(stake);
		if (blackHoleStakeMultEl) blackHoleStakeMultEl.textContent = String(mult);
	}

	function updateBlackHoleSelectionUI() {
	  const selectionSize = blackHoleState.selected.size;
	  const reward = Math.max(0, blackHoleState.reward || 0);
	  const coins = blackHoleState.coins || 0;
	  const stake = Math.max(0, Number(blackHoleState.stake) || 0);
	  const mult = getBlackHoleStakeMultiplier(stake);
	  const rewardWithStake = reward * mult;
	  
	  if (blackHoleSelectionCount) blackHoleSelectionCount.textContent = String(selectionSize);
	  if (blackHoleSelectionLimit) blackHoleSelectionLimit.textContent = String(BLACK_HOLE_CARD_COUNT);
	  if (blackHoleRewardEl) blackHoleRewardEl.textContent = String(rewardWithStake);
	  syncBlackHoleStakeUI();
	  
	  if (blackHoleClaimBtn) {
		blackHoleClaimBtn.disabled = selectionSize === 0 || blackHoleState.gameOver;
		blackHoleClaimBtn.textContent = blackHoleState.gameOver 
			? 'Game Over' 
			: (selectionSize === 0 ? 'Kies een kaart' : (coins > 0 ? `Claim +${rewardWithStake} (+${coins}ðŸª™)` : `Claim +${rewardWithStake}`));
	  }
	}

	function ensureBoardVisibleAfterBlackHole() {
		try {
			document.body.classList.remove('blackhole-open');
			const board = document.getElementById('board');
			if (board && board.style.display === 'none') {
				board.style.display = '';
			}
		} catch (_) {}
	}

	function handleBlackHoleCardClick(index) {
	  if (blackHoleState.gameOver) return;
	  if (typeof index !== 'number' || !blackHoleState.cards[index]) return;
	  if (blackHoleState.selected.has(index)) return;

	  const cardData = blackHoleState.cards[index];
	  blackHoleState.selected.add(index);
	  
	  const cardEl = blackHoleCardGrid.children[index];
	  if (cardEl) revealCardVisuals(cardEl, cardData);
	  const triggerBlackHoleEffect = (effect) => {
		if (!blackHoleModal || !effect) return;
		blackHoleModal.classList.remove('effect-pulse', 'effect-spark', 'effect-shake');
		void blackHoleModal.offsetWidth;
		blackHoleModal.classList.add(effect);
		setTimeout(() => {
			try { blackHoleModal.classList.remove(effect); } catch (_) {}
		}, 700);
	  };

	  if (cardData.type === 'blackhole') {
		blackHoleState.reward = 0;
		blackHoleState.coins = 0;
		blackHoleState.gameOver = true;
		const penalty = Math.min(getSpendableCoinCount(), TRAP_PENALTY || 5);
		for (let i = 0; i < penalty; i++) removeCoin();
		showBlackHoleFeedback(penalty > 0 ? `âš« ZWART GAT! -${penalty}ðŸª™` : 'âš« ZWART GAT!', 'warn');
		triggerBlackHoleEffect('effect-shake');
		
		// Reveal all
		blackHoleState.cards.forEach((c, i) => {
			if (!blackHoleState.selected.has(i)) {
				const el = blackHoleCardGrid.children[i];
				if (el) revealCardVisuals(el, c);
			}
		});
		
		const forfeitBtn = document.getElementById('blackhole-forfeit-btn');
		if (forfeitBtn) forfeitBtn.textContent = 'Sluiten';
		
	  } else if (cardData.type === 'multiplier') {
		blackHoleState.reward *= cardData.value;
		showBlackHoleFeedback(`Bonus x${cardData.value}!`, 'info');
		triggerBlackHoleEffect('effect-spark');
	  } else if (cardData.type === 'coins') {
		blackHoleState.coins = (blackHoleState.coins || 0) + (Number(cardData.value) || 0);
		showBlackHoleFeedback(`+${cardData.value}ðŸª™`, 'info');
		triggerBlackHoleEffect('effect-pulse');
	  } else {
		blackHoleState.reward += cardData.value;
		showBlackHoleFeedback(`+${cardData.value} punten`, 'info');
		triggerBlackHoleEffect('effect-pulse');
	  }

	  updateBlackHoleSelectionUI();
	}

	function openBlackHoleChallenge(trapRecord) {
	  if (!blackHoleModalLayer || !blackHoleModal) return;
	  try { saveGameState(); lastBlackHoleAutosave = Date.now(); } catch (_) {}
	  resetBlackHoleState();
	  blackHoleState.trap = trapRecord;
	  blackHoleState.cards = generateBlackHoleCards();
	  
	  if (blackHoleSubtext) {
		blackHoleSubtext.textContent = `Draai kaarten om voor punten. Pas op voor het Zwarte Gat! (Stoppen of zwart gat: âˆ’${TRAP_PENALTY}ðŸª™)`;
	  }

	  // Stake UI (optional): 0..10 coins, scaled multiplier x1..x5.
	  const coinsAvailable = getSpendableCoinCount();
	  const maxStake = Math.max(0, Math.min(10, coinsAvailable));
	  blackHoleState.stake = maxStake > 0 ? 1 : 0;
	  if (blackHoleStakeInput) {
		blackHoleStakeInput.max = String(maxStake);
		blackHoleStakeInput.min = maxStake > 0 ? '1' : '0';
		blackHoleStakeInput.disabled = maxStake <= 0;
	  }
	  syncBlackHoleStakeUI();
	  
	  const forfeitBtn = document.getElementById('blackhole-forfeit-btn');
	  if (forfeitBtn) forfeitBtn.textContent = 'Stop';
	  
	  renderBlackHoleCards();
	  updateBlackHoleSelectionUI();
	  showBlackHoleFeedback('ðŸŒ€ Tijd voor bonuspunten!');
	  blackHoleModalLayer.classList.add('show');
	  blackHoleModalLayer.setAttribute('aria-hidden', 'false');
	  document.body.classList.add('blackhole-open');
	  if (blackHoleModal.focus) {
		setTimeout(() => blackHoleModal.focus(), 80);
	  }
	}

	function closeBlackHoleModal() {
	  if (!blackHoleModalLayer) return;
	  blackHoleModalLayer.classList.remove('show');
	  blackHoleModalLayer.setAttribute('aria-hidden', 'true');
	  ensureBoardVisibleAfterBlackHole();
	  showBlackHoleFeedback('');
	  resetBlackHoleState();
	}

	function claimBlackHoleReward() {
	  const baseReward = Math.max(0, blackHoleState.reward || 0);
	  const coinsReward = Math.max(0, blackHoleState.coins || 0);
	  const stake = Math.max(0, Number(blackHoleState.stake) || 0);
	  const mult = getBlackHoleStakeMultiplier(stake);
	  const reward = baseReward * mult;
	  const trapRecord = blackHoleState.trap;
	  if ((baseReward <= 0 && coinsReward <= 0) || !trapRecord) {
		showBlackHoleFeedback('Selecteer eerst kaarten', 'warn');
		return;
	  }
	  if (stake > 0) {
		const coinsAvailable = getSpendableCoinCount();
		if (coinsAvailable < stake) {
			showBlackHoleFeedback('Niet genoeg munten voor deze inzet.', 'warn');
			return;
		}
		if (!spendCoins(stake)) {
			showBlackHoleFeedback('Inzet kon niet worden afgeschreven.', 'warn');
			return;
		}
	  }
	  if (reward > 0) {
			const zoneId = trapRecord?.zoneId || trapRecord?.cell?.dataset?.zoneId || '';
			const colorKey = getTrapColorKey(zoneId);
			if (colorKey && colorKey !== 'other') {
				colorScoreBonuses[colorKey] = Number(colorScoreBonuses[colorKey] || 0) + reward;
			} else {
				// Fallback: add to any available color bonus bucket
				colorScoreBonuses.yellow = Number(colorScoreBonuses.yellow || 0) + reward;
			}
	  }
	  if (coinsReward > 0) {
		for (let i = 0; i < coinsReward; i++) addCoin();
	  }
	  const stakeLabel = stake > 0 ? ` (inzet ${stake}ðŸª™ Ã—${mult})` : '';
	  showObjectiveToast(coinsReward > 0 ? `ðŸŒ€ Bonus +${reward} en +${coinsReward}ðŸª™!${stakeLabel}` : `ðŸŒ€ Bonus +${reward}!${stakeLabel}`);
	  closeBlackHoleModal();
	  updateScore();
	  try { if (lastBlackHoleAutosave) saveGameState(); } catch (_) {}
	}

	function forfeitBlackHoleChallenge() {
	  if (!blackHoleState.gameOver) {
		const penalty = Math.min(getSpendableCoinCount(), TRAP_PENALTY || 5);
		for (let i = 0; i < penalty; i++) removeCoin();
		if (penalty > 0) showObjectiveToast(`ðŸŒ€ Gestopt: -${penalty}ðŸª™`);
	  }
	  closeBlackHoleModal();
	  updateScore();
	  try { if (lastBlackHoleAutosave) saveGameState(); } catch (_) {}
	}

	function updateDeckPreview() {
	  const deckCount = document.querySelector('.deck-count');
	  const deckPreview = document.getElementById('deck-preview');
	  if (deckCount) {
		// UX request: show turns remaining instead of raw cards.
		// Assumption: a "turn" consumes 3 cards from the draw pile.
		const remainingCards = drawPile.length;
		const turnsRemaining = Math.ceil(remainingCards / 3);
		deckCount.textContent = turnsRemaining;
		deckCount.setAttribute('data-deck-count', turnsRemaining);
		if (deckPreview) {
			deckPreview.title = `Beurten over: ${turnsRemaining}`;
		}
	  }
	  if (deckModalLayer && deckModalLayer.classList.contains('show')) {
		populateDeckModalContent();
	  }
	}

	function spendCoins(amount) {
	  const coins = Array.from(document.querySelectorAll('#collected-coins .coin.active'));
	  if (coins.length < amount) return false;
	  coins.slice(0, amount).forEach(coin => {
		coin.classList.remove('active');
		coin.classList.add('used');
	  });
	  updateCoinCounter();
	  return true;
	}

	function getCoinStateSnapshot() {
	  return Array.from(document.querySelectorAll('#collected-coins .coin')).map(coin => ({
		active: coin.classList.contains('active'),
		used: coin.classList.contains('used')
	  }));
	}

	function restoreCoinState(snapshot) {
	  const coins = Array.from(document.querySelectorAll('#collected-coins .coin'));
	  coins.forEach((coin, idx) => {
		const state = snapshot[idx] || { active: false, used: false };
		coin.classList.toggle('active', !!state.active);
		coin.classList.toggle('used', !!state.used);
	  });
	}

	function buildCardSummaryHTML(score, coins, bonusCoins = 0) {
	  const hasBonus = Number.isFinite(bonusCoins) && bonusCoins > 0;
	  const bonusText = hasBonus ? `+${bonusCoins} bonus` : 'Geen bonus deze keer';
	  const bonusClass = hasBonus ? 'round-summary-bonus' : 'round-summary-bonus round-summary-bonus--muted';
	  return `
		<div class="round-summary-cards">
			<div class="round-summary-card">
				<span class="round-summary-icon">ðŸ†</span>
				<span class="round-summary-label">Totaalscore</span>
				<span class="round-summary-value">${score}</span>
			</div>
			<div class="round-summary-card round-summary-card--coins">
				<span class="round-summary-icon">ðŸª™</span>
				<span class="round-summary-label">Munten beschikbaar</span>
				<span class="round-summary-value">${coins}</span>
				<span class="${bonusClass}">${bonusText}</span>
			</div>
		</div>`;
	}

	function countShapeBlocks(matrix) {
	  return matrix.reduce((sum, row) => sum + row.reduce((acc, val) => acc + (val ? 1 : 0), 0), 0);
	}

	function calculateCardCost(cardData) {
	  const blocks = countShapeBlocks(cardData.matrix);
	  // Tier-based prijzen per blokgrootte
	  let baseCost = 2; // 1-3 blocks
	  if (blocks === 4) baseCost = 4;
	  else if (blocks === 5) baseCost = 6;
	  else if (blocks === 6) baseCost = 8;
	  else if (blocks >= 7) baseCost = 10;
	  // Golden modifier +2
	  const isGolden = !!(cardData.isGolden || cardData.color?.isGolden);
	  if (isGolden) baseCost += 2;
	  // Bonus Boost modifier
	  if (cardData && cardData.isBonusBoost) {
		const extra = (typeof BONUS_BOOST_CARD_COST_BONUS === 'number') ? BONUS_BOOST_CARD_COST_BONUS : 4;
		baseCost += extra;
	  }
	  if (cardData && cardData.isBonusEcho) {
		const extra = (typeof BONUS_ECHO_CARD_COST_BONUS === 'number') ? BONUS_ECHO_CARD_COST_BONUS : 4;
		baseCost += extra;
	  }
	  // Multikleur modifier +2
	  if (cardData.color && cardData.color.name === 'multikleur') baseCost += 2;
	  return baseCost;
	}

	function createRandomShopCardWithRarity() {
		// Random card odds tuning:
		// - 20% kans op grotere vorm (large)
		// - Multikleur: 5% basis, 20% met multikleur unlock, 50% met multikleur boost
		// - Goud: 3% basis, 15% met gouden unlock
		// - Extra large vormen komen mee in de â€œlargeâ€ kans als de upgrade er is
		const hasWildcardUnlock = hasUpgrade('wildcardCards');
		const hasWildcardBoost = hasUpgrade('multicolorBoost');
		const hasGoldUnlock = hasUpgrade('goldenCards');
		const hasExtraLarge = hasUpgrade('extraLargeBlocks');

		const pickRandom = (list) => (Array.isArray(list) && list.length)
			? list[Math.floor(Math.random() * list.length)]
			: null;

		const largePool = shapePool.filter(e => e && e.category === 'large');
		const basePool = shapePool.filter(e => e && e.category !== 'large');
		const largeRoll = Math.random();
		const wantLarge = largeRoll < 0.20;
		let entry = null;
		if (wantLarge && largePool.length) {
			// Mix in extra-large shapes (7+ blokjes) when unlocked.
			const xlPool = (hasExtraLarge && Array.isArray(EXTRA_LARGE_7_SHAPES)) ? EXTRA_LARGE_7_SHAPES : [];
			const useXL = xlPool.length && Math.random() < 0.25; // subset of large rolls become XL
			if (useXL) {
				const pick = pickRandom(xlPool);
				entry = pick ? { name: pick.name, matrix: pick.matrix, category: 'large' } : null;
			}
			if (!entry) entry = pickRandom(largePool) || getRandomShapeEntry();
		} else {
			entry = pickRandom(basePool) || getRandomShapeEntry();
		}

		const palette = NON_WILDCARD_COLORS.length ? NON_WILDCARD_COLORS : colors;
		const multicolorChance = hasWildcardBoost ? 0.50 : hasWildcardUnlock ? 0.20 : 0.07;
		const goldenChance = hasGoldUnlock ? 0.20 : 0.07;
		const isMulticolor = Math.random() < multicolorChance;
		const isGolden = Math.random() < goldenChance;
		const baseColor = isMulticolor
			? { name: 'multikleur', code: 'rainbow' }
			: palette[Math.floor(Math.random() * palette.length)];
		const color = cloneColor(baseColor);
		return instantiateBlueprint(createCardBlueprint(entry, color, { isGolden }));
	}

	function createGoldenShopCard() {
		// Dedicated purchasable golden card (unlocked via goldenCards upgrade).
		// Golden is treated as a modifier: any normal shape with a golden card frame.
		const candidates = shapePool.filter(e => e && (e.category === 'mini' || e.category === 'standard'));
		const entry = candidates.length
			? candidates[Math.floor(Math.random() * candidates.length)]
			: getRandomShapeEntry();
		const palette = NON_WILDCARD_COLORS.length ? NON_WILDCARD_COLORS : colors;
		const baseColor = palette[Math.floor(Math.random() * palette.length)];
		const color = cloneColor(baseColor);
		return instantiateBlueprint(createCardBlueprint(entry, color, { isGolden: true }));
	}

	function getBonusKeyFromColorName(colorName) {
		const name = String(colorName || '').trim().toLowerCase();
		if (!name) return null;
		for (const key of BONUS_ORDER) {
			const meta = BONUS_COLOR_CONFIG[key];
			if (meta && String(meta.colorName || '').toLowerCase() === name) return key;
		}
		return null;
	}

	const BONUS_BOOST_CARD_COST_BONUS = 4;
	function createBonusBoostCardBlueprint(colorKey = null) {
		const miniChoices = (CARD_BLUEPRINTS && Array.isArray(CARD_BLUEPRINTS.mini)) ? CARD_BLUEPRINTS.mini : [];
		const shapePick = miniChoices.length
			? miniChoices[Math.floor(Math.random() * miniChoices.length)]
			: { name: 'Domino verticaal', matrix: [[1],[1]] };
		const entry = { name: 'Bonus Boost', matrix: cloneShape(shapePick.matrix), category: 'mini' };
		let baseColor = null;
		if (colorKey && BONUS_COLOR_CONFIG[colorKey]) {
			const desiredName = BONUS_COLOR_CONFIG[colorKey].colorName;
			baseColor = NON_WILDCARD_COLORS.find(c => c && c.name === desiredName) || null;
		}
		if (!baseColor) {
			baseColor = NON_WILDCARD_COLORS.length
				? NON_WILDCARD_COLORS[Math.floor(Math.random() * NON_WILDCARD_COLORS.length)]
				: { name: 'geel', code: '#cfba51' };
		}
		return createCardBlueprint(entry, cloneColor(baseColor), { isBonusBoost: true });
	}

	function createBonusBoostShopCard() {
		const bp = createBonusBoostCardBlueprint();
		const card = instantiateBlueprint(bp);
		card.isBonusBoostShopCard = true;
		return card;
	}

	function createBonusEchoCardBlueprint(variantKey = null) {
		const miniChoices = (CARD_BLUEPRINTS && Array.isArray(CARD_BLUEPRINTS.mini)) ? CARD_BLUEPRINTS.mini : [];
		const defaultShape = { name: 'Echo Domino', matrix: [[1], [1]], category: 'mini' };
		const shapePick = miniChoices.find(entry => countShapeBlocks(entry.matrix) === BONUS_ECHO_REQUIRED_BONUSES) || defaultShape;
		const entry = { name: 'Bonus Echo', matrix: cloneShape(shapePick.matrix), category: 'mini' };
		const palette = NON_WILDCARD_COLORS.length ? NON_WILDCARD_COLORS : colors;
		const baseColor = cloneColor(palette[Math.floor(Math.random() * palette.length)]);
		const pickedVariant = variantKey || pickBonusEchoVariant();
		return createCardBlueprint(entry, baseColor, { isBonusEcho: true, bonusEchoVariant: pickedVariant });
	}

	function createBonusEchoShopCard() {
		const bp = createBonusEchoCardBlueprint();
		const card = instantiateBlueprint(bp);
		card.isBonusEchoShopCard = true;
		return card;
	}

	function createShopCard(choice, isRandomCard = false) {
		if (isRandomCard) {
			return createRandomShopCardWithRarity();
		}
		const entry = choice ?? getRandomShapeEntry();
		// Multikleur kaarten: beschikbaar vanaf level 1.7
		// Multicolor boost upgrade verdubbelt de kans (van 0.35 naar 0.70)
		const baseWildcardChance = 0.35;
		const wildcardChance = hasUpgrade('multicolorBoost') ? baseWildcardChance * 2 : baseWildcardChance;
		const allowWildcard = isSpecialModifiersUnlocked() && hasUpgrade('multicolorBoost') && Math.random() < wildcardChance;
		const palette = allowWildcard ? colors : NON_WILDCARD_COLORS;
		const color = cloneColor(palette[Math.floor(Math.random() * palette.length)]);
		const allowModifiers = isSpecialModifiersUnlocked();
		// Gouden kaarten alleen als je de upgrade hebt
		const isGolden = allowModifiers && hasUpgrade('goldenCards') && color.name !== 'multikleur' && Math.random() < 0.05;
		return instantiateBlueprint(createCardBlueprint(entry, color, { isGolden }));
	}

	function getPremiumShapeEntry() {
		const largeShapes = shapePool.filter(entry => entry.category === 'large');
		const candidates = largeShapes.filter(entry => countShapeBlocks(entry.matrix) >= 6);
		const pool = candidates.length ? candidates : largeShapes;
		if (!pool.length) return getRandomShapeEntry();
		return pool[Math.floor(Math.random() * pool.length)];
	}

	function createPremiumShopCard() {
		// Premium shop card: always a large shape, with boosted golden/multikleur odds.
		// Maar ALLEEN als je de relevante upgrade hebt gekocht!
		const entry = getPremiumShapeEntry();
		const roll = Math.random();
		
		// Gouden kaarten alleen met upgrade
		if (hasUpgrade('goldenCards') && roll < 0.25) {
			const palette = NON_WILDCARD_COLORS.length ? NON_WILDCARD_COLORS : colors;
			const baseColor = cloneColor(palette[Math.floor(Math.random() * palette.length)]);
			return instantiateBlueprint(createCardBlueprint(entry, baseColor, { isGolden: true }));
		}
		// Multikleur alleen met upgrade
		if (hasUpgrade('multicolorBoost') && roll < 0.55) {
			const rainbowColor = { name: 'multikleur', code: 'rainbow' };
			return instantiateBlueprint(createCardBlueprint(entry, rainbowColor));
		}
		// Anders: normale kleur
		const palette = NON_WILDCARD_COLORS.length ? NON_WILDCARD_COLORS : colors;
		const color = cloneColor(palette[Math.floor(Math.random() * palette.length)]);
		return instantiateBlueprint(createCardBlueprint(entry, color));
	}
	

	function placeActionButtons() {
		const actionWrap = document.getElementById('card-action-buttons');
		if (!actionWrap) return;
		const newCardsBtn = document.getElementById('new-cards-btn');
		const rotateBtn = document.getElementById('rotate-card-btn');
		const mirrorBtn = document.getElementById('mirror-card-btn');
		const deckPreview = document.getElementById('deck-preview');
		const turnCounter = document.getElementById('turn-counter-inline');
		[newCardsBtn, rotateBtn, mirrorBtn, deckPreview, turnCounter].forEach(el => {
			if (el && el.parentElement !== actionWrap) {
				actionWrap.appendChild(el);
			}
		});
	}

	const turnCounterEl = document.getElementById('turn-counter-inline');
	let turnCount = 0;
	function updateTurnCounterDisplay() {
		if (!turnCounterEl) return;
		const displayTurn = Math.max(turnCount, 1);
		turnCounterEl.style.display = '';
		turnCounterEl.textContent = `Beurt ${displayTurn}`;
		turnCounterEl.setAttribute('data-turn', String(displayTurn));
	}

	function setCardSelectionLock(lock, activeCardEl = null, options = {}) {
		const { allowGolden = false, allowNormal = false, allowedCardIds = null } = options;
		cardSelectionLocked = !!lock;
		const cards = document.querySelectorAll('#card-choice-zone .card-option');
		cards.forEach(card => {
			const isActive = card === activeCardEl;
			const isGoldenCard = card.dataset.golden === 'true';
			const cardId = card.dataset.cardId;
			
			// Disable als: locked en niet actief en (niet toegestaan OF niet plaatsbaar)
			const isAllowedId = Array.isArray(allowedCardIds) && allowedCardIds.includes(cardId);
			const lockedOut = cardSelectionLocked && !isActive && !isAllowedId && !(
				(allowGolden && isGoldenCard) || (allowNormal && !isGoldenCard)
			);
			// PERFORMANCE:
			// Do not call `isCardPlayable()` here. That function performs expensive full-board scans
			// (especially for multikleur), and this lock runs after each placement.
			const disable = lockedOut;
			
			card.classList.toggle('selection-disabled', disable);
			if (disable) {
				card.setAttribute('aria-disabled', 'true');
			} else {
				card.removeAttribute('aria-disabled');
			}
		});
	}

	function allowGoldenCardsInHand() {
		return !!document.querySelector('#card-choice-zone .card-option[data-golden="true"]');
	}

	function hasNonGoldenCardsInHand() {
		return !!document.querySelector('#card-choice-zone .card-option[data-golden="false"]');
	}

	function getBonusEchoReplayReadyCardIds() {
		return currentHand
			.filter(card => card && card.isBonusEcho && Number(card.bonusEchoReplaysAvailable || 0) > 0)
			.map(card => card.id);
	}

	function hasBonusEchoReplayReady() {
		return getBonusEchoReplayReadyCardIds().length > 0;
	}

	function resetTurnCardFlags() {
		goldenCardPlayedThisTurn = false;
		nonGoldenCardPlayedThisTurn = false;
	}

	function computeCardLockOptions() {
		// Turn rule: max 1 normal card per turn; golden is always allowed.
		const replayReadyIds = getBonusEchoReplayReadyCardIds();
		const allowNormalByTurnRule = !nonGoldenCardPlayedThisTurn;
		return {
			allowGolden: allowGoldenCardsInHand(),
			allowNormal: allowNormalByTurnRule && hasNonGoldenCardsInHand(),
			allowedCardIds: replayReadyIds
		};
	}

	function applyTurnCardLocks() {
		if (cardsPlayedThisTurn > 0) {
			setCardSelectionLock(true, null, computeCardLockOptions());
		} else {
			setCardSelectionLock(false);
		}
	}

	function recomputeTurnCardFlags() {
		resetTurnCardFlags();
		for (const entry of cardPlacementHistory) {
			if (!entry || entry.isBonusPlacement) continue;
			if (entry.wasGolden) goldenCardPlayedThisTurn = true;
			else nonGoldenCardPlayedThisTurn = true;
		}
	}

	function attachCardMetaHover(card, triggers = []) {
		let hideTimeout = null;
		const toggle = (state) => {
			if (hideTimeout) {
				clearTimeout(hideTimeout);
				hideTimeout = null;
			}
			if (state) {
				card.classList.add('show-meta');
			} else {
				const holdUntil = Number(card?.dataset?.metaHoldUntil || 0);
				if (holdUntil && Date.now() < holdUntil) {
					return;
				}
				hideTimeout = setTimeout(() => card.classList.remove('show-meta'), 80);
			}
		};

		triggers.filter(Boolean).forEach((el) => {
			el.addEventListener('pointerenter', () => toggle(true));
			el.addEventListener('pointerleave', () => toggle(false));
			el.addEventListener('focusin', () => toggle(true));
			el.addEventListener('focusout', () => toggle(false));
		});
	}

	function createCardElement(cardData, inlineLabel, options = {}) {
	  const { onSelect } = options;
	  const card = document.createElement('div');
	  card.classList.add('card', 'card-option');
	  card.dataset.cardId = cardData.id;
	  card.dataset.shapeName = cardData.shapeName;
	  card.dataset.shapeCols = String(cardData.matrix[0].length);
	  card.dataset.shapeRows = String(cardData.matrix.length);
	card.dataset.color = (cardData.color?.name || '').toLowerCase();
	  card.cardData = cardData;
	  card.cardShape = cardData.matrix;
	  card.cardColor = cardData.color;
	const isGoldenCard = !!cardData.isGolden || !!cardData.color?.isGolden;
	const isBonusBoostCard = !!cardData.isBonusBoost;
	const isReplayCopy = !!cardData.isBonusEchoReplayCopy;
	const isBonusEchoCard = !!cardData.isBonusEcho && !isReplayCopy;
	const isDeckCopy = !!cardData.isDeckCopy;
	const isLuckyCopy = !!cardData.isLuckyCopy;
	const displayName = getColorDisplayName(cardData.color);
	card.dataset.golden = isGoldenCard ? 'true' : 'false';
	card.dataset.bonusBoost = isBonusBoostCard ? 'true' : 'false';
	card.dataset.bonusEcho = isBonusEchoCard ? 'true' : 'false';
	card.dataset.deckCopy = isDeckCopy ? 'true' : 'false';
	card.dataset.luckyCopy = isLuckyCopy ? 'true' : 'false';
	const isWorld4Allowed = isWorld4CardAllowed(cardData);
	card.dataset.world4Allowed = isWorld4Allowed ? 'true' : 'false';
	if (isGoldenCard) {
		card.classList.add('card-golden');
	}
	if (isBonusBoostCard) {
		card.classList.add('card-bonus-boost');
	}
	if (isBonusEchoCard) {
		card.classList.add('card-bonus-echo');
	}
	if (isDeckCopy) {
		card.classList.add('card-deck-copy');
	}
	if (isLuckyCopy) {
		card.classList.add('card-lucky-copy');
	}
	if (!isWorld4Allowed) {
		card.classList.add('card-locked-color');
		const badge = document.createElement('div');
		badge.className = 'card-lock-badge';
		badge.textContent = '!';
		card.appendChild(badge);
	}
	// Visual markers for pre-level chosen cards
	if (cardData && cardData.isPrelevelChoice) {
		card.classList.add('prelevel-card');
		try {
			card.style.filter = cardData.isUsed ? 'grayscale(60%) brightness(0.6)' : 'brightness(0.85)';
			const badge = document.createElement('span'); badge.className = 'prelevel-badge'; badge.textContent = 'â—';
			badge.style.position = 'absolute'; badge.style.top = '6px'; badge.style.right = '6px'; badge.style.fontSize = '14px'; badge.style.pointerEvents = 'none';
			card.style.position = 'relative';
			card.appendChild(badge);
		} catch (e) {}
	}
	  const pattern = document.createElement('div');
	  pattern.classList.add('card-pattern');
	  card.appendChild(pattern);
	  updateCardPattern(card, cardData.matrix, cardData.color);

	const label = document.createElement('div');
	label.classList.add('card-label');
	const labelText = document.createElement('span');
	if (isBonusEchoCard || isBonusBoostCard) {
		labelText.textContent = '';
		label.append(labelText);
	} else {
		label.classList.add('card-label--empty');
	}

	const meta = document.createElement('div');
	meta.classList.add('card-meta');
	if (isBonusEchoCard) {
		const variant = cardData.bonusEchoVariant || 'replay';
		buildBonusEchoLabelMeta(label, meta, variant);
	} else if (isBonusBoostCard) {
		const colorKey = getBonusKeyFromColorName(cardData?.color?.name);
		buildBonusBoostLabelMeta(label, meta, colorKey);
	} else {
		meta.classList.add('card-meta--empty');
	}

	const metaTrigger = document.createElement('div');
	metaTrigger.className = 'card-meta-trigger';

	if (inlineLabel) {
		card.append(metaTrigger, meta, label);
		attachCardMetaHover(card, [metaTrigger]);
	}

	const hasReplayReady = isBonusEchoCard && Number(cardData.bonusEchoReplaysAvailable || 0) > 0;
	const justGrantedReplay = !!cardData.bonusEchoReplayJustGranted;
	if (isBonusEchoCard) {
		if (justGrantedReplay) {
			card.classList.add('card-replay-ready');
			cardData.bonusEchoReplayJustGranted = false;
		}
	}

	if (cardData && cardData.isBonusEchoReplayCopy) {
		card.classList.add('card-replay-copy');
		if (cardData.replayCopyJustSpawned) {
			cardData.replayCopyJustSpawned = false;
		}
	}

	if (isBonusEchoCard) {
		const variant = cardData.bonusEchoVariant || 'replay';
		attachBonusEchoTooltip(card, variant);
	}

	  // Pointer UX:
	  // - Touch: tap selects (no loose block), press/hold or move starts drag.
	  // - Mouse: click selects (no floating block); click+drag starts drag (floating block follows cursor).
	  card.addEventListener('pointerdown', event => {
		const isMobileLayout = isMobileViewport();
		const isTouchDevice = ('ontouchstart' in window || navigator.maxTouchPoints > 0);
		if (event.button !== undefined && event.button !== 0) return;

		// Mouse / non-touch: only start drag after actual movement.
		if (!isTouchDevice) {
			const pointerId = event.pointerId;
			const startX = event.clientX;
			const startY = event.clientY;
			let lastX = startX;
			let lastY = startY;
			let started = false;

			const clear = () => {
				document.removeEventListener('pointermove', onMove, true);
				document.removeEventListener('pointerup', onUp, true);
				document.removeEventListener('pointercancel', onUp, true);
			};

			const startDrag = () => {
				if (started) return;
				started = true;
				if (typeof onSelect === 'function') {
					onSelect(cardData, card);
				} else {
					selectCard(card, card.cardShape, card.cardColor, { clientX: lastX, clientY: lastY, pointerId, pointerType: event.pointerType, forceDrag: true });
				}
				// Prevent the subsequent click from toggling selection unexpectedly.
				suppressCardSelectUntil = Date.now() + 250;
				try { card.setPointerCapture(pointerId); } catch {}
				clear();
			};

			const onMove = ev => {
				if (ev.pointerId !== pointerId) return;
				lastX = ev.clientX;
				lastY = ev.clientY;
				const dx = Math.abs(lastX - startX);
				const dy = Math.abs(lastY - startY);
				if (!started && (dx + dy) > 3) {
					ev.preventDefault();
					startDrag();
				}
			};

			const onUp = ev => {
				if (ev.pointerId !== pointerId) return;
				if (started) {
					// Pointer capture can synthesize a click on the card even if the user released elsewhere.
					// Ensure that click cannot toggle selection/cleanup after an (invalid) release.
					suppressCardSelectUntil = Date.now() + 650;
				}
				clear();
			};

			document.addEventListener('pointermove', onMove, true);
			document.addEventListener('pointerup', onUp, true);
			document.addEventListener('pointercancel', onUp, true);
			return;
		}

		// Touch desktop (e.g. iPad): tap to select, drag to pick up block.
		// Changed from immediate forceDrag to tap-select behavior with drag support.
		if (!isMobileLayout) {
			const pointerId = event.pointerId;
			const startX = event.clientX;
			const startY = event.clientY;
			let lastX = startX;
			let lastY = startY;
			let started = false;
			let timer = null;

			const clear = () => {
				if (timer) {
					clearTimeout(timer);
					timer = null;
				}
				document.removeEventListener('pointermove', onMove, true);
				document.removeEventListener('pointerup', onUp, true);
				document.removeEventListener('pointercancel', onUp, true);
			};

			const startDrag = () => {
				if (started) return;
				started = true;
				// Start drag met forceDrag
				if (typeof onSelect === 'function') {
					onSelect(cardData, card);
				} else {
					selectCard(card, card.cardShape, card.cardColor, { clientX: lastX, clientY: lastY, pointerId, pointerType: event.pointerType, forceDrag: true });
				}
				suppressCardSelectUntil = Date.now() + 400;
				try { card.setPointerCapture(pointerId); } catch {}
				clear();
			};

			const onMove = ev => {
				if (ev.pointerId !== pointerId) return;
				lastX = ev.clientX;
				lastY = ev.clientY;
				const dx = Math.abs(lastX - startX);
				const dy = Math.abs(lastY - startY);
				// Als gebruiker beweegt, start drag
				if (!started && (dx + dy) > 8) {
					ev.preventDefault();
					startDrag();
				}
			};

			const onUp = ev => {
				if (ev.pointerId !== pointerId) return;
				if (started) {
					suppressCardSelectUntil = Date.now() + 650;
				}
				clear();
				// Als niet gedragged, laat de click handler het afhandelen (selectie/toggle)
			};

			document.addEventListener('pointermove', onMove, true);
			document.addEventListener('pointerup', onUp, true);
			document.addEventListener('pointercancel', onUp, true);

			// Long-press start drag (voor gebruikers die lang ingedrukt houden)
			timer = setTimeout(() => {
				if (started) return;
				startDrag();
			}, 200);
			return;
		}

		const pointerId = event.pointerId;
		const startX = event.clientX;
		const startY = event.clientY;
		let lastX = startX;
		let lastY = startY;
		let started = false;
		let timer = null;
		const prevTransform = card.style.transform;
		const prevFilter = card.style.filter;
		const prevWillChange = card.style.willChange;
		const prevTransition = card.style.transition;
		let liftActive = false;

		const applyLiftEffect = (clientY) => {
			// Only lift when moving upward; keep it subtle.
			const up = Math.max(0, (startY - (Number(clientY) || startY)));
			const lift = Math.min(22, up * 0.55);
			const t = lift / 22;
			const brightness = 1 - (t * 0.18); // down to ~0.82
			if (!liftActive) {
				liftActive = true;
				card.style.willChange = 'transform, filter';
				card.style.transition = 'transform 0.06s ease, filter 0.06s ease';
			}
			card.style.transform = `translateY(${-lift}px)`;
			card.style.filter = `brightness(${brightness})`;
		};

		const resetLiftEffect = () => {
			if (!liftActive) return;
			liftActive = false;
			card.style.transform = prevTransform;
			card.style.filter = prevFilter;
			card.style.willChange = prevWillChange;
			card.style.transition = prevTransition;
		};

		const clear = () => {
			if (timer) {
				clearTimeout(timer);
				timer = null;
			}
			resetLiftEffect();
			document.removeEventListener('pointermove', onMove, true);
			document.removeEventListener('pointerup', onUp, true);
			document.removeEventListener('pointercancel', onUp, true);
		};

		const startDrag = () => {
			if (started) return;
			started = true;
			resetLiftEffect();
			if (typeof onSelect === 'function') {
				onSelect(cardData, card);
			} else {
				selectCard(card, card.cardShape, card.cardColor, { clientX: lastX, clientY: lastY, pointerId, pointerType: event.pointerType, forceDrag: true });
			}
			suppressCardSelectUntil = Date.now() + 400;
			try {
				card.setPointerCapture(pointerId);
			} catch {}
			clear();
		};

		const onMove = ev => {
			if (ev.pointerId !== pointerId) return;
			lastX = ev.clientX;
			lastY = ev.clientY;
			const dx = Math.abs(lastX - startX);
			const dy = Math.abs(lastY - startY);
			// Visual: as the user pulls up, lift + darken the card ("picked up" feel).
			if (!started) {
				applyLiftEffect(lastY);
			}
			// If the user starts moving, interpret it as a drag intent.
			if (!started && (dx + dy) > 6) {
				ev.preventDefault();
				startDrag();
			}
		};

		const onUp = ev => {
			if (ev.pointerId !== pointerId) return;
			if (started) {
				suppressCardSelectUntil = Date.now() + 650;
			}
			clear();
		};

		document.addEventListener('pointermove', onMove, true);
		document.addEventListener('pointerup', onUp, true);
		document.addEventListener('pointercancel', onUp, true);

		// Long-press also starts drag (useful when moving less initially).
		timer = setTimeout(() => {
			if (started) return;
			startDrag();
		}, 120);
	  }, true);

	  card.addEventListener('click', event => {
		event.stopPropagation();
		const isMobileLayout = isMobileViewport();
		const wantsEchoInfo = isMobileLayout && card.classList.contains('card-bonus-echo');
		const clickedMeta = !!event.target.closest('.card-meta, .card-meta-trigger');
		if (wantsEchoInfo && clickedMeta) {
			event.preventDefault();
			const holdMs = 2000;
			const holdUntil = Date.now() + holdMs;
			card.dataset.metaHoldUntil = String(holdUntil);
			card.classList.add('show-meta');
			if (card._metaHoldTimer) {
				clearTimeout(card._metaHoldTimer);
			}
			card._metaHoldTimer = setTimeout(() => {
				delete card.dataset.metaHoldUntil;
				card.classList.remove('show-meta');
				card._metaHoldTimer = null;
			}, holdMs);
			return;
		}
		// Allow toggling off the currently selected card even during suppression windows.
		const clickedCardId = card?.dataset?.cardId || null;
		const isToggleOffClick = !!clickedCardId && !!selectedCardId && clickedCardId === selectedCardId;
		if (!isToggleOffClick && Date.now() < suppressCardSelectUntil) return;
		if (typeof onSelect === 'function') {
		  onSelect(cardData, card);
		} else {
		  selectCard(card, card.cardShape, card.cardColor);
		}
		// Only show controls when there is an active selection or a hanging block/bonus.
		const hasActiveContext = !!(selectedCardElement || draggedBlock || activeBonusPlacement);
		if (hasActiveContext) {
			if (rotateButton) rotateButton.disabled = false;
			if (mirrorButton) mirrorButton.disabled = false;
			addCardControlButtons();

			// Re-render on next frame so the draggable measures the correct cell size
			// if a zoom/lift was triggered via autoZoomToColorZone().
			requestAnimationFrame(() => {
				try {
					renderBlock(freeBlock, freeBlock._shape || shape, colorObj);
					const mAfter = getDragBlockCellMetrics(freeBlock);
					({ offsetX, offsetY } = computeShapeCenterOffsets(freeBlock._shape || shape, mAfter));
					setElPos(freeBlock, event.clientX - offsetX, event.clientY - offsetY - getFingerLiftOffsetY(event));
				} catch (e) {}
			});
		} else {
			if (rotateButton) rotateButton.disabled = true;
			if (mirrorButton) mirrorButton.disabled = true;
			removeCardControlButtons();
		}
	  });

	  return card;
	}

	function renderCurrentHand() {
	  const container = document.getElementById('card-options');
	  if (!container) {
		console.warn('âš ï¸ card-options container not found');
		return;
	  }
	  
	  if (typeof debugMode !== 'undefined' && debugMode) {
		console.log('ðŸ“‹ renderCurrentHand - currentHand:', currentHand.length, 'cards');
		console.log('ðŸ“‹ Container visible:', container.offsetParent !== null, 'display:', getComputedStyle(container).display);
	  }
	  
	  const inlineButton = true;

	  container.innerHTML = '';
	  selectedShape = null;
	  selectedColor = null;
	  selectedCardId = null;
	  selectedCardElement = null;
	  if (rotateButton) rotateButton.disabled = true;
		cardSelectionLocked = false;

	  // Respect scenario restrictions when set: `window.scenarioAllowedColors` is an
	  // optional array of Dutch color names (e.g. ['groen','blauw']). If present,
	  // only show cards matching those colors or multikleur cards.
	  const allowedColors = Array.isArray(window.scenarioAllowedColors) ? window.scenarioAllowedColors : null;
	  let handToRender = allowedColors
		? currentHand.filter(c => c && (allowedColors.includes((c.color && c.color.name) || '') || (c.color && c.color.name) === 'multikleur'))
		: currentHand.slice();
	  try {
		const info = (typeof getWorldAndSubLevel === 'function') ? getWorldAndSubLevel(currentLevel) : null;
		const isWorld4 = !!(info && Number(info.world) === 4);
		if (isWorld4 && Array.isArray(world4AllowedColors) && world4AllowedColors.length) {
			handToRender = handToRender.filter(card => isWorld4CardAllowed(card));
		}
	  } catch (_) {}
	  handToRender.forEach((cardData, idx) => {
		if (typeof debugMode !== 'undefined' && debugMode) {
			console.log(`  Card ${idx}:`, cardData.shapeName, cardData.color?.name);
		}
		const cardElement = createCardElement(cardData, inlineButton);
		container.appendChild(cardElement);
	  });
	  
	  if (typeof debugMode !== 'undefined' && debugMode) {
		console.log('ðŸŽ´ Rendered', currentHand.length, 'cards to hand. Container children:', container.children.length);
	  }
	  
	  // Desktop: toon scrollbalk alleen bij 4+ kaarten
	  if (currentHand.length >= 4) {
		container.classList.add('has-scroll');
		const sidebar = document.getElementById('desktop-right');
		if (sidebar) sidebar.classList.add('hand-has-scroll');
	  } else {
		container.classList.remove('has-scroll');
		const sidebar = document.getElementById('desktop-right');
		if (sidebar) sidebar.classList.remove('hand-has-scroll');
	  }

	  placeActionButtons();
	  applyCardSizing();
	  applyMobileHandFitForFiveCards();
	  // Mobile UX: show max ~3 cards and allow horizontal scroll with arrows.
	  try {
		container.scrollLeft = 0;
		initHandScrollControls();
		updateHandScrollControls();
	  } catch {}
	updateDrawButtonState();
	applyTurnCardLocks();
	if (tutorialState.active && currentLevel === 0) {
		highlightIntroPurpleCard();
	}
	try { if (typeof monitorScenarioProgress === 'function') monitorScenarioProgress(); } catch(e){}
	}

	function finalizeBonusPlacement(placementResult, coinSnapshotBefore, bonusContext) {
	  if (!bonusContext || !placementResult) return;
	  const { colorKey } = bonusContext;
	  
	  // Handle purchased placement - clear de preview state
	  if (colorKey === 'purchased') {
		clearPurchasedPlacement();
		const coinSnapshot = (coinSnapshotBefore || []).map(state => ({ active: state.active, used: state.used }));
		const actionId = ++actionSequence;
		cardPlacementHistory.push({
			isBonusPlacement: true,
			bonusKey: 'purchased',
			cells: (placementResult.cells || []).filter(Boolean),
			zoneId: placementResult.zoneId,
			coinSnapshotBefore: coinSnapshot,
			bonuses: Array.isArray(placementResult.bonuses) ? placementResult.bonuses.slice() : [],
			sequence: actionId,
			bonusSpent: true
		});
		updateUndoButton();
		updateDrawButtonState();
		try {
			document.dispatchEvent(new CustomEvent('locus:tutorial-bonus-placed', { detail: { bonusKey: 'purchased' } }));
		} catch (_) {}
		return;
	  }
	  
	  if (!colorKey || !BONUS_COLOR_CONFIG[colorKey]) return;
	  const coinSnapshot = (coinSnapshotBefore || []).map(state => ({ active: state.active, used: state.used }));
	  const consumed = spendBonusCharge(colorKey);
	  const actionId = ++actionSequence;
	  cardPlacementHistory.push({
		isBonusPlacement: true,
		bonusKey: colorKey,
		cells: (placementResult.cells || []).filter(Boolean),
		zoneId: placementResult.zoneId,
		coinSnapshotBefore: coinSnapshot,
		bonuses: Array.isArray(placementResult.bonuses) ? placementResult.bonuses.slice() : [],
		sequence: actionId,
		bonusSpent: consumed
	  });
	  updateUndoButton();
	if (consumed) {
		updateBonusInventoryUI();
	}
	  updateDrawButtonState();
	  try {
		document.dispatchEvent(new CustomEvent('locus:tutorial-bonus-placed', { detail: { bonusKey: colorKey } }));
	  } catch (_) {}
	}

	function updateDrawButtonState() {
	  if (!newCardsButton) return;
	  const hasBonusEchoExtraTurnReady = (bonusEchoExtraTurns > 0) && Array.isArray(discardPile) && discardPile.length > 0 && currentHand.length === 0;
	  if (drawPile.length === 0 && currentHand.length === 0 && hasBonusEchoExtraTurnReady) {
		newCardsButton.classList.remove('complete-round');
		newCardsButton.classList.remove('ready-for-next-turn');
		newCardsButton.disabled = false;
		newCardsButton.setAttribute('data-label', 'Bonusbeurt');
		newCardsButton.setAttribute('aria-label', 'Bonusbeurt');
		return;
	  }
	  if (drawPile.length === 0 && currentHand.length === 0) {
		// Voltooi ronde - tekst wijzigt naar "Einde beurt"
		newCardsButton.classList.add('complete-round');
		newCardsButton.classList.remove('ready-for-next-turn');
		newCardsButton.disabled = false;
		newCardsButton.setAttribute('data-label', 'Einde beurt');
		newCardsButton.setAttribute('aria-label', 'Einde beurt');
		return;
	  }
	  if (drawPile.length === 0) {
		if (hasBonusEchoExtraTurnReady) {
			newCardsButton.classList.remove('complete-round');
			newCardsButton.classList.remove('ready-for-next-turn');
			newCardsButton.disabled = false;
			newCardsButton.setAttribute('data-label', 'Bonusbeurt');
			newCardsButton.setAttribute('aria-label', 'Bonusbeurt');
			return;
		}
		// Voltooi ronde - tekst wijzigt naar "Einde beurt"
		newCardsButton.classList.add('complete-round');
		newCardsButton.classList.remove('ready-for-next-turn');
		// Never block progression; warnings are handled on click.
		newCardsButton.disabled = false;
		newCardsButton.setAttribute('data-label', 'Einde beurt');
		newCardsButton.setAttribute('aria-label', 'Einde beurt');
		return;
	  }
	  // Herstel naar standaard tekst
	  newCardsButton.classList.remove('complete-round');
	  newCardsButton.setAttribute('data-label', 'Volgende hand');
	  newCardsButton.setAttribute('aria-label', 'Volgende hand');

	  // PERFORMANCE:
	  // After a placement (especially golden), `isCardPlayable()` may scan huge zones (multikleur).
	  // Once the player has played at least one card this turn, this button should be enabled anyway.
	  const hasUsableBonuses = getRemainingBonusCharges() > 0;
	  if (cardsPlayedThisTurn > 0) {
		newCardsButton.classList.remove('ready-for-next-turn');
		newCardsButton.disabled = false;
		return;
	  }

	  const hasPlayableCards = currentHand.some(card => card && isCardPlayable(card));
	  const readyForNextTurn = !hasPlayableCards && !hasUsableBonuses;
	  newCardsButton.classList.toggle('ready-for-next-turn', readyForNextTurn);
	  // Never disable the button; if the player skips with playable cards, the click handler shows a warning.
	  newCardsButton.disabled = false;
	}

	function cloneCardForExtraTurn(card) {
		if (!card) return null;
		return {
			id: nextCardInstanceId(),
			blueprintId: card.blueprintId,
			shapeName: card.shapeName,
			matrix: cloneShape(card.matrix),
			category: card.category,
			color: cloneColor(card.color),
			isGolden: !!(card.isGolden || card.color?.isGolden),
			isBonusBoost: !!card.isBonusBoost,
			isBonusEcho: !!card.isBonusEcho,
			bonusEchoVariant: card.bonusEchoVariant || 'replay',
			bonusEchoReplaysAvailable: 0
		};
	}

	function prepareBonusEchoExtraTurnDeck() {
		if (!(bonusEchoExtraTurns > 0)) return false;
		const source = Array.isArray(discardPile) ? discardPile.slice() : [];
		if (!source.length) return false;
		const clones = source.map(cloneCardForExtraTurn).filter(Boolean);
		if (!clones.length) return false;
		drawPile = shuffleArray(clones);
		discardPile = [];
		currentHand = [];
		bonusEchoExtraTurns = Math.max(0, bonusEchoExtraTurns - 1);
		bonusEchoFreePlays = 0;
		bonusEchoStreak = 0;
		lastCardWasBonusEcho = false;
		lastBonusEchoVariant = null;
		cardPlacementHistory = [];
		cardsPlayedThisTurn = 0;
		resetTurnCardFlags();
		updateUndoButton();
		showObjectiveToast('ðŸ” Bonusbeurt! Je gespeelde kaarten keren terug voor een extra ronde.');
		updateDeckPreview();
		return true;
	}

	function createUpgradeCopy(sourceCard, originTag) {
		if (!sourceCard) return null;
		const color = cloneColor(sourceCard.color);
		return {
			id: nextCardInstanceId(),
			blueprintId: sourceCard.blueprintId,
			shapeName: sourceCard.shapeName,
			matrix: cloneShape(sourceCard.matrix),
			category: sourceCard.category,
			color,
			isGolden: !!(sourceCard.isGolden || sourceCard.color?.isGolden),
			isBonusBoost: !!sourceCard.isBonusBoost,
			isBonusEcho: !!sourceCard.isBonusEcho,
			bonusEchoReplaysAvailable: Number(sourceCard.bonusEchoReplaysAvailable || 0),
			generatedByUpgrade: originTag || null
		};
	}

	function finalizeHandDraw(baseHand) {
		const newHand = (Array.isArray(baseHand) ? baseHand.slice() : []);

		// extraHandSize: maak een kopie van een random kaart uit het deck (blijft in deck)
		if (hasUpgrade('extraHandSize') && drawPile.length > 0) {
			const copyIndex = Math.floor(Math.random() * drawPile.length);
			const copySource = drawPile[copyIndex];
			const extraCopy = createUpgradeCopy(copySource, 'extraHandSize');
			if (extraCopy) {
				extraCopy.isDeckCopy = true; // Markeer als kopie
				newHand.push(extraCopy);
			}
		}

		if (hasUpgrade('luckyDraw') && drawPile.length > 0 && Math.random() < LUCKY_DRAW_COPY_CHANCE) {
			const luckyIndex = Math.floor(Math.random() * drawPile.length);
			const luckySource = drawPile[luckyIndex];
			const luckyCopy = createUpgradeCopy(luckySource, 'luckyDraw');
			if (luckyCopy) {
				luckyCopy.isLuckyCopy = true;
				newHand.push(luckyCopy);
			}
		}
		currentHand = newHand;
		turnCount += 1;
		bonusUseHintShown = false;
		updateTurnCounterDisplay();
		renderCurrentHand();
	}

	function drawNextHand() {
	  if (drawPile.length === 0) {
		if (prepareBonusEchoExtraTurnDeck()) {
			// Deck is refilled for the extra turn; continue with draw.
		} else {
		updateDrawButtonState();
		return;
		}
	  }
	  cardPlacementHistory = [];
	  cardsPlayedThisTurn = 0;
	resetTurnCardFlags();
	updateUndoButton();
	bonusEchoFreePlays = 0;
	  
	  const BASE_HAND_DRAW = 3;
	  const drawCount = Math.min(BASE_HAND_DRAW, drawPile.length);

	  const newHand = [];
	  for (let i = 0; i < drawCount; i++) {
		newHand.push(drawPile.shift());
	  }
	  finalizeHandDraw(newHand);
	}

	function consumeCard(cardId) {
	  if (!cardId) return null;
	  const idx = currentHand.findIndex(card => card.id === cardId);
	  if (idx === -1) return null;
	  const [played] = currentHand.splice(idx, 1);
	  // Kopie-kaarten (van extraHandSize of luckyDraw) gaan niet naar discard pile
	  if (!played.isDeckCopy && !played.isLuckyCopy && !played.isBonusEchoReplayCopy) {
		discardPile.push(played);
	  }
	  selectedCardId = null;
	  selectedCardElement = null;
	  selectedShape = null;
	  selectedColor = null;
	  if (rotateButton) rotateButton.disabled = true;
	  // Don't call renderCurrentHand here - let finalizeCardPlacement do it after updating state
	  return {
		playedCard: played,
		handIndex: idx
	  };
	}

	function triggerBonusEchoGoalEffect(placementResult, text = '') {
		try {
			const cells = Array.isArray(placementResult?.cells) ? placementResult.cells.filter(Boolean) : [];
			const anchor = cells.length ? cells[0] : null;
			let x = window.innerWidth / 2;
			let y = window.innerHeight / 2;
			if (anchor && typeof anchor.getBoundingClientRect === 'function') {
				const rect = anchor.getBoundingClientRect();
				x = rect.left + rect.width / 2;
				y = rect.top + rect.height / 2;
			}
			sparkleEffect(x, y, 10);
			if (text) {
				showScoreAnimation(x, y - 10, text, '#f7e58f');
			}
		} catch (_) {}
	}

	function applyBonusEchoOutcome(playedCard, placementResult, options = {}) {
		const wasReplayPlay = !!options.wasReplayPlay;
		if (!playedCard || !playedCard.isBonusEcho || playedCard.isBonusEchoReplayCopy) {
			bonusEchoStreak = 0;
			lastCardWasBonusEcho = false;
			lastBonusEchoVariant = null;
			return { replayGranted: false, pointsAwarded: 0, extraTurnGranted: false, colorKey: null, variant: null, bonusRewards: [] };
		}
		const variant = playedCard.bonusEchoVariant || 'replay';
		const bonusClaims = Array.isArray(placementResult?.bonuses) ? placementResult.bonuses.filter(Boolean) : [];
		const colorKey = getBonusKeyFromColorName(playedCard?.color?.name);
		const meetsBonusRequirement = bonusClaims.length >= BONUS_ECHO_REQUIRED_BONUSES;
		const coinsClaimed = Array.isArray(placementResult?.cells)
			? placementResult.cells.filter(cell => cell && cell.classList && cell.classList.contains('gold-cell')).length
			: 0;
		const meetsCoinRequirement = coinsClaimed >= 2;
		const scoreDelta = Number(placementResult?.scoreDelta || 0) || 0;
		const scoredPoints = scoreDelta > 0;
		let pointsAwarded = 0;
		let extraTurnGranted = false;
		let replayGranted = false;
		const bonusRewards = [];
		switch (variant) {
			case 'points':
				if (meetsCoinRequirement) {
					pointsAwarded = colorKey ? BONUS_ECHO_SCORE_BONUS : 0;
					if (pointsAwarded > 0 && colorKey) {
						colorScoreBonuses[colorKey] = Number(colorScoreBonuses[colorKey] || 0) + pointsAwarded;
						triggerBonusEchoGoalEffect(placementResult, `+${pointsAwarded}`);
					}
				}
				break;
			case 'bonus': {
				if (scoredPoints) {
					for (let i = 0; i < BONUS_ECHO_BONUS_REWARD; i += 1) {
						const key = BONUS_ORDER[Math.floor(Math.random() * BONUS_ORDER.length)];
						if (key && BONUS_COLOR_CONFIG[key]) bonusRewards.push(key);
					}
					if (bonusRewards.length) triggerBonusEchoGoalEffect(placementResult, `+${BONUS_ECHO_BONUS_REWARD}`);
				}
				break;
			}
			case 'replay':
				if (meetsBonusRequirement && !wasReplayPlay && Number(playedCard.bonusEchoReplaysAvailable || 0) <= 0) {
					replayGranted = true;
					triggerBonusEchoGoalEffect(placementResult, 'â†»');
				}
				break;
			default:
				break;
		}
			const label = (BONUS_COLOR_CONFIG[colorKey]?.label) || playedCard?.color?.name || '';
			if (pointsAwarded > 0) {
				showObjectiveToast(`ðŸ” Bonus: +${pointsAwarded} ${label}`);
			} else if (bonusRewards.length > 0) {
				showObjectiveToast(`ðŸ” Bonus: +${bonusRewards.length} bonussen`);
			}
		bonusEchoStreak = 0;
		lastCardWasBonusEcho = false;
		lastBonusEchoVariant = null;
		return { replayGranted, pointsAwarded, extraTurnGranted, colorKey, variant, bonusRewards };
	}

	function recomputeBonusEchoSequenceState() {
		bonusEchoStreak = 0;
		lastCardWasBonusEcho = false;
		lastBonusEchoVariant = null;
	}

	function discardCurrentHand() {
	  if (currentHand.length === 0) return;
	  // Filter kopie-kaarten uit voordat ze naar discard gaan
	  currentHand.forEach(card => {
		if (!card.isDeckCopy && !card.isLuckyCopy && !card.isBonusEchoReplayCopy) {
			discardPile.push(card);
		}
	  });
	  currentHand = [];
	  cardPlacementHistory = [];
	cardsPlayedThisTurn = 0;
	resetTurnCardFlags();
	updateUndoButton();
	  selectedCardId = null;
	  selectedCardElement = null;
	  selectedShape = null;
	  selectedColor = null;
	  if (rotateButton) rotateButton.disabled = true;
	applyTurnCardLocks();
	}

	function finalizeCardPlacement(placementResult, coinSnapshotBefore) {
	  if (!selectedCardId || !placementResult) return;
	  const consumed = consumeCard(selectedCardId);
	  if (!consumed) return;
	cardsPlayedThisTurn += 1;
	const { playedCard, handIndex } = consumed;
	if (!playedCard?.isBonusEcho) {
		bonusEchoStreak = 0;
		lastCardWasBonusEcho = false;
		lastBonusEchoVariant = null;
	}
	const wasReplayPlay = !!(playedCard && playedCard.isBonusEcho && Number(playedCard.bonusEchoReplaysAvailable || 0) > 0);
	if (playedCard && playedCard.isBonusEcho && playedCard.bonusEchoReplaysAvailable > 0) {
		playedCard.bonusEchoReplaysAvailable = Math.max(0, playedCard.bonusEchoReplaysAvailable - 1);
	}
	let bonusEchoReplayGranted = false;
	let bonusEchoPointsAdded = 0;
	let bonusEchoExtraTurnGranted = false;
	let bonusEchoColorKey = null;
	let bonusEchoBonusesGranted = [];
	// Bonus Boost card: after playing it, only that color's bonus is 2Ã— (per level)
	try {
		if (playedCard && playedCard.isBonusBoost) {
			const boostKey = getBonusKeyFromColorName(playedCard?.color?.name);
			if (boostKey && BONUS_COLOR_CONFIG[boostKey]) {
				if (!(bonusBoostActiveColors instanceof Set)) bonusBoostActiveColors = new Set();
				bonusBoostActiveColors.add(boostKey);
				showObjectiveToast(`âš¡ Bonus Boost actief: 2Ã— ${BONUS_COLOR_CONFIG[boostKey].label} bonussen (dit level)`);
			}
		}
	} catch (e) {}
	const actionId = ++actionSequence;
	const cardSnapshot = {
		id: playedCard.id,
		blueprintId: playedCard.blueprintId,
		shapeName: playedCard.shapeName,
		matrix: cloneShape(playedCard.matrix),
		category: playedCard.category,
		color: cloneColor(playedCard.color)
	  };
	const wasGolden = !!(playedCard.isGolden || playedCard.color?.isGolden || cardSnapshot.color?.isGolden);
	if (wasGolden) goldenCardPlayedThisTurn = true;
	else nonGoldenCardPlayedThisTurn = true;
	const coinSnapshot = (coinSnapshotBefore || []).map(state => ({ active: state.active, used: state.used }));
	if (playedCard && playedCard.isBonusEcho) {
		const echoOutcome = applyBonusEchoOutcome(playedCard, placementResult, { wasReplayPlay });
		bonusEchoReplayGranted = !!echoOutcome.replayGranted;
		bonusEchoPointsAdded = Number(echoOutcome.pointsAwarded || 0);
		bonusEchoExtraTurnGranted = !!echoOutcome.extraTurnGranted;
		bonusEchoColorKey = echoOutcome.colorKey || null;
		bonusEchoBonusesGranted = Array.isArray(echoOutcome.bonusRewards) ? echoOutcome.bonusRewards.filter(Boolean) : [];
	} else {
		bonusEchoStreak = 0;
		lastCardWasBonusEcho = false;
		lastBonusEchoVariant = null;
	}
	if (bonusEchoBonusesGranted.length > 0) {
		const grants = [];
		bonusEchoBonusesGranted.forEach(key => {
			if (key && BONUS_COLOR_CONFIG[key]) {
				const grantedAmount = grantBonusCharge(key);
				if (grantedAmount > 0) grants.push({ key, amount: grantedAmount });
			}
		});
		bonusEchoBonusesGranted = grants;
	}
	if (playedCard && playedCard.isBonusEcho) {
		if (bonusEchoReplayGranted) {
			const replayCopy = {
				id: nextCardInstanceId(),
				blueprintId: playedCard.blueprintId,
				shapeName: playedCard.shapeName,
				matrix: cloneShape(playedCard.matrix),
				category: playedCard.category,
				color: cloneColor(playedCard.color),
				isGolden: !!(playedCard.isGolden || playedCard.color?.isGolden),
				isBonusBoost: false,
				isBonusEcho: true,
				bonusEchoVariant: playedCard.bonusEchoVariant || 'replay',
				bonusEchoReplaysAvailable: 1,
				isBonusEchoReplayCopy: true,
				replayCopyJustSpawned: true
			};
			currentHand.push(replayCopy);
			bonusEchoFreePlays = Number(bonusEchoFreePlays || 0) + 1;
		}
		if (bonusEchoExtraTurnGranted) {
			updateDrawButtonState();
		}
	}
	if (bonusEchoPointsAdded > 0) {
		try { updateScore(); } catch (_) {}
	}
	cardPlacementHistory.push({
		cardRef: playedCard,
		cardState: cardSnapshot,
		handIndex,
		cells: (placementResult.cells || []).filter(Boolean),
		zoneId: placementResult.zoneId,
		coinSnapshotBefore: coinSnapshot,
		bonuses: Array.isArray(placementResult.bonuses) ? placementResult.bonuses.slice() : [],
		turn: turnCount,
		sequence: actionId,
		wasGolden,
		bonusEchoPointsAdded,
		bonusEchoExtraTurnGranted,
		bonusEchoColorKey,
		bonusEchoBonusesGranted
	});
	updateUndoButton();
	try {
		document.dispatchEvent(new CustomEvent('locus:tutorial-card-placed', { detail: { placement: placementResult } }));
	} catch (_) {}
	// Golden cards are always extra; do not set per-turn locks.
	try {
		if (!bonusUseHintShown && currentHand.length === 0 && typeof getRemainingBonusCharges === 'function') {
			const charges = getRemainingBonusCharges();
			if (charges > 0) {
				showObjectiveToast('Tip: klik op een bonus om deze te gebruiken.');
				bonusUseHintShown = true;
			}
		}
	} catch (_) {}
	  // Rebuild the hand after removing the card so availability + button states refresh correctly
	  renderCurrentHand();
	  applyTurnCardLocks();
	}

	function clearBoardPreserveCoins() {
	  const coinSnapshot = getCoinStateSnapshot();
	  document.querySelectorAll('.cell.active').forEach(cell => cell.classList.remove('active'));
	  document.querySelectorAll('.cell.preview-allowed, .cell.preview-denied').forEach(cell => {
		cell.classList.remove('preview-allowed', 'preview-denied');
		cell.style.removeProperty('background');
	  });
	  historyStack.length = 0;
	  resetScoreState();
	  updateScore();
	  if (activeZoomZone) schedulePlaceholderSync(activeZoomZone);
	  restoreCoinState(coinSnapshot);
	}

	const roundModalLayer = document.getElementById('game-modal-layer');
	const roundModalSummary = document.getElementById('round-modal-summary');
	const roundModalTitle = document.getElementById('round-modal-title');
	const roundModalMessage = document.getElementById('round-modal-message');
	const roundModalNext = document.getElementById('round-modal-next');
	const roundModalRestart = document.getElementById('round-modal-restart');
	const roundModalCurrentRun = document.getElementById('round-modal-current-run');
	const shopModalLayer = document.getElementById('shop-modal-layer');
	const shopModalMessage = document.getElementById('shop-modal-message');
	const shopCardOptions = document.getElementById('shop-card-options');
	const shopUpgradeContainer = document.getElementById('shop-upgrade-container');
	const shopBonusContainer = document.getElementById('shop-bonus-container');
	const shopModalSkip = document.getElementById('shop-modal-skip');
	const preworldPickLayer = document.getElementById('preworld-pick-layer');
	const preworldPickModal = document.getElementById('preworld-pick-modal');
	const upgradeModalLayer = document.getElementById('upgrade-modal-layer');
	const upgradeModalClose = document.getElementById('upgrade-modal-close');
	const confirmCompleteLayer = document.getElementById('confirm-complete-layer');
	const confirmCompleteYes = document.getElementById('confirm-complete-yes');
	const confirmCompleteNo = document.getElementById('confirm-complete-no');
	const confirmCompleteDetails = document.getElementById('confirm-complete-details');
	let pendingRoundCompletion = null;

	function getCandidateZonesForColor(colorName) {
		if (!colorName) return [];
		const zones = Array.from(document.querySelectorAll('.zone')).filter(zone => zone.querySelector('.cell') && !zone.classList.contains('red-group'));
		return zones.filter(zone => {
			const zoneColor = zone.dataset.color || (zone.id && zone.id.startsWith('red-grid') ? 'rood' : null);
			if (!zoneColor) return false;
			if (colorName === 'multikleur') return true;
			if (colorName === 'rood') return zoneColor === 'rood';
			return zoneColor === colorName;
		});
	}

	function getUniqueRotations(shape) {
		const rotations = [];
		const seen = new Set();
		let current = cloneShape(shape);
		for (let i = 0; i < 4; i += 1) {
			const key = JSON.stringify(current);
			if (!seen.has(key)) {
				rotations.push(current.map(row => row.slice()));
				seen.add(key);
			}
			current = rotateShape(current);
		}
		return rotations;
	}

	function cardHasPlayablePlacement(card) {
		if (!card || !Array.isArray(card.matrix) || !card.matrix.length) return false;
		const colorName = card.color?.name || null;
		// Golden is a card modifier (frame-only), not a wildcard for placement.
		const zones = getCandidateZonesForColor(colorName);
		if (!zones.length) return false;
		const rotations = getUniqueRotations(card.matrix);
		for (const zone of zones) {
			const metrics = getZoneMetrics(zone);
			if (!metrics || metrics.maxX < metrics.minX || metrics.maxY < metrics.minY) continue;
			for (const shape of rotations) {
				const shapeHeight = shape.length;
				const shapeWidth = shape[0].length;
				const maxStartX = metrics.maxX - shapeWidth + 1;
				const maxStartY = metrics.maxY - shapeHeight + 1;
				if (maxStartX < metrics.minX || maxStartY < metrics.minY) continue;
				for (let baseX = metrics.minX; baseX <= maxStartX; baseX += 1) {
					for (let baseY = metrics.minY; baseY <= maxStartY; baseY += 1) {
						if (canPlace(zone, baseX, baseY, shape)) {
							return true;
						}
					}
				}
			}
		}
		return false;
	}

	function isCardAllowedByTurnRules(card) {
		// Turn rule: you may place at most 1 normal card per turn.
		// Golden cards are exempt.
		if (!card) return false;
		const isGolden = !!(card.isGolden || card.color?.isGolden);
		const isBonusEchoCard = !!card.isBonusEcho;
		const hasEchoReplay = isBonusEchoCard && Number(card.bonusEchoReplaysAvailable || 0) > 0;
		if (isGolden) return true;
		if (hasEchoReplay) return true;
		return !nonGoldenCardPlayedThisTurn;
	}

	function isCardPlayable(card) {
		if (!card) return false;
		if (!isWorld4CardAllowed(card)) return false;
		return isCardAllowedByTurnRules(card) && cardHasPlayablePlacement(card);
	}

	function getRemainingBonusCharges() {
		let total = BONUS_ORDER.reduce((sum, key) => sum + (bonusInventory[key] || 0), 0);
		// Include free placements ("Gratis")
		total += Math.max(0, Number(freePlacementsRemaining) || 0);
		// Include purchased placement (single pending purchased block)
		if (window.hasPurchasedPlacement) total += 1;
		return total;
	}

	function getCompletionWarningState() {
		const cards = currentHand.filter(Boolean);
		let playableCards = 0;
		cards.forEach(card => {
			if (isCardPlayable(card)) playableCards += 1;
		});
		const remainingBonuses = getRemainingBonusCharges();
		const hasActiveSelection = !!activeBonusPlacement || !!draggedBlock;
		return { playableCards, totalCards: cards.length, remainingBonuses, hasActiveSelection };
	}

	function buildCompletionWarningDetails(state = getCompletionWarningState()) {
		const parts = [];
		// Alleen waarschuwen voor speelbare kaarten
		if (state.playableCards > 0) {
			const cardLabel = state.playableCards === 1 ? 'speelbare kaart' : 'speelbare kaarten';
			parts.push(`${state.playableCards} ${cardLabel}`);
		}
		if (state.remainingBonuses > 0) {
			const bonusLabel = state.remainingBonuses === 1 ? 'bonus' : 'bonussen';
			parts.push(`${state.remainingBonuses} ${bonusLabel}`);
		}
		if (state.hasActiveSelection && parts.length === 0) {
			parts.push('een bonus of kaart die je net hebt geselecteerd');
		}
		if (parts.length === 0) return '';
		if (parts.length === 1) return `Je hebt nog ${parts[0]}.`;
		return `Je hebt nog ${parts[0]} en ${parts[1]}.`;
	}

	function hideCompleteRoundConfirm() {
		if (confirmCompleteLayer) confirmCompleteLayer.classList.remove('show');
		if (confirmCompleteDetails) {
			confirmCompleteDetails.textContent = '';
			confirmCompleteDetails.style.display = '';
		}
		pendingRoundCompletion = null;
	}

	function showDiscardHandConfirm(callback) {
		// Hergebruik de complete round confirm modal voor discard hand waarschuwing
		pendingRoundCompletion = callback;
		if (!confirmCompleteLayer) {
			if (typeof callback === 'function') callback();
			pendingRoundCompletion = null;
			return;
		}
		if (confirmCompleteDetails) {
			// ONLY warn about playable cards when moving to the next hand.
			// Bonuses should not block/warn here; they matter when ending the round.
			const playableCount = currentHand.filter(card => card && isCardPlayable(card)).length;
			if (playableCount > 0) {
				const cardLabel = playableCount === 1 ? 'speelbare kaart' : 'speelbare kaarten';
				confirmCompleteDetails.textContent = `Je hebt nog ${playableCount} ${cardLabel} die je zou kunnen plaatsen. Weet je zeker dat je naar de volgende hand wilt gaan?`;
			} else {
				confirmCompleteDetails.textContent = 'Weet je zeker dat je naar de volgende hand wilt gaan?';
			}
			confirmCompleteDetails.style.display = '';
		}
		confirmCompleteLayer.classList.add('show');
		if (confirmCompleteYes) confirmCompleteYes.focus();
	}

	function showCompleteRoundConfirm(callback) {
		pendingRoundCompletion = callback;
		if (!confirmCompleteLayer) {
			if (typeof callback === 'function') callback();
			pendingRoundCompletion = null;
			return;
		}
		if (confirmCompleteDetails) {
			const state = getCompletionWarningState();
			const detailText = buildCompletionWarningDetails(state);
			confirmCompleteDetails.textContent = detailText;
			confirmCompleteDetails.style.display = detailText ? '' : 'none';
		}
		confirmCompleteLayer.classList.add('show');
		if (confirmCompleteYes) confirmCompleteYes.focus();
	}

	function shouldWarnBeforeCompletingRound() {
		const { playableCards, remainingBonuses, hasActiveSelection } = getCompletionWarningState();
		return playableCards > 0 || remainingBonuses > 0 || hasActiveSelection;
	}

	function hideAllModals() {
		hideCompleteRoundConfirm();
		[roundModalLayer, shopModalLayer, upgradeModalLayer, preworldPickLayer].forEach(layer => {
			if (layer) layer.classList.remove('show');
		});
	}

	function showRoundModal(success, score, coins, bonusCoins = 0) {
		if (!roundModalLayer) return;
	// Prefer a loaded custom objective when present
	const loadedCustom = (window && window.loadedCustomObjectiveCompiled) ? window.loadedCustomObjectiveCompiled : null;
	const isScenarioMode = (() => {
		try { return !!(window && window._locusScenarioMode); } catch (e) { return false; }
	})();
	
	// Prefer a loaded custom objective when present
	const activeObjective = loadedCustom || getObjectiveById(currentObjectiveId) || getObjectiveForLevel(currentLevel);
	const objectiveLabel = activeObjective ? (activeObjective.short || activeObjective.description) : null;
	// Compute cleared state: custom objective exposes .check(scores), otherwise use existing completed set
	let objectiveCleared = true;
	if (loadedCustom) {
		try { objectiveCleared = !!loadedCustom.check(); } catch (e) { objectiveCleared = false; }
	} else {
		objectiveCleared = activeObjective ? isObjectiveCompleted(activeObjective.id) : true;
	}
	// Scenario: if the objective is not cleared, treat this as a failed completion.
	const scenarioObjectiveFailed = !!(isScenarioMode && loadedCustom && !objectiveCleared);
	const effectiveSuccess = !!(success && !scenarioObjectiveFailed);
	lastRoundWasSuccess = effectiveSuccess;
	if (roundModalTitle) {
		if (scenarioObjectiveFailed) {
			roundModalTitle.textContent = (window.loadedCustomLevelMeta && window.loadedCustomLevelMeta.name)
				? ('Niet voltooid - ' + window.loadedCustomLevelMeta.name)
				: 'Niet voltooid -';
		} else if (loadedCustom && window.loadedCustomLevelMeta && window.loadedCustomLevelMeta.name) {
			roundModalTitle.textContent = (effectiveSuccess ? 'Ronde voltooid' : 'Game Over') + ' â€” ' + window.loadedCustomLevelMeta.name;
		} else {
			roundModalTitle.textContent = effectiveSuccess ? 'Ronde voltooid' : 'Game Over';
		}
	}
	  if (effectiveSuccess) {
		if (objectiveLabel) {
			roundModalMessage.textContent = `Doel behaald: ${objectiveLabel}. Kies wat je nu wilt doen.`;
		} else {
			roundModalMessage.textContent = 'Je hebt het level gehaald! Maak je keuze hieronder.';
		}
	  } else {
		if (scenarioObjectiveFailed) {
			roundModalMessage.textContent = 'Helaas.. Doel niet behaald';
		} else {
		switch (lastRoundFailureReason) {
			case 'objective':
				roundModalMessage.textContent = objectiveLabel ? `Doel nog niet gehaald: ${objectiveLabel}.` : 'Er is nog een leveldoel dat niet gehaald is.';
				break;
			default:
				roundModalMessage.textContent = 'Niet gehaald... Je deck wordt teruggezet naar de standaard set.';
				break;
		}
		}
	  }
		if (roundModalSummary) {
		let summaryHTML = buildCardSummaryHTML(score, coins, bonusCoins);
		if (activeObjective) {
			const statusLabel = objectiveCleared ? 'Voltooid' : 'Niet voltooid';
			const objDesc = (loadedCustom && loadedCustom.description) ? loadedCustom.description : (activeObjective.short || activeObjective.description);
			summaryHTML += `<div class="modal-summary-line"><strong>Doel</strong><span>${objDesc} - ${statusLabel}</span></div>`;
		}
		roundModalSummary.innerHTML = summaryHTML;
	}
	  if (roundModalNext) {
		roundModalNext.textContent = effectiveSuccess ? `Naar level ${currentLevel + 1}` : 'Opnieuw proberen';
		roundModalNext.disabled = false;
		// Scenario objective fail: no next/continue option.
		roundModalNext.style.display = scenarioObjectiveFailed ? 'none' : '';
	  }
	  if (roundModalRestart) {
		roundModalRestart.textContent = effectiveSuccess ? 'Nieuwe run' : 'Reset deck';
	  }
	  if (roundModalCurrentRun) {
		const canReturn = !!(isScenarioMode && hasPreviousNormalRunSnapshot());
		roundModalCurrentRun.style.display = canReturn ? '' : 'none';
	  }
	  roundModalLayer.classList.add('show');
	}

	function updateShopUpgradeUI() {
		if (!shopUpgradeContainer) return;
		shopUpgradeContainer.innerHTML = '';
		shopUpgradeContainer.style.display = '';
		const upgradesSection = shopUpgradeContainer.closest('.shop-upgrades-section');
		const coins = getSpendableCoinCount();
		const level2Unlocked = !!(typeof hasUpgrade === 'function' ? hasUpgrade('bonusEcho') : (UPGRADES.bonusEcho && UPGRADES.bonusEcho.purchased));
		// Filter voor alleen unlocked en niet-gekochte upgrades
		const availableUpgrades = Object.entries(UPGRADES).filter(([id, upgrade]) => {
			return !upgrade.purchased && UNLOCK_PROGRESSION.isUpgradeUnlocked(id, currentLevel, currentWorld);
		});
		
		if (availableUpgrades.length === 0 && !level2Unlocked) {
			if (upgradesSection) upgradesSection.classList.add('shop-section--empty');
			const emptyState = document.createElement('p');
			emptyState.classList.add('shop-empty-state');
			emptyState.textContent = 'Geen upgrades beschikbaar. Speel meer levels om nieuwe upgrades te ontgrendelen!';
			shopUpgradeContainer.appendChild(emptyState);
			return;
		}
		
		if (upgradesSection) upgradesSection.classList.remove('shop-section--empty');
		
		availableUpgrades.forEach(([upgradeId, upgrade]) => {
			const upgradeCard = document.createElement('div');
			upgradeCard.classList.add('shop-upgrade-card');
			const effectiveCost = getEffectiveUpgradeCost(upgradeId);
			
			const upgradeHeader = document.createElement('div');
			upgradeHeader.classList.add('shop-upgrade-header');
			upgradeHeader.innerHTML = `<span class="upgrade-icon">${upgrade.icon}</span><span class="upgrade-name">${upgrade.name}</span>`;
			
			const upgradeDesc = document.createElement('p');
			upgradeDesc.classList.add('shop-upgrade-desc');
			upgradeDesc.textContent = upgrade.description;
			
			const upgradeActions = document.createElement('div');
			upgradeActions.classList.add('shop-upgrade-actions');
			
			const buyBtn = document.createElement('button');
			// In debug mode: gratis, anders toon kosten
			if (debugMode) {
				buyBtn.textContent = `Kopen (gratis)`;
				buyBtn.disabled = false;
				buyBtn.title = `Koop ${upgrade.name} (debug mode - gratis)`;
			} else {
				buyBtn.innerHTML = `Kopen (${effectiveCost} ${coinIcon()})`;
				buyBtn.disabled = coins < effectiveCost;
				buyBtn.title = coins < effectiveCost ? 'Onvoldoende munten' : `Koop ${upgrade.name}`;
			}
			buyBtn.addEventListener('click', () => purchaseUpgrade(upgradeId));
			
			upgradeActions.appendChild(buyBtn);
			upgradeCard.append(upgradeHeader, upgradeDesc, upgradeActions);
			shopUpgradeContainer.appendChild(upgradeCard);
		});

		if (level2Unlocked) {
			const upgradeCard = document.createElement('div');
			upgradeCard.classList.add('shop-upgrade-card');
			const upgradeHeader = document.createElement('div');
			upgradeHeader.classList.add('shop-upgrade-header');
			const upgradeDesc = document.createElement('p');
			upgradeDesc.classList.add('shop-upgrade-desc');
			const upgradableCount = ownedDeckBlueprints.filter(bp => bp && !bp.isBonusEchoUpgrade).length;
			const level2VariantKey = shopLevel2Variant || pickBonusEchoVariant();
			const level2Meta = getBonusEchoUiCopy(level2VariantKey);
			const level2Label = level2Meta?.sub ? level2Meta.sub.toUpperCase() : level2VariantKey.toUpperCase();
			const level2Desc = level2Meta?.desc || 'Level 2 upgrade.';
			upgradeHeader.innerHTML = `<span class="upgrade-icon">ðŸ”</span><span class="upgrade-name">Level 2 â€¢ ${level2Label}</span>`;
			upgradeDesc.textContent = upgradableCount > 0
				? `Type: ${level2Label} â€” ${level2Desc} Upgrade kaarten voor ${BONUS_ECHO_UPGRADE_COST} munten per kaart. Max 1 upgrade per shop.`
				: 'Alle kaarten hebben al een Level 2 upgrade.';
			const upgradeActions = document.createElement('div');
			upgradeActions.classList.add('shop-upgrade-actions');
			const buyBtn = document.createElement('button');
			const effectiveCost = debugMode ? 0 : BONUS_ECHO_UPGRADE_COST;
			if (debugMode) {
				buyBtn.textContent = `Upgrade (gratis) â€¢ ${level2Label}`;
				buyBtn.disabled = upgradableCount === 0 || shopLevel2Used;
				buyBtn.title = upgradableCount === 0
					? 'Geen kaarten om te upgraden'
					: (shopLevel2Used ? 'Je hebt al een upgrade gekozen in deze shop' : `Upgrade met ${level2Label} (debug)`);
			} else {
				buyBtn.innerHTML = `Upgrade ${level2Label} (${BONUS_ECHO_UPGRADE_COST} ${coinIcon()})`;
				buyBtn.disabled = coins < BONUS_ECHO_UPGRADE_COST || upgradableCount === 0 || shopLevel2Used;
				buyBtn.title = upgradableCount === 0
					? 'Geen kaarten om te upgraden'
					: (shopLevel2Used ? 'Je hebt al een upgrade gekozen in deze shop' : (coins < BONUS_ECHO_UPGRADE_COST ? 'Onvoldoende munten' : `Upgrade met ${level2Label}`));
			}
			buyBtn.addEventListener('click', () => startBonusEchoUpgradeFlow({ forcedVariant: level2VariantKey }));
			upgradeActions.appendChild(buyBtn);
			upgradeCard.append(upgradeHeader, upgradeDesc, upgradeActions);
			shopUpgradeContainer.appendChild(upgradeCard);
		}
	}

		function getLevel2UpgradeCandidates() {
			return ownedDeckBlueprints.filter(bp => bp && !bp.isBonusEchoUpgrade && !bp.isBonusEcho && !bp.isBonusBoost);
		}

		function applyBonusEchoUpgradeToBlueprint(blueprint, variantKey) {
			if (!blueprint || blueprint.isBonusEchoUpgrade) return false;
			const variant = variantKey || pickBonusEchoVariant();
			blueprint.isBonusEchoUpgrade = true;
			blueprint.isBonusEcho = true;
			blueprint.bonusEchoVariant = variant;
			blueprint.bonusEchoReplaysAvailable = 0;
			const syncCard = (card) => {
				if (card && card.blueprintId === blueprint.blueprintId) {
					card.isBonusEchoUpgrade = true;
					card.isBonusEcho = true;
					card.bonusEchoVariant = variant;
					card.bonusEchoReplaysAvailable = 0;
				}
			};
			[currentHand, drawPile, discardPile].forEach(pile => {
				if (!Array.isArray(pile)) return;
				pile.forEach(syncCard);
			});
			return true;
		}

		function startBonusEchoUpgradeFlow(options = {}) {
			const { free = false, forcedVariant = null, markUsed = true } = options;
			if (markUsed && shopLevel2Used) {
				if (shopModalMessage) shopModalMessage.textContent = 'Je kunt maar 1 kaart upgraden per shop.';
				return;
			}
			const candidates = getLevel2UpgradeCandidates();
			if (!candidates.length) {
				if (shopModalMessage) shopModalMessage.textContent = 'Geen kaarten om te upgraden.';
				return;
			}
			const coinsAvailable = getSpendableCoinCount();
			if (!debugMode && !free && coinsAvailable < BONUS_ECHO_UPGRADE_COST) {
				if (shopModalMessage) shopModalMessage.textContent = 'Onvoldoende munten voor Level 2.';
				return;
			}
			if (shopModalMessage) shopModalMessage.textContent = 'Kies een kaart om te upgraden.';
			const variant = forcedVariant || shopLevel2Variant || pickBonusEchoVariant();
			openLevel2UpgradeModal(candidates, (pickedBlueprint) => {
				if (!pickedBlueprint) return;
				if (!debugMode && !free && !spendCoins(BONUS_ECHO_UPGRADE_COST)) {
					if (shopModalMessage) shopModalMessage.textContent = 'Munten konden niet worden afgeschreven.';
					return;
				}
				if (!applyBonusEchoUpgradeToBlueprint(pickedBlueprint, variant)) return;
				if (UPGRADES.bonusEcho) UPGRADES.bonusEcho.purchased = true;
				if (markUsed) shopLevel2Used = true;
				const variantLabel = (getBonusEchoUiCopy(variant).sub || variant).toUpperCase();
				showObjectiveToast(`ðŸ” Level 2 (${variantLabel}) toegevoegd aan je kaart!`);
				updateDeckPreview();
				renderCurrentHand();
				updateShopCoinDisplay();
				updateShopUpgradeUI();
				refreshShopCardButtons();
				try { saveGameState(); } catch (_) {}
			}, variant);
		}

function refreshShopCardButtons() {
	if (!shopCardOptions) return;
	const coins = getSpendableCoinCount();
	shopCardOptions.querySelectorAll('.shop-card').forEach(card => {
		const cost = Number(card.dataset.cardCost);
		const btn = card.querySelector('.shop-card-actions button');
		if (!btn || !Number.isFinite(cost)) return;
		btn.disabled = coins < cost;
		btn.title = coins < cost ? 'Onvoldoende munten' : 'Voeg deze kaart toe aan je deck';
	});
}

function updateShopBonusUI() {
	if (!shopBonusContainer) return;
	shopBonusContainer.innerHTML = '';
	const coins = getSpendableCoinCount();
	let populated = false;
	const bonusSection = shopBonusContainer.closest('.shop-bonus-section');
	BONUS_ORDER.forEach(colorKey => {
		const meta = getBonusMeta(colorKey);
		if (!meta) return;
		const upgradeCost = BONUS_UPGRADE_COSTS[colorKey] ?? 6;
		const upgradeOwned = isBonusUpgraded(colorKey);
		const card = document.createElement('div');
		card.classList.add('shop-bonus-card');
		const info = document.createElement('div');
		info.classList.add('shop-bonus-info');
		const label = document.createElement('span');
		label.textContent = meta.label;
		info.append(label);
		const actions = document.createElement('div');
		actions.classList.add('shop-bonus-actions');
		if (!upgradeOwned) {
			const upgradeBtn = document.createElement('button');
			upgradeBtn.type = 'button';
			upgradeBtn.classList.add('shop-bonus-upgrade-btn');
			upgradeBtn.innerHTML = debugMode ? `Upgrade (gratis)` : `Upgrade (${upgradeCost} ${coinIcon()})`;
			upgradeBtn.disabled = debugMode ? false : coins < upgradeCost;
			upgradeBtn.title = coins < upgradeCost ? 'Onvoldoende munten' : `Upgrade de ${meta.label.toLowerCase()} bonus permanent`;
			upgradeBtn.addEventListener('click', () => purchaseBonusUpgrade(colorKey));
			actions.appendChild(upgradeBtn);
		} else {
			const status = document.createElement('span');
			status.classList.add('shop-bonus-status');
			status.textContent = 'GeÃ¼pgraded';
			actions.appendChild(status);
		}
		card.append(info, actions);
		shopBonusContainer.appendChild(card);
		populated = true;
	});
	if (!populated) {
		const empty = document.createElement('div');
		empty.classList.add('shop-bonus-card');
		empty.textContent = 'Geen bonussen beschikbaar.';
		empty.style.justifyContent = 'center';
		empty.style.fontWeight = '600';
		shopBonusContainer.appendChild(empty);
	}
	if (bonusSection) {
		bonusSection.classList.toggle('shop-section--empty', !populated);
	}
}
	
function updateShopFreePlaceUI() {
	const freePlaceContainer = document.getElementById('shop-freeplace-container');
	if (!freePlaceContainer) return;
	freePlaceContainer.innerHTML = '';
	
	const coins = getSpendableCoinCount();
	const freePlaceCost = 2;
	
	const card = document.createElement('div');
	card.classList.add('shop-bonus-card');
	card.style.padding = '16px';
	
	const info = document.createElement('div');
	info.style.display = 'flex';
	info.style.flexDirection = 'column';
	info.style.gap = '8px';
	
	const label = document.createElement('span');
	label.innerHTML = `+1 gratis blokplaatsing (${freePlaceCost} ${coinIcon()})`;
	label.style.fontWeight = '600';
	label.style.fontSize = '0.95rem';
	
	const description = document.createElement('span');
	description.textContent = 'Plaats een extra 1x1 blok op elke kleur deze ronde';
	description.style.fontSize = '0.8rem';
	description.style.opacity = '0.7';
	
	if (freePlacementsRemaining > 0) {
		const status = document.createElement('span');
		status.textContent = `âœ“ Je hebt ${freePlacementsRemaining} gratis plaatsing${freePlacementsRemaining === 1 ? '' : 'en'}`;
		status.style.color = '#4CAF50';
		status.style.fontSize = '0.85rem';
		status.style.fontWeight = '600';
		info.append(label, description, status);
	} else {
		info.append(label, description);
	}
	
	const buyBtn = document.createElement('button');
	buyBtn.type = 'button';
	buyBtn.classList.add('shop-bonus-upgrade-btn');
	buyBtn.textContent = `Koop (+1 plaatsing)`;
	buyBtn.disabled = coins < freePlaceCost;
	buyBtn.title = coins < freePlaceCost ? 'Onvoldoende munten' : 'Koop een extra gratis plaatsing';
	buyBtn.addEventListener('click', () => purchaseFreePlacement(freePlaceCost));
	
	card.appendChild(info);
	card.appendChild(buyBtn);
	freePlaceContainer.appendChild(card);
}

function purchaseFreePlacement(cost) {
	const coinsAvailable = getSpendableCoinCount();
	if (coinsAvailable < cost) {
		if (shopModalMessage) shopModalMessage.textContent = 'Onvoldoende munten voor deze aankoop.';
		return;
	}
	if (!spendCoins(cost)) {
		if (shopModalMessage) shopModalMessage.textContent = 'Munten konden niet worden afgeschreven.';
		return;
	}
	
	freePlacementsRemaining += 1;
	updateShopFreePlaceUI();
	updateShopCoinDisplay();
	showObjectiveToast(`ðŸŽ +1 gratis plaatsing gekocht! (${freePlacementsRemaining} totaal)`);
}

function purchaseBonusUpgrade(colorKey) {
		const meta = getBonusMeta(colorKey);
		if (!meta || isBonusUpgraded(colorKey)) return;
		const cost = BONUS_UPGRADE_COSTS[colorKey] ?? 6;
		
		// In debugMode zijn bonus upgrades gratis
		if (!debugMode) {
			const coinsAvailable = getSpendableCoinCount();
			if (coinsAvailable < cost) {
				if (shopModalMessage) shopModalMessage.textContent = 'Onvoldoende munten voor deze upgrade.';
				return;
			}
			if (!spendCoins(cost)) {
				if (shopModalMessage) shopModalMessage.textContent = 'Munten konden niet worden afgeschreven.';
				return;
			}
		}
		
		setBonusUpgraded(colorKey, true);
		updateBonusInventoryUI();
		if (shopModalMessage) shopModalMessage.textContent = `${meta.label} bonus geÃ¼pgraded!`;
		showObjectiveToast(`ðŸŒŸ ${meta.label} bonus verbeterd!`);
		updateShopUpgradeUI();
		updateShopBonusUI();
		refreshShopCardButtons();
	}

function purchaseUpgrade(upgradeId) {
		const upgrade = UPGRADES[upgradeId];
		if (!upgrade || upgrade.purchased) return;
		const effectiveCost = getEffectiveUpgradeCost(upgradeId);
		
		// In debugMode zijn alle upgrades gratis
		if (!debugMode) {
			const coins = getSpendableCoinCount();
			if (coins < effectiveCost) {
				if (shopModalMessage) shopModalMessage.textContent = 'Je hebt niet genoeg munten voor deze upgrade.';
				return;
			}
			
			if (!spendCoins(effectiveCost)) {
				if (shopModalMessage) shopModalMessage.textContent = 'Munten konden niet worden afgeschreven.';
				return;
			}
		}
		
	upgrade.purchased = true;
	
	// In scenario mode, upgrades should not trigger onPurchase side effects
	// (which can rebuild boards, open reward modals, or save to localStorage).
	try {
		if (!(window && window._locusScenarioMode) && upgrade.onPurchase) {
			upgrade.onPurchase();
		}
	} catch (e) {}
	
	if (shopModalMessage) {
		shopModalMessage.textContent = `${upgrade.icon} ${upgrade.name} aangekocht!`;
	}
	updateShopUpgradeUI();
	updateShopBonusUI();
	refreshShopCardButtons();
	showObjectiveToast(`${upgrade.icon} ${upgrade.name} ontgrendeld!`);
}

function openShopModal(callback) {
	  pendingShopCallback = callback;
	  if (!shopModalLayer || getSpendableCoinCount() === 0) {
		if (typeof pendingShopCallback === 'function') pendingShopCallback();
		pendingShopCallback = null;
		return;
	  }
	  if (shopCardOptions) {
		shopCardOptions.innerHTML = '';
		const largeShopUnlocked = (UNLOCK_PROGRESSION && typeof UNLOCK_PROGRESSION.isCategoryUnlocked === 'function')
			? UNLOCK_PROGRESSION.isCategoryUnlocked('large', currentLevel)
			: (currentLevel >= 3);
		
		// SHOP: max 3 kaart-opties.
		// Grotere blokken (large/xl/xxl) vervangen soms een kleinere optie i.p.v. extra bij te komen.
		// Vanaf level 2 komt er 1 "random" (mystery) kaart bij, plus 2 andere aanbiedingen.
		const offers = [];

		// Helper: pick N unieke entries.
		function pickUnique(list, count) {
			const pool = list.slice();
			const out = [];
			while (pool.length && out.length < count) {
				const idx = Math.floor(Math.random() * pool.length);
				out.push(pool.splice(idx, 1)[0]);
			}
			return out;
		}

		// Build tier factories (deterministic cost per tier).
		const tierFactories = {
			mini: () => {
				const miniChoices = (CARD_BLUEPRINTS && Array.isArray(CARD_BLUEPRINTS.mini)) ? CARD_BLUEPRINTS.mini : [];
				const miniPick = miniChoices.length
					? miniChoices[Math.floor(Math.random() * miniChoices.length)]
					: { name: 'Domino verticaal', matrix: [[1],[1]] };
				const entry = { name: miniPick.name, matrix: cloneShape(miniPick.matrix), category: 'mini' };
				return { option: createShopCard(entry), cost: 2, fixed: true };
			},
			standard: () => {
				const standardChoices = (CARD_BLUEPRINTS && Array.isArray(CARD_BLUEPRINTS.standard)) ? CARD_BLUEPRINTS.standard : [];
				const standardPick = standardChoices.length
					? standardChoices[Math.floor(Math.random() * standardChoices.length)]
					: { name: 'O', matrix: [[1,1],[1,1]] };
				const entry = { name: standardPick.name, matrix: cloneShape(standardPick.matrix), category: 'standard' };
				return { option: createShopCard(entry), cost: 4, fixed: true };
			},
			large: () => {
				const largeBlueprints = (CARD_BLUEPRINTS && Array.isArray(CARD_BLUEPRINTS.large)) ? CARD_BLUEPRINTS.large : [];
				const fiveBlockPool = largeBlueprints
					.filter(entry => entry && entry.matrix)
					.map(entry => ({ name: entry.name, matrix: entry.matrix, blocks: countShapeBlocks(entry.matrix) }))
					.filter(entry => entry.blocks === 5);
				const pickedLarge = fiveBlockPool.length
					? fiveBlockPool[Math.floor(Math.random() * fiveBlockPool.length)]
					: { name: 'Plus', matrix: [[0,1,0],[1,1,1],[0,1,0]] };
				const entry = { name: pickedLarge.name, matrix: cloneShape(pickedLarge.matrix), category: 'large' };
				return { option: createShopCard(entry), cost: 6, fixed: true };
			},
			xl: () => {
				const xlPick = XL_6_SHAPES[Math.floor(Math.random() * XL_6_SHAPES.length)];
				const entry = { name: xlPick.name, matrix: cloneShape(xlPick.matrix), category: 'large' };
				return { option: createShopCard(entry), cost: 8, fixed: true };
			},
			xxl: () => {
				const xxlPick = EXTRA_LARGE_7_SHAPES[Math.floor(Math.random() * EXTRA_LARGE_7_SHAPES.length)];
				const entry = { name: xxlPick.name, matrix: cloneShape(xxlPick.matrix), category: 'large' };
				return { option: createShopCard(entry), cost: 10, fixed: true };
			}
		};

		const MINI_SHOP_DISABLE_LEVEL = 4;
		const miniShopDisabled = currentLevel >= MINI_SHOP_DISABLE_LEVEL && largeShopUnlocked;
		const SIZE_TIER_WEIGHTS = {
			mini: miniShopDisabled ? 0 : 0.45,
			standard: 1.1,
			large: 1.35,
			xl: 0.35,
			xxl: 0.2
		};

		function pickWeightedSize(keys, exclude = new Set()) {
			const pool = keys.filter(key => !exclude.has(key) && (SIZE_TIER_WEIGHTS[key] ?? 1) > 0);
			if (!pool.length) return null;
			const total = pool.reduce((sum, key) => sum + (SIZE_TIER_WEIGHTS[key] ?? 1), 0);
			let target = Math.random() * total;
			for (const key of pool) {
				target -= (SIZE_TIER_WEIGHTS[key] ?? 1);
				if (target <= 0) return key;
			}
			return pool[pool.length - 1];
		}

		// Which size tiers are available right now?
		const availableSizeKeys = ['mini', 'standard'];
		if (largeShopUnlocked) availableSizeKeys.push('large');
		if (hasUpgrade('xlBlocks') && Array.isArray(XL_6_SHAPES) && XL_6_SHAPES.length) availableSizeKeys.push('xl');
		if (hasUpgrade('extraLargeBlocks') && Array.isArray(EXTRA_LARGE_7_SHAPES) && EXTRA_LARGE_7_SHAPES.length) availableSizeKeys.push('xxl');
		if (miniShopDisabled) {
			const idx = availableSizeKeys.indexOf('mini');
			if (idx >= 0 && availableSizeKeys.length > 1) availableSizeKeys.splice(idx, 1);
		}

		// Specials are allowed but should not explode the amount of options.
		const availableSpecialFactories = [];
		if (hasUpgrade('bonusBoost')) {
			availableSpecialFactories.push(() => {
				const boostCard = createBonusBoostShopCard();
				boostCard.isBonusBoostShopCard = true;
				return { option: boostCard, cost: calculateCardCost(boostCard), fixed: false };
			});
		}
		if (hasUpgrade('goldenCards')) {
			availableSpecialFactories.push(() => {
				const goldenCard = createGoldenShopCard();
				goldenCard.isGoldenShopCard = true;
				return { option: goldenCard, cost: calculateCardCost(goldenCard), fixed: false };
			});
		}
		if (hasUpgrade('betterCards')) {
			availableSpecialFactories.push(() => {
				const premiumCard = createPremiumShopCard();
				premiumCard.isPremiumShopCard = true;
				return { option: premiumCard, cost: calculateCardCost(premiumCard), fixed: false };
			});
		}

		// Choose 2 offers (at least 1 size tier). Early game stays mini+standard.
		let picked = [];
		if (!largeShopUnlocked && availableSpecialFactories.length === 0) {
			picked = ['mini', 'standard'];
		} else {
			const firstSize = pickWeightedSize(availableSizeKeys) || 'standard';
			picked.push(firstSize);
			// Second slot: either another size, or sometimes a special.
			const allowSpecial = availableSpecialFactories.length > 0 && Math.random() < 0.35;
			if (allowSpecial) {
				const specialFactory = pickUnique(availableSpecialFactories, 1)[0];
				if (specialFactory) {
					offers.push(specialFactory());
				}
			} else {
				const remainingSizes = availableSizeKeys.filter(k => k !== firstSize);
				const secondSize = pickWeightedSize(remainingSizes, new Set([firstSize])) || firstSize;
				picked.push(secondSize);
			}
		}

		// Add size tier offers.
		picked.forEach(key => {
			const factory = tierFactories[key];
			if (!factory) return;
			offers.push(factory());
		});

		// Add the random (mystery) card once it is unlocked.
		const randomCardUnlocked = (UNLOCK_PROGRESSION && typeof UNLOCK_PROGRESSION.isFeatureUnlocked === 'function')
			? UNLOCK_PROGRESSION.isFeatureUnlocked('randomShopCard', currentLevel, currentWorld)
			: currentLevel >= 2;
		if (randomCardUnlocked) {
			const randomCard = createShopCard(null, true);
			randomCard.isRandomShopCard = true;
			offers.push({ option: randomCard, cost: 6, fixed: false, isRandom: true });
		}

		// Defensive: ensure max 3.
		const finalOffers = offers.slice(0, 3);
		const coins = getSpendableCoinCount();
		finalOffers.forEach((offer, index) => {
		  const option = offer.option;
		  const cost = offer.cost;
		  const isRandom = !!offer.isRandom;
		  const isFixed = !!offer.fixed;
		  
		  const wrapper = document.createElement('div');
		  wrapper.classList.add('shop-card');
		  wrapper.dataset.cardCost = String(cost);
		  if (isRandom) wrapper.classList.add('shop-card-random');
		  if (isFixed) wrapper.classList.add('shop-card-fixed');

		  const header = document.createElement('div');
		  header.classList.add('shop-card-header');
		  
		  // Voor random kaarten geen titel tonen om geheim te houden.
		  // Voor niet-random: verberg de tetris-bloknaam (alleen kleur badge tonen).
		  if (!isRandom) {
			const colorBadge = document.createElement('span');
			colorBadge.classList.add('card-meta');
			const isGoldenCard = !!(option?.isGolden || option?.color?.isGolden);
			const displayName = getColorDisplayName(option?.color);
			colorBadge.textContent = isGoldenCard ? 'GOUD' : (displayName ? displayName.toUpperCase() : 'KAART');
			header.append(colorBadge);
		  }

		  const price = document.createElement('div');
		  price.classList.add('shop-card-price');
		  if (isRandom) {
			price.innerHTML = `âœ¨ Random: ${cost} ${coinIcon()}`;
		  } else {
			price.innerHTML = `Kosten: ${cost} ${coinIcon()}`;
		  }

		  const preview = document.createElement('div');
		  preview.classList.add('shop-card-preview');
		  
		  // Mystery card voor random slot
		  if (isRandom) {
			const mysteryContainer = document.createElement('div');
			mysteryContainer.classList.add('mystery-card-container');
			
			const mysteryInner = document.createElement('div');
			mysteryInner.classList.add('mystery-card-inner');
			mysteryInner.dataset.cardIndex = String(index);
			
			const mysteryFront = document.createElement('div');
			mysteryFront.classList.add('mystery-card-front');
			const questionMark = document.createElement('div');
			questionMark.classList.add('question-mark');
			questionMark.textContent = '?';
			mysteryFront.appendChild(questionMark);
			
			const mysteryBack = document.createElement('div');
			mysteryBack.classList.add('mystery-card-back');
			const previewCard = createCardElement(option, true, { onSelect: () => {} });
			previewCard.classList.add('shop-preview-card');
			previewCard.style.cursor = 'default';
			previewCard.style.pointerEvents = 'none';
			const { cardSize } = getCardSizing();
			const isMobileView = window.innerWidth <= MOBILE_BREAKPOINT;
			if (isMobileView) {
			  previewCard.style.width = '118px';
			  previewCard.style.minHeight = '178px';
			} else {
			  previewCard.style.width = `${cardSize}px`;
			  previewCard.style.minHeight = `${cardSize}px`;
			}
			mysteryBack.appendChild(previewCard);
			
			mysteryInner.append(mysteryFront, mysteryBack);
			mysteryContainer.appendChild(mysteryInner);
			preview.appendChild(mysteryContainer);
		  } else {
			// Normale kaart preview
			const previewCard = createCardElement(option, true, { onSelect: () => {} });
			previewCard.classList.add('shop-preview-card');
			previewCard.style.cursor = 'default';
			previewCard.style.pointerEvents = 'none';
			const { cardSize } = getCardSizing();
			const isMobileView = window.innerWidth <= MOBILE_BREAKPOINT;
			if (isMobileView) {
			  previewCard.style.width = '118px';
			  previewCard.style.minHeight = '178px';
			} else {
			  previewCard.style.width = `${cardSize}px`;
			  previewCard.style.minHeight = `${cardSize}px`;
			}
			preview.appendChild(previewCard);
		  }

		  const actions = document.createElement('div');
		  actions.classList.add('shop-card-actions');
		  const buyBtn = document.createElement('button');
		  buyBtn.textContent = 'Kopen';
		  buyBtn.disabled = coins < cost;
		  buyBtn.title = coins < cost ? 'Onvoldoende munten' : 'Voeg deze kaart toe aan je deck';
		  buyBtn.addEventListener('click', event => {
			 event.stopPropagation();
			 handleShopPurchase(option, cost, index);
		  });
		  actions.appendChild(buyBtn);

		  wrapper.append(header, price, preview, actions);
		  shopCardOptions.appendChild(wrapper);
		});
		applyCardSizing();
		refreshShopCardButtons();
	  }
	  if (shopModalMessage) {
		const coins = getSpendableCoinCount();
		const showUpgradesInMsg = currentLevel >= 5;
		
		let message = '';
		if (coins === 0) {
			message = 'Je hebt nog geen munten verzameld deze ronde.';
		} else if (showUpgradesInMsg) {
			message = `Je hebt ${coins} munt${coins === 1 ? '' : 'en'} om te besteden aan kaarten of upgrades.`;
		} else {
			message = `Je hebt ${coins} munt${coins === 1 ? '' : 'en'} om te besteden aan kaarten.`;
		}
		shopModalMessage.textContent = message;
	  }
	  updateShopCoinDisplay();
	  
	  // Toon/verberg upgrades en bonussen op basis van level
	  const showUpgrades = currentLevel >= 5; // Upgrades altijd zichtbaar vanaf level 5
	  const upgradesSection = document.querySelector('.shop-upgrades-section');
	  const bonusSection = document.querySelector('.shop-bonus-section');
	  const freePlaceSection = document.querySelector('.shop-freeplace-section');
	  const lowerGrid = document.querySelector('.shop-lower-grid');
	  
	  // VERBERG bonus sectie in normale shop (alleen beschikbaar via bonus shop button)
	  if (bonusSection) {
		bonusSection.style.display = 'none';
	  }
	  
	  // VERBERG freeplace sectie - dit is nu beschikbaar via de knop bij de munten
	  if (freePlaceSection) {
		freePlaceSection.style.display = 'none';
	  }
	  
	  if (showUpgrades) {
		// Kies Ã©Ã©n Level 2 variant voor deze shop-ronde en reset gebruiksvlag.
		shopLevel2Variant = pickBonusEchoVariant();
		shopLevel2Used = false;
		if (upgradesSection) upgradesSection.style.display = '';
		if (lowerGrid) lowerGrid.style.display = '';
		updateShopUpgradeUI();
	  } else {
		if (upgradesSection) upgradesSection.style.display = 'none';
		if (lowerGrid) lowerGrid.style.display = 'none';
	  }
	  
	  shopModalLayer.classList.add('show');
	}

	function handleShopPurchase(option, cost, cardIndex) {
	  if (!shopModalLayer) return;
	  const coinsAvailable = getSpendableCoinCount();
	  if (coinsAvailable < cost) {
		if (shopModalMessage) shopModalMessage.textContent = 'Onvoldoende munten voor deze kaart.';
		return;
	  }
	  if (!spendCoins(cost)) {
		if (shopModalMessage) shopModalMessage.textContent = 'Munten konden niet worden afgeschreven.';
		return;
	  }
	  
	  updateShopUpgradeUI();
	  updateShopBonusUI();
	  refreshShopCardButtons();
	  
	  // Check of dit een mystery/random card is
	  if (option && option.isRandomShopCard) {
		const mysteryInner = document.querySelector(`.mystery-card-inner[data-card-index="${cardIndex}"]`);
		if (mysteryInner) {
		  // Disable alle knoppen tijdens animatie
		  const allBuyButtons = shopCardOptions.querySelectorAll('button');
		  allBuyButtons.forEach(btn => btn.disabled = true);
		  
		  // Trigger flip animatie
		  mysteryInner.classList.add('flipped');
		  
		  // Wacht 1.5 seconden voordat we de kaart toevoegen
		  setTimeout(() => {
			ownedDeckBlueprints.push({
			  blueprintId: option.blueprintId,
			  shapeName: option.shapeName,
			  matrix: cloneShape(option.matrix),
			  category: option.category,
			  color: cloneColor(option.color),
			  isGolden: !!(option.isGolden || option.color?.isGolden),
			  isBonusBoost: !!option.isBonusBoost
			});
			
			// Shop blijft open - markeer mystery kaart als gekocht
			if (shopModalMessage) shopModalMessage.textContent = 'Mystery kaart gekocht! Koop meer of klik "Sla over".';
			const shopCards = shopCardOptions.querySelectorAll('.shop-card');
			if (shopCards[cardIndex]) {
			  shopCards[cardIndex].style.opacity = '0.5';
			  shopCards[cardIndex].style.pointerEvents = 'none';
			  const btn = shopCards[cardIndex].querySelector('button');
			  if (btn) {
				btn.disabled = true;
				btn.textContent = 'Gekocht!';
			  }
			}
			
			// Re-enable andere buttons
			const allBuyButtons = shopCardOptions.querySelectorAll('button');
			allBuyButtons.forEach(btn => {
			  if (!btn.closest('.shop-card').style.pointerEvents) {
				btn.disabled = false;
			  }
			});
			
			refreshShopCardButtons();
		  }, 1500);
		  return;
		}
	  }
	  
	  // Normale kaart aankoop
	  ownedDeckBlueprints.push({
		blueprintId: option.blueprintId,
		shapeName: option.shapeName,
		matrix: cloneShape(option.matrix),
		category: option.category,
		color: cloneColor(option.color),
		isGolden: !!(option.isGolden || option.color?.isGolden),
		isBonusBoost: !!option.isBonusBoost
	  });
	  
	  // Shop blijft open - verwijder de gekochte kaart en toon bericht
	  if (shopModalMessage) shopModalMessage.textContent = 'Kaart gekocht! Koop meer of klik "Sla over" om te sluiten.';
	  
	  // Verwijder de gekochte kaart visueel
	  const shopCards = shopCardOptions.querySelectorAll('.shop-card');
	  if (shopCards[cardIndex]) {
		shopCards[cardIndex].style.opacity = '0.5';
		shopCards[cardIndex].style.pointerEvents = 'none';
		const btn = shopCards[cardIndex].querySelector('button');
		if (btn) {
		  btn.disabled = true;
		  btn.textContent = 'Gekocht!';
		}
	  }
	  
	  // Update buttons maar sluit shop NIET
	  updateShopUpgradeUI();
	  updateShopBonusUI();
	  refreshShopCardButtons();
	}

	function skipShop() {
	  
	  // Herstel normale shop layout
	  const shopModalTitle = document.getElementById('shop-modal-title');
	  const shopCardOptions = document.getElementById('shop-card-options');
	  const upgradesSection = document.querySelector('.shop-upgrades-section');
	  
	  if (shopModalTitle) shopModalTitle.textContent = 'Kaarten & Upgrades';
	  if (shopCardOptions) {
		const cardsSection = shopCardOptions.closest('.shop-cards-section');
		if (cardsSection) cardsSection.style.display = '';
	  }
	  if (upgradesSection) upgradesSection.style.display = '';
	  
	  if (shopModalLayer) shopModalLayer.classList.remove('show');
	  if (typeof pendingShopCallback === 'function') pendingShopCallback();
	  pendingShopCallback = null;
	}

function resetWorldLayoutStyles() {
	const zoneIds = ['yellow-zone', 'purple-zone', 'green-zone', 'blue-zone', 'red-zone'];
	const gridIds = ['yellow-grid', 'purple-grid', 'green-grid', 'blue-grid', 'red-grid'];
	const redSubGridIds = ['red-grid1', 'red-grid2', 'red-grid3', 'red-grid4', 'red-grid5', 'red-grid6'];
	zoneIds.forEach(id => {
		const el = document.getElementById(id);
		if (!el || !el.style) return;
		['width','height','min-width','max-width','min-height','max-height','overflow','overflow-x','overflow-y','transform','transform-origin','position','top','left','right','bottom'].forEach(prop => {
			try { el.style.removeProperty(prop); } catch (_) {}
		});
	});
	gridIds.forEach(id => {
		const el = document.getElementById(id);
		if (!el || !el.style) return;
		['margin','margin-left','margin-right','margin-top','margin-bottom','justify-content','transform','transform-origin','width','height'].forEach(prop => {
			try { el.style.removeProperty(prop); } catch (_) {}
		});
	});
	// Reset red subgrids visibility to default (1-4 visible, 5-6 hidden)
	['red-grid1','red-grid2','red-grid3','red-grid4'].forEach(id => {
		const el = document.getElementById(id);
		if (el) el.style.display = '';
	});
	['red-grid5','red-grid6'].forEach(id => {
		const el = document.getElementById(id);
		if (el) el.style.display = 'none';
	});
	// Reset world3 red lock visibility
	const lockEl = document.getElementById('world3-red-lock');
	if (lockEl) lockEl.style.display = '';
	// Also reset board columns
	const columns = document.querySelectorAll('#board > .column');
	columns.forEach(col => {
		if (!col || !col.style) return;
		['width','height','min-width','max-width','min-height','max-height','transform','transform-origin','position'].forEach(prop => {
			try { col.style.removeProperty(prop); } catch (_) {}
		});
	});
}

	function rebuildGameBoards() {
	  // Scenario sessions use an imported board; never regenerate the level boards in that mode.
	  // This prevents upgrade callbacks (e.g., blackHoleAccess) from overwriting the imported layout.
	  try {
		if (window && window._locusScenarioMode && !isLoadingGame) {
			return;
		}
	  } catch (e) {}
	  closeZoom();
	  resetScoreState();
	  historyStack.length = 0;
	  bumpGridVersion();
	  
	  // Bepaal in welke world we zitten
	  const { world, subLevel } = getWorldAndSubLevel(currentLevel);
	  currentWorld = world;
	  document.body.classList.toggle('world-2', world === 2);
	  document.body.classList.toggle('world-1', world === 1);
	  document.body.classList.toggle('world-3', world === 3);
	  document.body.classList.toggle('world-4', world === 4);
	  if (world !== 4) {
		setWorld4AllowedColors(null);
		clearWorld4Locks();
	  }
	  
	  // World 1: disable scrolling in green zone
	  const greenZone = document.getElementById('green-zone');
	  if (greenZone) {
		if (world === 1) {
		  greenZone.classList.add('no-scroll');
		} else {
		  greenZone.classList.remove('no-scroll');
		}
	  }
	  
	  if (world === 1) {
		rebuildGameBoards_World1();
	  } else if (world === 2) {
		rebuildGameBoards_World2();
	  } else if (world === 3) {
		rebuildGameBoards_World3();
	  } else if (world === 4) {
		rebuildGameBoards_World4();
	  } else {
		// Fallback naar World 3 voor toekomstige worlds
		rebuildGameBoards_World3();
	  }
	  // World 3 red progression visibility (and ensure 5/6 stay hidden in other worlds)
	  try { applyWorld3RedStage(world === 3 ? world3RedStage : 0); } catch (e) {}
	  // Ensure layout is rebuilt after world switches (prevents stale sizing/layout state).
	  try {
		if (typeof scheduleLayoutReflow === 'function') {
			// Force reflow even if viewport hasn't changed (level change at same window size).
			if (typeof lastLayoutViewportKey !== 'undefined') lastLayoutViewportKey = '';
			scheduleLayoutReflow(0);
		}
	  } catch (e) {}
	}

	// WORLD 4: Board layout = World 3 sizing/layout, plus doors/keys gating
	function getWorld4YellowShape(subLevel = 1) {
		const shapes = [
			{
				name: 'kroon',
				pattern: [4, 6, 8, 10, 12, 14, 12, 10, 12, 10, 8, 6, 4],
				offsets: [5, 4, 3, 2, 1, 0, 1, 2, 1, 2, 3, 4, 5],
				boldCells: [[5, 6], [5, 7], [6, 6], [6, 7]]
			},
			{
				name: 'schild',
				pattern: [6, 8, 10, 12, 12, 12, 10, 8, 6],
				offsets: [3, 2, 1, 0, 0, 0, 1, 2, 3],
				boldCells: [[4, 5], [4, 6], [3, 6], [5, 6]]
			},
			{
				name: 'zandloper',
				pattern: [4, 6, 8, 10, 8, 6, 4, 6, 8, 10, 8, 6, 4],
				offsets: [4, 3, 2, 1, 2, 3, 4, 3, 2, 1, 2, 3, 4],
				boldCells: [[6, 5], [6, 6], [5, 5], [7, 6]]
			}
		];
		const idx = Math.max(0, (Number(subLevel || 1) - 1) % shapes.length);
		return shapes[idx];
	}

	function applyWorld4YellowGeneration(subLevel = 1) {
		const yellowShape = getWorld4YellowShape(subLevel);
		if (!yellowShape) return;
		const yellowRows = yellowShape.pattern.length;
		const yellowCols = Math.max(
			...yellowShape.pattern.map((len, i) => (Number(len) || 0) + (Number(yellowShape.offsets[i]) || 0))
		);
		const yellowPointsArray = [12, 18, 24, 32, 40, 48, 56, 64, 72, 80, 88, 96, 104, 112];
		const yellowColumnPoints = yellowShape.pattern.map((_, idx) => yellowPointsArray[idx] || (48 + (idx - 5) * 8));
		window.yellowGridConfig = {
			rows: yellowRows,
			cols: yellowCols,
			rowLengths: yellowShape.pattern.slice(),
			rowOffsets: yellowShape.offsets.slice(),
			pointsByColumn: yellowColumnPoints.slice(),
			columnHeights: yellowShape.pattern.map((_, i) => i),
			pointsByRow: [],
			pointsByWidth: {},
			pointsPerRow: 0,
			pointsPerColumn: 0,
			scoreMode: 'rings',
			ringMinPoints: 14,
			ringMaxPoints: 72
		};
		createGrid('yellow-grid', yellowRows, yellowCols, {
			goldCells: true,
			symbols: true,
			minSymbols: 10,
			maxSymbols: 12,
			coinChance: 0.12,
			maxCoins: 16,
			rowLengths: yellowShape.pattern,
			rowOffsets: yellowShape.offsets,
			fixedBoldCells: yellowShape.boldCells,
			boldColumns: [],
			pointsPerColumn: yellowColumnPoints,
			ringShading: true,
			trimRight: true,
			trapChance: 0,
			maxTraps: 0,
			blackHoleChance: 0
		});
		try { bumpGridVersion(); } catch (e) {}
		const yellowZone = document.getElementById('yellow-zone');
		if (yellowZone && yellowShape.boldCells) {
			const cleanupYellowStartCell = (cell) => {
				if (!cell) return;
				cell.classList.remove('gold-cell');
				cell.querySelectorAll('.symbol').forEach(s => s.remove());
				if (cell.classList.contains('trap-cell')) {
					cell.classList.remove('trap-cell');
					delete cell.dataset.trap;
					delete cell.dataset.trapType;
					delete cell.dataset.trapTriggered;
					delete cell.dataset.trapInstanceId;
					cell.querySelectorAll('.trap-symbol').forEach(s => s.remove());
				}
			};
			yellowShape.boldCells.forEach(([row, col]) => {
				const cell = getCell(yellowZone, col, row);
				if (!cell) return;
				if (!cell.classList.contains('bold-cell')) cell.classList.add('bold-cell');
				cleanupYellowStartCell(cell);
			});
			yellowZone.querySelectorAll('.cell.bold-cell').forEach(cleanupYellowStartCell);
		}
	}

	function rebuildGameBoards_World4() {
		// Reuse World 3 generator for consistent field layout
		rebuildGameBoards_World3();
		try {
			const info = (typeof getWorldAndSubLevel === 'function') ? getWorldAndSubLevel(currentLevel) : null;
			applyWorld4YellowGeneration(Number(info?.subLevel || 1));
		} catch (e) { console.warn('World 4 yellow generation failed', e); }
		try { applyWorld4LocksForLevel(currentLevel); } catch (e) { console.warn('World 4 locks failed', e); }
	}

	function applyWorld4LocksForLevel(level) {
		// Clear any previous state for this level (board is already rebuilt at this point)
		try { clearWorld4Locks(); } catch (e) {}

			// World 4: start with a limited palette (random 3 of 5 zones per level).
			// IMPORTANT: keys/doors should only involve the active colors (no references to inactive zones).
			const activeColors = getWorld4ActiveColorsForLevel(level);
			const inactiveColors = WORLD4_ALL_COLORS.filter(c => !activeColors.includes(c));
			try { setWorld4AllowedColors(activeColors); } catch (e) {}
			try { if (!(world4UnlockedColors instanceof Set)) world4UnlockedColors = new Set(); world4UnlockedColors.clear(); window.world4UnlockedColors = world4UnlockedColors; } catch (e) {}

		const worldInfo = (typeof getWorldAndSubLevel === 'function') ? getWorldAndSubLevel(level) : null;
		if (!worldInfo || Number(worldInfo.world) !== 4) return;

		const greenZone = document.getElementById('green-zone');
		const purpleZone = document.getElementById('purple-zone');
		const blueZone = document.getElementById('blue-zone');
		const yellowZone = document.getElementById('yellow-zone');
		const redZone = document.getElementById('red-zone');
		if (!greenZone) return;

		// Hide inactive zones at the start of the level.
		try {
			const hideZone = (colorKey) => {
				const c = String(colorKey || '').toLowerCase();
				if (c === 'rood') {
					if (redZone) redZone.style.display = 'none';
					return;
				}
				const z = document.querySelector(`.zone[data-color="${c}"]`) || document.getElementById(`${c}-zone`);
				if (z) z.style.display = 'none';
			};
			inactiveColors.forEach(hideZone);
		} catch (e) {}

		// Ensure active zones are visible (in case a previous level hid them).
		try {
			const showZone = (colorKey) => {
				const c = String(colorKey || '').toLowerCase();
				if (c === 'rood') {
					if (redZone) redZone.style.display = '';
					return;
				}
				const z = document.querySelector(`.zone[data-color="${c}"]`) || document.getElementById(`${c}-zone`);
				if (z) z.style.display = '';
			};
			activeColors.forEach(showZone);
		} catch (e) {}

		function ensureCellSymbol(cell, cls, html) {
			if (!cell) return;
			try {
				let el = cell.querySelector(`.${cls}`);
				if (!el) {
					el = document.createElement('span');
					el.className = cls;
					cell.appendChild(el);
				}
				el.innerHTML = html;
			} catch (e) {}
		}

		// Use the nicer 4.2-style glyphs (emoji) for immediate readability.
		const ICON_KEY = '<span class="key-glyph" aria-hidden="true">ðŸ—ï¸</span>';
		const ICON_DOOR = '<span class="door-glyph" aria-hidden="true">ðŸšª</span>';

		function isStampableCell(cell) {
			if (!cell) return false;
			if (cell.classList.contains('void-cell')) return false;
			if (cell.dataset.disabled === 'true') return false;
			if (cell.classList.contains('bold-cell')) return false;
			if (cell.classList.contains('active')) return false;
			if (cell.classList.contains('key-cell') || cell.classList.contains('door-cell')) return false;
			return true;
		}

		function findNearestStampableCell(zone, preferredX, preferredY, maxRadius = 10) {
			if (!zone) return null;
			let metrics = null;
			try { metrics = (typeof getZoneMetrics === 'function') ? getZoneMetrics(zone) : null; } catch (e) { metrics = null; }
			const inBounds = (x, y) => {
				if (!metrics) return true;
				return x >= metrics.minX && x <= metrics.maxX && y >= metrics.minY && y <= metrics.maxY;
			};
			// Ring search around the preferred coordinate
			for (let r = 0; r <= maxRadius; r++) {
				for (let dy = -r; dy <= r; dy++) {
					for (let dx = -r; dx <= r; dx++) {
						if (Math.max(Math.abs(dx), Math.abs(dy)) !== r) continue;
						const x = preferredX + dx;
						const y = preferredY + dy;
						if (!inBounds(x, y)) continue;
						const c = getCell(zone, x, y);
						if (c && isStampableCell(c)) return c;
					}
				}
			}
			// Fallback: any stampable cell in zone
			try {
				const all = Array.from(zone.querySelectorAll('.cell')).filter(isStampableCell);
				return all.length ? all[0] : null;
			} catch (e) {
				return null;
			}
		}

		function getZoneMetricsSafe(zone) {
			try {
				return (typeof getZoneMetrics === 'function') ? getZoneMetrics(zone) : null;
			} catch (e) {
				return null;
			}
		}

		function clampRegionToMetrics(region, metrics) {
			if (!metrics || !region) return region;
			const minX = Number(metrics.minX);
			const maxX = Number(metrics.maxX);
			const minY = Number(metrics.minY);
			const maxY = Number(metrics.maxY);
			if (!Number.isFinite(minX) || !Number.isFinite(maxX) || !Number.isFinite(minY) || !Number.isFinite(maxY)) return region;
			const w = Math.max(1, Math.min(region.w, (maxX - minX + 1)));
			const h = Math.max(1, Math.min(region.h, (maxY - minY + 1)));
			const x0 = Math.max(minX, Math.min(region.x0, maxX - w + 1));
			const y0 = Math.max(minY, Math.min(region.y0, maxY - h + 1));
			return { x0, y0, w, h };
		}

		function buildDoorPlacementForZone(zone, colorKey, index, doorCount, subLevel) {
			const metrics = getZoneMetricsSafe(zone);
			const minX = Number(metrics?.minX ?? 0);
			const maxX = Number(metrics?.maxX ?? 10);
			const minY = Number(metrics?.minY ?? 0);
			const maxY = Number(metrics?.maxY ?? 10);
			const width = Math.max(1, maxX - minX + 1);
			const height = Math.max(1, maxY - minY + 1);
			const t = Math.min(1, Math.max(0, (Number(subLevel || 1) - 1) / 9));
			const doorX = minX + Math.round(width * (0.55 + (index % 2 === 0 ? 0.08 : -0.06)));
			const doorY = minY + Math.round(height * (0.35 + (index % 3) * 0.12));
			const baseW = Math.max(4, Math.round(width * (0.26 + t * 0.08)));
			const baseH = Math.max(4, Math.round(height * (0.24 + t * 0.10)));
			const regions = [
				{ x0: minX + Math.round(width * 0.62), y0: minY + Math.round(height * 0.12), w: baseW, h: baseH },
				{ x0: minX + Math.round(width * 0.12), y0: minY + Math.round(height * 0.62), w: baseW, h: baseH },
				{ x0: minX + Math.round(width * 0.58), y0: minY + Math.round(height * 0.58), w: baseW, h: baseH }
			].map(r => clampRegionToMetrics(r, metrics));
			return { x: doorX, y: doorY, regions };
		}

		function lockRegionBehindDoor(zone, doorId, x0, y0, w, h) {
			if (!zone) return 0;
			let locked = 0;
			for (let y = 0; y < h; y++) {
				for (let x = 0; x < w; x++) {
					const cell = getCell(zone, x0 + x, y0 + y);
					if (!cell) continue;
					if (cell.dataset.doorId && String(cell.dataset.doorId) === String(doorId)) continue;
					if (cell.classList.contains('bold-cell')) continue;
					if (cell.classList.contains('active')) continue;
					cell.dataset.lockedDoorId = String(doorId);
					cell.classList.add('locked-behind-door');
					locked++;
				}
			}
			return locked;
		}

		function tryLockRegion(zone, doorId, candidates) {
			if (!zone || !candidates || !candidates.length) return 0;
			for (const c of candidates) {
				const locked = lockRegionBehindDoor(zone, doorId, c.x0, c.y0, c.w, c.h);
				if (locked > 0) return locked;
			}
			return 0;
		}

		function lockRegions(zone, doorId, candidates, maxRegions = 1) {
			if (!zone || !candidates || !candidates.length) return 0;
			let total = 0;
			let used = 0;
			for (const c of candidates) {
				if (used >= maxRegions) break;
				const locked = lockRegionBehindDoor(zone, doorId, c.x0, c.y0, c.w, c.h);
				if (locked > 0) {
					total += locked;
					used += 1;
				}
			}
			return total;
		}

		function placeDoor(zone, x, y, doorId, colorKey) {
			let cell = getCell(zone, x, y);
			if (!cell || !isStampableCell(cell)) {
				cell = findNearestStampableCell(zone, x, y, 12);
			}
			if (!cell) return null;
			// Visual ink: always match the zone this door is placed in (active color).
			try {
				const ink = String(zone && zone.dataset ? (zone.dataset.color || '') : '').toLowerCase();
				if (ink) cell.dataset.w4Ink = ink;
			} catch (_) {}
			// Ensure door cells don't also act as bonus/coin/trap cells
			try {
				cell.classList.remove('gold-cell', 'trap-cell');
				delete cell.dataset.trap;
				delete cell.dataset.trapType;
				delete cell.dataset.trapTriggered;
				cell.querySelectorAll('.symbol,.trap-symbol').forEach(s => s.remove());
			} catch (e) {}
			cell.classList.add('door-cell');
			cell.dataset.doorId = String(doorId);
			cell.dataset.doorColor = String(colorKey);
			ensureCellSymbol(cell, 'door-symbol', ICON_DOOR);
			return cell;
		}

		function placeKey(zone, x, y, colorKey) {
			let cell = getCell(zone, x, y);
			if (!cell || !isStampableCell(cell)) {
				cell = findNearestStampableCell(zone, x, y, 12);
			}
			if (!cell) return null;
			// Visual ink: always match the zone this key is placed in (active color).
			try {
				const ink = String(zone && zone.dataset ? (zone.dataset.color || '') : '').toLowerCase();
				if (ink) cell.dataset.w4Ink = ink;
			} catch (_) {}
			// Ensure key cells don't also grant coins/bonuses/traps
			try {
				cell.classList.remove('gold-cell', 'trap-cell');
				delete cell.dataset.trap;
				delete cell.dataset.trapType;
				delete cell.dataset.trapTriggered;
				cell.querySelectorAll('.symbol,.trap-symbol').forEach(s => s.remove());
			} catch (e) {}
			cell.classList.add('key-cell');
			cell.dataset.keyColor = String(colorKey);
			cell.dataset.keyConsumed = 'false';
			ensureCellSymbol(cell, 'key-symbol', ICON_KEY);
			return cell;
		}

		function placeKeyOnCell(cell, colorKey) {
			if (!cell || !colorKey) return null;
			if (!isStampableCell(cell) && !cell.classList.contains('locked-behind-door')) return null;
			// Visual ink: match the zone color
			try {
				const zone = cell.closest('.zone');
				const ink = String(zone && zone.dataset ? (zone.dataset.color || '') : '').toLowerCase();
				if (ink) cell.dataset.w4Ink = ink;
			} catch (_) {}
			try {
				cell.classList.remove('gold-cell', 'trap-cell');
				delete cell.dataset.trap;
				delete cell.dataset.trapType;
				delete cell.dataset.trapTriggered;
				cell.querySelectorAll('.symbol,.trap-symbol').forEach(s => s.remove());
			} catch (e) {}
			cell.classList.add('key-cell');
			cell.dataset.keyColor = String(colorKey);
			cell.dataset.keyConsumed = 'false';
			ensureCellSymbol(cell, 'key-symbol', ICON_KEY);
			return cell;
		}

		// Place doors/keys for active colors only.
		// Each door locks a larger region in the SAME active zone, until its matching key is used.
		const activeZonesByColor = {
			geel: yellowZone,
			groen: greenZone,
			blauw: blueZone,
			paars: purpleZone,
			rood: document.getElementById('red-grid1') || redZone
		};
		const subLevel = Number(worldInfo?.subLevel || 1);
		const rng = world4Mulberry32(0xC0FFEE ^ (Number(level) || 1));
		const doorCount = Math.max(1, Math.min(activeColors.length, (subLevel <= 2 ? 1 : (subLevel <= 5 ? 2 : 3))));
		const doorColors = shuffleWithRng(activeColors.slice(), rng).slice(0, doorCount);
		const lockRegionCount = subLevel >= 6 ? 2 : 1;

		const placedDoors = [];
		doorColors.forEach((doorColor, idx) => {
			const zone = activeZonesByColor[doorColor];
			if (!zone) return;
			const doorId = `w4:door:${doorColor}:${idx + 1}`;
			const placement = buildDoorPlacementForZone(zone, doorColor, idx, doorCount, subLevel);
			const doorCell = placeDoor(zone, placement.x, placement.y, doorId, doorColor);
			if (!doorCell) return;
			try { lockRegions(zone, doorId, placement.regions || [], lockRegionCount); } catch (e) {}
			placedDoors.push({ doorColor, doorId, zone });
		});

		const pickKeyCellBehindDoor = (doorId) => {
			try {
				const locked = Array.from(document.querySelectorAll(`.cell[data-locked-door-id="${doorId}"]`));
				const viable = locked.filter(c => c && !c.classList.contains('door-cell') && !c.classList.contains('key-cell'));
				if (!viable.length) return null;
				const idx = Math.floor(rng() * viable.length);
				return viable[idx] || null;
			} catch (e) {
				return null;
			}
		};

		const pickZoneKeyAnchor = (zone) => {
			const metrics = getZoneMetricsSafe(zone);
			const minX = Number(metrics?.minX ?? 1);
			const maxX = Number(metrics?.maxX ?? 8);
			const minY = Number(metrics?.minY ?? 1);
			const maxY = Number(metrics?.maxY ?? 8);
			const x = minX + Math.max(1, Math.round((maxX - minX) * 0.15));
			const y = minY + Math.max(1, Math.round((maxY - minY) * 0.15));
			return { x, y };
		};

		// Place keys; later keys can be hidden behind earlier doors for a larger progression.
		placedDoors.forEach((d, i) => {
			const targetDoorColor = d.doorColor;
			let placed = false;
			if (subLevel >= 4 && i > 0) {
				const prev = placedDoors[i - 1];
				const lockedCell = prev ? pickKeyCellBehindDoor(prev.doorId) : null;
				if (lockedCell) {
					const keyCell = placeKeyOnCell(lockedCell, targetDoorColor);
					if (keyCell) placed = true;
				}
			}
			if (placed) return;
			// Otherwise, place in a different active zone.
			const candidateZones = activeColors
				.filter(c => c !== targetDoorColor)
				.map(c => activeZonesByColor[c])
				.filter(Boolean);
			const fallbackZones = activeColors.map(c => activeZonesByColor[c]).filter(Boolean);
			const zones = candidateZones.length ? candidateZones : fallbackZones;
			for (let zi = 0; zi < zones.length && !placed; zi++) {
				const z = zones[(zi + i) % zones.length];
				const coord = pickZoneKeyAnchor(z);
				const keyCell = placeKey(z, coord.x, coord.y, targetDoorColor);
				if (keyCell) placed = true;
			}
		});

		// World 4 upgrade: start with 1 unlocked door color (starter key).
		try {
			if (hasUpgrade('world4StarterKey') && placedDoors.length) {
				const pickIdx = Math.floor(rng() * placedDoors.length);
				const autoColor = placedDoors[pickIdx]?.doorColor || placedDoors[0]?.doorColor;
				if (autoColor) unlockWorld4Color(autoColor);
			}
		} catch (e) {}

		// Refresh UI after World 4 gating updates.
		try { updateBonusInventoryUI(); } catch (e) {}
		try { renderCurrentHand(); } catch (e) {}
	}

	// WORLD 1: Originele grid layout (levels 1-10)
	function rebuildGameBoards_World1() {
	  
	  const yellowColumnHeights = [6, 6, 8, 8, 10, 10, 12, 12, 14, 14];
	  const yellowCols = yellowColumnHeights.length;
	  const yellowRows = Math.max(...yellowColumnHeights);
	  const yellowRowPattern = [];
	  const yellowRowOffsets = [];
	  for (let r = 0; r < yellowRows; r++) {
		let activeCount = 0;
		for (let c = 0; c < yellowCols; c++) {
		  const topRow = yellowRows - yellowColumnHeights[c];
		  if (r >= topRow) activeCount++;
		}
		yellowRowPattern.push(activeCount);
		yellowRowOffsets.push(Math.max(0, yellowCols - activeCount));
	  }
	  // Punten per kolom: 8 voor eerste, dan 12, 16, 24, 32, 40... (exponentieel stijgend)
	  const yellowPointsArray = [8, 12, 16, 24, 32, 40, 48, 56, 64, 72];
	  const yellowColumnPoints = yellowColumnHeights.map((height, idx) => yellowPointsArray[idx] || (24 + (idx - 3) * 8));
	  
	  window.yellowGridConfig = {
		rows: yellowRows,
		cols: yellowCols,
		rowLengths: yellowRowPattern.slice(),
		rowOffsets: yellowRowOffsets.slice(),
		pointsByColumn: yellowColumnPoints.slice(),
		columnHeights: yellowColumnHeights.slice(),
		pointsByRow: [],
		pointsByWidth: {},
		pointsPerRow: 0,
		pointsPerColumn: 0
	  };
	  
	  const blueRowPattern = [2, 2, 3, 3, 3, 2, 2, 3, 3, 2, 2, 3, 3, 3, 2, 2, 3, 3, 2, 2, 3, 3, 2, 3, 3];
	  const blueRowOffsets = [1, 1, 1, 0, 0, 1, 2, 2, 2, 3, 2, 2, 1, 1, 1, 0, 0, 0, 1, 2, 2, 2, 3, 2, 1];
	  const blueRows = blueRowPattern.length;
	  const blueCols = Math.max(...blueRowOffsets.map((offset, idx) => offset + (blueRowPattern[idx] || 0)), 3);

	  // Alleen traps genereren vanaf level 5, met scaling naar level 10
	  const shouldGenerateTraps = currentLevel >= 5;
	  const blackHoleAvailable = isUpgradeAvailable('blackHoleAccess');
	  // Trap chance schaalt van 0.05 (level 5) naar 0.09 (level 10+)
	  const baseTrapChance = shouldGenerateTraps ? (currentLevel >= 10 ? 0.09 : 0.05) : 0;
	  const trapChance = baseTrapChance;
	  const maxTraps = shouldGenerateTraps ? (currentLevel >= 10 ? 8 : 5) : 0;
	  const blackHoleChance = blackHoleAvailable ? BLACK_HOLE_DEFAULT_CHANCE : 0;
	  
	  // Als black hole upgrade is gekocht: maximaal 1 black hole per level
	  const blackHoleOnlyChance = blackHoleAvailable && !shouldGenerateTraps ? 0.10 : 0;
	  const blackHoleOnlyMaxTraps = blackHoleAvailable && !shouldGenerateTraps ? 1 : 0;

	  const boardConfigs = [
		() => createGrid('yellow-grid', yellowRows, yellowCols, { goldCells: true, symbols: true, minSymbols: 8, maxSymbols: 8, coinChance: 0.22, maxCoins: 17, rowLengths: yellowRowPattern, rowOffsets: yellowRowOffsets, boldColumns: [0], pointsPerColumn: yellowColumnPoints, columnShading: true, trapChance: 0, maxTraps: 0, blackHoleChance: 0 }),
		() => {
			const isIntroLevel = Number(currentLevel || 0) === 0;
			const purpleOptions = {
				symbols: true,
				goldCells: true,
				minSymbols: 8,
				maxSymbols: 8,
				coinChance: 0.03,
				maxCoins: 4,
				avoidAdjacentBold: true,
				trapChance: (shouldGenerateTraps ? 0.08 : 0) || blackHoleOnlyChance,
				maxTraps: shouldGenerateTraps ? 7 : 0,
				blackHoleChance: blackHoleAvailable ? 0.3 : 0
			};
			if (isIntroLevel) {
				purpleOptions.randomBoldCount = 0;
				purpleOptions.ensureAdjacentBoldPair = true;
			} else {
				purpleOptions.randomBoldCount = 8;
				purpleOptions.ensureAdjacentBoldPair = false;
			}
			return createGrid('purple-grid', 9, 9, purpleOptions);
		},
		() => createGrid('blue-grid', blueRows, blueCols, { boldBottom: true, goldCells: true, symbols: true, minSymbols: 8, maxSymbols: 8, coinChance: 0.07, maxCoins: 8, rowLengths: blueRowPattern, rowOffsets: blueRowOffsets, trapChance: (shouldGenerateTraps ? 0.04 : 0), maxTraps: shouldGenerateTraps ? 4 : 0, blackHoleChance: 0 }),
		() => generateRoots('green-grid', 15, 15, 40, 0.25, 0.06, 12, 16, 4, false, (shouldGenerateTraps ? 0.07 : 0), shouldGenerateTraps ? 5 : 0, 0),
		() => generateRoots('red-grid1', 4, 4, 10, 0.3, 0.04, 2, 2, 2, true, 0.00, 0, 0, { targetCells: 8, targetPoints: 16, showPointsLabel: true }),
		() => generateRoots('red-grid2', 4, 5, 10, 0.3, 0.04, 2, 3, 2, true, 0.00, 0, 0, { targetCells: 12, targetPoints: 30, showPointsLabel: true }),
		() => generateRoots('red-grid3', 5, 5, 12, 0.3, 0.06, 3, 4, 2, true, 0.00, 0, 0, { targetCells: 16, targetPoints: 40, showPointsLabel: true }),
		() => generateRoots('red-grid4', 5, 5, 12, 0.3, 0.06, 4, 4, 2, true, 0.00, 0, 0, { targetCells: 20, targetPoints: 50, showPointsLabel: true })
	  ];
	  boardConfigs.forEach(fn => fn());
	  updateScore();
	  
	  // Reset zone groottes naar originele World 1 waardes
	  resetZoneSizesForWorld1();
	}
	
	// Reset zone groottes naar originele World 1 CSS waardes
	function resetZoneSizesForWorld1() {
	  const yellowZone = document.getElementById('yellow-zone');
	  const purpleZone = document.getElementById('purple-zone');
	  const blueZone = document.getElementById('blue-zone');
	  const greenZone = document.getElementById('green-zone');
	  const blueGrid = document.getElementById('blue-grid');
	  
	  if (yellowZone) {
		yellowZone.style.height = '450px';
		yellowZone.style.minWidth = '300px';
		yellowZone.style.width = '';
	  }
	  
	  if (purpleZone) {
		purpleZone.style.height = '310px';
		purpleZone.style.width = '';
	  }
	  
	  if (blueZone) {
		blueZone.style.width = '180px';
		blueZone.style.maxHeight = '';
		blueZone.style.overflowX = '';
		blueZone.style.overflowY = '';
		blueZone.style.minWidth = '';
	  }
	  if (blueGrid) {
		blueGrid.style.transform = '';
		blueGrid.style.justifyContent = '';
		blueGrid.style.marginLeft = '';
		blueGrid.style.marginRight = '';
	  }
	  
	  if (greenZone) {
		greenZone.style.width = '';
		greenZone.style.height = '';
		greenZone.style.maxHeight = '';
		greenZone.style.overflowY = '';
		greenZone.style.overflowX = '';
	  }
	}


	// WORLD 2: Nieuwe complexe grids (levels 11-20)
	function rebuildGameBoards_World2() {
	  const { subLevel } = getWorldAndSubLevel(currentLevel);
	  
	  // Trap/black hole configuratie
	  const shouldGenerateTraps = currentLevel >= 15; // World 2 start met traps vanaf sublevel 5
	  const blackHoleAvailable = isUpgradeAvailable('blackHoleAccess');
	  const trapChance = shouldGenerateTraps ? 0.12 : 0.05;
	  const maxTraps = shouldGenerateTraps ? 12 : 3;
	  const blackHoleChance = blackHoleAvailable ? BLACK_HOLE_DEFAULT_CHANCE : 0;
	  
	  // GEEL: Verschillende vormen (diamant, ster, spiraal, etc) in plaats van lijnen
	  // Grotere grids met speciale patronen die je moet voltooien
	  const yellowShapes = [
		// Diamant patroon - GROTER en langwerpiger
		{ pattern: [3, 4, 6, 8, 10, 11, 10, 8, 6, 4, 3], offsets: [5, 4, 3, 2, 1, 0, 1, 2, 3, 4, 5], boldCells: [[0,0], [5,5], [10,10], [0,10], [5,0]] },
		// Spiraal - Vierkant 11x11 (1 rij korter voor vierkant vorm)
		{ pattern: [11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11], offsets: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], boldCells: [[0,0], [0,10], [10,0], [10,10], [5,5]] },
		// Kruis - GROTER en langwerpiger
		{ pattern: [3, 3, 3, 3, 3, 10, 3, 3, 3, 3, 3], offsets: [3, 3, 3, 3, 3, 0, 3, 3, 3, 3, 3], boldCells: [[0,0], [0,2], [5,0], [5,9], [10,0], [10,2]] }
	  ];
	  // WORLD 2 request: keep the yellow board shape consistent across sublevels.
	  // Use the rectangular "spiral" layout (index 1) instead of rotating to the cross/plus.
	  const yellowShape = yellowShapes[1];
	  const yellowRows = yellowShape.pattern.length;
	  const yellowCols = Math.max(...yellowShape.pattern) + Math.max(...yellowShape.offsets);
	  // Punten per kolom: 8 voor eerste, dan 12, 16, 24, 32, 40... (exponentieel stijgend)
	  const yellowPointsArray = [8, 12, 16, 24, 32, 40, 48, 56, 64, 72];
	  const yellowColumnPoints = yellowShape.pattern.map((width, idx) => yellowPointsArray[idx] || (24 + (idx - 3) * 8));
	  
	  window.yellowGridConfig = {
		rows: yellowRows,
		cols: yellowCols,
		rowLengths: yellowShape.pattern.slice(),
		rowOffsets: yellowShape.offsets.slice(),
		pointsByColumn: yellowColumnPoints.slice(),
		columnHeights: yellowShape.pattern.map((_, i) => i),
		pointsByRow: [],
		pointsByWidth: {},
		pointsPerRow: 0,
		pointsPerColumn: 0,
		// WORLD 2: Yellow is scored by diagonals (not columns)
		scoreMode: 'diagonal',
		diagonalAxis: 'xMinusY',
		diagonalPointsPerCell: 2,
		minDiagonalLength: 4,
		// World 2 request: allow scoring for corner â†’ center (bold cell) diagonal segments.
		allowDiagonalToCenter: true
	  };
	  
	  // BLAUW: Lange continue rivier (60+ rijen) die kronkelt en soms breed wordt
	  // Blauw grid: Continue rivier die altijd doorloopt, met extra tak tijdens split
	  // World 2 request (UX): keep the river within the zone width (no horizontal scrolling needed).
	  // Maak de rivier iets smaller zodat hij beter op het scherm past.
	  const blueCols = 10;
	  const blueRowPattern = [];
	  const blueRowOffsets = [];
	  const blueSplitData = []; // Voor tracking split info
	  const blueGapCells = new Set(); // Cells die void moeten zijn (gap tussen main en split)
	  
	  let currentOffset = 4;
	  let currentWidth = 3;
	  let prevOffset = currentOffset;
	  let prevWidth = currentWidth;
	  
	  // Split tracking
	  let inSplit = false;
	  let splitRowsLeft = 0;
	  let splitOffset = 0;
	  let splitWidth = 3;
	  let prevSplitOffset = 0;
	  let prevSplitWidth = 3;
	  
	  for (let i = 0; i < 60; i++) {
		// Variatie in breedte van hoofdrivier
		if (i % 12 === 7) {
		  currentWidth = 4 + Math.floor(Math.random() * 2); // 4-5 breed
		} else {
		  currentWidth = 2 + Math.floor(Math.random() * 3); // 2-4 breed
		}
		
		// ALTIJD overlap checken voor hoofdrivier (ook tijdens split!)
		if (i > 0) {
		  const minOffset = prevOffset - currentWidth + 1; // Minimaal 1 cell overlap
		  const maxOffset = prevOffset + prevWidth - 1;
		  
		  // Kleine kronkeling
		  let newOffset = currentOffset;
		  if (Math.random() > 0.5) {
			newOffset += (Math.random() > 0.5 ? 1 : -1);
		  }
		  
		  const mainMaxOffset = Math.max(0, blueCols - currentWidth);
		  // Beperk binnen overlap range Ã©n binnen de grid-breedte
		  const boundedMinOffset = Math.max(0, Math.min(mainMaxOffset, minOffset));
		  const boundedMaxOffset = Math.max(0, Math.min(mainMaxOffset, maxOffset));
		  newOffset = Math.max(boundedMinOffset, Math.min(boundedMaxOffset, newOffset));
		  currentOffset = newOffset;
		}
		
		// Voeg hoofdrivier toe (ALTIJD)
		blueRowPattern.push(currentWidth);
		blueRowOffsets.push(currentOffset);
		
		// Onthoud voor volgende iteratie
		prevOffset = currentOffset;
		prevWidth = currentWidth;
		
		// Check of we split moeten starten
		if (!inSplit && i === 20) {
		  inSplit = true;
		  splitRowsLeft = 20; // Langer: 20 rijen ipv 12
		  splitWidth = 3;
		  // Split tak start direct aansluitend aan hoofdrivier
		  splitOffset = currentOffset + currentWidth - 1; // 1 cell overlap voor connectie
		  prevSplitOffset = splitOffset;
		  prevSplitWidth = splitWidth;
		}
		
		// Als we in split zijn, COMBINEER main en split in Ã©Ã©n row MAAR markeer gap als void
		if (inSplit) {
		  // Zorg dat er minimaal 1 lege cell tussen main en split is (behalve bij start/eind)
		  const isStartRow = splitRowsLeft === 20;
		  const mergeRows = 8;
		  const isEndingPhase = splitRowsLeft <= mergeRows; // Laatste rijen: samenvoegen tot 1 tak
		  
		  // Split tak heeft overlap met zijn eigen vorige rij (during merge we relax a bit so it can actually re-join)
		  if (splitRowsLeft < 20 && !isStartRow) { // Niet de eerste rij
			const relax = isEndingPhase ? 2 : 0;
			const minSplitOffset = prevSplitOffset - splitWidth + 1 - relax; // overlap range (relaxed near merge)
			const maxSplitOffset = prevSplitOffset + prevSplitWidth - 1 + relax;
			
			// Kleine variatie
			let newSplitOffset = splitOffset;
			if (!isEndingPhase && Math.random() > 0.5) {
			  newSplitOffset += (Math.random() > 0.5 ? 1 : -1);
			}
			
			// EERST: beperk binnen overlap range van eigen vorige rij
			splitOffset = Math.max(minSplitOffset, Math.min(maxSplitOffset, newSplitOffset));
			// DAN: clamp binnen grid-breedte
			{
				const splitMaxOffset = Math.max(0, blueCols - splitWidth);
				splitOffset = Math.max(0, Math.min(splitMaxOffset, splitOffset));
			}
		  }
		  
		  // Positioneer split relatief aan main
		  const mainStart = currentOffset;
		  const mainEnd = currentOffset + currentWidth;
		  
		  if (isStartRow) {
			// Bij start: direct aansluitend (overlap voor connectie)
			splitOffset = mainEnd - 1; // 1 cell overlap
		  } else if (isEndingPhase) {
			// Laatste rijen: forceer samenvoegen tot 1 door overlap/adjacency te maken.
			const desiredSplitOffset = mainEnd - 1; // overlap 1 cell with main
			const relax = 2;
			const minSplitOffset = prevSplitOffset - splitWidth + 1 - relax;
			const maxSplitOffset = prevSplitOffset + prevSplitWidth - 1 + relax;
			splitOffset = Math.max(minSplitOffset, Math.min(maxSplitOffset, desiredSplitOffset));
		  } else {
			// Tijdens split: houd minimaal 1 lege cell tussen main en split
			// Maar: zorg dat split overlap houdt met ZIJN eigen vorige rij
			const splitStart = splitOffset;
			const minGap = splitRowsLeft <= (mergeRows + 2) ? 0 : 1; // vlak voor merge: laat gap verdwijnen
			
			// Als split te dichtbij main komt, schuif naar rechts (als dat binnen overlap range blijft)
			if (splitStart < mainEnd + minGap) {
			  const desiredSplitOffset = mainEnd + minGap;
			  // Check of dit binnen overlap range van vorige split rij valt
			  const minSplitOffset = prevSplitOffset - splitWidth + 1;
			  const maxSplitOffset = prevSplitOffset + prevSplitWidth - 1;
			  
			  if (desiredSplitOffset >= minSplitOffset && desiredSplitOffset <= maxSplitOffset) {
				splitOffset = desiredSplitOffset;
			  }
			  // Anders: behoud huidige offset (heeft overlap met vorige split rij)
			}
		  }
		  // Ensure split stays inside the available width.
		  {
			const splitMaxOffset = Math.max(0, blueCols - splitWidth);
			splitOffset = Math.max(0, Math.min(splitMaxOffset, splitOffset));
		  }
		  
		  // COMBINEER main en split in Ã©Ã©n row inclusief de gap
		  const combinedStart = Math.min(currentOffset, splitOffset);
		  const combinedEnd = Math.max(currentOffset + currentWidth, splitOffset + splitWidth);
		  const combinedWidth = combinedEnd - combinedStart;
		  
		  // Markeer gap cells als void (tussen main en split) - ALLEEN als er een gap is
		  const actualMainEnd = currentOffset + currentWidth;
		  const actualSplitStart = splitOffset;
		  if (actualMainEnd < actualSplitStart) {
			for (let gapCol = actualMainEnd; gapCol < actualSplitStart; gapCol++) {
			  blueGapCells.add(`${gapCol},${i}`); // Sla op als "col,row"
			}
		  }
		  
		  // Update de laatste toegevoegde row (die we net hebben toegevoegd)
		  blueRowPattern[blueRowPattern.length - 1] = combinedWidth;
		  blueRowOffsets[blueRowOffsets.length - 1] = combinedStart;
		  
		  
		  prevSplitOffset = splitOffset;
		  prevSplitWidth = splitWidth;
		  
		  splitRowsLeft--;
		  if (splitRowsLeft <= 0) {
			inSplit = false;
		  }
		}
	  }
	  
	  const blueRows = 60;
	  
	  // PAARS (World 2): bigger grid (+1 row/col) with fixed corner bold cells
	  const purpleSize = 13;
	  window.purpleGridConfig = {
		world2: true,
		outerRingBonusPerBold: 20
	  };
	  
	  // GROEN: Veel groter (20x20) met langere wortels en meer vertakkingen
	  // Punten verdubbelen naarmate je verder van startcells bent
	  const greenSize = 20;
	  const greenMaxGrowth = 60 + subLevel * 5; // Langere wortels
	  const greenBoldChance = 0.35; // Meer bold cells
	  
	  // ROOD: 4 grids met verschillende groottes - smaller maar hoger voor betere ruimtebenutting
	  // Connectie bonus: als je beide vult krijg je extra punten
	  // Alleen grids gebruiken die in de HTML bestaan (red-grid1 t/m red-grid4)
	  const redConfigs = [
		{ id: 'red-grid1', width: 5, height: 4, growth: 17, bonus: true },  // World 2 tweak: wider (+2), shorter (-2)
		{ id: 'red-grid2', width: 6, height: 4, growth: 19, bonus: true },  // World 2 tweak: wider (+2), shorter (-2)
		{ id: 'red-grid3', width: 6, height: 5, growth: 21, bonus: false }, // World 2 tweak: wider (+2), shorter (-2)
		{ id: 'red-grid4', width: 6, height: 5, growth: 23, bonus: false }  // World 2 tweak: wider (+2), shorter (-2)
	  ].filter(cfg => document.getElementById(cfg.id)); // Filter alleen bestaande grids
	  
	  // Genereer alle grids
	  const boardConfigs = [
		// Geel: Shape-based met bold cells op specifieke posities - MINDER coins/symbolen (50% reduction voor World 2)
		() => {
		  createGrid('yellow-grid', yellowRows, yellowCols, {
			goldCells: true,
			symbols: true,
			// World 2 request: a bit more symbols (+~40%).
			minSymbols: 10,
			maxSymbols: 14,
			coinChance: 0.09,
			maxCoins: 10,
			rowLengths: yellowShape.pattern,
			rowOffsets: yellowShape.offsets,
			boldColumns: [], // Geen kolom-based bolds
			pointsPerColumn: yellowColumnPoints,
			diagonalShading: true,
			diagonalLegend: true,
			trapChance: 0,
			maxTraps: 0,
			blackHoleChance: 0
		  });
		  // Voeg handmatig bold cells toe op specifieke posities
		  const yellowZone = document.getElementById('yellow-zone');
		  if (yellowZone && yellowShape.boldCells) {
			const cleanupYellowStartCell = (cell) => {
				if (!cell) return;
				// Remove any bonuses/symbols/traps that were assigned before this cell became a start/bold cell.
				cell.classList.remove('gold-cell');
				cell.querySelectorAll('.symbol').forEach(s => s.remove());
				if (cell.classList.contains('trap-cell')) {
					cell.classList.remove('trap-cell');
					delete cell.dataset.trap;
					delete cell.dataset.trapType;
					delete cell.dataset.trapTriggered;
					delete cell.dataset.trapInstanceId;
					cell.querySelectorAll('.trap-symbol').forEach(s => s.remove());
				}
			};
			yellowShape.boldCells.forEach(([row, col]) => {
			  const cell = getCell(yellowZone, col, row);
			  if (!cell) return;
			  if (!cell.classList.contains('bold-cell')) cell.classList.add('bold-cell');
			  cleanupYellowStartCell(cell);
			});
			// Safety net: ensure NO bold/start cell in yellow contains symbols/coins.
			yellowZone.querySelectorAll('.cell.bold-cell').forEach(cleanupYellowStartCell);
		  }
		},
		
		// Paars: World 2 rules (fixed corner bolds + outer ring shading) - 50% reduction coins/symbols
		() => createGrid('purple-grid', purpleSize, purpleSize, {
		  symbols: true,
		  goldCells: true,
		  minSymbols: 8,
		  maxSymbols: 11,
		  coinChance: 0.04,
		  maxCoins: 6,
		  // Keep the World 2 fixed corner bolds, but also keep the normal connector bolds in the middle (like World 1).
		  randomBoldCount: 10,
		  avoidAdjacentBold: true,
		  // World 2 request: random bold cells must NOT appear in the outer 2 rings.
		  randomBoldMinEdgeDistance: 2,
		  fixedBoldCells: [[0,0], [0, purpleSize - 1], [purpleSize - 1, 0], [purpleSize - 1, purpleSize - 1]],
		  outerRingShade: true,
		  trapChance: trapChance,
		  maxTraps: Math.floor(maxTraps * 1.2),
		  blackHoleChance: blackHoleChance * 0.5
		}),
		
		// Blauw: Lang kronkelig pad met split tak - 50% reduction coins/symbols voor World 2
		() => {
		  createGrid('blue-grid', blueRows, blueCols, {
			boldBottom: true,
			goldCells: true,
			symbols: true,
			minSymbols: 18,
			maxSymbols: 26,
			coinChance: 0.11,
			maxCoins: 20,
			rowLengths: blueRowPattern,
			rowOffsets: blueRowOffsets,
			voidCells: blueGapCells, // Gap cells tussen main en split
			trimLeft: true,
			trimRight: true,
			trapChance: trapChance * 0.8,
			maxTraps: Math.floor(maxTraps * 0.8),
			blackHoleChance: 0
		  });
		  // UX: start the blue view at the bottom once after rebuild.
		  const blueZone = document.getElementById('blue-zone');
		  if (blueZone) blueZone.dataset.needsInitialScrollBottom = 'true';
		},
		
		// Groen: Complexe wortelstructuur met meer vertakkingen (smaller maar hoger)
		// World 2: 50% minder symbols en coins dan normaal
		() => {
		  const greenSize = 28; // World 2: wider so horizontal scrolling is meaningful
		  const greenRows = 34; // Slightly shorter/less tall than before
		  const greenMaxGrowth = 220; // Growth budget for the mega-root + 4 arms
		  const greenBoldChance = 0.25;
		  const greenSplitChance = 0.35; // Hogere splitChance voor meer vertakkingen
		  window.greenGridConfig = {
			world2: true,
			minEndPoints: 8,
			minEndCellPoints: 14,
			maxEndCellPoints: 30
		  };
		  // NOTE: generateRoots signature is (.., branchCount, splitChance, coinChance, minSymbols, maxSymbols, maxCoins, ...)
		  // Previously, splitChance and coinChance were accidentally swapped, causing huge coin/bonus density.
		  // World 2 request: noticeably fewer bonuses on green.
		  const greenCoinChance = 0.015;
		  return generateRoots('green-grid', greenRows, greenSize, greenMaxGrowth, greenSplitChance, greenCoinChance, 3, 5, 2, false, trapChance, Math.floor(maxTraps * 0.9), blackHoleChance * 0.3);
		},
		
		// Rood: 4 grids met verschillende groottes (smaller maar hoger)
		// World 2: iets meer symbols/coins dan voorheen (+~30%)
		...redConfigs.map(cfg => () => {
		  // Slight boost: minSymbols 3, maxSymbols 4, maxCoins 3, coinChance +~30%
		  const grid = generateRoots(cfg.id, cfg.height, cfg.width, cfg.growth, 0.35, 0.04, 3, 4, 3, true, 0, 0, 0, { showPointsLabel: true });
		  // Markeer bonus grids visueel
		  if (cfg.bonus) {
			const zone = document.getElementById(cfg.id.replace('-grid', '-zone'));
			if (zone) zone.dataset.bonusGrid = 'true';
		  }
		  return grid;
		})
	  ];
	  
	  boardConfigs.forEach(fn => fn());
	  updateScore();
	  
	  // World 2: reset scroll memory so green centers on start cell (centralized)
	  try {
		resetZoneScrollMemory('green-zone');
		scheduleGreenCenter({ force: true, allowZoom: false, fallback: true, fallbackDelay: 140 });
		resetZoneScrollState('blue-zone', resetBlueZoomScroll);
	  } catch (_) {}
	  
	  // Defer zone sizing to the centralized one-time layout pass
	  markZoneSizingNeeded();
	  
	}
	
	// WORLD 3: Ultimate challenge - Mix van World 1 en 2 met extra moeilijkheid (levels 21-30)
	function rebuildGameBoards_World3() {
	  const { subLevel } = getWorldAndSubLevel(currentLevel);
	  
	  // World 3: Meer traps en hogere moeilijkheid
	  const blackHoleAvailable = isUpgradeAvailable('blackHoleAccess');
	  const trapChance = 0.05 + (subLevel * 0.01); // 5-15% trap chance
	  const maxTraps = 10 + subLevel; // 10-20 max traps
	  const blackHoleChance = blackHoleAvailable ? BLACK_HOLE_DEFAULT_CHANCE : 0;
	  
	  // GEEL: Mega diamant patroon - combinatie van World 1 kolommen + World 2 vormen
	  // Grotere vorm met diagonale scoring
	  // Fix: Offsets met 1 verminderd voor betere symmetrie op de zone
	  const yellowShape = {
		pattern: [4, 6, 8, 10, 12, 12, 12, 12, 10, 8, 6, 4],
		offsets: [4, 3, 2, 1, 0, 0, 0, 0, 1, 2, 3, 4],
		boldCells: [[5,5], [5,6], [6,5], [6,6]]
	  };
	  const yellowRows = yellowShape.pattern.length;
	  // Use the true bounding width (max(offset + length)), not max(length)+max(offset).
	  // This prevents extra empty columns that can cause the diamond to appear shifted/clipped.
	  const yellowCols = Math.max(
		...yellowShape.pattern.map((len, i) => (Number(len) || 0) + (Number(yellowShape.offsets[i]) || 0))
	  );
	  
	  // World 3: Hogere punten per kolom/diagonaal
	  const yellowPointsArray = [10, 15, 20, 28, 36, 44, 52, 60, 68, 76, 84, 92, 100];
	  const yellowColumnPoints = yellowShape.pattern.map((width, idx) => yellowPointsArray[idx] || (44 + (idx - 5) * 8));
	  
	  window.yellowGridConfig = {
		rows: yellowRows,
		cols: yellowCols,
		rowLengths: yellowShape.pattern.slice(),
		rowOffsets: yellowShape.offsets.slice(),
		pointsByColumn: yellowColumnPoints.slice(),
		columnHeights: yellowShape.pattern.map((_, i) => i),
		pointsByRow: [],
		pointsByWidth: {},
		pointsPerRow: 0,
		pointsPerColumn: 0,
		// World 3 request: score per "cirkel" (ring) of the diamond.
		scoreMode: 'rings',
		ringMinPoints: 12,
		ringMaxPoints: 64
	  };
	  
	  // BLAUW: Ultra lange rivier met meerdere splits (80 rijen!)
	  // World 3 request (UX): keep the river within the zone width (no horizontal scrolling needed).
	  // Match the purple grid width (14 cols) and clamp offsets to stay inside.
	  const blueCols = 13;
	  const blueRowPattern = [];
	  const blueRowOffsets = [];
	  const blueGapCells = new Set();
	  
	  let currentOffset = 6;
	  let currentWidth = 3;
	  let prevOffset = currentOffset;
	  let prevWidth = currentWidth;
	  
	  // Split tracking - World 3: 2 splits!
	  let inSplit = false;
	  let splitRowsLeft = 0;
	  let splitOffset = 0;
	  let splitWidth = 3;
	  let prevSplitOffset = 0;
	  let prevSplitWidth = 3;
	  let splitCount = 0; // Track how many splits we've done
	  
	  for (let i = 0; i < 80; i++) {
		// Variatie in breedte
		if (i % 10 === 5) {
		  currentWidth = 4 + Math.floor(Math.random() * 3); // 4-6 breed
		} else {
		  currentWidth = 2 + Math.floor(Math.random() * 3); // 2-4 breed
		}
		
		// Overlap check voor hoofdrivier
		if (i > 0) {
		  const minOffset = prevOffset - currentWidth + 1;
		  const maxOffset = prevOffset + prevWidth - 1;
		  
		  let newOffset = currentOffset;
		  if (Math.random() > 0.4) {
			newOffset += (Math.random() > 0.5 ? 1 : -1);
		  }
		  
		  const mainMaxOffset = Math.max(0, blueCols - currentWidth);
		  const boundedMinOffset = Math.max(0, Math.min(mainMaxOffset, minOffset));
		  const boundedMaxOffset = Math.max(0, Math.min(mainMaxOffset, maxOffset));
		  newOffset = Math.max(boundedMinOffset, Math.min(boundedMaxOffset, newOffset));
		  currentOffset = newOffset;
		}
		
		blueRowPattern.push(currentWidth);
		blueRowOffsets.push(currentOffset);
		
		prevOffset = currentOffset;
		prevWidth = currentWidth;
		
		// World 3: Twee splits - op rij 20 en rij 50
		if (!inSplit && (i === 20 || i === 50) && splitCount < 2) {
		  inSplit = true;
		  splitRowsLeft = i === 20 ? 18 : 15; // Langere eerste split
		  splitWidth = 3;
		  splitOffset = currentOffset + currentWidth - 1;
		  prevSplitOffset = splitOffset;
		  prevSplitWidth = splitWidth;
		  splitCount++;
		}
		
		// Split logica (vergelijkbaar met World 2)
		if (inSplit) {
		  const isStartRow = (i === 20 || i === 50);
		  const mergeRows = 6;
		  const isEndingPhase = splitRowsLeft <= mergeRows;
		  
		  if (splitRowsLeft < 18 && !isStartRow) {
			const relax = isEndingPhase ? 2 : 0;
			const minSplitOffset = prevSplitOffset - splitWidth + 1 - relax;
			const maxSplitOffset = prevSplitOffset + prevSplitWidth - 1 + relax;
			
			let newSplitOffset = splitOffset;
			if (!isEndingPhase && Math.random() > 0.5) {
			  newSplitOffset += (Math.random() > 0.5 ? 1 : -1);
			}
			
			splitOffset = Math.max(minSplitOffset, Math.min(maxSplitOffset, newSplitOffset));
			{
				const splitMaxOffset = Math.max(0, blueCols - splitWidth);
				splitOffset = Math.max(0, Math.min(splitMaxOffset, splitOffset));
			}
		  }
		  
		  const mainStart = currentOffset;
		  const mainEnd = currentOffset + currentWidth;
		  
		  if (isStartRow) {
			splitOffset = mainEnd - 1;
		  } else if (isEndingPhase) {
			const desiredSplitOffset = mainEnd - 1;
			const relax = 2;
			const minSplitOffset = prevSplitOffset - splitWidth + 1 - relax;
			const maxSplitOffset = prevSplitOffset + prevSplitWidth - 1 + relax;
			splitOffset = Math.max(minSplitOffset, Math.min(maxSplitOffset, desiredSplitOffset));
		  } else {
			const minGap = splitRowsLeft <= (mergeRows + 2) ? 0 : 1;
			const splitStart = splitOffset;
			
			if (splitStart < mainEnd + minGap) {
			  const desiredSplitOffset = mainEnd + minGap;
			  const minSplitOffset = prevSplitOffset - splitWidth + 1;
			  const maxSplitOffset = prevSplitOffset + prevSplitWidth - 1;
			  
			  if (desiredSplitOffset >= minSplitOffset && desiredSplitOffset <= maxSplitOffset) {
				splitOffset = desiredSplitOffset;
			  }
			}
		  }
		  {
			const splitMaxOffset = Math.max(0, blueCols - splitWidth);
			splitOffset = Math.max(0, Math.min(splitMaxOffset, splitOffset));
		  }
		  
		  const combinedStart = Math.min(currentOffset, splitOffset);
		  const combinedEnd = Math.max(currentOffset + currentWidth, splitOffset + splitWidth);
		  const combinedWidth = combinedEnd - combinedStart;
		  
		  const actualMainEnd = currentOffset + currentWidth;
		  const actualSplitStart = splitOffset;
		  if (actualMainEnd < actualSplitStart) {
			for (let gapCol = actualMainEnd; gapCol < actualSplitStart; gapCol++) {
			  blueGapCells.add(`${gapCol},${i}`);
			}
		  }
		  
		  blueRowPattern[blueRowPattern.length - 1] = combinedWidth;
		  blueRowOffsets[blueRowOffsets.length - 1] = combinedStart;
		  
		  prevSplitOffset = splitOffset;
		  prevSplitWidth = splitWidth;
		  
		  splitRowsLeft--;
		  if (splitRowsLeft <= 0) {
			inSplit = false;
		  }
		}
	  }
	  
	  const blueRows = 80;
	  
	  // PAARS: Mega grid (14x14) met extra bold cells in het midden
	  const purpleSize = 14;
	  window.purpleGridConfig = {
		world3: true,
		outerRingBonusPerBold: 25, // Hogere bonus dan World 2
		innerRingBonus: true, // Nieuwe mechanic: bonus voor inner ring ook
		innerRingBonusPerBold: 15
	  };
	  
	  // GROEN: Ultra groot (36x36) met maximale vertakkingen
	  const greenRows = 40;
	  const greenCols = 36;
	  const greenMaxGrowth = 300 + subLevel * 15;
	  window.greenGridConfig = {
		world3: true,
		minEndPoints: 18,
		minEndCellPoints: 18,
		maxEndCellPoints: 40,
		branchBonusMultiplier: 2
	  };
	  
	  // ROOD: Alle 6 grids actief met hogere moeilijkheid (alleen wereld 3)
	  const redConfigs = [
		{ id: 'red-grid1', width: 6, height: 5, growth: 22 },
		{ id: 'red-grid2', width: 7, height: 5, growth: 25 },
		{ id: 'red-grid3', width: 7, height: 6, growth: 28 },
		{ id: 'red-grid4', width: 7, height: 6, growth: 30 },
		{ id: 'red-grid5', width: 8, height: 10, growth: 34 },
		{ id: 'red-grid6', width: 8, height: 10, growth: 38 }
	  ].filter(cfg => document.getElementById(cfg.id));
	  
	  // World 3 red progression: stage visibility is handled via applyWorld3RedStage().
	  // We still generate all 6 grids here so stage 2 can appear instantly.
	  
	  // Genereer alle grids
	  const boardConfigs = [
		// Geel: Mega diamant met veel bold cells
		() => {
		  createGrid('yellow-grid', yellowRows, yellowCols, {
			goldCells: true,
			symbols: true,
			minSymbols: 12,
			maxSymbols: 12,
			coinChance: 0.10,
			maxCoins: 16,
			rowLengths: yellowShape.pattern,
			rowOffsets: yellowShape.offsets,
			fixedBoldCells: yellowShape.boldCells,
			boldColumns: [],
			pointsPerColumn: yellowColumnPoints,
			diagonalShading: false,
			diagonalLegend: false,
			ringShading: true,
			trimRight: true,
			trapChance: 0,
			maxTraps: 0,
			blackHoleChance: 0
		  });
		  const yellowZone = document.getElementById('yellow-zone');
		  if (yellowZone && yellowShape.boldCells) {
			const cleanupYellowStartCell = (cell) => {
				if (!cell) return;
				cell.classList.remove('gold-cell');
				cell.querySelectorAll('.symbol').forEach(s => s.remove());
				if (cell.classList.contains('trap-cell')) {
					cell.classList.remove('trap-cell');
					delete cell.dataset.trap;
					delete cell.dataset.trapType;
					delete cell.dataset.trapTriggered;
					delete cell.dataset.trapInstanceId;
					cell.querySelectorAll('.trap-symbol').forEach(s => s.remove());
				}
			};
			yellowShape.boldCells.forEach(([row, col]) => {
			  const cell = getCell(yellowZone, col, row);
			  if (!cell) return;
			  if (!cell.classList.contains('bold-cell')) cell.classList.add('bold-cell');
			  cleanupYellowStartCell(cell);
			});
			yellowZone.querySelectorAll('.cell.bold-cell').forEach(cleanupYellowStartCell);
		  }
		},
		
		// Paars: Mega grid met binnen- en buitenring bonussen
		() => createGrid('purple-grid', purpleSize, purpleSize, {
		  symbols: true,
		  goldCells: true,
		  minSymbols: 16,
		  maxSymbols: 16,
		  coinChance: 0.06,
		  maxCoins: 12,
		  randomBoldCount: 14,
		  avoidAdjacentBold: true,
		  fixedBoldCells: [[0,0], [0, purpleSize - 1], [purpleSize - 1, 0], [purpleSize - 1, purpleSize - 1], 
						   [0, Math.floor(purpleSize/2)], [purpleSize - 1, Math.floor(purpleSize/2)],
						   [Math.floor(purpleSize/2), 0], [Math.floor(purpleSize/2), purpleSize - 1]],
		  outerRingShade: true,
		  trapChance: trapChance * 1.1,
		  maxTraps: Math.floor(maxTraps * 1.1),
		  blackHoleChance: blackHoleChance * 0.2
		}),
		
		// Blauw: Ultra lange rivier met 2 splits
		() => {
		  createGrid('blue-grid', blueRows, blueCols, {
			boldBottom: true,
			goldCells: true,
			symbols: true,
			minSymbols: 30,
			maxSymbols: 30,
			coinChance: 0.20,
			maxCoins: 25,
			rowLengths: blueRowPattern,
			rowOffsets: blueRowOffsets,
			voidCells: blueGapCells,
			trimLeft: true,
			trimRight: true,
			trapChance: trapChance * 0.9,
			maxTraps: Math.floor(maxTraps * 0.9),
			blackHoleChance: blackHoleChance * 0.2
		  });
		},
		
		// Groen: Ultra groot met maximale vertakkingen
		() => {
		  const greenSplitChance = 0.55;
		  return generateRoots('green-grid', greenRows, greenCols, greenMaxGrowth, greenSplitChance, 0.06, 12, 21, 6, false, trapChance, Math.floor(maxTraps * 1.1), blackHoleChance * 0.4);
		},
		
		// Rood: Alle 6 grids
		...redConfigs.map(cfg => () => {
		  return generateRoots(cfg.id, cfg.height, cfg.width, cfg.growth, 0.4, 0.08, 4, 8, 4, true, trapChance * 0.5, Math.floor(maxTraps * 0.3), 0, { showPointsLabel: true });
		})
	  ];
	  
	  boardConfigs.forEach(fn => fn());
	  updateScore();
	  // World 3: after regenerating the board, re-anchor the initial unzoomed view.
	  // Without this, existing scroll memory can keep green at (0,0) instead of centered.
	  try {
		resetZoneScrollMemory('green-zone');
		scheduleGreenCenter({ force: true, allowZoom: false, fallback: true, fallbackDelay: 140 });
		resetZoneScrollState('blue-zone', resetBlueZoomScroll);
	  } catch (_) {}
	  
	  // Defer zone sizing to the centralized one-time layout pass (works for World 3)
	  markZoneSizingNeeded();
	  // Extra safeguard: recentre green after sizing settles so it does not jump left on World 3.
	  try { scheduleGreenCenter({ force: true, allowZoom: false, fallback: true, fallbackDelay: 160 }); } catch (_) {}
	}
	
	// Pas zone groottes dynamisch aan voor World 2 grids
	function enableZoneDragScroll(zoneEl, opts = {}) {
		if (!zoneEl) return;
		if (zoneEl.dataset.dragScrollEnabled === 'true') return;
		zoneEl.dataset.dragScrollEnabled = 'true';
		const ignoreSelectors = opts.ignoreSelectors || '.card,.card-option,#controls,#bottom-bar';
		const threshold = typeof opts.threshold === 'number' ? opts.threshold : 6;
		let activePointerId = null;
		let startX = 0;
		let startY = 0;
		let startScrollLeft = 0;
		let startScrollTop = 0;
		let moved = false;
		let dragRaf = null;
		let pendingDx = 0;
		let pendingDy = 0;

		zoneEl.addEventListener('pointerdown', (e) => {
			if (e.button !== undefined && e.button !== 0) return; // left button only
			// Don't hijack pointer drags while placing a block.
			if (typeof draggedBlock !== 'undefined' && draggedBlock) return;
			if (typeof draggedShape !== 'undefined' && draggedShape) return;
			if (typeof activeBonusPlacement !== 'undefined' && activeBonusPlacement) return;
			if (ignoreSelectors && e.target.closest(ignoreSelectors)) return;
			activePointerId = e.pointerId;
			moved = false;
			startX = e.clientX;
			startY = e.clientY;
			startScrollLeft = zoneEl.scrollLeft;
			startScrollTop = zoneEl.scrollTop;
			zoneEl.dataset.dragScrolling = 'false';
			zoneEl.classList.add('drag-scroll-active');
			try { zoneEl.setPointerCapture(activePointerId); } catch (_) {}
		});

		zoneEl.addEventListener('pointermove', (e) => {
			if (activePointerId === null || e.pointerId !== activePointerId) return;
			const dx = e.clientX - startX;
			const dy = e.clientY - startY;
			if (!moved && (Math.abs(dx) > threshold || Math.abs(dy) > threshold)) {
				moved = true;
				zoneEl.dataset.dragScrolling = 'true';
			}
			if (!moved) return;
			e.preventDefault();
			pendingDx = dx;
			pendingDy = dy;
			if (!dragRaf) {
				dragRaf = requestAnimationFrame(() => {
					zoneEl.scrollLeft = startScrollLeft - pendingDx;
					zoneEl.scrollTop = startScrollTop - pendingDy;
					dragRaf = null;
				});
			}
		}, { passive: false });

		const endDrag = () => {
			if (activePointerId === null) return;
			activePointerId = null;
			zoneEl.classList.remove('drag-scroll-active');
			// Keep the "dragScrolling" flag briefly so pointerup on a cell can detect it.
			if (zoneEl.dataset.dragScrolling === 'true') {
				setTimeout(() => { zoneEl.dataset.dragScrolling = 'false'; }, 0);
			}
		};
		zoneEl.addEventListener('pointerup', endDrag);
		zoneEl.addEventListener('pointercancel', endDrag);
	}

	function adjustZoneSizesForWorld2() {
	  // Mobile zoom: sizing is handled by CSS to keep all zoomed zones uniform across worlds.
	  // IMPORTANT: Inline styles override CSS, so we must clear any previously-set widths/heights while zoomed.
	  try {
		const isZoomedIn = document.body.classList.contains('zoomed-in');
		const isMobileZoomSizing = (typeof window !== 'undefined' && window.matchMedia)
			? window.matchMedia('(max-width: 650px), (hover: none) and (pointer: coarse)').matches
			: (window.innerWidth <= 650);
		if (isZoomedIn && isMobileZoomSizing) {
			['yellow-zone', 'green-zone', 'blue-zone', 'purple-zone', 'red-zone'].forEach(id => {
				const el = document.getElementById(id);
				if (!el || !el.style) return;
				el.style.removeProperty('width');
				el.style.removeProperty('height');
				el.style.removeProperty('min-width');
				el.style.removeProperty('max-width');
				el.style.removeProperty('min-height');
				el.style.removeProperty('max-height');
			});
			return;
		}
	  } catch (e) {}
	  // Gebruik de echte --cell-size CSS variabele voor consistente sizing tussen werelden
	  const computedCellSize = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--cell-size')) || 26;
	  const cellSize = Math.max(18, Math.min(30, computedCellSize)); // Clamp between 18 and 30
	  const worldInfo = (typeof getWorldAndSubLevel === 'function') ? getWorldAndSubLevel(currentLevel) : null;
	  const isWorld1 = !!(worldInfo && worldInfo.world === 1);
	  const isWorld2 = !!(worldInfo && worldInfo.world === 2);
	  const isWorld3 = !!(worldInfo && worldInfo.world === 3);
	  const isWorld4 = !!(worldInfo && worldInfo.world === 4);
	  const isPortrait = window.innerHeight > window.innerWidth;
	  const isShortHeight = window.innerHeight <= 925;
	  const isDesktopPortraitLayout = document.body.classList.contains('desktop-portrait')
			&& !document.body.classList.contains('mobile-sidebar-layout')
			&& !document.body.classList.contains('touch-portrait');
	  // Purple needs extra vertical chrome so it never clips (header/padding/outline).
	  const purpleChromePx = isDesktopPortraitLayout ? 50 : 40;
	  const tallZoneMaxVh = isPortrait ? '52vh' : (isShortHeight ? '65vh' : '85vh');
	  // Green should be visibly shorter so the rest of the UI fits, but still scrollable.
	  // User request: make it ~40px shorter.
	  const greenZoneMaxVh = isPortrait ? 'calc(40vh - 40px)' : (isShortHeight ? 'calc(50vh - 40px)' : 'calc(52vh - 40px)');
	  const tallZoneMaxPx = isPortrait ? 600 : (isShortHeight ? 800 : 1200);
	  
	  // Geel zone - iets korter
	  const yellowGrid = document.getElementById('yellow-grid');
	  const yellowZone = document.getElementById('yellow-zone');
	  if (yellowGrid && yellowZone) {
		const yellowRows = parseInt(yellowGrid.dataset.rows) || 10;
		const yellowCols = parseInt(yellowGrid.dataset.cols) || 10;
		yellowZone.style.width = `${yellowCols * cellSize + 40}px`;
		// Keep enough headroom so the top/bottom spacing remains even.
		yellowZone.style.height = `${yellowRows * cellSize + 70}px`;
	  }
	  
	  // Paars zone - aangepast voor 10x10 grid (2 rijen smaller)
	  const purpleGrid = document.getElementById('purple-grid');
	  const purpleZone = document.getElementById('purple-zone');
	  if (purpleGrid && purpleZone) {
		const purpleSize = parseInt(purpleGrid.dataset.rows) || 10;
		// Tighter chrome around the generated purple grid - gebruik minder padding.
		purpleZone.style.width = `${purpleSize * cellSize + 30}px`;
		purpleZone.style.height = `${purpleSize * cellSize + purpleChromePx}px`;
	  }

	  // WORLD 2/3/4 UX: make yellow zone the same width as purple.
	  try {
		const worldInfo = typeof getWorldAndSubLevel === 'function' ? getWorldAndSubLevel(currentLevel) : null;
		if (worldInfo && (worldInfo.world === 2 || worldInfo.world === 3 || worldInfo.world === 4) && yellowZone && purpleZone) {
			// IMPORTANT: Yellow must FOLLOW Purple width (not the other way around).
			// Do NOT use max(purple,yellow) here; that makes yellow only grow and never shrink.
			const purpleW = (
				parseFloat(purpleZone.style.width || '') ||
				(purpleZone.getBoundingClientRect ? purpleZone.getBoundingClientRect().width : 0) ||
				purpleZone.offsetWidth ||
				0
			);
			const targetWidthPx = Math.max(1, Math.round(purpleW));
			const targetWidth = `${targetWidthPx}px`;
			yellowZone.style.setProperty('width', targetWidth);
			yellowZone.style.setProperty('min-width', targetWidth);
			yellowZone.style.setProperty('max-width', targetWidth);
			
		}
	  } catch (_) {}
	  
	  // Blauw zone - aangepast voor smaller splits, minder min-width
	  const blueGrid = document.getElementById('blue-grid');
	  const blueZone = document.getElementById('blue-zone');
	  if (blueGrid && blueZone) {
		const blueRows = parseInt(blueGrid.dataset.rows) || 60;
		const blueCols = parseInt(blueGrid.dataset.cols) || 18;
		// WORLD 2 UX (user request): fixed max width + allow horizontal scrolling.
		const viewportW = Number(window.innerWidth) || 0;
		const isNarrow = viewportW <= 650;
		const isCoarse = (typeof isCoarsePointer === 'function') ? isCoarsePointer() : false;
		// "Mobile-like" also includes touch landscape sidebar layout (can be >650px wide but still mobile UX).
		const isMobileLike = (typeof isMobileViewport === 'function') ? isMobileViewport() : isNarrow;
		// Make the min-width match the maximum generated width so no horizontal scroll is needed.
		// Use the theoretical grid width (cols * cell-size) plus a small buffer, and include the widest actual row.
		const contentWidthPx = blueCols * cellSize;
		let widestRowCells = blueCols;
		try {
			const rows = blueGrid ? Array.from(blueGrid.querySelectorAll('.grid-row')) : [];
			if (rows.length) {
				widestRowCells = Math.max(widestRowCells, ...rows.map(r => (r.children ? r.children.length : 0)));
			}
		} catch (e) {}
		const blueTargetWidthPx = Math.max(1, Math.round(Math.max(contentWidthPx, widestRowCells * cellSize)));

		// WORLD 2 UX: Blauw zone hoogte = geel + paars + gap ertussen
		let blueHeight;
		if (yellowGrid && purpleGrid) {
		  // Bereken hoogtes direct in plaats van offsetHeight (die kan 0 zijn bij eerste render)
		  const yellowRows = parseInt(yellowGrid.dataset.rows) || 10;
		  const purpleRows = parseInt(purpleGrid.dataset.rows) || 10;
		  const yellowHeight = yellowRows * cellSize + 70; // Zelfde als yellowZone.style.height berekening
			const purpleHeight = purpleRows * cellSize + purpleChromePx; // Zelfde als purpleZone.style.height berekening
		  const gapBetweenZones = 10; // Gap tussen geel en paars zones
		  blueHeight = yellowHeight + purpleHeight + gapBetweenZones;
		} else {
		  blueHeight = Math.min(blueRows * cellSize, tallZoneMaxPx);
		}
		// World 2 (mobile): user requested ~+50px extra height.
		if (isWorld2 && isMobileLike && isCoarse) blueHeight += 50;
		// On smalle mobile/portrait layouts, don't force an explicit height; clamp to viewport (World 2 only).
		const safeMargin = 140; // header + spacing buffer so blue doesn't exceed the viewport
		const viewportH = Number(window.innerHeight) || 0;
		if (isWorld2 && isMobileLike) {
			const maxAllowed = Math.max(200, viewportH - safeMargin);
			const clamped = Math.max(0, Math.min(blueHeight, maxAllowed));
			blueZone.style.removeProperty('height');
			blueZone.style.minHeight = `${Math.round(clamped)}px`;
		} else {
			blueZone.style.height = `${blueHeight}px`;
			blueZone.style.minHeight = `${blueHeight}px`;
		}
		// Verwijder maxHeight beperking zodat blauw echt even lang kan zijn als geel+paars
		blueZone.style.maxHeight = 'none';
		blueZone.style.overflowY = 'auto';
		blueZone.style.overflowX = 'auto';
		// Remove margins so the view starts exactly at the left edge.
		blueGrid.style.margin = '0px';
		blueGrid.style.justifyContent = 'start';
		blueGrid.style.transform = '';
		// World 2/3/4: unzoomed blue should start bottom-centered (bold start cells),
		// and later keep the user's last unzoomed scroll position.
		if (isWorld2 || isWorld3 || isWorld4) {
			const mem = getZoneScrollMemory('blue-zone');
			if (mem && mem.normal) {
				// "level" is an internal stamp (not persisted) to detect new boards.
				if (mem.normal.level !== currentLevel) {
					mem.normal.initialized = false; // force anchor bottom on first layout of this level
					mem.normal.level = currentLevel;
				}
			}
		}
		restoreOrAnchorZoneScroll(blueZone, (z) => resetBlueZoomScroll(z));
		enableZoneDragScroll(blueZone, { ignoreSelectors: '#controls,#bottom-bar,#card-choice-zone,.card,.card-option' });
	  }
	  
	  // Groen zone
	  const greenGrid = document.getElementById('green-grid');
	  const greenZone = document.getElementById('green-zone');
	  if (greenGrid && greenZone) {
		// World 1 request: keep green fixed (no scrolling).
		if (isWorld1) {
			greenZone.classList.add('no-scroll');
			greenZone.style.overflow = 'hidden';
			greenZone.style.touchAction = 'manipulation';
			greenZone.scrollTop = 0;
			greenZone.scrollLeft = 0;
		} else {
			greenZone.classList.remove('no-scroll');
			// Keep green scrollable when content exceeds the viewport.
			greenZone.style.overflowY = 'auto';
			greenZone.style.overflowX = 'auto';
			// Clear potentially stale inline sizing; we re-apply below when needed.
			greenZone.style.removeProperty('width');
			greenZone.style.removeProperty('height');
			// NOTE: Don't remove min-height here - syncZoneHeights() manages it.
			greenZone.style.removeProperty('max-height');
			enableZoneDragScroll(greenZone, { ignoreSelectors: '#controls,#bottom-bar,#card-choice-zone,.card,.card-option' });
		}
	  }
	  
	  // Rood zones - VEEL meer height voor uitstekende cells
	  ['red-grid1', 'red-grid2', 'red-grid3', 'red-grid4'].forEach(gridId => {
		const redGrid = document.getElementById(gridId);
		if (redGrid) {
		  const zoneId = gridId.replace('-grid', '-zone');
		  const redZone = document.getElementById(zoneId);
		  if (redZone) {
			const redRows = parseInt(redGrid.dataset.rows) || 6;
			const redCols = parseInt(redGrid.dataset.cols) || 6;
			// Auto height met ruime minimum - geen fixed heights meer
			redZone.style.width = `${redCols * cellSize + 40}px`;
			redZone.style.height = 'auto';
			redZone.style.minHeight = `${redRows * cellSize + 150}px`; // Nog meer buffer
			redZone.style.overflow = 'visible'; // Laat uitstekende cells zien
		  }
		}
	  });

	  requestAnimationFrame(() => {
		// World 2 request: green zone must be a SQUARE: height == width (unzoomed).
		// World 3/4 request: keep green zone same format as World 2 (avoid overly tall zone).
		try {
			if ((isWorld2 || isWorld3 || isWorld4) && greenZone && !document.body.classList.contains('zoomed-in')) {
				// Use the UNTRANSFORMED layout width as source of truth.
				// If an ancestor is transform-scaled, getBoundingClientRect() returns the scaled width,
				// and setting height to that value would be scaled again (ending up too short).
				let target = Math.round(greenZone.offsetWidth || 0);
				if (!(target > 0)) {
					target = Math.round(greenZone.getBoundingClientRect().width);
				}
				if (!(target > 0)) {
					// Fallback to the desktop sizing formula.
					target = Math.round((13 * cellSize) + 80);
				}
				greenZone.style.height = `${target}px`;
				greenZone.style.minHeight = `${target}px`;
				greenZone.style.maxHeight = `${target}px`;
			}
		} catch (_) {}

		// Zone sizing only; centering/height sync is handled centrally.
	  });
	}

		const PREWORLD_PICK_BUDGET = 9;

		function closePreworldPickModal() {
			if (preworldPickLayer) {
				preworldPickLayer.classList.remove('show');
				preworldPickLayer.setAttribute('aria-hidden', 'true');
			}
		}

		function buildPreworldChoiceEntries() {
			const entries = [];
			const addList = (list, category) => {
				if (!Array.isArray(list)) return;
				list.forEach(entry => {
					if (!entry || !entry.matrix) return;
					entries.push({
						name: entry.name || 'Kaart',
						matrix: cloneShape(entry.matrix),
						category: category || entry.category || 'standard'
					});
				});
			};
			addList(CARD_BLUEPRINTS && CARD_BLUEPRINTS.mini, 'mini');
			addList(CARD_BLUEPRINTS && CARD_BLUEPRINTS.standard, 'standard');
			addList(CARD_BLUEPRINTS && CARD_BLUEPRINTS.large, 'large');
			const seen = new Set();
			const out = [];
			entries.forEach(entry => {
				const key = `${entry.name}|${JSON.stringify(entry.matrix)}`;
				if (seen.has(key)) return;
				seen.add(key);
				if (countShapeBlocks(entry.matrix) <= 5) out.push(entry);
			});
			return shuffleArray(out);
		}

		function openPreworldPickModal(options = {}) {
			const { onComplete } = options;
			if (!preworldPickLayer || !preworldPickModal) {
				if (typeof onComplete === 'function') onComplete([]);
				return;
			}
			const budgetEl = document.getElementById('preworld-pick-budget');
			const grid = document.getElementById('preworld-pick-grid');
			const confirmBtn = document.getElementById('preworld-pick-confirm');
			const subtextEl = document.getElementById('preworld-pick-subtext');
			if (!grid || !confirmBtn) {
				if (typeof onComplete === 'function') onComplete([]);
				return;
			}
			let remaining = PREWORLD_PICK_BUDGET;
			let warningEl = document.getElementById('preworld-pick-warning');
			if (!warningEl && subtextEl && subtextEl.parentElement) {
				warningEl = document.createElement('div');
				warningEl.id = 'preworld-pick-warning';
				warningEl.className = 'preworld-pick-warning';
				subtextEl.parentElement.insertBefore(warningEl, subtextEl.nextSibling);
			}
			const selected = new Map();
			const palette = (Array.isArray(NON_WILDCARD_COLORS) && NON_WILDCARD_COLORS.length)
				? NON_WILDCARD_COLORS
				: colors;

			grid.innerHTML = '';
			const entries = buildPreworldChoiceEntries();
			entries.forEach((entry, index) => {
				const color = cloneColor(palette[index % palette.length] || palette[0] || { name: 'grijs', code: '#a0a0a0' });
				const previewBlueprint = {
					shapeName: entry.name,
					matrix: cloneShape(entry.matrix),
					category: entry.category,
					color
				};
				const card = buildDeckModalCard(previewBlueprint, index, { interactive: false });
				if (card) card.classList.add('preworld-pick-card');
				const cost = countShapeBlocks(entry.matrix);
				const item = document.createElement('button');
				item.type = 'button';
				item.className = 'preworld-pick-item';
				item.dataset.cost = String(cost);
				item.dataset.key = `${entry.name}-${index}`;
				const costBadge = document.createElement('div');
				costBadge.className = 'preworld-cost';
				costBadge.textContent = `${cost}ðŸª™`;
				item.appendChild(costBadge);
				if (card) item.appendChild(card);
				item.addEventListener('click', () => {
					const key = item.dataset.key;
					const isSelected = selected.has(key);
					if (isSelected) {
						selected.delete(key);
						remaining += cost;
						item.classList.remove('selected');
					} else {
						if (cost > remaining) return;
						const bpEntry = { name: entry.name, matrix: entry.matrix, category: entry.category };
						const blueprint = createCardBlueprint(bpEntry, color);
						selected.set(key, blueprint);
						remaining -= cost;
						item.classList.add('selected');
					}
					updatePreworldPickUI();
				});
				grid.appendChild(item);
			});

			const updatePreworldPickUI = () => {
				if (budgetEl) budgetEl.textContent = String(remaining);
				grid.querySelectorAll('.preworld-pick-item').forEach(item => {
					const cost = Number(item.dataset.cost || 0);
					const isSelected = item.classList.contains('selected');
					const disabled = !isSelected && cost > remaining;
					item.classList.toggle('disabled', disabled);
					item.setAttribute('aria-disabled', disabled ? 'true' : 'false');
				});
				if (warningEl) {
					if (remaining > 0) {
						warningEl.textContent = `Je hebt nog ${remaining}ðŸª™ over. Gebruik ze voor extra startkaarten.`;
						warningEl.style.display = 'block';
					} else {
						warningEl.textContent = '';
						warningEl.style.display = 'none';
					}
				}
				confirmBtn.disabled = false;
			};
			updatePreworldPickUI();

			confirmBtn.onclick = () => {
				confirmBtn.disabled = true;
				if (remaining > 0) {
					const proceed = window.confirm(`Je hebt nog ${remaining}ðŸª™ over. Wil je toch starten?`);
					if (!proceed) {
						confirmBtn.disabled = false;
						return;
					}
				}
				const picks = Array.from(selected.values());
				closePreworldPickModal();
				if (typeof onComplete === 'function') onComplete(picks);
			};

			preworldPickLayer.classList.add('show');
			preworldPickLayer.setAttribute('aria-hidden', 'false');
			if (preworldPickModal && preworldPickModal.focus) {
				setTimeout(() => preworldPickModal.focus(), 60);
			}
		}


	function startLevel(level, options) {
	  const opts = (options && typeof options === 'object') ? options : {};
	  // If a scenario is active, never regenerate boards via the normal level pipeline.
	  // Some UI flows (e.g., shop modal callbacks) historically call startLevel() again.
	  // In scenario mode we route to startScenarioRun() to avoid overwriting the imported board.
	  try {
		if (window && window._locusScenarioMode && !isLoadingGame) {
			try { if (typeof startScenarioRun === 'function') startScenarioRun(); } catch (e) {}
			return;
		}
	  } catch (e) {}

	  // Bij start van een wereld: vooraf kaarten kiezen met budget
	  try {
		const info = getWorldAndSubLevel(Number(level) || 0);
		const world = Number(info && info.world) || 1;
		const subLevel = Number(info && info.subLevel) || 1;
		const isWorldStart = (subLevel === 1) && Number(level) !== 0;
		const worldKey = String(world);
		const alreadyDoneForWorld = !!(starterPicksDoneByWorld && starterPicksDoneByWorld[worldKey]);
		if (isWorldStart && !alreadyDoneForWorld && !preLevelStarterPicksInProgress && !isLoadingGame) {
			// Switch off the intro deck before we start the picker, so picks land on the standard deck
			// and won't be wiped when we restart startLevel after the picker completes.
			if (introDeckActive) {
				introDeckActive = false;
				resetDeckToStandard();
			}
			preLevelStarterPicksInProgress = true;
			openPreworldPickModal({
				onComplete: (pickedBlueprints) => {
					if (Array.isArray(pickedBlueprints) && pickedBlueprints.length) {
						pickedBlueprints.forEach(bp => ownedDeckBlueprints.push(bp));
					}
					starterPicksDoneByWorld[worldKey] = true;
					// Back-compat: keep the old flag in sync for world 1.
					if (world === 1) preLevelStarterPicksDone = true;
					preLevelStarterPicksInProgress = false;
					try { saveGameState(); } catch (e) {}
					startLevel(level, options);
				}
			});
			return;
		}
	  } catch (e) {}

	  // Normal mode: ensure scenario flags are cleared.
	  try { if (window) { window._locusScenarioMode = false; window._locusScenarioLoaded = false; } } catch (e) {}

	  // World 4: reset color gating + locks between levels
	  setWorld4AllowedColors(null);
	  clearWorld4Locks();

	  currentLevel = level;
	  markZoneSizingNeeded();
	// Stop any lingering tutorial state when leaving the intro level so hints do not bleed into later levels.
	if (level !== 0 && tutorialState.active) {
		tutorialState.active = false;
		tutorialState.cardSelected = false;
		tutorialState.cardPlaced = false;
		tutorialState.bonusPlaced = false;
		tutorialState.bonusReady = false;
		clearTutorialHighlights();
		hideTutorialOverlay();
		hideTutorialGhost();
	}
	  // Clear any previously loaded custom board metadata when starting a normal level
	  // (but preserve it when we are loading a custom-board save).
	  if (!opts.preserveLoadedCustomMeta) {
		try { window.loadedCustomLevelMeta = null; window.loadedCustomObjectiveCompiled = null; window.loadedCustomLevelMetaCompleted = false; } catch(e){}
	  }
	  lastRoundFailureReason = null;
	  const { world: levelWorld } = getWorldAndSubLevel(currentLevel);
	  const world4Active = Number(levelWorld) === 4;
	  // World 3 red progression resets per level (but should not reset during load).
	  if (!isLoadingGame) {
		world3RedStage = 1;
		try { applyWorld3RedStage(Number(levelWorld) === 3 ? world3RedStage : 0); } catch (e) {}
	  }
		
	  // Rebuild shape pool zodat nieuwe card categorieÃ«n beschikbaar zijn
	  shapePool = buildShapePool();
		
	  // Reset alle score- en zone-tracking state voor het nieuwe level EERST
	  // (incl. per-zone caches zoals scoredYellowColumns/Segments, blue scored rows, etc.)
	  resetScoreState();
	  freePlacementsRemaining = 0;
	bonusUseHintShown = false;
	  
	  // Reset ALLE score UI elementen naar 0 VOORDAT objectives worden gecontroleerd
	  document.querySelectorAll('#scoreboard .score').forEach(el => {
		el.textContent = '0';
	  });
	  const totalScoreEl = document.getElementById('total-score');
	  if (totalScoreEl) totalScoreEl.textContent = '0';
	  
	  // Reset latestScoreSnapshot zodat objectives op 0 berekend worden
	  latestScoreSnapshot = { yellow: 0, red: 0, green: 0, purple: 0, blue: 0, bonus: 0, total: 0 };
	  
	  // Dan objectives resetten (zodat renderObjectivePanel de juiste scores ziet)
	  // Bij laden van een save: behoud de geladen objective state (currentObjectiveId + history).
	  if (!(isLoadingGame && opts.preserveLoadedObjectives)) {
		resetObjectives();
	  }
	  
	  // NOTE: Do NOT call updateScore() here. The board from the previous level/run is
	  // still mounted until rebuildGameBoards() runs. Calling updateScore() now would
	  // repopulate latestScoreSnapshot with old scores and incorrectly affect objectives.
	  
	  // Apply coinMaster upgrade if active: grant immediate coins visually
	  if (hasUpgrade('coinMaster')) {
		const bonusAmount = UPGRADES.coinMaster.bonusCoins || 2;
		for (let i = 0; i < bonusAmount; i++) addCoin();
	  }
		
	  	if (!(isLoadingGame && opts.preserveLoadedObjectives)) {
		setCurrentObjectiveForLevel(level);
	  } else {
		// Ensure UI reflects the loaded objective state.
			try {
				renderObjectivePanel();
				if (!currentObjectiveId) setCurrentObjectiveForLevel(level);
			} catch (e) {}
	  }
	  // Extra bonussen wanneer het doel "in elke kleur" vereist: 2 per kleur bij de start van het level.
	  if (!isLoadingGame) {
		try {
			const objective = getObjectiveById(currentObjectiveId);
			grantAllColorObjectiveBonuses(objective);
		} catch (e) { console.warn('Kon all-color bonus grant niet toepassen', e); }
	  }
	  // Preserve turn counter if we are loading from a save (already set from savedDeckState.turnCount)
	  if (!(isLoadingGame && savedDeckState)) {
		turnCount = 0;
	  }
	  selectedCardId = null;
	  selectedCardElement = null;
	  selectedShape = null;
	  selectedColor = null;
	  cardSelectionLocked = false;
	  if (rotateButton) rotateButton.disabled = true;
	  try { document.body.classList.add('board-loading'); } catch (_) {}
	  rebuildGameBoards();
	  // World 2: place a single bonus-upgrade shop event on the board.
	  placeBonusUpgradeFieldEvent_World2();
	  
	  // Plaats portals als de upgrade actief is
	  if (portalsActive) {
		placePortalsForLevel();
	  }
	  
	  // Removed placeUpgradeShop and placeMegaBonus - shop now always accessible from level 5
	  
	  // Bonus upgrade shop is no longer opened via a button.
	  const bonusShopBtn = document.getElementById('bonus-shop-btn');
	  if (bonusShopBtn) bonusShopBtn.style.display = 'none';
	  
	  cardPlacementHistory = [];
	  cardsPlayedThisTurn = 0;
	  actionSequence = 0;
	  resetTurnCardFlags();
	  updateUndoButton();
	  
	// Intro level gebruikt een vaste paarse deck zodat de eerste hand altijd paars bevat
	if (currentLevel === 0 && !isLoadingGame) {
		ownedDeckBlueprints = buildIntroTutorialDeckBlueprint();
		introDeckActive = true;
	} else if (introDeckActive && currentLevel > 0 && !isLoadingGame) {
		introDeckActive = false;
		resetDeckToStandard();
	}

	  
	  // Bij laden van een save: gebruik de opgeslagen deck state indien beschikbaar
	  if (isLoadingGame && savedDeckState) {
		drawPile = savedDeckState.drawPile || [];
		// Apply scenario filter so restricted colors are not present in the draw pile.
		if (Array.isArray(window.scenarioAllowedColors)) {
			const allowed = window.scenarioAllowedColors;
			drawPile = (drawPile || []).filter(c => c && (allowed.includes((c.color && c.color.name) || '') || (c.color && c.color.name) === 'multikleur'));
		}
		// World 4: keep only allowed colors in the draw pile when restrictions are active.
		if (world4Active && Array.isArray(world4AllowedColors) && world4AllowedColors.length) {
			drawPile = (drawPile || []).filter(card => isWorld4CardAllowed(card));
		}
		discardPile = savedDeckState.discardPile || [];
		currentHand = savedDeckState.currentHand || [];
		turnCount = savedDeckState.turnCount || 0;
	} else {
		// Nieuwe start: maak fresh deck
		if (currentLevel === 0) {
			const introBlueprints = ownedDeckBlueprints && ownedDeckBlueprints.length ? ownedDeckBlueprints : buildIntroTutorialDeckBlueprint();
			drawPile = introBlueprints.map(bp => instantiateBlueprint(bp));
		} else {
			drawPile = shuffleArray(ownedDeckBlueprints.map(bp => instantiateBlueprint(bp)));
		}
		// If scenario restricts colors, remove disallowed cards from the draw pile
		// so they are never drawn during this run.
		if (Array.isArray(window.scenarioAllowedColors)) {
			const allowed = window.scenarioAllowedColors;
			drawPile = drawPile.filter(c => c && (allowed.includes((c.color && c.color.name) || '') || (c.color && c.color.name) === 'multikleur'));
		}
		// World 4: keep the draw pile limited to the current allowed palette.
		if (world4Active && Array.isArray(world4AllowedColors) && world4AllowedColors.length) {
			drawPile = drawPile.filter(card => isWorld4CardAllowed(card));
		}
		discardPile = [];
		currentHand = [];
		turnCount = 0;
	}
	  
	  updateDeckPreview();
	  updateTurnCounterDisplay();
	  
	  // Als we een restore hebben gedaan, render de bestaande hand
	  // Anders, trek nieuwe kaarten
	  if (isLoadingGame && savedDeckState && currentHand.length > 0) {
		renderCurrentHand();
	  } else {
		renderCurrentHand();
		drawNextHand();
	  }
	  
	  updateDeckPreview();
	  
	  // Auto-save na het starten van een level (behalve tijdens laden)
	  if (!isLoadingGame) {
		saveGameState();
	  }
	}

	function resetDeckToStandard() {
	  const base = buildStandardDeckBlueprint();
		ownedDeckBlueprints = base;
	}

	// ========== SAVE/LOAD SYSTEM ==========

	/** Serialize a single card object for save/export. Used by saveGameState(). */
	function serializeCard(card) {
		return {
			id: card.id,
			blueprintId: card.blueprintId,
			shapeName: card.shapeName,
			matrix: card.matrix,
			category: card.category,
			color: card.color ? { name: card.color.name, code: card.color.code, isGolden: card.color.isGolden } : null,
			isGolden: card.isGolden || false,
			isBonusBoost: card.isBonusBoost || false,
			isBonusEcho: card.isBonusEcho || false,
			bonusEchoVariant: card.bonusEchoVariant || null,
			bonusEchoReplaysAvailable: card.bonusEchoReplaysAvailable || 0
		};
	}

	function saveGameState() {
	  try {
		// Scenario-link sessions are meant to be temporary/shareable.
		// Do NOT overwrite the player's normal save when playing a shared scenario.
		try {
			if (window && window._locusScenarioMode) return true;
		} catch (e) {}

		// Only persist a board snapshot/world override when a custom board is active (editor/scenario).
		// For normal runs we want the world to be derived from the level mapping on each load.
		const isCustomBoardSession = (() => {
			try {
				if (window && window._locusEditorApplied) return true;
				if (window && window.loadedCustomLevelMeta) return true;
				if (window && Array.isArray(window.scenarioAllowedColors) && window.scenarioAllowedColors.length) return true;
			} catch (e) {}
			return false;
		})();

		const gameState = {
		  version: '1.0',
		  timestamp: Date.now(),
		  // Explicit run mode so loaders can distinguish normal vs custom/scenario sessions.
		  runMode: isCustomBoardSession ? 'custom' : 'normal',
		  currentLevel: currentLevel,
		  world3RedStage: Number(world3RedStage) === 2 ? 2 : 1,
		  customBoard: isCustomBoardSession,
		  // totalTurns/currentStreak removed (unused UI)
		  
		  // Coins
		  coins: Array.from(document.querySelectorAll('#collected-coins .coin')).map(coin => ({
			active: coin.classList.contains('active'),
			used: coin.classList.contains('used')
		  })),
		  
		  // Upgrades
		  upgrades: Object.keys(UPGRADES).reduce((acc, key) => {
			acc[key] = UPGRADES[key].purchased || false;
			return acc;
		  }, {}),
		  
		  // Bonuses
		  bonusInventory: { ...bonusInventory },
		  bonusMasteryState: { ...bonusMasteryState },
		  bonusEchoState: {
			colorScoreBonuses: { ...colorScoreBonuses },
			bonusEchoExtraTurns,
			bonusEchoStreak,
			bonusEchoFreePlays,
			lastCardWasBonusEcho,
			lastBonusEchoVariant
		  },
		  starterPicksDoneByWorld: { ...(starterPicksDoneByWorld || {}) },
		  preLevelStarterPicksDone,
		  
		  // Objectives
		  currentObjectiveId: currentObjectiveId,
		  completedObjectives: [...completedObjectives],
		  completedObjectiveIds: Array.from(completedObjectiveIds || []),
		  
		  // Deck
		  ownedDeckBlueprints: ownedDeckBlueprints.map(bp => ({
			blueprintId: bp.blueprintId,
			shapeName: bp.shapeName,
			matrix: bp.matrix,
			category: bp.category,
			color: bp.color ? { name: bp.color.name, code: bp.color.code, isGolden: bp.color.isGolden } : null,
			isGolden: bp.isGolden || false,
			isBonusBoost: bp.isBonusBoost || false,
			isBonusEcho: bp.isBonusEcho || false,
			bonusEchoVariant: bp.bonusEchoVariant || null
		  })),
		  
		  // Current game state (drawPile, discardPile, currentHand)
		  drawPile: drawPile.map(serializeCard),
		  discardPile: discardPile.map(serializeCard),
		  currentHand: currentHand.map(serializeCard),
		  cardsPlayedThisTurn: cardsPlayedThisTurn,
		  turnCount: turnCount,
		  
		  // Portals
		  portalsActive: portalsActive || false
		};

		// Only for editor/scenario: persist world + board snapshot + meta so it stays stable across reload.
		if (isCustomBoardSession) {
			try { gameState.currentWorld = currentWorld; } catch (e) {}
			// Track which level the board snapshot belongs to (prevents mismatched board/level restores).
			try { gameState.boardHtmlLevel = currentLevel; } catch (e) {}
			try { gameState.scenarioAllowedColors = window.scenarioAllowedColors || null; } catch (e) {}
			try { gameState.loadedCustomLevelMeta = window.loadedCustomLevelMeta || null; } catch (e) {}
			// Include a sanitized snapshot of the current board DOM (without active/placed cells)
			try {
				if (typeof getEditorBoardHtml === 'function') {
					const raw = getEditorBoardHtml();
					if (raw) gameState.boardHtml = (typeof sanitizeBoardHtml === 'function') ? sanitizeBoardHtml(raw) : raw;
				} else if (document.getElementById('board')) {
					const raw = document.getElementById('board').outerHTML;
					if (raw) gameState.boardHtml = (typeof sanitizeBoardHtml === 'function') ? sanitizeBoardHtml(raw) : raw;
				}
			} catch (e) {}
		}
		
		localStorage.setItem('locusGameSave', JSON.stringify(gameState));
		return true;
	  } catch (error) {
		console.error('âŒ Failed to save game:', error);
		return false;
	  }
	}

// Sanitize a board HTML snapshot so it never contains runtime-placed cells or inline styles.
// IMPORTANT: Preserve inline styles for grids using absolute positioning (green/red).
function sanitizeBoardHtml(html) {
	try {
		const tmp = document.createElement('div');
		tmp.innerHTML = html || '';
		tmp.querySelectorAll('.cell').forEach(cell => {
			// Preserve symbols/bonus visuals; only clear runtime-filled state
			try { cell.classList.remove('active', 'edge-cell'); } catch (e) {}
			// Check if this cell uses absolute positioning (green/red zones)
			// These rely on inline left/top for placement - do NOT remove their styles
			// Red subgrids (red-grid1, red-grid2, etc.) have cells directly inside, no .grid child
			const grid = cell.closest('.grid');
			const zone = cell.closest('.zone');
			const isGreenGrid = (grid && grid.id === 'green-grid') || (zone && zone.dataset && zone.dataset.color === 'groen');
			const isRedGrid = (zone && zone.id && zone.id.startsWith('red-grid')) ||
				(zone && zone.dataset && zone.dataset.color === 'rood') ||
				(zone && zone.classList && zone.classList.contains('red-group'));
			const usesAbsolutePositioning = isAbsolutePositionedGrid(cell);
			// Only remove inline styles for CSS Grid-based zones, not absolute-positioned ones
			if (!usesAbsolutePositioning) {
				try { cell.removeAttribute('style'); } catch (e) {}
			}
		});
		// Also remove any floating info popovers in zones
		tmp.querySelectorAll('.zone-info-btn, .zone-info-popover, .zone-handle, .grid-resizer, .zone-delete').forEach(n => n.remove());
		return tmp.innerHTML;
	} catch (e) {
		return html;
	}
}

function setWorld4AllowedColors(colors) {
	try {
		world4AllowedColors = Array.isArray(colors) ? colors.map(c => String(c || '').toLowerCase()) : null;
		window.world4AllowedColors = world4AllowedColors;
	} catch (e) {
		world4AllowedColors = null;
	}
}

function clearWorld4Locks() {
	try {
		world4UnlockedColors = new Set();
		window.world4UnlockedColors = world4UnlockedColors;
		// Restore zone visibility (World 4 gating might have hidden some)
		try {
			['yellow-zone','green-zone','blue-zone','purple-zone','red-zone'].forEach(id => {
				const z = document.getElementById(id);
				if (z) z.style.display = '';
			});
		} catch (e) {}
		// Remove any lingering door/key visuals + locked regions
		document.querySelectorAll('.door-cell,.key-cell,.cell.locked-behind-door,.cell.locked-cell').forEach(el => {
			try {
				el.classList.remove('door-open','door-armed','door-cell','key-cell','key-consumed','locked-behind-door','locked-cell');
				delete el.dataset.lockedDoorId;
				delete el.dataset.doorId;
				delete el.dataset.doorColor;
				delete el.dataset.keyColor;
				delete el.dataset.keyConsumed;
				delete el.dataset.w4Ink;
				const sym = el.querySelector && el.querySelector('.door-symbol,.key-symbol');
				if (sym) sym.remove();
			} catch (_) {}
		});
	} catch (e) {}
}

function isWorld4ColorUnlocked(color) {
	const key = String(color || '').toLowerCase();
	return world4UnlockedColors instanceof Set && world4UnlockedColors.has(key);
}

function unlockWorld4Color(color) {
	const key = String(color || '').toLowerCase();
	if (!key) return;
	if (!(world4UnlockedColors instanceof Set)) world4UnlockedColors = new Set();
	if (world4UnlockedColors.has(key)) return;
	world4UnlockedColors.add(key);
	window.world4UnlockedColors = world4UnlockedColors;
	// Add to the allowed palette (hand cards become playable) and reveal the zone.
	try {
		if (!world4AllowedColors || !world4AllowedColors.length) {
			setWorld4AllowedColors([key]);
		} else if (!world4AllowedColors.includes(key)) {
			setWorld4AllowedColors(world4AllowedColors.concat([key]));
		}
	} catch (e) {}
	try {
		if (key === 'rood') {
			const rz = document.getElementById('red-zone');
			if (rz) rz.style.display = '';
		} else {
			const z = document.querySelector(`.zone[data-color="${key}"]`) || document.getElementById(`${key}-zone`);
			if (z) z.style.display = '';
		}
	} catch (e) {}
	// Arm matching doors (visual cue); door still requires activation to open.
	try {
		document.querySelectorAll(`.cell.door-cell[data-door-color]`).forEach(cell => {
			const c = String(cell.dataset.doorColor || '').toLowerCase();
			if (c !== key) return;
			cell.classList.add('door-armed');
		});
	} catch (e) {}
	try { if (typeof renderCurrentHand === 'function') renderCurrentHand(); } catch (e) {}
	try { if (typeof updateBonusInventoryUI === 'function') updateBonusInventoryUI(); } catch (e) {}
}

function isWorld4DoorOpen(doorId) {
	const id = String(doorId || '').trim();
	if (!id) return false;
	try {
		const door = document.querySelector(`.cell.door-cell[data-door-id="${CSS.escape(id)}"]`);
		return !!(door && door.classList.contains('door-open'));
	} catch (e) {
		// Fallback if CSS.escape isn't available
		try {
			const door = Array.from(document.querySelectorAll('.cell.door-cell')).find(el => String(el.dataset.doorId || '') === id);
			return !!(door && door.classList.contains('door-open'));
		} catch (_) { return false; }
	}
}

function openWorld4Door(doorId) {
	const id = String(doorId || '').trim();
	if (!id) return;
	let door = null;
	try {
		door = document.querySelector(`.cell.door-cell[data-door-id="${CSS.escape(id)}"]`);
	} catch (e) {
		door = Array.from(document.querySelectorAll('.cell.door-cell')).find(el => String(el.dataset.doorId || '') === id) || null;
	}
	if (!door) return;
	if (!door.classList.contains('door-open')) {
		door.classList.add('door-open');
		door.classList.remove('door-armed');
		try { showObjectiveToast('ðŸšª Deur geopend!'); } catch (e) {}
		// World 4 upgrade: opening a door grants a free placement
		try {
			if (hasUpgrade('world4DoorSurge')) {
				freePlacementsRemaining += 1;
				updateBonusInventoryUI();
				showObjectiveToast('âš¡ Gratis plaatsing ontvangen!');
			}
		} catch (e) {}
	}
	// Unlock the region behind this door
	try {
		document.querySelectorAll(`.cell[data-locked-door-id]`).forEach(cell => {
			if (String(cell.dataset.lockedDoorId || '') !== id) return;
			try { delete cell.dataset.lockedDoorId; } catch (_) {}
			cell.classList.remove('locked-behind-door');
		});
	} catch (e) {}
}

function isWorld4CardAllowed(cardData) {
	if (!world4AllowedColors || !world4AllowedColors.length) return true;
	const name = String(cardData?.color?.name || '').toLowerCase();
	if (name === 'multikleur') return true;
	return world4AllowedColors.includes(name);
}

	function loadGameState() {
	  try {
		const saved = localStorage.getItem('locusGameSave');
		if (!saved) {
		  return false;
		}
		
		const gameState = JSON.parse(saved);
		if (!gameState) {
		  console.error('âŒ Failed to parse save data');
		  return false;
		}
		const savedBonusEchoState = gameState.bonusEchoState ? { ...gameState.bonusEchoState } : null;
		const savedPreLevelStarterPicksDone = (typeof gameState.preLevelStarterPicksDone === 'boolean') ? gameState.preLevelStarterPicksDone : null;
		const savedStarterPicksDoneByWorld = (gameState && gameState.starterPicksDoneByWorld && typeof gameState.starterPicksDoneByWorld === 'object')
			? gameState.starterPicksDoneByWorld
			: null;
		
		if (gameState.version !== '1.0') {
		  console.warn('âš ï¸ Save version mismatch:', gameState.version);
		  return false;
		}
		
		
		// Determine if this save represents an editor/scenario/custom-board session.
		// IMPORTANT: Old saves may contain boardHtml snapshots from normal runs; we must ignore those.
		const isCustomBoardSave = (() => {
			try {
				if (gameState.customBoard === true) return true;
				if (gameState.loadedCustomLevelMeta) return true;
				if (Array.isArray(gameState.scenarioAllowedColors) && gameState.scenarioAllowedColors.length) return true;
			} catch (e) {}
			return false;
		})();
		// Apply run mode flags for this session.
		try {
			const runMode = String(gameState.runMode || (isCustomBoardSave ? 'custom' : 'normal'));
			if (window) {
				window._locusScenarioMode = (runMode === 'scenario');
				window._locusScenarioLoaded = (runMode === 'scenario');
				window._locusRunMode = runMode;
			}
		} catch (e) {}
		
		// Restore level (world will be derived from level for normal runs)
		// IMPORTANT: do not use `|| 1` here; level 0 is a valid intro level.
		const rawSavedLevel = (gameState && Object.prototype.hasOwnProperty.call(gameState, 'currentLevel'))
			? gameState.currentLevel
			: null;
		let loadedLevel = Number(rawSavedLevel);
		if (!Number.isFinite(loadedLevel)) loadedLevel = 1;
		loadedLevel = Math.max(0, loadedLevel);
		// Heuristic: if a save claims level 0 but contains evidence of later-level progress,
		// infer the most likely level from objective history and purchased upgrades.
		if (loadedLevel === 0) {
			let inferred = 0;
			try {
				const parseLevelFromObjectiveId = (id) => {
					if (!id) return null;
					const s = String(id);
					const m = s.match(/\blevel[-_](\d{1,2})\b/i);
					if (!m) return null;
					const n = Number(m[1]);
					return Number.isFinite(n) ? n : null;
				};

				let maxCompletedLevel = 0;
				// First: infer from saved objective IDs directly (works even when OBJECTIVES is randomized).
				const ids = [];
				if (gameState.currentObjectiveId) ids.push(gameState.currentObjectiveId);
				if (Array.isArray(gameState.completedObjectiveIds)) ids.push(...gameState.completedObjectiveIds);
				if (Array.isArray(gameState.completedObjectives)) {
					gameState.completedObjectives.forEach(o => { if (o && o.id) ids.push(o.id); });
				}
				ids.forEach(id => {
					const lvl = parseLevelFromObjectiveId(id);
					if (Number.isFinite(lvl)) maxCompletedLevel = Math.max(maxCompletedLevel, lvl);
				});

				// If currentObjectiveId maps to a known objective, that can also hint the current level.
				try {
					if (typeof getObjectiveById === 'function' && gameState.currentObjectiveId) {
						const obj = getObjectiveById(gameState.currentObjectiveId);
						const lvl = Number(obj && obj.level);
						if (Number.isFinite(lvl) && lvl > 0) inferred = Math.max(inferred, lvl);
					}
				} catch (e) {}

				// If we have any objective evidence beyond 0, assume we're at least that level (or next).
				if (maxCompletedLevel > 0) inferred = Math.max(inferred, maxCompletedLevel + 1);

				// Second: infer from purchased upgrades (world2/world3-only upgrades imply higher levels).
				try {
					let minByUpgrades = 0;
					if (gameState.upgrades && typeof gameState.upgrades === 'object') {
						Object.entries(gameState.upgrades).forEach(([key, purchased]) => {
							if (!purchased) return;
							const meta = (typeof UNLOCK_PROGRESSION === 'object' && UNLOCK_PROGRESSION && UNLOCK_PROGRESSION.upgrades)
								? UNLOCK_PROGRESSION.upgrades[key]
								: null;
							const lvl = Number(meta && meta.unlockedAtLevel);
							if (Number.isFinite(lvl)) minByUpgrades = Math.max(minByUpgrades, lvl);
						});
					}
					if (minByUpgrades > 0) inferred = Math.max(inferred, minByUpgrades);
				} catch (e) {}
			} catch (e) { inferred = 0; }
			if (inferred > 0) {
				console.warn('âš ï¸ Save reported level 0, inferred level from objectives:', inferred);
				loadedLevel = inferred;
			}
		}
		currentLevel = loadedLevel;
		// World 3 red progression: always start at stage 1 on load (do not carry stage 2 across reloads).
		world3RedStage = 1;
		turnCount = gameState.turnCount || 0;
		// Loading a non-intro level should never keep the intro deck flag.
		if (currentLevel > 0) {
			introDeckActive = false;
		}
		
		// Restore scenario/editor meta early so startLevel can filter decks if needed
		try { window.scenarioAllowedColors = isCustomBoardSave ? (gameState.scenarioAllowedColors || null) : null; } catch (e) {}
		try {
			if (isCustomBoardSave && gameState.loadedCustomLevelMeta) {
				window.loadedCustomLevelMeta = gameState.loadedCustomLevelMeta;
				window.loadedCustomObjectiveCompiled = null;
				window.loadedCustomLevelMetaCompleted = false;
				if (window.loadedCustomLevelMeta && window.loadedCustomLevelMeta.objective) {
					try { window.loadedCustomObjectiveCompiled = parseObjectiveTextToObjective(String(window.loadedCustomLevelMeta.objective || '').trim()); } catch (e) { window.loadedCustomObjectiveCompiled = null; }
				}
			} else {
				window.loadedCustomLevelMeta = null;
				window.loadedCustomObjectiveCompiled = null;
				window.loadedCustomLevelMetaCompleted = false;
			}
		} catch (e) {}
		
		// Restore upgrades
		if (gameState.upgrades) {
		  Object.keys(gameState.upgrades).forEach(key => {
			if (UPGRADES[key]) {
			  UPGRADES[key].purchased = gameState.upgrades[key];
			  return;
			}
			// Back-compat: compactCards was renamed/merged into miniPack34.
			if (key === 'compactCards' && UPGRADES.miniPack34) {
			  UPGRADES.miniPack34.purchased = gameState.upgrades[key];
			}
		  });
		}
		
		// Restore bonuses
		if (gameState.bonusInventory) {
		  Object.keys(gameState.bonusInventory).forEach(key => {
			bonusInventory[key] = gameState.bonusInventory[key];
		  });
		}
		if (gameState.bonusMasteryState) {
		  Object.keys(gameState.bonusMasteryState).forEach(key => {
			bonusMasteryState[key] = gameState.bonusMasteryState[key];
		  });
		}
		if (gameState.bonusEchoState) {
			try {
				const savedEcho = gameState.bonusEchoState || {};
				colorScoreBonuses = { ...colorScoreBonuses, ...(savedEcho.colorScoreBonuses || {}) };
				bonusEchoExtraTurns = Number(savedEcho.bonusEchoExtraTurns || 0);
				bonusEchoStreak = Number(savedEcho.bonusEchoStreak || 0);
				bonusEchoFreePlays = Number(savedEcho.bonusEchoFreePlays || 0);
				lastCardWasBonusEcho = !!savedEcho.lastCardWasBonusEcho;
				lastBonusEchoVariant = savedEcho.lastBonusEchoVariant || null;
			} catch (e) { resetBonusEchoState(); }
		} else {
			resetBonusEchoState();
		}
		// Restore starter pick completion so world-start pickers are respected after load
		starterPicksDoneByWorld = {};
		if (savedStarterPicksDoneByWorld) {
			try {
				Object.keys(savedStarterPicksDoneByWorld).forEach((k) => {
					starterPicksDoneByWorld[String(k)] = !!savedStarterPicksDoneByWorld[k];
				});
			} catch (e) { starterPicksDoneByWorld = {}; }
			// Back-compat: ensure old boolean applies to world 1.
			if (typeof savedPreLevelStarterPicksDone === 'boolean') {
				starterPicksDoneByWorld['1'] = !!savedPreLevelStarterPicksDone;
			}
		} else {
			// Back-compat + anti-surprise: older saves didn't track this per world.
			// Infer that already-passed worlds are done, and if we're mid-world, mark the current world as done
			// so loading doesn't immediately pop a picker.
			try {
				const info = getWorldAndSubLevel(Number(currentLevel) || 0);
				const wNow = Number(info && info.world) || 1;
				const sNow = Number(info && info.subLevel) || 1;
				for (let w = 1; w < wNow; w += 1) starterPicksDoneByWorld[String(w)] = true;
				if (sNow > 1) starterPicksDoneByWorld[String(wNow)] = true;
			} catch (e) {}
			if (typeof savedPreLevelStarterPicksDone === 'boolean') {
				starterPicksDoneByWorld['1'] = !!savedPreLevelStarterPicksDone;
			}
		}
		preLevelStarterPicksDone = !!starterPicksDoneByWorld['1'];
		preLevelStarterPicksInProgress = false;
		
		// Restore objectives
		currentObjectiveId = gameState.currentObjectiveId || null;
		completedObjectives.length = 0;
		if (gameState.completedObjectives) {
		  gameState.completedObjectives.forEach(obj => completedObjectives.push(obj));
		}
		completedObjectiveIds.clear();
		if (gameState.completedObjectiveIds) {
		  gameState.completedObjectiveIds.forEach(id => completedObjectiveIds.add(id));
		}
		
		// Restore deck
		if (gameState.ownedDeckBlueprints && gameState.ownedDeckBlueprints.length > 0) {
		  ownedDeckBlueprints = gameState.ownedDeckBlueprints.map(bp => {
			const colorObj = bp.color ? 
			  (bp.color.isGolden ? 
				{ name: bp.color.name, code: bp.color.code, isGolden: true } : 
				colors.find(c => c.name === bp.color.name) || bp.color
			  ) : null;
			
			// Valideer dat matrix bestaat
			if (!bp.matrix || !Array.isArray(bp.matrix)) {
			  console.error('Invalid matrix in blueprint:', bp);
			  return null;
			}
			
			return {
			  blueprintId: bp.blueprintId || nextBlueprintId(),
			  shapeName: bp.shapeName || 'unknown',
			  matrix: bp.matrix,
			  category: bp.category || 'standard',
			  color: colorObj,
			  isGolden: bp.isGolden || false,
			  isBonusBoost: bp.isBonusBoost || false,
			  isBonusEcho: bp.isBonusEcho || false,
			  bonusEchoVariant: bp.bonusEchoVariant || (bp.isBonusEcho ? 'replay' : null)
			};
		  }).filter(bp => bp !== null);
		  
		  // Als er geen valide blueprints zijn, reset naar standard
		  if (ownedDeckBlueprints.length === 0) {
			console.warn('No valid blueprints loaded, resetting to standard deck');
			resetDeckToStandard();
		  }
		} else {
		  resetDeckToStandard();
		}
		
		// Restore portals
		portalsActive = gameState.portalsActive || false;
		
		// Restore coins
		if (gameState.coins) {
		  initialiseCoins(gameState.coins.length);
		} else {
		  initialiseCoins();
		}
		resetCoins();
		if (gameState.coins) {
		  const coinElements = Array.from(document.querySelectorAll('#collected-coins .coin'));
		  gameState.coins.forEach((coinData, index) => {
			if (coinElements[index]) {
			  if (coinData.active) coinElements[index].classList.add('active');
			  if (coinData.used) coinElements[index].classList.add('used');
			}
		  });
		  updateCoinCounter();
		}
		
		// Helper functie om card instance te herstellen
		function restoreCardInstance(cardData) {
		  const colorObj = cardData.color ? 
			(cardData.color.isGolden ? 
			  { name: cardData.color.name, code: cardData.color.code, isGolden: true } : 
			  colors.find(c => c.name === cardData.color.name) || cardData.color
			) : null;
		  
		  return {
			id: cardData.id || nextCardInstanceId(),
			blueprintId: cardData.blueprintId,
			shapeName: cardData.shapeName,
			matrix: cardData.matrix,
			category: cardData.category || 'standard',
			color: colorObj,
			isGolden: cardData.isGolden || false,
			isBonusBoost: cardData.isBonusBoost || false,
			isBonusEcho: cardData.isBonusEcho || false,
			bonusEchoVariant: cardData.bonusEchoVariant || (cardData.isBonusEcho ? 'replay' : null),
			bonusEchoReplaysAvailable: cardData.bonusEchoReplaysAvailable || 0
		  };
		}
		
		const resumeDeckState = !!isCustomBoardSave;
		if (resumeDeckState) {
			// Prepareer saved deck state voor gebruik in startLevel
			savedDeckState = {
			  drawPile: gameState.drawPile ? gameState.drawPile.map(restoreCardInstance) : [],
			  discardPile: gameState.discardPile ? gameState.discardPile.map(restoreCardInstance) : [],
			  currentHand: gameState.currentHand ? gameState.currentHand.map(restoreCardInstance) : [],
			  turnCount: gameState.turnCount || 0
			};
			
			// Als alle kaarten in discard zitten (einde van een ronde), herstel ze naar draw pile
			if (savedDeckState.drawPile.length === 0 && savedDeckState.currentHand.length === 0 && savedDeckState.discardPile.length > 0) {
			  savedDeckState.drawPile = shuffleArray(savedDeckState.discardPile);
			  savedDeckState.discardPile = [];
			}
			
		} else {
			savedDeckState = null;
		}
		
		// Start the loaded level (resume deck only for custom/scenario boards)
		isLoadingGame = resumeDeckState;
		startLevel(currentLevel, { preserveLoadedCustomMeta: isCustomBoardSave, preserveLoadedObjectives: resumeDeckState });
		// Only restore the board snapshot for editor/scenario saves.
		// Normal runs should rebuild the board from the level/world mapping.
		if (isCustomBoardSave) {
			try {
				if (gameState.boardHtml) {
					const hasBoardHtmlLevel = (gameState && Object.prototype.hasOwnProperty.call(gameState, 'boardHtmlLevel'));
					// Older saves might have `customBoard: true` accidentally; only trust snapshots if we have strong custom/scenario indicators.
					const hasStrongCustomIndicators = !!(gameState.loadedCustomLevelMeta || gameState.scenarioAllowedColors || hasBoardHtmlLevel);
					if (!hasStrongCustomIndicators) {
						console.warn('âš ï¸ Ignoring boardHtml restore (missing custom indicators).');
					} else {
						const boardHtmlLevelRaw = hasBoardHtmlLevel ? gameState.boardHtmlLevel : null;
						const boardHtmlLevel = Number(boardHtmlLevelRaw);
						const expectedLevel = Number(currentLevel);
						const levelMatches = !Number.isFinite(boardHtmlLevel) || boardHtmlLevel === expectedLevel;
						if (!levelMatches) {
							console.warn('âš ï¸ Skipping boardHtml restore due to level mismatch:', { boardHtmlLevel, expectedLevel });
						} else {
							const htmlToApply = (typeof sanitizeBoardHtml === 'function') ? sanitizeBoardHtml(gameState.boardHtml) : gameState.boardHtml;
							applyBoardHtmlToGame(htmlToApply);
						}
					}
				}
				// Restore world override for custom boards (do after startLevel which rebuilds world from level)
				if (gameState.currentWorld) {
					currentWorld = Number(gameState.currentWorld) || currentWorld;
					document.body.classList.toggle('world-2', currentWorld === 2);
					document.body.classList.toggle('world-1', currentWorld === 1);
					document.body.classList.toggle('world-3', currentWorld === 3);
				}
				// Re-apply custom title/objective text in UI
				if (gameState.loadedCustomLevelMeta && typeof setLoadedLevelMeta === 'function') {
					setLoadedLevelMeta(gameState.loadedCustomLevelMeta.name, gameState.loadedCustomLevelMeta.objective, gameState.loadedCustomLevelMeta.scenarioId);
					try {
						// If this save was a scenario (e.g. 4.1/4.2), re-register its subgoals
						const sid = (gameState.loadedCustomLevelMeta && gameState.loadedCustomLevelMeta.scenarioId) ? gameState.loadedCustomLevelMeta.scenarioId : '';
						if (sid) registerScenarioSubgoals(sid, gameState.loadedCustomLevelMeta);
					} catch (e) {}
				}
			} catch (e) { console.error('Failed to restore custom board after startLevel', e); }
		}
		if (savedBonusEchoState) {
			try {
				colorScoreBonuses = { ...colorScoreBonuses, ...(savedBonusEchoState.colorScoreBonuses || {}) };
				bonusEchoExtraTurns = Number(savedBonusEchoState.bonusEchoExtraTurns || 0);
				bonusEchoStreak = Number(savedBonusEchoState.bonusEchoStreak || 0);
				bonusEchoFreePlays = Number(savedBonusEchoState.bonusEchoFreePlays || 0);
				lastCardWasBonusEcho = !!savedBonusEchoState.lastCardWasBonusEcho;
				if (typeof updateScore === 'function') updateScore();
			} catch (e) { console.error('Failed to reapply Bonus Echo state after load', e); }
		}
		isLoadingGame = false;
		savedDeckState = null; // Clear na gebruik
		// Ensure the stage visibility is applied after load (in case DOM was rebuilt).
		try { applyWorld3RedStage(Number(getWorldAndSubLevel(currentLevel)?.world || 1) === 3 ? world3RedStage : 0); } catch (e) {}
		
		// IMPORTANT: Reset green/blue scroll memory and center after loading.
		try {
			resetZoneScrollMemory('green-zone');
			resetZoneScrollMemory('blue-zone');
			scheduleGreenCenter({ force: true, allowZoom: false, fallback: true, fallbackDelay: 160 });
			const blueZone = document.getElementById('blue-zone');
			if (blueZone) requestAnimationFrame(() => resetBlueZoomScroll(blueZone));
		} catch (_) {}
		
		updateBonusInventoryUI();
		
		return true;
	  } catch (error) {
		console.error('âŒ Failed to load game:', error);
		return false;
	  }
	}

	function clearSaveData() {
	  try {
		localStorage.removeItem('locusGameSave');
		return true;
	  } catch (error) {
		console.error('âŒ Failed to clear save data:', error);
		return false;
	  }
	}

	function startNewRun() {
	  hideAllModals();
	  // If a scenario/editor board hid zones and removed their grid containers, restore the normal skeleton.
	  // This prevents getting "stuck" with only blue/green after clicking Nieuw spel.
	  try {
		const boardScope = document.getElementById('board') || document;
		const ensureZone = (zoneId, color, gridId) => {
			const zone = document.getElementById(zoneId) || boardScope.querySelector(`.zone[data-color="${color}"]`);
			if (!zone) return;
			try { zone.style.display = ''; } catch (e) {}
			let grid = zone.querySelector(`#${gridId}`) || zone.querySelector(':scope > .grid') || zone.querySelector('.grid');
			if (!grid) {
				grid = document.createElement('div');
				grid.className = 'grid';
				grid.id = gridId;
				zone.appendChild(grid);
			} else {
				try { grid.classList.add('grid'); } catch (e) {}
				if (!grid.id) grid.id = gridId;
			}
		};
		ensureZone('purple-zone', 'paars', 'purple-grid');
		ensureZone('yellow-zone', 'geel', 'yellow-grid');
		ensureZone('green-zone', 'groen', 'green-grid');
		ensureZone('blue-zone', 'blauw', 'blue-grid');
		// Red group
		const redGroup = document.getElementById('red-zone') || boardScope.querySelector('.zone.red-group') || boardScope.querySelector('.zone[data-color="rood"]');
		if (redGroup) {
			try { redGroup.style.display = ''; } catch (e) {}
			for (let i = 1; i <= 4; i += 1) {
				const id = `red-grid${i}`;
				let sub = document.getElementById(id) || redGroup.querySelector(`#${id}`);
				if (!sub) {
					sub = document.createElement('div');
					sub.className = 'zone';
					sub.id = id;
					sub.dataset.color = 'rood';
					sub.dataset.zone = id;
					sub.dataset.subgrid = String(i);
					redGroup.appendChild(sub);
				} else {
					try { sub.classList.add('zone'); } catch (e) {}
					try { sub.dataset.color = 'rood'; } catch (e) {}
					try { sub.dataset.zone = id; } catch (e) {}
					try { sub.dataset.subgrid = String(i); } catch (e) {}
					try { sub.style.display = ''; } catch (e) {}
				}
			}
		}
	  } catch (e) {}
	  // New run is always the normal game mode.
	  try {
		if (window) {
			window._locusScenarioMode = false;
			window._locusScenarioLoaded = false;
			window._locusRunMode = 'normal';
			window.scenarioAllowedColors = null;
		}
	  } catch (e) {}
	  
	  // Reset alle upgrades
	  Object.keys(UPGRADES).forEach(key => {
		UPGRADES[key].purchased = false;
	  });
	  starterPicksDoneByWorld = {};
	  preLevelStarterPicksDone = false;
	  preLevelStarterPicksInProgress = false;
	  
	  // Reset portals
	  portalsActive = false;
	  clearPortals();
	  
	  // Reset bonussen
	  BONUS_ORDER.forEach(colorKey => {
		bonusInventory[colorKey] = 0;
		bonusMasteryState[colorKey] = false;
	  });
	  updateBonusInventoryUI();
	introDeckActive = false;
	  resetDeckToStandard();
	  resetCoins();
	  addCoin();
	  
	  // Reset alle scores naar 0
	  document.querySelectorAll('#scoreboard .score').forEach(el => {
		el.textContent = '0';
	  });
	  const totalScoreEl = document.getElementById('total-score');
	  if (totalScoreEl) totalScoreEl.textContent = '0';
	  
	  // Reset blue zone scored rows tracking
	  window['blue-grid-scoredRows'] = new Map();
	  window['blue-grid-scoredTargets'] = new Map();
	  window['blue-grid-rowPlacements'] = new Map();
	  window['blue-grid-placementScorings'] = new Map();
	  try { window._locusEditorApplied = false; } catch (e) {}
	  // Clear per-grid editor-applied markers
	  try {
		document.querySelectorAll('.grid').forEach(g => {
			try { if (g && g.dataset && g.dataset.editorApplied) delete g.dataset.editorApplied; } catch (e) {}
		});
	  } catch (e) {}
	  
	  // Reset coinsAwardedFromScore
	  if (typeof coinsAwardedFromScore !== 'undefined') coinsAwardedFromScore = 0;
	  
	const startLevelNum = (typeof isTutorialCompleted === 'function' && isTutorialCompleted()) ? 1 : 0;
	startLevel(startLevelNum);
	if (startLevelNum === 0) {
		scheduleTutorialOnFirstRun();
	}
	}

	function completeRound() {
	  if (currentHand.length !== 0 || drawPile.length !== 0) {
		return;
	  }
	  if (bonusEchoExtraTurns > 0 && Array.isArray(discardPile) && discardPile.length > 0) {
		if (prepareBonusEchoExtraTurnDeck()) {
			drawNextHand();
			updateDeckPreview();
			return;
		}
	  }
		const score = Number(document.getElementById('total-score')?.textContent || '0') || 0;
		const coinsBeforeBonus = getSpendableCoinCount();
		grantRoundScoreCoins(score);
		const coinsAfterBonus = getSpendableCoinCount();
		const bonusCoins = Math.max(0, coinsAfterBonus - coinsBeforeBonus);
		const coins = coinsAfterBonus;
		const objectiveCleared = isCurrentObjectiveCompleted();
		const success = objectiveCleared;
		lastRoundFailureReason = success ? null : 'objective';
		showRoundModal(success, score, coins, bonusCoins);
	}

	function finalizeRoundCompletion() {
		let handWasDiscarded = false;
		if (currentHand.length > 0) {
			const objectiveComplete = isCurrentObjectiveCompleted();
			if (cardsPlayedThisTurn === 0 && !objectiveComplete) return;
			discardCurrentHand();
			handWasDiscarded = true;
		}
		cardsPlayedThisTurn = 0;
		if (!handWasDiscarded) {
			renderCurrentHand();
		}
		completeRound();
	}

	let selectedShape = null;
	let selectedColor = null;
	let floatingPreviewActive = false;
	let suppressCardSelectUntil = 0;
	let desktopHoverDragActive = false;
	let suppressDesktopDropUntil = 0;

	function cancelDesktopHoverDragKeepSelection({ showPreview = false } = {}) {
		if (!desktopHoverDragActive) return;
		const overlay = document.getElementById('drag-overlay');
		try { draggedBlock?.remove(); } catch {}
		draggedBlock = null;
		draggedShape = null;
		draggedColor = null;
		lastZone = null;
		lastBaseX = lastBaseY = null;
		desktopHoverDragActive = false;
		suppressDesktopDropUntil = 0;
		endPointerDragTracking();
		if (overlay) overlay.style.display = 'none';
		document.body.classList.remove('dragging');
		document.body.style.cursor = '';
		document.documentElement.style.cursor = '';
		stopGlobalDragVisuals();
		removeCardControlButtons();
		if (showPreview && selectedShape && selectedColor) {
			showFloatingPreview(selectedShape, selectedColor);
		}
	}

	function startDesktopHoverDragFromSelection(cardEl, shape, color) {
		if (!cardEl || !shape || !color) return;
		// Desktop mouse UX: click-to-pickup (no on-card option buttons, no floating preview)
		hideFloatingPreview();
		removeCardControlButtons();
		// If a drag block exists, remove it without clearing selection.
		if (draggedBlock) {
			const overlay = document.getElementById('drag-overlay');
			try { draggedBlock.remove(); } catch {}
			draggedBlock = null;
			draggedShape = null;
			draggedColor = null;
			lastZone = null;
			lastBaseX = lastBaseY = null;
			endPointerDragTracking();
			if (overlay) overlay.style.display = 'none';
			document.body.classList.remove('dragging');
			document.body.style.cursor = '';
			document.documentElement.style.cursor = '';
			stopGlobalDragVisuals();
		}

		const rect = cardEl.getBoundingClientRect();
		const startX = rect.left + (rect.width / 2);
		const startY = rect.top + (rect.height / 2);

		const block = makeDraggable(shape, color);
		const m = getDragBlockCellMetrics(block);
		const centerOffsets = computeShapeCenterOffsets(shape, m);
		offsetX = centerOffsets.offsetX;
		offsetY = centerOffsets.offsetY;
		setElPos(block, startX - offsetX, startY - offsetY);

		draggedBlock = block;
		resetDragBlockGap();
		draggedShape = block._shape || shape;
		draggedColor = color;
		lastZone = null;
		lastBaseX = lastBaseY = null;

		desktopHoverDragActive = true;
		suppressDesktopDropUntil = Date.now() + 250;

		const overlay = document.getElementById('drag-overlay');
		if (overlay && !overlay.contains(block)) {
			overlay.appendChild(block);
			overlay.style.display = 'block';
		}
		beginPointerDrag({ clientX: startX, clientY: startY, pointerId: null });
		startGlobalDragVisuals();
	}

	function selectCard(card, shape, color, options = {}) {
		if (!card) return;
		if (card.classList.contains('selection-disabled') && card !== selectedCardElement) return;
		// BUG FIX: Als er een bonusblokje actief is en we klikken op een kaart,
		// moet het bonusblok eerst geannuleerd worden om transformatie/kopiÃ«ren te voorkomen.
		if (activeBonusPlacement) {
			cancelActiveBonusPlacement({ updateInventory: true, hidePreview: true });
		}
		const forceDrag = !!options.forceDrag;
		const isMobileLayout = isMobileViewport();
		const isTouchDevice = ('ontouchstart' in window || navigator.maxTouchPoints > 0);
		// Touch UX: alleen een draggable block spawnen als forceDrag true is (bij slepen/long-press).
		// Een normale tap moet alleen selecteren en floating preview + control buttons tonen.
		const shouldSpawnBlock = forceDrag;
		const isSameCard = (selectedCardElement === card) || (!!selectedCardId && !!card?.dataset?.cardId && selectedCardId === card.dataset.cardId);
		if (isSameCard && !forceDrag) {
			cancelDesktopHoverDragKeepSelection({ showPreview: false });
			// Clear any selected styling (DOM can be re-rendered, so be defensive).
			document.querySelectorAll('.card-option.selected').forEach(el => el.classList.remove('selected'));
			selectedCardId = null;
			selectedCardElement = null;
			selectedShape = null;
			selectedColor = null;
			if (rotateButton) rotateButton.disabled = true;
			if (mirrorButton) mirrorButton.disabled = true;
			if (draggedBlock) cleanupDragState({ clearBonus: false });
			hideFloatingPreview();
			removeCardControlButtons();
			// UX: deselecting a card should also exit zoomed-in view.
			closeZoom();
			applyTurnCardLocks();
			// Voorkom dat een snelle tweede klik direct weer selecteert
			suppressCardSelectUntil = Date.now() + 500;
			return;
		}
		// For any other selection, always allow switching to a new card immediately.
		// If we are starting a drag from the currently selected card, remove the old drag
		// block without clearing the card selection.
		if (isSameCard && forceDrag && draggedBlock) {
			const overlay = document.getElementById('drag-overlay');
			try { draggedBlock.remove(); } catch {}
			draggedBlock = null;
			draggedShape = null;
			draggedColor = null;
			lastZone = null;
			lastBaseX = lastBaseY = null;
			endPointerDragTracking();
			if (overlay) overlay.style.display = 'none';
			document.body.classList.remove('dragging');
			document.body.style.cursor = '';
			document.documentElement.style.cursor = '';
			stopGlobalDragVisuals();
			removeCardControlButtons();
		}
		if (draggedBlock) cleanupDragState({ clearBonus: false });
		document.querySelectorAll('.card-option').forEach(c => c.classList.remove('selected'));
		removeCardControlButtons();
		card.classList.add('selected');
		const cardData = card.cardData;
		// Use the normalized/padded shape stored on the card first; fallback to raw matrix.
		const currentShape = card.cardShape || cardData?.matrix || shape;
		const currentColor = cardData?.color || card.cardColor || color;
		selectedCardId = card.dataset.cardId || null;
		selectedCardElement = card;
		selectedShape = currentShape;
		selectedColor = currentColor;
		if (rotateButton) rotateButton.disabled = false;
		if (mirrorButton) mirrorButton.disabled = false;
		try {
			document.dispatchEvent(new CustomEvent('locus:tutorial-card-selected', { detail: { element: card, cardData } }));
		} catch (_) {}
		// Keep cards switchable; only apply turn-based locks (golden vs normal) + playability.
		applyTurnCardLocks();

		// Desktop mouse UX: click-to-pickup (hover follow) without option buttons.
		// Touch UX: selection doesn't spawn a loose draggable copy; touch uses drag or floating preview.
		if (!shouldSpawnBlock) {
			if (isMobileLayout) {
				autoZoomToColorZone(currentColor);
				// Mobile: toon floating preview + control buttons
				showFloatingPreview(currentShape, currentColor);
				addCardControlButtons();
			} else if (isTouchDevice) {
				// Large-screen touch devices (iPad): floating preview + control buttons voor draaien/spiegelen
				showFloatingPreview(currentShape, currentColor);
				addCardControlButtons();
			} else {
				startDesktopHoverDragFromSelection(card, currentShape, currentColor);
			}
			// Keep UI consistent: ensure controls can be used right after selecting.
			if (rotateButton) rotateButton.disabled = false;
			if (mirrorButton) mirrorButton.disabled = false;
			return;
		}

	// Auto-zoom naar de juiste zone op basis van kleur (altijd op mobiel)
	if (isMobileLayout) {
		autoZoomToColorZone(currentColor);
	}

	// Maak het blok direct draggable vanaf de kaart positie
	const block = makeDraggable(currentShape, currentColor);
	const rect = card.getBoundingClientRect();
	const hasPointerPos = Number.isFinite(options.clientX) && Number.isFinite(options.clientY);
	const m = getDragBlockCellMetrics(block);
	const centerOffsets = computeShapeCenterOffsets(currentShape, m);

	if (forceDrag && hasPointerPos) {
		// Force-drag: start at pointer position (mouse or touch long-press).
		offsetX = centerOffsets.offsetX;
		offsetY = centerOffsets.offsetY;
		const touchOffsetY = getFingerLiftOffsetY(options);
		setElPos(block, options.clientX - offsetX, options.clientY - offsetY - touchOffsetY);
		const overlay = document.getElementById('drag-overlay');
		if (overlay && !overlay.contains(block)) {
			overlay.appendChild(block);
			overlay.style.display = 'block';
		}
	} else if (isMobileLayout) {
		offsetX = centerOffsets.offsetX;
		offsetY = centerOffsets.offsetY;
		const touchOffsetY = getFingerLiftOffsetY(options);
		let startX = rect.left + (rect.width / 2);
		let startY = rect.top + (rect.height / 2);
		if (hasPointerPos) {
			startX = options.clientX;
			startY = options.clientY;
		}
		setElPos(block, startX - offsetX, startY - offsetY - touchOffsetY);
		// Show the draggable immediately on touch (no need to lift finger first).
		if (isTouchDevice) {
			const overlay = document.getElementById('drag-overlay');
			if (overlay && !overlay.contains(block)) {
				overlay.appendChild(block);
				overlay.style.display = 'block';
			}
		}
	} else {
		setElPos(block, rect.left, rect.top);
		offsetX = 0;
		offsetY = 0;
	}

	draggedBlock = block;
	resetDragBlockGap();
	draggedShape = block._shape || selectedShape;
	draggedColor = selectedColor;
	lastZone = null;
	lastBaseX = lastBaseY = null;
	if (forceDrag) {
		beginPointerDrag({
			clientX: hasPointerPos ? options.clientX : (rect.left + rect.width / 2),
			clientY: hasPointerPos ? options.clientY : (rect.top + rect.height / 2),
			pointerId: options.pointerId || null
		});
		startGlobalDragVisuals();
	}

	// Voor touch devices op mobiel: toon direct transform buttons bij het blok
	if (isTouchDevice && isCoarsePointer()) {
		addCardControlButtons();
	}
}

// EN:
// - FIX: When a dragged block is active, it can sit on top of the card UI and
//   â€œeatâ€ the click, so clicking the same selected card won't toggle/cancel.
//   This capture-phase handler peeks *under* the dragged block and cancels
//   if the user clicked the currently selected card.
document.addEventListener('pointerdown', ev => {
	if (!draggedBlock) return;
	if (ev.button !== 0) return;

	// Prefer desktop/mouse behavior; on touch devices users already have a cancel button.
	const isTouchDevice = ('ontouchstart' in window || navigator.maxTouchPoints > 0);
	if (isTouchDevice) return;

	const x = ev.clientX;
	const y = ev.clientY;

	const prevPointerEvents = draggedBlock.style.pointerEvents;
	draggedBlock.style.pointerEvents = 'none';
	const underlying = document.elementFromPoint(x, y);
	draggedBlock.style.pointerEvents = prevPointerEvents || '';

	const clickedCard = underlying ? underlying.closest('.card-option') : null;
	if (!clickedCard) return;

	// Clicking a card should always clear the sticky block.
	// If it's the currently selected card, toggle it off (deselect).
	if (selectedCardElement && clickedCard === selectedCardElement) {
		ev.preventDefault();
		ev.stopPropagation();
		cleanupDragState({ clearBonus: false, hidePreview: true });
		selectCard(clickedCard);
		return;
	}

	// Other card: clear the block but allow the click to continue so the new card selects.
	cleanupDragState({ clearBonus: false, hidePreview: true });
}, true);
	// Whether the touch control buttons should be visible right now.
	// Keep this conservative to avoid buttons getting "stuck" on-screen.
	function shouldShowCardControlButtons() {
		try {
			if (desktopHoverDragActive) return false;
			// Bonus placement active (dragging a bonus block)
			if (activeBonusPlacement) return true;
			// Dragging any block
			if (draggedBlock) return true;
			// Floating preview is active (touch flow)
			if (typeof floatingPreviewActive !== 'undefined' && floatingPreviewActive) return true;
			// A card is selected (card-pick flow)
			if (selectedCardElement && selectedShape && selectedColor) return true;
		} catch (e) {}
		return false;
	}
	try { window.__locusShouldShowCardControlButtons = shouldShowCardControlButtons; } catch (e) {}

	function addCardControlButtons() {
		const isMobileLayout = window.innerWidth <= MOBILE_BREAKPOINT;
		const isTouchDevice = ('ontouchstart' in window || navigator.maxTouchPoints > 0);
		// Desktop mouse UX: no on-card option buttons.
		if (!isMobileLayout && !isTouchDevice) return;
		if (desktopHoverDragActive) return;
		// Skip control buttons for purchased placement (1x1 block doesn't need rotate/mirror)
		if (activeBonusPlacement && activeBonusPlacement.purchasedPlacement) {
			removeCardControlButtons();
			return;
		}
		// If nothing is currently selected/dragging, ensure controls are hidden.
		if (!shouldShowCardControlButtons()) {
			removeCardControlButtons();
			return;
		}

		// If this is a bonus draggable (or we have an activeBonusPlacement), do not show mirror button
		const isBonusDrag = !!( (draggedBlock && draggedBlock.classList && draggedBlock.classList.contains('bonus-draggable')) || (activeBonusPlacement && activeBonusPlacement.colorKey) );
		
		// Check of buttons al bestaan
		let rotateBtn = document.querySelector('.card-control-rotate');
		let mirrorBtn = document.querySelector('.card-control-mirror');
		let cancelBtn = document.querySelector('.card-control-cancel');
		
		if (!rotateBtn) {
			// Maak rotate button
			rotateBtn = document.createElement('button');
			rotateBtn.className = 'card-control-btn card-control-rotate';
			rotateBtn.innerHTML = 'â†»';
			rotateBtn.title = 'Draai blok';
			rotateBtn.setAttribute('aria-label', 'Draai blok');
			
			const handleRotate = (e) => {
				e.preventDefault();
				e.stopPropagation();
				e.stopImmediatePropagation();
				rotateSelectedCard();
			};
			
			rotateBtn.addEventListener('click', handleRotate);
			rotateBtn.addEventListener('touchend', handleRotate);
			rotateBtn.addEventListener('mousedown', (e) => {
				e.preventDefault();
				e.stopPropagation();
				e.stopImmediatePropagation();
			});
			rotateBtn.addEventListener('touchstart', (e) => {
				e.preventDefault();
				e.stopPropagation();
				e.stopImmediatePropagation();
			});
			rotateBtn.addEventListener('pointerdown', (e) => {
				e.preventDefault();
				e.stopPropagation();
				e.stopImmediatePropagation();
			});
			document.body.appendChild(rotateBtn);
		}
		
		if (!mirrorBtn) {
			// Maak mirror button
			mirrorBtn = document.createElement('button');
			mirrorBtn.className = 'card-control-btn card-control-mirror';
			mirrorBtn.innerHTML = 'â‡„';
			mirrorBtn.title = 'Spiegel blok';
			mirrorBtn.setAttribute('aria-label', 'Spiegel blok');
			
			const handleMirror = (e) => {
				e.preventDefault();
				e.stopPropagation();
				e.stopImmediatePropagation();
				mirrorSelectedCard();
			};
			
			mirrorBtn.addEventListener('click', handleMirror);
			mirrorBtn.addEventListener('touchend', handleMirror);
			mirrorBtn.addEventListener('mousedown', (e) => {
				e.preventDefault();
				e.stopPropagation();
				e.stopImmediatePropagation();
			});
			mirrorBtn.addEventListener('touchstart', (e) => {
				e.preventDefault();
				e.stopPropagation();
				e.stopImmediatePropagation();
			});
			mirrorBtn.addEventListener('pointerdown', (e) => {
				e.preventDefault();
				e.stopPropagation();
				e.stopImmediatePropagation();
			});
			document.body.appendChild(mirrorBtn);
		}
		
		if (!cancelBtn) {
			// Maak cancel button
			cancelBtn = document.createElement('button');
			cancelBtn.className = 'card-control-btn card-control-cancel';
			cancelBtn.innerHTML = 'Ã—';
			cancelBtn.title = 'Annuleer selectie';
			cancelBtn.setAttribute('aria-label', 'Annuleer selectie');
			
			const handleCancel = (e) => {
				e.preventDefault();
				e.stopPropagation();
				e.stopImmediatePropagation();
				// Verwijder het gedraaide tetris blok
				if (draggedBlock) {
					try { draggedBlock.remove(); } catch {}
					draggedBlock = null;
					draggedShape = null;
					draggedColor = null;
				}
				if (activeBonusPlacement) {
					cancelActiveBonusPlacement({ hidePreview: true });
				} else if (selectedCardElement) {
					selectCard(selectedCardElement); // Toggle off
				}
				hideFloatingPreview();
				closeZoom();
				removeCardControlButtons();
			};
			
			cancelBtn.addEventListener('click', handleCancel);
			cancelBtn.addEventListener('touchend', handleCancel);
			cancelBtn.addEventListener('mousedown', (e) => {
				e.preventDefault();
				e.stopPropagation();
				e.stopImmediatePropagation();
			});
			cancelBtn.addEventListener('touchstart', (e) => {
				e.preventDefault();
				e.stopPropagation();
				e.stopImmediatePropagation();
			});
			cancelBtn.addEventListener('pointerdown', (e) => {
				e.preventDefault();
				e.stopPropagation();
				e.stopImmediatePropagation();
			});
			document.body.appendChild(cancelBtn);
		}
		
				// Maak buttons zichtbaar. For touch-initiated bonus drags we may delay
				// the mirror button until release (activeBonusPlacement.delayedControls).
				rotateBtn.classList.add('visible');
				cancelBtn.classList.add('visible');
				const isDelayingMirror = !!(activeBonusPlacement && activeBonusPlacement.delayedControls && isTouchDevice);
				const showMirror = !isBonusDrag && !isDelayingMirror;
				if (showMirror) {
					mirrorBtn.classList.add('visible');
					mirrorBtn.disabled = false;
					mirrorBtn.style.display = '';
					try { delete mirrorBtn.dataset.delayed; } catch (e) { mirrorBtn.dataset.delayed = ''; }
				} else {
					// Keep mirror hidden and disabled until later (or for bonus drags)
					mirrorBtn.classList.remove('visible');
					mirrorBtn.disabled = true;
					mirrorBtn.style.display = 'none';
					mirrorBtn.dataset.delayed = isDelayingMirror ? 'true' : '';
				}

		// Position buttons for touch devices:
		if (isTouchDevice) {
			// Always pin controls bottom-center on touch to avoid overlap/jumble and
			// to keep the draggable easy to pick up after rotate/release.
			const clampX = (x, w=44) => Math.max(8, Math.min((window.innerWidth - (w + 8)), Math.round(x)));
			const applyDynamicPos = (btn) => {
				if (!btn) return;
				btn.classList.add('dynamic-pos');
				btn.style.right = 'auto';
				btn.style.marginLeft = '0px';
				btn.style.top = 'auto';
			};
			const clearDynamicPos = (btn) => {
				if (!btn) return;
				btn.classList.remove('dynamic-pos');
				btn.style.removeProperty('right');
				btn.style.removeProperty('margin-left');
			};

			const centerX = Math.round(window.innerWidth / 2);
			const rootStyle = getComputedStyle(document.documentElement);
			const bottomBarHeight = parseFloat(rootStyle.getPropertyValue('--bottom-bar-height'));
			const fallbackBottomBarHeight = parseFloat(rootStyle.getPropertyValue('--bottom-height'));
			const effectiveBottomBarHeight = Number.isFinite(bottomBarHeight)
				? bottomBarHeight
				: (Number.isFinite(fallbackBottomBarHeight) ? fallbackBottomBarHeight : 70);
			const viewportH = Math.round((window.visualViewport && window.visualViewport.height) ? window.visualViewport.height : window.innerHeight);
			const isSmallViewport = viewportH <= 720 || window.innerWidth <= 380;
			const isZoomedIn = document.body.classList.contains('zoomed-in');
			const bottomPx = (isZoomedIn && isSmallViewport)
				? Math.max(2, Math.round(effectiveBottomBarHeight - 24))
				: Math.round(effectiveBottomBarHeight + 10);
			const bottomVal = `${bottomPx}px`;
			// Fixed order so buttons never â€œswapâ€: cancel, rotate, mirror
			const visibleBtns = [];
			if (cancelBtn) visibleBtns.push(cancelBtn);
			if (rotateBtn) visibleBtns.push(rotateBtn);
			if (mirrorBtn && mirrorBtn.classList.contains('visible') && !mirrorBtn.dataset.delayed) visibleBtns.push(mirrorBtn);

			[rotateBtn, mirrorBtn, cancelBtn].forEach(btn => {
				if (!btn) return;
				if (visibleBtns.includes(btn)) applyDynamicPos(btn);
				else clearDynamicPos(btn);
			});

			const count = visibleBtns.length || 1;
			const spacing = 64;
			const startX = centerX - spacing * (count - 1) / 2;
			for (let i = 0; i < count; i++) {
				const btn = visibleBtns[i];
				if (!btn) continue;
				btn.style.left = clampX((startX + i * spacing) - 22) + 'px';
				btn.style.bottom = bottomVal;
				btn.style.top = 'auto';
			}
		}
	}

	function removeCardControlButtons() {
		// Verberg alle card control buttons
			const buttons = document.querySelectorAll('.card-control-btn');
			buttons.forEach(btn => {
				btn.classList.remove('visible');
				btn.classList.remove('dynamic-pos');
				// Clear any inline positioning applied for touch mode so CSS can take over again.
				btn.style.removeProperty('left');
				btn.style.removeProperty('top');
				btn.style.removeProperty('bottom');
				btn.style.removeProperty('right');
				btn.style.removeProperty('margin-left');
			});
	}

	// After releasing a drag (touch/pointer), re-show/reposition the touch controls
	// at the bottom, without affecting gameplay state.
	(function installCardControlRepositionHook(){
		if (window.__locusCardControlRepositionHookInstalled) return;
		window.__locusCardControlRepositionHookInstalled = true;
		function repositionSoon(){
			try {
				setTimeout(function(){
					try {
						const shouldShow = (typeof window.__locusShouldShowCardControlButtons === 'function')
							? window.__locusShouldShowCardControlButtons()
							: false;
						if (shouldShow) {
							addCardControlButtons();
						} else {
							removeCardControlButtons();
						}
					} catch (e) {}
					try {
						document.querySelectorAll('.card-control-btn').forEach(btn => {
							btn.style.transform = '';
						});
					} catch (e) {}
				}, 60);
			} catch (e) {}
		}
		['touchend','pointerup','mouseup','touchcancel'].forEach(ev => {
			document.addEventListener(ev, repositionSoon, { passive: true });
		});
	})();

	// PHASE 3 REFACTOR: Helper function to rotate draggedBlock while preserving visual center
	// BUG FIX: Also recompute offsetX/offsetY so drag positioning stays correct
	// MOBILE FIX: Use actual rendered block size for accurate offsets
	function rotateDraggedBlockInPlace(newShape, color) {
		if (!draggedBlock) return;
		try {
			// Get current position BEFORE any changes
			const beforeRect = draggedBlock.getBoundingClientRect();
			const centerX = beforeRect.left + beforeRect.width / 2;
			const centerY = beforeRect.top + beforeRect.height / 2;
			
			const nextShape = cloneShape(newShape);
			draggedShape = nextShape;
			draggedBlock._shape = nextShape;
			
			// Render the new shape
			renderBlock(draggedBlock, nextShape, color);
			
			// Force layout recalculation
			draggedBlock.offsetHeight;
			
			const afterRect = draggedBlock.getBoundingClientRect();
			
			// Calculate new position to keep the visual center stable
			if (Number.isFinite(centerX) && Number.isFinite(centerY) && afterRect.width > 0 && afterRect.height > 0) {
				const newLeft = centerX - afterRect.width / 2;
				const newTop = centerY - afterRect.height / 2;
				// Use setElPos which handles transform-based positioning correctly
				setElPos(draggedBlock, newLeft, newTop);
			}
			
			draggedBlock.style.opacity = '1';
			draggedBlock.style.visibility = '';
			if (!draggedBlock.style.position) draggedBlock.style.position = 'fixed';
			draggedBlock.style.zIndex = draggedBlock.style.zIndex || '10000';
			const overlay = document.getElementById('drag-overlay');
			if (overlay) {
				if (!overlay.contains(draggedBlock)) overlay.appendChild(draggedBlock);
				overlay.style.display = 'block';
			}
			// CRITICAL: Recompute center offsets so drag positioning matches the rotated shape
			// Use the actual rendered size for accurate positioning
			const m = getDragBlockCellMetrics(draggedBlock);
			({ offsetX, offsetY } = computeShapeCenterOffsets(nextShape, m));
		} catch (e) {
			const nextShape = cloneShape(newShape);
			draggedShape = nextShape;
			draggedBlock._shape = nextShape;
			renderBlock(draggedBlock, nextShape, color);
			// Also recompute in fallback path
			try {
				const mFallback = getDragBlockCellMetrics(draggedBlock);
				({ offsetX, offsetY } = computeShapeCenterOffsets(nextShape, mFallback));
			} catch (e2) {}
		}
	}

	function rotateSelectedCard() {
	  if (activeBonusPlacement) {
		// Roteer de shape in activeBonusPlacement
		const currentShape = selectedShape || draggedShape;
		if (!currentShape) return;
		const newShape = rotateShape(currentShape);
		selectedShape = newShape;
		activeBonusPlacement.shape = cloneShape(newShape);
		if (draggedBlock) {
			rotateDraggedBlockInPlace(newShape, draggedColor || selectedColor);
			try { addCardControlButtons(); } catch (e) {}
		} else if (draggedShape) {
			draggedShape = cloneShape(newShape);
		}
		if (floatingPreviewActive) updateFloatingPreview(newShape, draggedColor || selectedColor);
		if (lastZone) {
		  clearPreview(lastZone);
		  lastBaseX = null;
		  lastBaseY = null;
		}
		return;
	  }
	  if (!selectedShape || !selectedColor) return;
	  const selectedCard = selectedCardElement || document.querySelector('.card-option.selected');
	  if (!selectedCard) return;
	  const newShape = rotateShape(selectedShape);
	  selectedShape = newShape;
	  const cardData = selectedCard.cardData;
	  if (cardData) cardData.matrix = newShape;
	  selectedCard.cardShape = newShape;
	  const cardColor = cardData?.color || selectedCard.cardColor || selectedColor;
	  selectedCard.cardColor = cardColor;
	  updateCardPattern(selectedCard, newShape, cardColor);
	  applyCardSizing();
	  
	  // Update floating preview direct met nieuwe shape
	  if (floatingPreviewActive) {
		updateFloatingPreview(selectedShape, selectedColor);
	  }
	  
	// If a draggable block exists (e.g. sticky preview), always keep it in sync.
	if (draggedBlock) {
		rotateDraggedBlockInPlace(newShape, draggedColor || selectedColor);
		// Clear preview since shape changed
		if (lastZone) {
			clearPreview(lastZone);
			lastBaseX = null;
			lastBaseY = null;
		}
	}
	}

	function mirrorSelectedCard() {
		// If controls were deliberately delayed for a touch-initiated bonus drag,
		// ignore mirror actions until the controls are revealed on release.
		if (activeBonusPlacement && activeBonusPlacement.delayedControls) return;

		if (activeBonusPlacement) {
		// Spiegel de shape in activeBonusPlacement
		const currentShape = selectedShape || draggedShape;
		if (!currentShape) return;
		const newShape = mirrorShape(currentShape);
		selectedShape = newShape;
		activeBonusPlacement.shape = cloneShape(newShape);
		if (draggedBlock) {
			const nextShape = cloneShape(newShape);
			draggedShape = nextShape;
			draggedBlock._shape = nextShape;
			try { liftToBody(draggedBlock); } catch (e) {}
			renderBlock(draggedBlock, nextShape, draggedColor || selectedColor);
		} else if (draggedShape) {
			draggedShape = cloneShape(newShape);
		}
		if (floatingPreviewActive) updateFloatingPreview(newShape, draggedColor || selectedColor);
		if (lastZone) {
		  clearPreview(lastZone);
		  lastBaseX = null;
		  lastBaseY = null;
		}
		return;
	  }
	  if (!selectedShape || !selectedColor) return;
	  const selectedCard = selectedCardElement || document.querySelector('.card-option.selected');
	  if (!selectedCard) return;
	  const newShape = mirrorShape(selectedShape);
	  selectedShape = newShape;
	  const cardData = selectedCard.cardData;
	  if (cardData) cardData.matrix = newShape;
	  selectedCard.cardShape = newShape;
	  const cardColor = cardData?.color || selectedCard.cardColor || selectedColor;
	  selectedCard.cardColor = cardColor;
	  updateCardPattern(selectedCard, newShape, cardColor);
	  applyCardSizing();
	  
	  // Update floating preview direct met nieuwe shape
	  if (floatingPreviewActive) {
		updateFloatingPreview(selectedShape, selectedColor);
	  }
	  
	  if (draggedBlock) {
		rotateDraggedBlockInPlace(newShape, draggedColor || selectedColor);
		if (lastZone) {
			clearPreview(lastZone);
			lastBaseX = null;
			lastBaseY = null;
		}
	  }
}

// Helper functie om beide shape manipulation buttons te enablen/disablen
function setShapeButtonsEnabled(enabled) {
  if (rotateButton) rotateButton.disabled = !enabled;
  if (mirrorButton) mirrorButton.disabled = !enabled;
}

// ========================================
// FLOATING PREVIEW VOOR TOUCH DEVICES
// ========================================

function showFloatingPreview(shape, color, options = {}) {
		const preview = document.getElementById('floating-preview');
		if (!preview) return;

		const isNarrowMobile = window.innerWidth <= 650;
		const isBonusPreview = !!(activeBonusPlacement || options.useDefaultPosition);
		// Phone UX: the floating preview box is redundant (card already shows the shape) and
		// looks bad when it can't align perfectly with the card. Keep it only for bonus placement.
		if (isNarrowMobile && !isBonusPreview) {
			hideFloatingPreview();
			return;
		}

		floatingPreviewActive = true;
		updateFloatingPreview(shape, color);
		preview.style.display = 'flex';

		// Hide mirror control for bonus previews (we don't allow mirroring bonus blocks)
		try {
			const mirrorBtnEl = document.getElementById('floating-preview-mirror');
			if (mirrorBtnEl) {
				if (isBonusPreview) {
					mirrorBtnEl.style.display = 'none';
				} else {
					mirrorBtnEl.style.display = '';
				}
			}
		} catch (e) {}

		const shouldPinAboveBottomBar = (window.innerWidth <= 650) || document.body.classList.contains('zoomed-in');
		const baseTransform = (isBonusPreview || shouldPinAboveBottomBar) ? 'translate(-50%, 0)' : 'none';
		const targetScale = isBonusPreview ? 0.55 : 1;
		const startScale = isBonusPreview ? 0.48 : 0.85;
		preview.dataset.baseTransform = baseTransform;

		const rootStyle = getComputedStyle(document.documentElement);
		const bottomBarHeight = parseFloat(rootStyle.getPropertyValue('--bottom-bar-height'));
		const fallbackBottomBarHeight = parseFloat(rootStyle.getPropertyValue('--bottom-height'));
		const effectiveBottomBarHeight = Number.isFinite(bottomBarHeight)
			? bottomBarHeight
			: (Number.isFinite(fallbackBottomBarHeight) ? fallbackBottomBarHeight : 150);

		// Positioneer preview: boven de bottom bar (mobiel/zoom), anders op kaart positie (tenzij bonus placement)
		if (shouldPinAboveBottomBar) {
			// Zet de preview net boven de bottom bar zodat rotate/mirror/cancel niet over de zoomed zone vallen.
			preview.style.top = 'auto';
			preview.style.left = '50%';
			preview.style.right = 'auto';
			const viewportH = Math.round((window.visualViewport && window.visualViewport.height) ? window.visualViewport.height : window.innerHeight);
			const isVerySmall = viewportH <= 700 || window.innerWidth <= 380;
			const isSmall = viewportH <= 780 || window.innerWidth <= 420;
			const extraDrop = isVerySmall ? 60 : (isSmall ? 36 : 6);
			const bottomOffset = Math.max(6, Math.round(effectiveBottomBarHeight - extraDrop));
			preview.style.bottom = `${bottomOffset}px`;
		} else if (isBonusPreview) {
			// Bonus: klein en onderin, gecentreerd
			preview.style.top = 'auto';
			preview.style.left = '50%';
			preview.style.bottom = '22px';
			preview.style.right = 'auto';
		} else if (selectedCardElement) {
			// Kaart selectie: positioneer op de kaart
			const cardRect = selectedCardElement.getBoundingClientRect();
			preview.style.left = `${cardRect.left + (cardRect.width / 2) - 69}px`; // 69 = halve breedte preview
			preview.style.top = `${cardRect.top + (cardRect.height / 2) - 90}px`; // 90 = halve hoogte preview
			preview.style.bottom = 'auto';
			preview.style.right = 'auto';
		}

		preview.style.transform = `${baseTransform} scale(${startScale})`;
		preview.style.opacity = '0.9';

		// Animeer in
		setTimeout(() => {
			preview.style.transform = `${baseTransform} scale(${targetScale})`;
			preview.style.opacity = '1';
		}, 10);
	}

	function hideFloatingPreview() {
		const preview = document.getElementById('floating-preview');
		if (!preview) return;

		floatingPreviewActive = false;
		preview.style.display = 'none';
		const baseTransform = preview.dataset.baseTransform || 'none';
		preview.style.transform = `${baseTransform} scale(0.8)`;
		preview.style.opacity = '0';
	}

	function updateFloatingPreview(shape, color) {
		const patternContainer = document.getElementById('floating-preview-pattern');
		if (!patternContainer) return;

		// Clear oude pattern
		patternContainer.innerHTML = '';

		// Bereken cell size: als we gezoomd zijn of dit een bonus-preview is,
		// meet de werkelijke celgrootte uit de actieve zoomzone en gebruik die
		// zodat de preview overeenkomt met wat de gebruiker ziet op het bord.
		const rows = shape.length;
		const cols = shape[0].length;
		let cellSize = 0;
		let gapPx = 2;
		try {
			if (document.body.classList.contains('zoomed-in') && typeof activeZoomZone !== 'undefined' && activeZoomZone) {
				cellSize = Math.round(getActualCellSize(activeZoomZone));
				const metrics = getBoardCellMetrics();
				gapPx = metrics.gap || 2;
			}
		} catch (e) {
			cellSize = 0;
		}

		// Fallback: keep the old small container-based sizing when not zoomed
		if (!cellSize || !Number.isFinite(cellSize) || cellSize <= 8) {
			const maxDim = Math.max(rows, cols);
			const containerSize = 76; // 100px - 24px padding
			cellSize = Math.max(8, Math.floor(containerSize / maxDim) - 2);
			gapPx = 2;
		}

		// Maak grid voor het pattern
		const grid = document.createElement('div');
		grid.style.display = 'grid';
		grid.style.gap = `${gapPx}px`;
		grid.style.gridTemplateColumns = `repeat(${cols}, ${cellSize}px)`;
		grid.style.gridTemplateRows = `repeat(${rows}, ${cellSize}px)`;

		// Haal color code op (kan object of string zijn)
		const colorCode = (typeof color === 'object' && color.code) ? color.code : color;
		const colorName = (typeof color === 'object' && color.name) ? color.name : '';
		// BUG FIX: Multikleur moet rainbow gradient tonen in floating preview
		const isMultikleur = colorName === 'multikleur' || colorCode === 'rainbow';
		const fillStyle = isMultikleur
			? 'linear-gradient(45deg, #f06272, #fff25a, #4ed346, #5d90f0, #a35eff)'
			: colorCode;

		// Render cellen
		shape.forEach((row, y) => {
			row.forEach((val, x) => {
				const cell = document.createElement('div');
				cell.style.width = `${cellSize}px`;
				cell.style.height = `${cellSize}px`;
				cell.style.borderRadius = '3px';
				
				if (val === 1) {
					cell.style.background = fillStyle;
					cell.style.border = '1px solid rgba(0,0,0,0.2)';
					cell.style.boxShadow = '0 1px 3px rgba(0,0,0,0.2)';
				} else {
					cell.style.background = 'transparent';
				}
				
				grid.appendChild(cell);
			});
		});

		patternContainer.appendChild(grid);
	}

	// ========================================
	// ZOOM-LENS VOOR PLAATSING PREVIEW
	// ========================================
	
	function showZoomLens(x, y, zone, baseX, baseY, shape, color, isValid) {
		const lens = document.getElementById('placement-zoom-lens');
		if (!lens) return;
		
		// Bepaal welk grid we moeten tonen
		let targetZone = zone;
		
		// Als er een actieve zoom zone is, gebruik die (tenzij het een rood subgrid is)
		if (activeZoomZone) {
			if (activeZoomZone.id === 'red-zone') {
				// Als we in de red-zone zitten, gebruik het specifieke subgrid
				if (zone && zone.dataset && zone.dataset.subgrid) {
					targetZone = zone; // Gebruik het specifieke rood subgrid
				} else {
					targetZone = activeZoomZone; // Fallback naar parent
				}
			} else {
				// Voor andere zones: gebruik de actieve gezoomde zone
				targetZone = activeZoomZone;
			}
		}
		// Als geen activeZoomZone: gewoon het huidige zone gebruiken
		
		// Positioneer lens links van touch punt (zodat vinger niet in de weg zit)
		const lensWidth = 160;
		const lensHeight = 160;
		const offset = 20; // Extra marge
		
		// Probeer eerst links van de vinger
		let lensX = x - lensWidth - offset;
		let lensY = y - (lensHeight / 2); // Verticaal gecentreerd op touch punt
		
		// Als niet genoeg ruimte links, probeer rechts
		if (lensX < 10) {
			lensX = x + offset;
		}
		
		// Als nog steeds niet past, force links met minimum marge
		if (lensX + lensWidth > window.innerWidth - 10) {
			lensX = Math.max(10, x - lensWidth - offset);
		}

		// Voorkom dat lens verticaal buiten scherm gaat
		lensY = Math.max(10, Math.min(window.innerHeight - lensHeight - 10, lensY));

		lens.style.left = `${lensX}px`;
		lens.style.top = `${lensY}px`;
		lens.style.display = 'block';
		lens.style.opacity = '1';

		// Render de zoom inhoud met de juiste zone
		updateZoomLensContent(targetZone, baseX, baseY, shape, color, isValid);
	}

	function hideZoomLens() {
		const lens = document.getElementById('placement-zoom-lens');
		if (!lens) return;
		lens.style.display = 'none';
		lens.style.opacity = '0';
	}

	function updateZoomLensContent(zone, baseX, baseY, shape, color, isValid) {
		const content = document.getElementById('zoom-lens-content');
		if (!content) return;

		content.innerHTML = '';

		// Vind het grid element
		let targetGrid = zone;
		if (zone.dataset && zone.dataset.subgrid) {
			// Dit is een rood subgrid
			targetGrid = zone;
		} else if (zone.classList.contains('grid')) {
			targetGrid = zone;
		} else {
			// Zoek .grid binnen de zone
			const gridChild = zone.querySelector('.grid');
			if (gridChild) targetGrid = gridChild;
		}

		// Bereken het gebied dat we moeten tonen (shape gebied + kleine marge)
		const shapeRows = shape.length;
		const shapeCols = shape[0].length;
		const margin = 1;
		
		const viewStartX = Math.max(0, baseX - margin);
		const viewStartY = Math.max(0, baseY - margin);
		const viewEndX = baseX + shapeCols + margin;
		const viewEndY = baseY + shapeRows + margin;

		// Get een sample cell om de grootte te bepalen
		const sampleCell = targetGrid.querySelector('.cell:not(.void-cell)');
		if (!sampleCell) {
			content.innerHTML = '<div style="padding: 20px; text-align: center; color: #999; font-size: 11px;">Wachten...</div>';
			return;
		}
		
		const cellRect = sampleCell.getBoundingClientRect();
		const cellSize = cellRect.width;

		// Maak een nieuwe container voor de lens inhoud
		const lensContainer = document.createElement('div');
		lensContainer.style.position = 'relative';
		lensContainer.style.width = `${(viewEndX - viewStartX) * cellSize}px`;
		lensContainer.style.height = `${(viewEndY - viewStartY) * cellSize}px`;
		lensContainer.style.margin = 'auto';
		
		// Get alle cellen in het target grid
		const allCells = targetGrid.querySelectorAll('.cell');
		const colorCode = (typeof color === 'object' && color.code) ? color.code : color;
		const colorName = (typeof color === 'object' && color.name) ? color.name : 'unknown';
		
		let visibleCount = 0;
		
		allCells.forEach(cell => {
			const cellX = parseInt(cell.dataset.x, 10);
			const cellY = parseInt(cell.dataset.y, 10);
			
			// Skip cellen buiten ons view gebied of void cells
			if (isNaN(cellX) || isNaN(cellY) ||
			    cellX < viewStartX || cellX >= viewEndX ||
			    cellY < viewStartY || cellY >= viewEndY ||
			    cell.classList.contains('void-cell')) {
				return;
			}
			
			visibleCount++;
			
			// Clone de cel voor in de lens
			const cellClone = cell.cloneNode(true);
			cellClone.style.position = 'absolute';
			cellClone.style.left = `${(cellX - viewStartX) * cellSize}px`;
			cellClone.style.top = `${(cellY - viewStartY) * cellSize}px`;
			cellClone.style.width = `${cellSize}px`;
			cellClone.style.height = `${cellSize}px`;
			cellClone.style.boxSizing = 'border-box';
			
			// Check of deze cel deel uitmaakt van de te plaatsen shape
			const shapeRelX = cellX - baseX;
			const shapeRelY = cellY - baseY;
			const isInShape = shapeRelY >= 0 && shapeRelY < shapeRows &&
			                  shapeRelX >= 0 && shapeRelX < shapeCols &&
			                  shape[shapeRelY][shapeRelX] === 1;

			if (isInShape) {
				// Voeg preview overlay toe - dit is de tetris block preview
				const overlay = document.createElement('div');
				overlay.style.position = 'absolute';
				overlay.style.inset = '3px'; // Kleine marge binnen de cel
				overlay.style.pointerEvents = 'none';
				overlay.style.zIndex = '10';
				overlay.style.borderRadius = '3px';
				
				if (isValid) {
					// Groene rand voor geldige plaatsing
					if (colorName === 'multikleur') {
						overlay.style.background = 'linear-gradient(135deg, rgba(240,98,114,0.8), rgba(255,242,90,0.8), rgba(78,211,70,0.8), rgba(93,144,240,0.8), rgba(163,94,255,0.8))';
					} else {
						overlay.style.backgroundColor = colorCode;
						overlay.style.opacity = '0.7';
					}
					overlay.style.border = '3px solid #4CAF50';
					overlay.style.boxShadow = '0 0 8px rgba(76, 175, 80, 1), inset 0 0 6px rgba(255,255,255,0.5)';
				} else {
					// Rode rand voor ongeldige plaatsing
					overlay.style.backgroundColor = '#ff5252';
					overlay.style.opacity = '0.65';
					overlay.style.border = '3px solid #f44336';
					overlay.style.boxShadow = '0 0 8px rgba(244, 67, 54, 1)';
				}
				
				cellClone.appendChild(overlay);
			}
			
			lensContainer.appendChild(cellClone);
		});

		if (visibleCount === 0) {
			content.innerHTML = '<div style="padding: 20px; text-align: center; color: #999; font-size: 11px;">Geen cellen</div>';
			return;
		}

		// Wrapper voor centreren en overflow
		const wrapper = document.createElement('div');
		wrapper.style.width = '100%';
		wrapper.style.height = '100%';
		wrapper.style.display = 'flex';
		wrapper.style.alignItems = 'center';
		wrapper.style.justifyContent = 'center';
		wrapper.style.overflow = 'hidden';
		wrapper.style.borderRadius = '12px';
		wrapper.appendChild(lensContainer);

		content.appendChild(wrapper);
	}

	// Touch handlers voor floating preview
	(function initFloatingPreviewHandlers() {
		/*
			EN:
			- WHY: â€œFloating previewâ€ is a touch-friendly mini-panel that lets the user rotate/mirror/cancel,
			  and also initiate a drag by grabbing the preview itself.
			- DUPLICATE: rotate/mirror/cancel exists in multiple UI paths (keyboard, wheel, buttons).
			- STATE: interacts with `selectedShape/Color`, `draggedBlock/Shape/Color`, `floatingPreviewActive`.
		*/
		const preview = document.getElementById('floating-preview');
		const rotateBtn = document.getElementById('floating-preview-rotate');
		const mirrorBtn = document.getElementById('floating-preview-mirror');
		const cancelBtn = document.getElementById('floating-preview-cancel');

		if (!preview || !rotateBtn || !mirrorBtn || !cancelBtn) return;

		// Rotate button
		rotateBtn.addEventListener('click', (e) => {
			e.stopPropagation();
			rotateSelectedCard();
		});

		// Mirror button
		mirrorBtn.addEventListener('click', (e) => {
			e.stopPropagation();
			mirrorSelectedCard();
		});

		// Cancel button
		cancelBtn.addEventListener('click', (e) => {
			e.stopPropagation();
			if (activeBonusPlacement) {
				cancelActiveBonusPlacement({ hidePreview: true });
			} else if (selectedCardElement) {
				selectCard(selectedCardElement); // Toggle off (dit verbergt preview al)
			}
			hideFloatingPreview(); // Verberg altijd bij cancel button
			removeCardControlButtons(); // Verberg control buttons
			closeZoom();
		});

		// Drag vanaf preview
		let dragStarted = false;
		let startX, startY;

		preview.addEventListener('pointerdown', (e) => {
			/*
				EN:
				- WHY: Start a drag by grabbing the floating preview panel.
				- STATE: creates the same draggable block as normal card drag.
				- NOTE: Uses pointer capture so the drag continues even if finger leaves the element.
			*/
			// Negeer als we een button raken
			if (e.target.closest('button')) return;

			e.preventDefault();
			dragStarted = true;
			startX = e.clientX;
			startY = e.clientY;

			preview.classList.add('dragging');
			preview.setPointerCapture(e.pointerId);

			// Start drag: maak draggable block
			if (selectedShape && selectedColor && !draggedBlock) {
				const block = makeDraggable(selectedShape, selectedColor);
				const rect = preview.getBoundingClientRect();
				setElPos(block, rect.left, rect.top);

				draggedBlock = block;
				resetDragBlockGap();
				draggedShape = block._shape || selectedShape;
				draggedColor = selectedColor;
				beginPointerDrag({ clientX: e.clientX, clientY: e.clientY, pointerId: e.pointerId });
				startGlobalDragVisuals();

				// Set offset zodat blok net boven vinger verschijnt
				({ offsetX, offsetY } = computeShapeCenterOffsets(draggedShape));
				offsetY += 40; // +40px zodat blok boven vinger verschijnt
			}
		});

		preview.addEventListener('pointermove', (e) => {
			/*
				EN:
				- WHY: Instead of duplicating the entire drag logic here, we synthesize a `pointermove`
				  and dispatch it on `document`, so the main drag handler runs.
				- DUPLICATE/OVERRIDE RISK: This depends on the document-level pointermove handler being present
				  and on event ordering. If multiple document pointermove handlers exist, behavior can change.
			*/
			if (!dragStarted) return;

			const deltaX = Math.abs(e.clientX - startX);
			const deltaY = Math.abs(e.clientY - startY);

			// Als we genoeg bewogen hebben, behandel als drag
			if (deltaX > 5 || deltaY > 5) {
				// Trigger het normale drag systeem
				const moveEvent = new PointerEvent('pointermove', {
					clientX: e.clientX,
					clientY: e.clientY,
					bubbles: true
				});
				document.dispatchEvent(moveEvent);
			}
		});

		preview.addEventListener('pointerup', (e) => {
			if (!dragStarted) return;

			dragStarted = false;
			preview.classList.remove('dragging');
			
			const deltaX = Math.abs(e.clientX - startX);
			const deltaY = Math.abs(e.clientY - startY);

			// Als we nauwelijks bewogen, behandel als tap
			if (deltaX < 5 && deltaY < 5) {
				// Optioneel: highlight preview of doe niets
			}
		});

		preview.addEventListener('pointercancel', () => {
			dragStarted = false;
			preview.classList.remove('dragging');
		});
	})();

	// ========================================
	// TAP-TO-PLACE VOOR TOUCH DEVICES
	// ========================================
	document.addEventListener('click', (e) => {
		/*
			EN:
			- WHY: On touch devices, allow â€œtap a cell to place the selected cardâ€ instead of dragging.
			- STATE: requires `floatingPreviewActive` + `selectedShape` + `selectedColor`.
			- OVERRIDE/DUPLICATE RISK: This is a global document click handler and can conflict with:
			  - zoom close click handler
			  - menu close click handler
			  - per-cell click toggles (e.g. debug mode)
			  Use `stopPropagation()` carefully.
		*/
		// Alleen actief als we een kaart geselecteerd hebben EN floating preview zichtbaar is
		if (!floatingPreviewActive || !selectedShape || !selectedColor) return;
		
		// Check of we op een cell klikken
		const cell = e.target.closest('.cell');
		if (!cell || cell.classList.contains('void-cell') || cell.dataset.disabled === 'true') return;

		// Check of we in een zone zijn
		const zone = cell.closest('.zone');
		if (!zone || zone.classList.contains('zone-placeholder')) return;

		// Negeer clicks op buttons, controls, etc
		if (e.target.closest('button') || e.target.closest('#card-choice-zone') || 
			e.target.closest('#controls') || e.target.closest('#floating-preview')) return;

		// Stop event zodat toggleCell niet triggert
		e.preventDefault();
		e.stopPropagation();

		// Probeer te plaatsen
		const baseX = parseInt(cell.dataset.x, 10) || 0;
		const baseY = parseInt(cell.dataset.y, 10) || 0;

		// Check of plaatsing valid is
		if (canPlace(zone, baseX, baseY, selectedShape)) {
			const coinSnapshotBefore = getCoinStateSnapshot();
			const placementResult = placeShape(zone, baseX, baseY, selectedShape, selectedColor);
			if (placementResult) {
				if (activeBonusPlacement) {
					finalizeBonusPlacement(placementResult, coinSnapshotBefore, activeBonusPlacement);
					cleanupDragState({ clearBonus: true, updateInventory: false, hidePreview: true });
				} else {
					finalizeCardPlacement(placementResult, coinSnapshotBefore);
					cleanupDragState({ clearBonus: false, hidePreview: true });
				}
				// Voer na-plaatsing logica uit
				if (rotateButton) rotateButton.disabled = true;
				if (mirrorButton) mirrorButton.disabled = true;
				updateTurnState();
			}
		} else {
			// Visual feedback dat plaatsing invalid is
			// Preview uitgeschakeld
			// showPreview(zone, selectedShape, baseX, baseY, false);
			// setTimeout(() => clearPreview(zone), 300;
		}
	}, true); // Use capture phase zodat we voor andere handlers triggeren

	// ========================================
	// ZONE INFO POPOVERS ("i" linksboven)
	// ========================================
	(() => {
		const getCurrentWorld = () => {
			try {
				if (typeof getWorldAndSubLevel === 'function') {
					return Number(getWorldAndSubLevel(currentLevel)?.world || 1) || 1;
				}
				return Number(currentWorld || 1) || 1;
			} catch {
				return 1;
			}
		};

		const WORLD_INFO = {
			1: {
				paars: '<strong>Paars</strong>: Begin overal. Haal 8 punten per verbinding van paarse dikgedrukte cellen.',
				geel: '<strong>Geel</strong>: Begin links. Je scoort als je een volledige kolom vult. Kolommen 1-2 geven 12 punten per kolom, 3-4 geven 18, 5-6 geven 30, 7-8 geven 42 punten, en 9-10 geven 60 punten per kolom.',
				groen: '<strong>Groen</strong>: Begin vanaf het midden. Bereik de donkergroene cellen om 8 punten te verdienen.',
				rood: '<strong>Rood</strong>: Begin overal. Elk rood vak dat volledig gevuld is levert punten op:',
				blauw: '<strong>Blauw</strong>: Begin onderaan. Bereik dikgedrukte cellen om punten te behalen.'
			},
			2: {
				paars: '<strong>Paars</strong>: Maak verbindingen van aaneengesloten paarse cellen. Score: 8 per verbinding, verbinding naar hoekcel: 10 punten, hoekcellen onderling: 25 punten per verbinding.',
				geel: '<strong>Geel</strong>: Je scoort als je een diagonale lijn vult. (start vanaf dikgedrukte cellen)',
				groen: '<strong>Groen</strong>: Begin vanaf het midden. Bereik de donkergroene cellen om punten te verdienen, hoe verder van het midden, hoe meer punten je kan verdienen.',
				rood: '<strong>Rood</strong>: Begin overal. Elk rood vak dat volledig gevuld is levert punten op:',
				blauw: '<strong>Blauw</strong>: Begin onderaan. Bereik dikgedrukte cellen om punten te behalen.'
			},
			3: {
				paars: '<strong>Paars</strong>: Maak verbindingen van aaneengesloten paarse cellen. Score: 8 per verbinding, verbinding naar hoekcel: 10 punten, hoekcellen onderling: 25 punten per verbinding.',
				geel: '<strong>Geel</strong>: Je scoort per volledige ring van de diamant. De buitenste ring geeft de meeste punten, de binnenste ring de minste (oplopend tot 64 punten).',
				groen: '<strong>Groen</strong>: Begin vanaf het midden. Bereik de donkergroene cellen om punten te verdienen, hoe verder van het midden, hoe meer punten je kan verdienen.',
				rood: '<strong>Rood</strong>: Begin overal. Elk rood vak dat volledig gevuld is levert punten op:',
				blauw: '<strong>Blauw</strong>: Begin onderaan. Bereik dikgedrukte cellen om punten te behalen.'
			}
		};

		const getZoneKey = (zoneEl) => {
			if (!zoneEl) return null;
			if (zoneEl.id === 'purple-zone') return 'paars';
			if (zoneEl.id === 'yellow-zone') return 'geel';
			if (zoneEl.id === 'green-zone') return 'groen';
			if (zoneEl.id === 'red-zone') return 'rood';
			if (zoneEl.id === 'blue-zone') return 'blauw';
			return zoneEl.dataset.color || null;
		};

		const closeAll = () => {
			document.querySelectorAll('.zone[data-info-open="true"]').forEach(zone => {
				zone.dataset.infoOpen = 'false';
				const btn = zone.querySelector('.zone-info-btn');
				const pop = zone.querySelector('.zone-info-popover');
				if (btn) btn.setAttribute('aria-expanded', 'false');
				if (pop) pop.setAttribute('aria-hidden', 'true');
			});
		};

		const openZoneInfo = (zone, btn) => {
			if (!zone || !btn) return;
			const key = getZoneKey(zone);
			const world = getCurrentWorld();
			const pop = zone.querySelector('.zone-info-popover');
			let html = WORLD_INFO[world]?.[key] || WORLD_INFO[1]?.[key] || '';
			// Red: show deterministic per-subgrid points only inside the info popover.
			try {
				if (key === 'rood' && zone.id === 'red-zone') {
					const ids = ['red-grid1','red-grid2','red-grid3','red-grid4','red-grid5','red-grid6'];
					const tierNames = ['klein', 'midden', 'groot', 'mega', 'mega', 'mega'];
					const lines = [];
					ids.forEach((id, idx) => {
						const g = document.getElementById(id);
						if (!g) return;
						const pts = Number(g.dataset.redTargetPoints) || (g.querySelectorAll ? (g.querySelectorAll('.cell:not(.void-cell)').length * 2) : 0);
						const tier = tierNames[idx] || 'mega';
						if (pts > 0) lines.push(`${tier}: <strong>${pts} punten</strong>`);
					});
					if (lines.length) {
						html += `<div style="margin-top:8px"><br>${lines.join('<br>')}</div>`;
					}
				}
			} catch (e) {}
			if (pop) {
				pop.innerHTML = html;
				pop.setAttribute('aria-hidden', 'false');
			}
			zone.dataset.infoOpen = 'true';
			btn.setAttribute('aria-expanded', 'true');
		};

		const maybeCloseZoneInfo = (zone, relatedTarget) => {
			if (!zone) return;
			if (relatedTarget && (relatedTarget.closest('.zone-info-popover') || relatedTarget.closest('.zone') === zone)) return;
			zone.dataset.infoOpen = 'false';
			const btn = zone.querySelector('.zone-info-btn');
			const pop = zone.querySelector('.zone-info-popover');
			if (btn) btn.setAttribute('aria-expanded', 'false');
			if (pop) pop.setAttribute('aria-hidden', 'true');
		};

		document.addEventListener('mouseover', (event) => {
			const btn = event.target.closest('.zone-info-btn');
			if (!btn) return;
			const zone = btn.closest('.zone');
			if (!zone) return;
			closeAll();
			openZoneInfo(zone, btn);
		}, true);

		document.addEventListener('mouseout', (event) => {
			const btn = event.target.closest('.zone-info-btn');
			if (!btn) return;
			const zone = btn.closest('.zone');
			if (!zone) return;
			maybeCloseZoneInfo(zone, event.relatedTarget);
		}, true);

		// If the pointer entered the popover and then leaves it (or leaves the zone entirely),
		// the button won't receive mouseout again. Close based on leaving the whole zone.
		document.addEventListener('mouseout', (event) => {
			const zone = event.target.closest('.zone');
			if (!zone) return;
			if (zone.dataset.infoOpen !== 'true') return;
			const toEl = event.relatedTarget;
			if (toEl && (toEl.closest('.zone') === zone || toEl.closest('.zone-info-popover'))) return;
			maybeCloseZoneInfo(zone, toEl);
		}, true);

		document.addEventListener('focusin', (event) => {
			const btn = event.target.closest('.zone-info-btn');
			if (!btn) return;
			const zone = btn.closest('.zone');
			if (!zone) return;
			closeAll();
			openZoneInfo(zone, btn);
		}, true);

		document.addEventListener('focusout', (event) => {
			const btn = event.target.closest('.zone-info-btn');
			if (!btn) return;
			const zone = btn.closest('.zone');
			if (!zone) return;
			maybeCloseZoneInfo(zone, event.relatedTarget);
		}, true);

		document.addEventListener('pointerdown', (event) => {
			if (event.target.closest('.zone') || event.target.closest('.zone-info-popover')) return;
			closeAll();
		}, true);

		document.addEventListener('keydown', (event) => {
			if (event.key === 'Escape') closeAll();
		}, true);
	})();

	rotateButton = document.getElementById('rotate-card-btn');
	if (rotateButton) {
	  rotateButton.addEventListener('click', event => {
		event.stopPropagation();
		rotateSelectedCard();
	  });
	  rotateButton.disabled = true;
	}

	mirrorButton = document.getElementById('mirror-card-btn');
	if (mirrorButton) {
	  mirrorButton.addEventListener('click', event => {
		event.stopPropagation();
		mirrorSelectedCard();
	  });
	  mirrorButton.disabled = true;
	}

	const bonusShopBtn = document.getElementById('bonus-shop-btn');
	if (bonusShopBtn) {
	  bonusShopBtn.style.display = 'none';
	}

	if (deckPreviewEl) {
	  deckPreviewEl.addEventListener('click', event => {
		event.preventDefault();
		event.stopPropagation();
		openDeckModal();
	  });
	  deckPreviewEl.addEventListener('keydown', event => {
		if (event.key === 'Enter' || event.key === ' ') {
		  event.preventDefault();
		  openDeckModal();
		}
	  });
	}

	if (deckModalClose) {
	  deckModalClose.addEventListener('click', event => {
		event.preventDefault();
		closeDeckModal();
	  });
	}

	if (deckModalLayer) {
	  deckModalLayer.addEventListener('click', event => {
		if (event.target === deckModalLayer) {
		  closeDeckModal();
		}
	  });
	}

	if (blackHoleClaimBtn) {
	  blackHoleClaimBtn.addEventListener('click', event => {
		event.preventDefault();
		claimBlackHoleReward();
	  });
	}

	if (blackHoleForfeitBtn) {
	  blackHoleForfeitBtn.addEventListener('click', event => {
		event.preventDefault();
		forfeitBlackHoleChallenge();
	  });
	}

	if (blackHoleModalLayer) {
	  blackHoleModalLayer.addEventListener('click', event => {
		if (event.target === blackHoleModalLayer) {
		  forfeitBlackHoleChallenge();
		}
	  });
	}

	const newCardsButton = document.getElementById('new-cards-btn');
	if (newCardsButton) {
	  newCardsButton.addEventListener('click', event => {
		event.stopPropagation();
		if (drawPile.length === 0) {
		  const canUseBonusEchoTurn = bonusEchoExtraTurns > 0 && discardPile.length > 0 && currentHand.length === 0;
		  if (canUseBonusEchoTurn && prepareBonusEchoExtraTurnDeck()) {
			// After preparing the deck, draw the bonus hand immediately.
			drawNextHand();
			updateDeckPreview();
			return;
		  }
		  // End of round: warn about playable cards AND remaining bonuses.
		  if (shouldWarnBeforeCompletingRound()) {
			showCompleteRoundConfirm(finalizeRoundCompletion);
		  } else {
			finalizeRoundCompletion();
		  }
		  return;
		}
		if (currentHand.length > 0) {
		  // Next hand: ONLY warn about playable cards (no bonus-only warnings).
		  const hasPlayableCards = currentHand.some(card => card && isCardPlayable(card));
		  if (hasPlayableCards) {
			showDiscardHandConfirm(() => {
			  discardCurrentHand();
			  drawNextHand();
			  updateDeckPreview();
			});
			return;
		  }
		  discardCurrentHand();
		}
		drawNextHand();
		updateDeckPreview();
	  });
	}

	const debugToggleBtn = document.getElementById('debug-mode-toggle');
	const newGameBtn = document.getElementById('new-game-btn');
	const persistedDebug = localStorage.getItem('debugModeEnabled') === 'true';
	setDebugMode(persistedDebug);
	if (debugToggleBtn) {
		debugToggleBtn.addEventListener('click', event => {
			event.preventDefault();
			toggleDebugMode();
		});
	}
	
	// Nieuw Spel button en modal handlers
	const confirmNewGameLayer = document.getElementById('confirm-new-game-layer');
	const confirmNewGameYes = document.getElementById('confirm-new-game-yes');
	const confirmNewGameNo = document.getElementById('confirm-new-game-no');
	
	function showNewGameConfirm() {
		if (confirmNewGameLayer) {
			confirmNewGameLayer.classList.add('show');
		}
	}
	
	function hideNewGameConfirm() {
		if (confirmNewGameLayer) {
			confirmNewGameLayer.classList.remove('show');
		}
	}
	
	if (newGameBtn) {
		newGameBtn.addEventListener('click', event => {
			event.preventDefault();
			showNewGameConfirm();
		});
	}
	
	if (confirmNewGameYes) {
		confirmNewGameYes.addEventListener('click', () => {
			hideNewGameConfirm();
			clearSaveData();
			startNewRun();
		});
	}
	
	if (confirmNewGameNo) {
		confirmNewGameNo.addEventListener('click', () => {
			hideNewGameConfirm();
		});
	}
	
	if (confirmNewGameLayer) {
		confirmNewGameLayer.addEventListener('click', event => {
			if (event.target === confirmNewGameLayer) {
				hideNewGameConfirm();
			}
		});
	}

	// Print instellingen + printvriendelijke output (geen screenshot)
	const printBtn = document.getElementById('print-btn');
	const printSettingsLayer = document.getElementById('print-settings-layer');
	const printSettingsClose = document.getElementById('print-settings-close');
	const printSettingsCancel = document.getElementById('print-settings-cancel');
	const printSettingsPrint = document.getElementById('print-settings-print');
	const printSettingsPreview = document.getElementById('print-settings-preview');
	const printOptNoBonuses = document.getElementById('print-opt-no-bonuses');
	const editorBtn = document.getElementById('menu-editor-btn');

	function showPrintSettings() {
		if (!printSettingsLayer) return;
		printSettingsLayer.classList.add('show');
		printSettingsLayer.setAttribute('aria-hidden', 'false');
	}
	function hidePrintSettings() {
		if (!printSettingsLayer) return;
		printSettingsLayer.classList.remove('show');
		printSettingsLayer.setAttribute('aria-hidden', 'true');
	}
	function getPrintSettings() {
		const selected = document.querySelector('input[name="print-board-source"]:checked');
		const source = selected ? String(selected.value) : 'current';
		return {
			source,
			lightMode: false,
			noBonuses: !!(printOptNoBonuses && printOptNoBonuses.checked)
		};
	}

	function stripBoardForLowInk(rootEl) {
		if (!rootEl) return;
		rootEl.querySelectorAll('.zone-info-btn,.zone-info-popover,h2').forEach(el => el.remove());
		rootEl.querySelectorAll('.symbol,.trap-symbol,.coin-icon,.coin').forEach(el => el.remove());
		// Remove classes that imply heavy fills; print CSS will further normalize.
		rootEl.querySelectorAll('.cell.gold-cell').forEach(el => el.classList.remove('gold-cell'));
		rootEl.querySelectorAll('.cell.trap-cell').forEach(el => el.classList.remove('trap-cell'));
	}

	function buildPrintBoardFromCurrent(noBonuses) {
		const board = document.getElementById('board');
		if (!board) return '';
		const columns = Array.from(board.children).filter(el => el && el.classList && el.classList.contains('column'));
		const playColumns = columns.slice(0, 3);
		const wrapper = document.createElement('div');
		wrapper.className = 'board';
		playColumns.forEach(col => wrapper.appendChild(col.cloneNode(true)));
		if (noBonuses) stripBoardForLowInk(wrapper);
		return wrapper.outerHTML;
	}

	// External editor bridge (separate page): send a snapshot of the current playfield.
	const LOCUS_EDITOR_STORAGE_KEY = 'locusEditorBoardHtml';
	function getEditorBoardHtml() {
		// Editor wants the full playfield; do not strip bonuses/symbols here.
		try {
			return buildPrintBoardFromCurrent(false);
		} catch (e) {
			const board = document.getElementById('board');
			return board ? board.outerHTML : '';
		}
	}

	// Apply a board HTML snapshot into the current game DOM by replacing known grids.
	function applyBoardHtmlToGame(boardHtml) {
		if (!boardHtml) return;
		try {
			const boardRoot = document.getElementById('board');
			const boardScope = boardRoot || document;
			const gridIdForColor = (c) => {
				const cc = String(c || '').toLowerCase();
				if (cc === 'paars' || cc === 'purple') return 'purple-grid';
				if (cc === 'geel' || cc === 'yellow') return 'yellow-grid';
				if (cc === 'groen' || cc === 'green') return 'green-grid';
				if (cc === 'blauw' || cc === 'blue') return 'blue-grid';
				return '';
			};
			const ensureZoneGridContainer = (zoneEl, gridId) => {
				if (!zoneEl || !gridId) return null;
				let grid = zoneEl.querySelector(`#${gridId}`) || zoneEl.querySelector(':scope > .grid') || zoneEl.querySelector('.grid');
				if (!grid) {
					grid = document.createElement('div');
					grid.className = 'grid';
					grid.id = gridId;
					zoneEl.appendChild(grid);
				}
				try { grid.classList.add('grid'); } catch (e) {}
				if (!grid.id) grid.id = gridId;
				return grid;
			};
			const ensureRedGroupSkeleton = () => {
				const destRed = boardScope.querySelector('.zone.red-group') || boardScope.querySelector('.zone[data-color="rood"]') || document.getElementById('red-zone');
				if (!destRed) return null;
				// Ensure the 4 subgrids exist (applyBoardHtmlToGame used to delete them)
				for (let i = 1; i <= 4; i += 1) {
					const id = `red-grid${i}`;
					let sub = destRed.querySelector(`#${id}`);
					if (!sub) {
						sub = document.createElement('div');
						sub.className = 'zone';
						sub.id = id;
						sub.dataset.color = 'rood';
						sub.dataset.zone = id;
						sub.dataset.subgrid = String(i);
						destRed.appendChild(sub);
					} else {
						try { sub.classList.add('zone'); } catch (e) {}
						try { sub.dataset.color = 'rood'; } catch (e) {}
						try { sub.dataset.zone = id; } catch (e) {}
						try { sub.dataset.subgrid = String(i); } catch (e) {}
					}
				}
				return destRed;
			};
			const temp = document.createElement('div');
			temp.innerHTML = boardHtml;
			// helper: ensure absolute-positioned root grids have a real layout box
			function ensureAbsoluteContainerSizing(containerEl, srcEl) {
				if (!containerEl) return;
				// Determine the zone ID for this container
				const zone = containerEl.closest('.zone');
				const zoneId = containerEl.id || (zone ? zone.id : '') || '';
				
				// Root grids (green/red) must render with absolute-positioned children.
				// Editor exports may omit inline `position/left/top`, so we reconstruct them from data-x/y or data-c/r.
				function ensureAbsoluteCells(targetEl) {
					if (!targetEl) return;
					const cells = Array.from(targetEl.querySelectorAll('.cell'));
					// Determine columns from dataset or by counting cells in each row
					let fallbackCols = (() => {
						const n = parseInt(String(targetEl.dataset && targetEl.dataset.cols || ''), 10);
						return Number.isFinite(n) && n > 0 ? n : 0;
					})();
					// If no cols in dataset, try to infer from cell count and rows, or use sqrt heuristic
					if (!fallbackCols && cells.length > 0) {
						const rowsAttr = parseInt(String(targetEl.dataset && targetEl.dataset.rows || ''), 10);
						if (Number.isFinite(rowsAttr) && rowsAttr > 0) {
							fallbackCols = Math.ceil(cells.length / rowsAttr);
						} else {
							// Use sqrt heuristic for square-ish grids
							fallbackCols = Math.ceil(Math.sqrt(cells.length));
						}
					}
					cells.forEach((cell, idx) => {
						try {
							if (!cell || !cell.style) return;
									// Normalize away transform-based positioning from the editor export.
									// The game board expects absolute left/top for green/red cells.
									try {
										cell.classList.remove('use-transform-pos');
										cell.style.removeProperty('--dx');
										cell.style.removeProperty('--dy');
									} catch (e) {}
							// Ensure absolute positioning
							if (!cell.style.position || cell.style.position === 'relative') {
								cell.style.position = 'absolute';
							}
							let x = Number(cell.dataset.x ?? cell.dataset.c);
							let y = Number(cell.dataset.y ?? cell.dataset.r);
									// If coords come from data-c/r, also mirror them into data-x/y
									if (Number.isFinite(x) && (cell.dataset.x == null || cell.dataset.x === '')) {
										cell.dataset.x = String(Math.floor(x));
									}
									if (Number.isFinite(y) && (cell.dataset.y == null || cell.dataset.y === '')) {
										cell.dataset.y = String(Math.floor(y));
									}
							// Fallback: derive coordinates from DOM order if needed (only if missing)
							if (!Number.isFinite(x) || !Number.isFinite(y)) {
								if (fallbackCols > 0) {
									x = Number.isFinite(x) ? x : (idx % fallbackCols);
									y = Number.isFinite(y) ? y : Math.floor(idx / fallbackCols);
									// Store derived coordinates in dataset for later use
									cell.dataset.x = String(x);
									cell.dataset.y = String(y);
								}
							}
									// Ensure normalized x/y are always present for game logic
									if (Number.isFinite(x)) cell.dataset.x = String(Math.floor(x));
									if (Number.isFinite(y)) cell.dataset.y = String(Math.floor(y));
							// Ensure zoneId is set for game logic
							if (zoneId && !cell.dataset.zoneId) {
								cell.dataset.zoneId = zoneId;
							}
							// Only set left/top if they are missing (preserve existing positions)
							if (!cell.style.left && Number.isFinite(x)) {
								cell.style.left = `calc(${x} * var(--cell-size))`;
							}
							if (!cell.style.top && Number.isFinite(y)) {
								cell.style.top = `calc(${y} * var(--cell-size))`;
							}
						} catch (e) {}
					});
				}
				const readInt = (v) => {
					const n = parseInt(String(v || ''), 10);
					return Number.isFinite(n) && n > 0 ? n : 0;
				};
				let cols = readInt((containerEl.dataset && containerEl.dataset.cols) || (srcEl && srcEl.dataset && srcEl.dataset.cols));
				let rows = readInt((containerEl.dataset && containerEl.dataset.rows) || (srcEl && srcEl.dataset && srcEl.dataset.rows));
				if (!cols || !rows) {
					const cells = Array.from(containerEl.querySelectorAll('.cell:not(.void-cell)'));
					let maxX = -Infinity;
					let maxY = -Infinity;
					cells.forEach(c => {
						const x = Number(c.dataset.x ?? c.dataset.c);
						const y = Number(c.dataset.y ?? c.dataset.r);
						if (Number.isFinite(x)) maxX = Math.max(maxX, x);
						if (Number.isFinite(y)) maxY = Math.max(maxY, y);
					});
					if (!cols && Number.isFinite(maxX) && maxX >= 0) cols = maxX + 1;
					if (!rows && Number.isFinite(maxY) && maxY >= 0) rows = maxY + 1;
					if (containerEl.dataset) {
						if (cols) containerEl.dataset.cols = String(cols);
						if (rows) containerEl.dataset.rows = String(rows);
					}
				}
				// These root grids rely on absolute-positioned children; without a width/height the zone can look empty
				try { containerEl.style.position = 'relative'; } catch (e) {}
				if (cols) {
					try { containerEl.style.width = `calc(${cols} * var(--cell-size))`; } catch (e) {}
				}
				if (rows) {
					try { containerEl.style.height = `calc(${rows} * var(--cell-size))`; } catch (e) {}
				}
				// Root grids are not CSS-grid laid out; keep them as a normal block box
				try { containerEl.style.display = 'block'; } catch (e) {}
				// And ensure the children are truly placed absolutely (prevents the â€œcells under each otherâ€ symptom)
				ensureAbsoluteCells(containerEl);
			}
			// helper: remove editor-only chrome from a node
			function stripEditorChrome(node) {
				if (!node) return;
				node.querySelectorAll('.zone-handle, .grid-resizer, .zone-delete').forEach(n => n.remove());
				node.querySelectorAll('[draggable]').forEach(n => n.removeAttribute('draggable'));
			}
			// helper: copy grid content from source grid into destination grid (cleaning editor chrome)
			function copyGridContent(srcGrid, destGrid) {
				if (!srcGrid || !destGrid) return;
				stripEditorChrome(srcGrid);
				// Clone children to avoid carrying over event listeners or references
				destGrid.innerHTML = '';
				// Be robust: some older editor exports may wrap cells in extra nodes.
				const directCells = Array.from(srcGrid.querySelectorAll(':scope > .cell'));
				const cellsToCopy = directCells.length ? directCells : Array.from(srcGrid.querySelectorAll('.cell'));
				if (cellsToCopy.length) {
					cellsToCopy.forEach(ch => destGrid.appendChild(ch.cloneNode(true)));
				} else {
					Array.from(srcGrid.children || []).forEach(ch => destGrid.appendChild(ch.cloneNode(true)));
				}
				// Ensure any runtime-filled state (active) is cleared so the game starts with an empty board
				// IMPORTANT: Do NOT remove inline styles for grids using absolute positioning (green/red).
				// Those grids rely on inline left/top for cell placement.
				// Red subgrids (red-grid1, red-grid2, etc.) don't have a .grid child - cells are directly inside.
				const isGreenGrid = destGrid.id === 'green-grid' || destGrid.closest('.zone[data-color="groen"]');
				const isRedGrid = destGrid.id && destGrid.id.startsWith('red-grid') || destGrid.closest('.zone[data-color="rood"]') || destGrid.closest('.red-group') || (destGrid.dataset && destGrid.dataset.color === 'rood');
				const usesAbsolutePositioning = isAbsolutePositionedGrid(destGrid);
				
				// Determine the zone ID for this grid
				const zone = destGrid.closest('.zone');
				const zoneId = destGrid.id || (zone ? zone.id : '') || '';
				
				destGrid.querySelectorAll('.cell').forEach(cell => {
					try { cell.classList.remove('active', 'edge-cell'); } catch (e) {}
					if (!usesAbsolutePositioning) {
						try { cell.removeAttribute('style'); } catch (e) {}
					}
				});
				// copy dataset rows/cols
				if (srcGrid.dataset && srcGrid.dataset.rows) destGrid.dataset.rows = srcGrid.dataset.rows;
				if (srcGrid.dataset && srcGrid.dataset.cols) destGrid.dataset.cols = srcGrid.dataset.cols;
				// ensure grid template columns/rows match dataset or cell count (only for CSS Grid zones, not absolute-positioned ones)
				if (!usesAbsolutePositioning) {
					// IMPORTANT: Do NOT trust existing destGrid.dataset.cols here.
					// When importing into an already-running game (or after loadGameState), the destination grid may
					// still carry cols/rows from the current level. That would distort the imported layout.
					const allCells = Array.from(destGrid.querySelectorAll(':scope > .cell'));
					let cols = 0;
					let rows = 0;
					try {
						let maxX = -1;
						let maxY = -1;
						allCells.forEach(c => {
							const x = Number(c?.dataset?.x ?? c?.dataset?.c);
							const y = Number(c?.dataset?.y ?? c?.dataset?.r);
							if (Number.isFinite(x)) maxX = Math.max(maxX, Math.floor(x));
							if (Number.isFinite(y)) maxY = Math.max(maxY, Math.floor(y));
						});
						if (maxX >= 0) cols = maxX + 1;
						if (maxY >= 0) rows = maxY + 1;
					} catch (e) {}
					if (!cols) {
						// Prefer source dataset if present
						cols = parseInt(String(srcGrid?.dataset?.cols || ''), 10) || 0;
					}
					if (!rows) {
						rows = parseInt(String(srcGrid?.dataset?.rows || ''), 10) || 0;
					}
					if (!cols && rows && allCells.length) cols = Math.ceil(allCells.length / rows);
					if (!rows && cols && allCells.length) rows = Math.ceil(allCells.length / cols);
					if (!cols && allCells.length) cols = Math.max(1, Math.round(Math.sqrt(allCells.length)));
					if (!rows && cols && allCells.length) rows = Math.max(1, Math.ceil(allCells.length / cols));
					if (cols) {
						destGrid.style.gridTemplateColumns = `repeat(${cols}, var(--cell-size))`;
						destGrid.style.gridAutoRows = 'var(--cell-size)';
						try { destGrid.dataset.cols = String(cols); } catch (e) {}
						try { if (rows) destGrid.dataset.rows = String(rows); } catch (e) {}
					}
					
					// CRITICAL: Ensure all cells have data-x, data-y, and data-zone-id for game logic
					allCells.forEach((cell, idx) => {
						const x = cols ? (idx % cols) : 0;
						const y = cols ? Math.floor(idx / cols) : idx;
						cell.dataset.x = String(x);
						cell.dataset.y = String(y);
						if (zoneId) cell.dataset.zoneId = zoneId;
					});
				} else {
					// For green/red grids: derive cols/rows from cell count if not set
					const cellCount = destGrid.querySelectorAll(':scope > .cell').length;
					if (!destGrid.dataset.cols && cellCount > 0) {
						const inferred = Math.ceil(Math.sqrt(cellCount));
						destGrid.dataset.cols = String(inferred);
						destGrid.dataset.rows = String(Math.ceil(cellCount / inferred));
					}
					ensureAbsoluteContainerSizing(destGrid, srcGrid);
				}
			}
			// Map zones by color so editor IDs don't need to match game IDs
			const colors = ['paars','geel','groen','blauw'];
			colors.forEach(color => {
				const srcZone = temp.querySelector(`.zone[data-color="${color}"]`) || temp.querySelector(`#${color}-zone`);
				const destZone = boardScope.querySelector(`.zone[data-color="${color}"]`);
				if (!destZone) return;
				// Treat a zone as removed if it doesn't exist OR if it contains no usable cells.
				// NOTE: Some editor exports may have cells directly under the zone without a .grid wrapper.
				// In that case, we must copy from the zone itself.
				const srcGrid = srcZone ? (srcZone.querySelector(':scope > .grid') || srcZone.querySelector('.grid')) : null;
				const srcContainer = srcGrid || srcZone;
				const srcCellCount = srcContainer
					? srcContainer.querySelectorAll('.cell').length
					: 0;
				if (!srcZone || !srcCellCount) {
					// Editor removed this zone â€” hide it in the game view
					destZone.style.display = 'none';
					// IMPORTANT: do not destroy the zone DOM (it breaks future normal runs).
					// Keep/recreate the grid container so the normal generator can rebuild later.
					const gid = gridIdForColor(color);
					const destGridKeep = ensureZoneGridContainer(destZone, gid);
					if (destGridKeep) destGridKeep.innerHTML = '';
					return;
				} else {
					destZone.style.display = '';
				}
				const destGrid = ensureZoneGridContainer(destZone, gridIdForColor(color));
				copyGridContent(srcContainer, destGrid);
				// Diagnostics: help spot missing grids/cells during editor -> game import
				try {
					const srcCount = srcContainer ? srcContainer.querySelectorAll('.cell').length : 0;
					const dstCount = destGrid ? destGrid.querySelectorAll('.cell').length : 0;
					const srcNonVoid = srcContainer ? srcContainer.querySelectorAll('.cell:not(.void-cell)').length : 0;
					const dstNonVoid = destGrid ? destGrid.querySelectorAll('.cell:not(.void-cell)').length : 0;
					const srcSymbols = srcContainer ? srcContainer.querySelectorAll('.symbol,.trap-symbol,.portal-symbol').length : 0;
					const dstSymbols = destGrid ? destGrid.querySelectorAll('.symbol,.trap-symbol,.portal-symbol').length : 0;
				} catch (e) {}

				// Special handling for green zone: synchronize end-cell / start markers from the editor
				// NOTE: The game uses .bold-cell as the start marker in green, NOT .start-cell.
				// Support older boards where cells may be direct children of the zone (no .grid wrapper)
				if (String(color).toLowerCase() === 'groen') {
					try {
							// IMPORTANT: Green uses absolute-positioned root cells.
							// The normal generator marks them as .root-cell, and CSS uses that class to shrink+center
							// them (creating the visible spacing). Ensure imported boards get the same class.
							const destRoot = (destGrid || destZone);
							if (destRoot) destRoot.querySelectorAll('.cell').forEach(c => { try { c.classList.add('root-cell'); } catch (e) {} });

						// Remove any lingering start-cell markers in destination (game doesn't use them)
						const destContainerForStartRemove = destGrid || destZone;
						if (destContainerForStartRemove) destContainerForStartRemove.querySelectorAll('.cell.start-cell').forEach(n => n.classList.remove('start-cell'));

						// Collect source and destination cells robustly whether wrapped in .grid or direct children
						const srcCells = Array.from((srcGrid ? srcGrid : srcZone).querySelectorAll(':scope > .cell'));
						const destCells = Array.from((destGrid ? destGrid : destZone).querySelectorAll(':scope > .cell'));

						// Build a map of dest cells by coordinates for robust matching
						const destCellMap = new Map();
						destCells.forEach(dcell => {
							const r = dcell.dataset.r || dcell.dataset.y;
							const c = dcell.dataset.c || dcell.dataset.x;
							if (r !== undefined && c !== undefined) {
								destCellMap.set(`${r},${c}`, dcell);
							}
						});

						srcCells.forEach((scell) => {
							const r = scell.dataset.r || scell.dataset.y;
							const c = scell.dataset.c || scell.dataset.x;
							const dcell = destCellMap.get(`${r},${c}`);
							if (!dcell) return;
							const shouldBeEnd = scell.classList.contains('end-cell');
							const shouldBeStart = scell.classList.contains('start-cell') || scell.classList.contains('bold-cell');
							// Preserve end-cell state
							if (shouldBeEnd) dcell.classList.add('end-cell');
							else dcell.classList.remove('end-cell');
							// Ensure start markers in the editor become bold-cells in the game
							if (shouldBeStart && !dcell.classList.contains('bold-cell')) dcell.classList.add('bold-cell');
						});
					} catch (e) { /* ignore */ }
				}

				// Special handling for blue zone: preserve editor-placed bold-cells as start positions
				// Only use bottom-row fallback if NO bold-cells exist from the source
				if (String(color).toLowerCase() === 'blauw') {
					try {
						const srcContainer = srcGrid || srcZone;
						const destContainer = destGrid || destZone;
						if (destContainer) {
							// Check if source had any bold-cells (editor-placed start positions)
							const srcHasBoldCells = srcContainer && srcContainer.querySelectorAll('.cell.bold-cell').length > 0;
							const destHasBoldCells = destContainer.querySelectorAll('.cell.bold-cell').length > 0;
							
							// Backfill coordinate attributes if an older export used r/c instead of x/y
							destContainer.querySelectorAll('.cell').forEach(c => {
								if ((c.dataset.x == null || c.dataset.x === '') && c.dataset.c != null) c.dataset.x = String(c.dataset.c);
								if ((c.dataset.y == null || c.dataset.y === '') && c.dataset.r != null) c.dataset.y = String(c.dataset.r);
							});
							
							// Only apply bottom-row fallback if there are NO existing bold-cells
							if (!srcHasBoldCells && !destHasBoldCells) {
								const destCells = Array.from(destContainer.querySelectorAll(':scope > .cell:not(.void-cell)'));
								if (destCells.length) {
									let maxY = -Infinity;
									destCells.forEach(c => {
										const y = Number(c.dataset.y || c.dataset.r || c.dataset.y);
										if (Number.isFinite(y) && y > maxY) maxY = y;
									});
									if (maxY !== -Infinity) {
										destCells.filter(c => Number(c.dataset.y || c.dataset.r || c.dataset.y) === maxY)
											.forEach(c => { if (!c.classList.contains('bold-cell')) c.classList.add('bold-cell'); });
									}
								}
							}
						}
					} catch (e) { /* ignore */ }
				}
			});
			// Post-import: if the editor snapshot had explicit bold-cells for blue,
			// enforce that the game uses exactly those positions (avoid bottom-row fallback).
			try {
				const srcBlue = temp.querySelector('.zone[data-color="blauw"]') || temp.querySelector('#blauw-zone');
				const destBlue = boardScope.querySelector('.zone[data-color="blauw"]');
				if (srcBlue && destBlue) {
					const srcBold = Array.from(srcBlue.querySelectorAll(':scope > .grid > .cell.bold-cell, :scope > .cell.bold-cell, .cell.bold-cell'));
					if (srcBold.length > 0) {
						// Clear existing bold markers in destination
						destBlue.querySelectorAll('.cell.bold-cell').forEach(n => n.classList.remove('bold-cell'));
						// Map dest cells by r,c or y,x for robust matching
						const destCells = Array.from(destBlue.querySelectorAll(':scope > .grid > .cell, :scope > .cell'));
						const destMap = new Map();
						destCells.forEach(d => {
							const r = d.dataset.r || d.dataset.y;
							const c = d.dataset.c || d.dataset.x;
							if (r !== undefined && c !== undefined) destMap.set(`${r},${c}`, d);
						});
						srcBold.forEach(s => {
							const r = s.dataset.r || s.dataset.y;
							const c = s.dataset.c || s.dataset.x;
							const match = destMap.get(`${r},${c}`);
							if (match) match.classList.add('bold-cell');
						});
					}
				}
			} catch (e) { /* ignore */ }
			// Handle red-group (may contain multiple sub-zones)
			// NOTE: Red subgrids use absolute positioning (like green), cells are directly in the zone (no .grid child)
			const srcRed = temp.querySelector('.zone.red-group') || temp.querySelector('.zone[data-color="rood"]');
			const destRed = ensureRedGroupSkeleton() || boardScope.querySelector('.zone.red-group') || boardScope.querySelector('.zone[data-color="rood"]');
			if (!destRed) {
				// nothing to do
			} else {
				const srcRedHasCells = !!(srcRed && srcRed.querySelectorAll('.cell').length);
				const srcRedHasSubs = !!(srcRed && srcRed.querySelectorAll(':scope > .zone').length);
				if (!srcRed || (!srcRedHasCells && !srcRedHasSubs)) {
				// Editor removed red-group entirely â€” hide it
				destRed.style.display = 'none';
				// IMPORTANT: do not destroy red subgrid DOM; just clear cells so normal runs can regenerate.
				try { destRed.querySelectorAll(':scope > .zone').forEach(z => { try { z.style.display = ''; } catch (e) {} z.querySelectorAll(':scope > .cell').forEach(c => c.remove()); z.innerHTML = z.innerHTML; }); } catch (e) {}
				} else {
				const srcSubs = Array.from(srcRed.querySelectorAll(':scope > .zone'));
				let destSubs = Array.from(destRed.querySelectorAll(':scope > .zone'));
				// Create missing destination sub-zones if necessary
				if (destSubs.length < srcSubs.length) {
					srcSubs.slice(destSubs.length).forEach((srcSub, i) => {
						const newSub = document.createElement('div');
						newSub.className = 'zone';
						newSub.dataset.color = 'rood';
						newSub.id = srcSub.id || `red-grid${destSubs.length + i + 1}`;
						destRed.appendChild(newSub);
					});
					destSubs = Array.from(destRed.querySelectorAll(':scope > .zone'));
				}
				srcSubs.forEach((srcSub, idx) => {
					const destSub = destSubs[idx] || destSubs[destSubs.length - 1];
					if (!destSub) return;
					// Red subgrids: cells are directly in the zone, not in a .grid child
					// Check if there's a .grid child or if cells are direct children
					const srcGrid = srcSub.querySelector(':scope > .grid');
					const destGrid = destSub.querySelector(':scope > .grid');
					if (srcGrid && destGrid) {
						// Standard case with .grid child on both sides
						copyGridContent(srcGrid, destGrid);
							ensureAbsoluteContainerSizing(destGrid, srcGrid);
								try { (destGrid || destSub).querySelectorAll('.cell').forEach(c => c.classList.add('root-cell')); } catch (e) {}
					} else if (srcGrid && !destGrid) {
						// Source has .grid wrapper but destination expects cells directly in the zone
						stripEditorChrome(srcSub);
						// Remove existing direct cells in dest
						destSub.querySelectorAll(':scope > .cell').forEach(c => c.remove());
						// Clone from srcGrid into destSub (direct children)
							const srcCells = Array.from(srcGrid.querySelectorAll(':scope > .cell'));
							const srcCellsToCopy = srcCells.length ? srcCells : Array.from(srcGrid.querySelectorAll('.cell'));
							srcCellsToCopy.forEach(srcCell => {
							const clone = srcCell.cloneNode(true);
							try { clone.classList.remove('active', 'edge-cell'); } catch (e) {}
							destSub.appendChild(clone);
						});
						// Copy dataset from srcGrid or srcSub if present
						if (srcGrid.dataset && srcGrid.dataset.rows) destSub.dataset.rows = srcGrid.dataset.rows;
						if (srcGrid.dataset && srcGrid.dataset.cols) destSub.dataset.cols = srcGrid.dataset.cols;
						if (srcSub.dataset && srcSub.dataset.rows) destSub.dataset.rows = srcSub.dataset.rows;
						if (srcSub.dataset && srcSub.dataset.cols) destSub.dataset.cols = srcSub.dataset.cols;
							ensureAbsoluteContainerSizing(destSub, srcGrid);
								try { destSub.querySelectorAll('.cell').forEach(c => c.classList.add('root-cell')); } catch (e) {}
					} else if (!srcGrid && destGrid) {
						// Source has direct cells in the zone but destination expects a .grid child
						stripEditorChrome(srcSub);
						// Clear destination grid and append cloned cells into its .grid
						destGrid.innerHTML = '';
							const srcCells = Array.from(srcSub.querySelectorAll(':scope > .cell'));
							const srcCellsToCopy = srcCells.length ? srcCells : Array.from(srcSub.querySelectorAll('.cell'));
							srcCellsToCopy.forEach(srcCell => {
							const clone = srcCell.cloneNode(true);
							try { clone.classList.remove('active', 'edge-cell'); } catch (e) {}
							destGrid.appendChild(clone);
						});
						// Copy dataset into destGrid
						if (srcSub.dataset && srcSub.dataset.rows) destGrid.dataset.rows = srcSub.dataset.rows;
						if (srcSub.dataset && srcSub.dataset.cols) destGrid.dataset.cols = srcSub.dataset.cols;
							ensureAbsoluteContainerSizing(destGrid, srcSub);
								try { destGrid.querySelectorAll('.cell').forEach(c => c.classList.add('root-cell')); } catch (e) {}
					} else {
						// Neither side has a .grid wrapper: both expect direct children in the zone
						stripEditorChrome(srcSub);
						destSub.querySelectorAll(':scope > .cell').forEach(c => c.remove());
							const srcCells = Array.from(srcSub.querySelectorAll(':scope > .cell'));
							const srcCellsToCopy = srcCells.length ? srcCells : Array.from(srcSub.querySelectorAll('.cell'));
							srcCellsToCopy.forEach(srcCell => {
							const clone = srcCell.cloneNode(true);
							try { clone.classList.remove('active', 'edge-cell'); } catch (e) {}
							destSub.appendChild(clone);
						});
						if (srcSub.dataset.rows) destSub.dataset.rows = srcSub.dataset.rows;
						if (srcSub.dataset.cols) destSub.dataset.cols = srcSub.dataset.cols;
							ensureAbsoluteContainerSizing(destSub, srcSub);
								try { destSub.querySelectorAll('.cell').forEach(c => c.classList.add('root-cell')); } catch (e) {}
					}
				});
					// Diagnostics for red import
					try {
						const dstSubCount = Array.from(destRed.querySelectorAll(':scope > .zone')).map(z => z.querySelectorAll('.cell').length);
					} catch (e) {}
			}
		}

			// Ensure any portal cells in the destination are considered start positions by marking them bold
			try {
				const allPortalDest = boardScope.querySelectorAll('.portal-cell');
				allPortalDest.forEach(pc => { if (!pc.classList.contains('bold-cell')) pc.classList.add('bold-cell'); });
			} catch (e) { /* ignore */ }
			// Initialize trap state for imported boards so black-hole and other traps work
			try {
				// Find candidate trap cells: explicit dataset, editor trap class, or trap-symbol present
				const allCells = Array.from(boardScope.querySelectorAll('.cell'));
				const importedTraps = allCells.filter(cell => {
					if (!cell) return false;
					if (cell.dataset && cell.dataset.trap === 'true') return true;
					if (cell.classList && cell.classList.contains('trap-cell')) return true;
					if (cell.querySelector && cell.querySelector('.trap-symbol')) return true;
					return false;
				});
				importedTraps.forEach(cell => {
					try {
						// Ensure the dataset.trap flag exists
						if (!cell.dataset) cell.dataset = {};
						// Prefer explicit trapType if present, else infer from symbol/class
						if (!cell.dataset.trapType) {
							const hasBH = !!cell.querySelector('.trap-symbol.trap-symbol--black-hole');
							const hasPit = !!cell.querySelector('.trap-symbol') && !hasBH;
							if (hasBH) cell.dataset.trapType = 'blackHole';
							else if (hasPit) cell.dataset.trapType = 'pit';
						}
						const inferredIsBH = cell.dataset.trapType === 'blackHole' || !!cell.querySelector('.trap-symbol.trap-symbol--black-hole');
						if (inferredIsBH) {
							cell.dataset.blackHole = 'true';
							delete cell.dataset.trap;
						} else if (!cell.dataset.trap || String(cell.dataset.trap) !== 'true') {
							cell.dataset.trap = 'true';
						}
						const zoneId = cell.dataset.zoneId || cell.closest('.grid')?.id || '';
						// Register or release trap depending on active state
						if (inferredIsBH) ensureBlackHoleState(cell, zoneId, { silent: true });
						else ensureTrapState(cell, zoneId, { silent: true });
					} catch (e) { /* ignore per-cell errors */ }
				});
				// Refresh trap UI summary
				try { if (typeof renderTrapSummary === 'function') renderTrapSummary(); } catch (e) {}
			} catch (e) { /* ignore */ }
			// Final cleanup: remove any lingering editor chrome from DOM
			boardScope.querySelectorAll('.zone-handle, .grid-resizer, .zone-delete').forEach(n => n.remove());
			// Recompute scores and UI
			if (typeof resetScoreState === 'function') resetScoreState();
			if (typeof updateScore === 'function') updateScore();
			if (typeof updateDeckPreview === 'function') updateDeckPreview();
			if (typeof renderCurrentHand === 'function') renderCurrentHand();
			// Mark that a board was applied from the external editor so runtime logic
			// can opt-in to editor-specific behaviors (e.g. blue startcells anywhere).
			try { window._locusEditorApplied = true; } catch (e) {}
			try {
				// Mark every grid element so validation can detect editor-applied boards
				boardScope.querySelectorAll('.grid').forEach(g => {
					try { if (g && g.dataset) g.dataset.editorApplied = 'true'; } catch (e) {}
				});
			} catch (e) {}
		} catch (e) {
			console.error('applyBoardHtmlToGame failed', e);
		}
	}

	// Set the visible level title and objective in the UI when loading a custom board
	// Optional: pass `scenarioId` (e.g. '4.1') so scenario subgoals can be rehydrated on load.
	function setLoadedLevelMeta(name, objective, scenarioId) {
		try {
			// Persist loaded custom level metadata and compile objective once
			window.loadedCustomLevelMeta = {
				name: name ? String(name) : '',
				objective: objective == null ? '' : String(objective).trim(),
				scenarioId: scenarioId == null ? '' : String(scenarioId).trim()
			};
			window.loadedCustomObjectiveCompiled = null;
			window.loadedCustomLevelMetaCompleted = false;
			if (window.loadedCustomLevelMeta.objective) {
				try { window.loadedCustomObjectiveCompiled = parseObjectiveTextToObjective(window.loadedCustomLevelMeta.objective); } catch (e) { window.loadedCustomObjectiveCompiled = null; }
			}
			// Prevent built-in objectives interfering
			currentObjectiveId = null;
			const titleEl = document.querySelector('#objective-zone h2');
			const currentEl = document.getElementById('objective-current');
			if (titleEl) titleEl.textContent = window.loadedCustomLevelMeta.name || titleEl.textContent;
			let obj = window.loadedCustomLevelMeta.objective || '';
			if (!obj) obj = 'Haal 100 punten';
			if (currentEl) currentEl.innerHTML = `<strong>Doel:</strong> ${obj}`;
		} catch (e) { /* ignore */ }
	}

// Scenario subgoals registration (used by World 4 prototype scenarios 4.1/4.2)
function registerScenarioSubgoals(scenarioId, meta) {
	try {
		const sid = String(scenarioId || (meta && meta.scenarioId) || '').trim();
		if (!sid) return;
		const isDoorOpen = (doorId) => {
			try { return isWorld4DoorOpen(String(doorId || '')); } catch (e) { return false; }
		};
		const isColorUnlocked = (colorNl) => {
			try { return isWorld4ColorUnlocked(String(colorNl || '').trim().toLowerCase()); } catch (e) { return false; }
		};
		if (sid === '4.1') {
			const subgoals = [
				{ title: 'Groen 5Ã—5', text: 'Maak een 5Ã—5 volledig actief blok in groen.', check: () => checkGridHasFilledSquare('green-grid', 5) },
				{ title: 'Sleutel', text: 'Activeer de sleutel in groen om blauw te unlocken.', check: () => isColorUnlocked('blauw') },
				{ title: 'Deur', text: 'Open de blauwe deur om het gebied erachter vrij te spelen.', check: () => isDoorOpen('sc:4.1:door:blauw:1') }
			];
			setScenarioSubgoals(subgoals);
			return;
		}
		if (sid === '4.2') {
			const subgoals = [
				{ title: '4Ã—4 Vorm', text: 'Maak een 4Ã—4 volledig actief blok in groen.', check: () => checkGridHasFilledSquare('green-grid', 4) },
				{ title: 'Sleutel gebruiken', text: 'Gebruik de sleutel in blauw om groen te unlocken.', check: () => isColorUnlocked('groen') },
				{ title: 'Deur openen', text: 'Open de deur in groen om het gebied erachter vrij te spelen.', check: () => isDoorOpen('sc:4.2:door:groen:1') }
			];
			setScenarioSubgoals(subgoals);
			return;
		}
	} catch (e) { console.error(e); }
}

// --- Scenario helpers for World 4 prototypes (4.1, 4.2) ---
function buildScenarioBoardHtml(scenarioId) {
	// Build a minimal board DOM for the scenario and return outerHTML.
	const board = document.createElement('div');
	board.className = 'board';

	const ensureSymbol = (cell, cls, html) => {
		try {
			if (!cell) return;
			let el = cell.querySelector(`.${cls}`);
			if (!el) {
				el = document.createElement('span');
				el.className = cls;
				cell.appendChild(el);
			}
			el.innerHTML = html;
		} catch (e) {}
	};
	const KEY_HTML = '<span class="key-glyph" aria-hidden="true">ðŸ—ï¸</span>';
	const DOOR_HTML = '<span class="door-glyph" aria-hidden="true">ðŸšª</span>';
	const placeBonusSymbol = (cell, bonusKey) => {
		try {
			if (!cell) return;
			if (cell.classList.contains('void-cell') || cell.classList.contains('bold-cell')) return;
			if (cell.classList.contains('gold-cell') || cell.classList.contains('trap-cell')) return;
			if (cell.classList.contains('key-cell') || cell.classList.contains('door-cell')) return;
			if (cell.querySelector('.symbol')) return;
			const key = String(bonusKey || '').trim().toLowerCase();
			// Hard restrict: scenario 4.1/4.2 only allow green/blue bonuses.
			if (key !== 'green' && key !== 'blue') return;
			const sym = document.createElement('div');
			sym.classList.add('symbol', 'gray', key);
			sym.style.setProperty('--symbol.color', key);
			sym.setAttribute('aria-label', 'Bonus');
			cell.appendChild(sym);
		} catch (e) {}
	};

	// Column placeholders to match main layout so applyBoardHtmlToGame maps zones correctly
	const col1 = document.createElement('div'); col1.className = 'column';
	const col2 = document.createElement('div'); col2.className = 'column';
	const col3 = document.createElement('div'); col3.className = 'column';
	const col4 = document.createElement('div'); col4.className = 'column';

	// For 4.1: rectangular green + wide blue
	if (scenarioId === '4.1') {
		// Green zone (placed in column 2) â€” larger, slightly irregular field
		const gz = document.createElement('div'); gz.className = 'zone'; gz.dataset.color = 'groen'; gz.id = 'green-zone';
		const gg = document.createElement('div'); gg.className = 'grid'; gg.id = 'green-grid'; gg.dataset.rows = '10'; gg.dataset.cols = '10';
		for (let y=0;y<10;y++) for (let x=0;x<10;x++) { const c = document.createElement('div'); c.className='cell'; c.dataset.x=String(x); c.dataset.y=String(y);
			// carve a few void pockets for visual interest
			if ((x===0 || x===9) && (y<2 || y>7)) c.classList.add('void-cell');
			if ((y===0 || y===9) && (x<2 || x>7)) c.classList.add('void-cell');
			gg.appendChild(c); }
		gz.appendChild(gg);
		col2.appendChild(gz);

		// Blue zone (column 3) wide rectangle with varied bands
		const bz = document.createElement('div'); bz.className = 'zone'; bz.dataset.color = 'blauw'; bz.id = 'blue-zone';
		const bg = document.createElement('div'); bg.className = 'grid'; bg.id = 'blue-grid'; bg.dataset.rows = '10'; bg.dataset.cols = '22';
		for (let y=0;y<10;y++) for (let x=0;x<22;x++) { const c = document.createElement('div'); c.className='cell'; c.dataset.x=String(x); c.dataset.y=String(y);
			// create narrow banding: some rows are slightly obstructed for challenge
			if ((y===2 || y===7) && (x%5===0)) c.classList.add('void-cell');
			bg.appendChild(c); }
		bz.appendChild(bg);
		col3.appendChild(bz);

		// Add a simple key+door test:
		// - Key in green unlocks a blue door
		// - Region behind the blue door is locked until door is opened
		try {
			const keyCell = gg.querySelector('.cell[data-x="2"][data-y="2"]');
			if (keyCell && !keyCell.classList.contains('void-cell')) {
				keyCell.classList.add('key-cell');
				keyCell.dataset.keyColor = 'blauw';
				keyCell.dataset.keyConsumed = 'false';
				keyCell.dataset.w4Ink = 'groen';
				ensureSymbol(keyCell, 'key-symbol', KEY_HTML);
			}
			const doorCell = bg.querySelector('.cell[data-x="14"][data-y="3"]');
			if (doorCell && !doorCell.classList.contains('void-cell')) {
				doorCell.classList.add('door-cell');
				doorCell.dataset.doorId = 'sc:4.1:door:blauw:1';
				doorCell.dataset.doorColor = 'blauw';
				doorCell.dataset.w4Ink = 'blauw';
				ensureSymbol(doorCell, 'door-symbol', DOOR_HTML);
				// Lock a larger region "behind" the door
				for (let y = 1; y <= 8; y++) {
					for (let x = 15; x <= 21; x++) {
						const c = bg.querySelector(`.cell[data-x="${x}"][data-y="${y}"]`);
						if (!c || c.classList.contains('void-cell') || c.classList.contains('bold-cell')) continue;
						c.dataset.lockedDoorId = 'sc:4.1:door:blauw:1';
						c.classList.add('locked-behind-door');
					}
				}
			}
			// Bonus symbols: ONLY green/blue (some behind the door)
			placeBonusSymbol(gg.querySelector('.cell[data-x="4"][data-y="4"]'), 'green');
			placeBonusSymbol(bg.querySelector('.cell[data-x="10"][data-y="6"]'), 'blue');
			placeBonusSymbol(bg.querySelector('.cell[data-x="18"][data-y="4"]'), 'blue');
			placeBonusSymbol(gg.querySelector('.cell[data-x="6"][data-y="3"]'), 'green');
			placeBonusSymbol(gg.querySelector('.cell[data-x="7"][data-y="6"]'), 'green');
			placeBonusSymbol(bg.querySelector('.cell[data-x="6"][data-y="2"]'), 'blue');
			placeBonusSymbol(bg.querySelector('.cell[data-x="13"][data-y="8"]'), 'blue');
			// behind the door extra rewards
			placeBonusSymbol(bg.querySelector('.cell[data-x="16"][data-y="2"]'), 'blue');
			placeBonusSymbol(bg.querySelector('.cell[data-x="20"][data-y="7"]'), 'blue');
		} catch (e) {}

		// Keep other columns empty (applyBoardHtmlToGame will hide missing zones)
	}

	// For 4.2: creative shapes + subgoal hints (some void cells + a portal/key)
	if (scenarioId === '4.2') {
		// Green: larger organic island (11x11) with void pockets and start-cells
		const gz = document.createElement('div'); gz.className = 'zone'; gz.dataset.color = 'groen'; gz.id = 'green-zone';
		const gg = document.createElement('div'); gg.className = 'grid'; gg.id = 'green-grid'; gg.dataset.rows = '11'; gg.dataset.cols = '11';
		for (let y=0;y<11;y++) for (let x=0;x<11;x++) {
			const c = document.createElement('div'); c.className='cell'; c.dataset.x=String(x); c.dataset.y=String(y);
			// create organic voids
			if ((Math.abs(x-5)+Math.abs(y-5))>7) c.classList.add('void-cell');
			// bold anchors to guide subgoal placement
			if ((x===5 && (y===2 || y===8)) || ((x===2||x===8) && y===5)) c.classList.add('bold-cell');
			gg.appendChild(c);
		}
		gz.appendChild(gg);
		col2.appendChild(gz);

		// Blue: long winding strip with key
		const bz = document.createElement('div'); bz.className = 'zone'; bz.dataset.color = 'blauw'; bz.id = 'blue-zone';
		const bg = document.createElement('div'); bg.className = 'grid'; bg.id = 'blue-grid'; bg.dataset.rows = '7'; bg.dataset.cols = '24';
		for (let y=0;y<7;y++) for (let x=0;x<24;x++) {
			const c = document.createElement('div'); c.className='cell'; c.dataset.x=String(x); c.dataset.y=String(y);
			// place the key (4.2-style)
			if (x===3 && y===3) {
				c.classList.add('key-cell');
				c.dataset.keyColor = 'groen';
				c.dataset.keyConsumed = 'false';
				c.dataset.w4Ink = 'blauw';
				ensureSymbol(c, 'key-symbol', KEY_HTML);
			}
			// occasional voids to create placement rhythm
			if ((x%7===0) && (y===1 || y===5)) c.classList.add('void-cell');
			bg.appendChild(c);
		}
		bz.appendChild(bg);
		col3.appendChild(bz);

		// Add a green door + a bigger locked region behind it
		try {
			const doorCell = gg.querySelector('.cell[data-x="6"][data-y="5"]');
			if (doorCell && !doorCell.classList.contains('void-cell')) {
				doorCell.classList.add('door-cell');
				doorCell.dataset.doorId = 'sc:4.2:door:groen:1';
				doorCell.dataset.doorColor = 'groen';
				doorCell.dataset.w4Ink = 'groen';
				ensureSymbol(doorCell, 'door-symbol', DOOR_HTML);
				for (let y = 3; y <= 9; y++) {
					for (let x = 7; x <= 10; x++) {
						const c = gg.querySelector(`.cell[data-x="${x}"][data-y="${y}"]`);
						if (!c || c.classList.contains('void-cell') || c.classList.contains('bold-cell')) continue;
						if (c === doorCell) continue;
						c.dataset.lockedDoorId = 'sc:4.2:door:groen:1';
						c.classList.add('locked-behind-door');
					}
				}
			}
		} catch (e) {}
		// Bonus symbols: ONLY green/blue (some behind the door)
		try {
			placeBonusSymbol(gg.querySelector('.cell[data-x="3"][data-y="5"]'), 'green');
			placeBonusSymbol(gg.querySelector('.cell[data-x="9"][data-y="7"]'), 'green');
			placeBonusSymbol(bg.querySelector('.cell[data-x="12"][data-y="3"]'), 'blue');
			placeBonusSymbol(bg.querySelector('.cell[data-x="18"][data-y="5"]'), 'blue');
			placeBonusSymbol(bg.querySelector('.cell[data-x="7"][data-y="1"]'), 'blue');
			// behind the door extra rewards
			placeBonusSymbol(gg.querySelector('.cell[data-x="8"][data-y="6"]'), 'green');
			placeBonusSymbol(gg.querySelector('.cell[data-x="10"][data-y="8"]'), 'green');
		} catch (e) {}
	}

	board.appendChild(col1); board.appendChild(col2); board.appendChild(col3); board.appendChild(col4);
	return board.outerHTML;
}

function showPreLevelChoice(onPick) {
	// Small modal offering 3 multikleur card choices (instantiated from shapePool).
	try {
		const overlayId = 'prelevel-choice-overlay';
		let overlay = document.getElementById(overlayId);
		if (!overlay) {
			overlay = document.createElement('div'); overlay.id = overlayId; overlay.className = 'highscore-modal-overlay';
			overlay.innerHTML = `<div class="highscore-modal"><h2>Kies Ã©Ã©n bonuskaart</h2><div id="prelevel-choices" style="display:flex;gap:8px;flex-wrap:wrap;margin:8px 0"></div><div style="margin-top:8px"><button class="modal-btn" id="prelevel-skip">Sla over</button></div></div>`;
			document.body.appendChild(overlay);
		}
		overlay.classList.add('show');
		const container = document.getElementById('prelevel-choices'); container.innerHTML='';
		// Create 3 options
		const rainbowColor = { name: 'multikleur', code: 'rainbow' };
		for (let i=0;i<3;i++) {
			const shapeEntry = shapePool[(Math.abs(i + Math.floor(Math.random()*shapePool.length)) % shapePool.length)];
			const bp = createCardBlueprint(shapeEntry, rainbowColor);
			const card = instantiateBlueprint(bp);
			const el = createCardElement(card, true, { onSelect: () => {} });
			el.style.cursor='pointer';
			el.addEventListener('click', ()=>{
				overlay.classList.remove('show');
				try { onPick(card); } catch(e){}
			});
			container.appendChild(el);
		}
		document.getElementById('prelevel-skip').onclick = ()=>{ overlay.classList.remove('show'); try{ onPick(null); }catch(e){} };
	} catch (e) { console.error(e); try{ onPick(null); }catch(e){} }
}

function loadScenario(id, meta) {
	const boardHtml = buildScenarioBoardHtml(id);
	applyBoardHtmlToGame(boardHtml);
	// Scenarios 4.1/4.2 are World 4 prototypes: enable the World 4 key/door mechanics.
	try {
		currentWorld = 4;
		document.body.classList.remove('world-1', 'world-2', 'world-3');
		document.body.classList.add('world-4');
	} catch (e) {}
	try {
		// Reset key state for a clean test run, but keep the scenario board intact.
		world4UnlockedColors = new Set();
		window.world4UnlockedColors = world4UnlockedColors;
		if (meta && Array.isArray(meta.allowedColors) && meta.allowedColors.length) {
			setWorld4AllowedColors(meta.allowedColors);
		} else {
			setWorld4AllowedColors(null);
		}
	} catch (e) {}
	const scenarioId = (meta && meta.scenarioId) ? meta.scenarioId : id;
	const objectiveText = (meta && meta.objective != null)
		? meta.objective
		: (String(scenarioId || '').trim().startsWith('4.') ? 'Voltooi alle subdoelen.' : (meta && meta.desc) ? meta.desc : '');
	setLoadedLevelMeta(meta.name, objectiveText, scenarioId);
	// Ensure subgoals are registered immediately (important for restore flows where wrappers may attach later)
	try { registerScenarioSubgoals(scenarioId, meta); } catch (e) {}
	// Restrict visible cards to the scenario colors (Dutch names)
	window.scenarioAllowedColors = meta.allowedColors || null;
	// Reset relevant game state so the scenario always starts with the scenario's
	// own deck/coins/scores rather than the player's current in-progress session.
	try {
		if (typeof resetScoreState === 'function') resetScoreState();
		if (typeof resetCoins === 'function') resetCoins();
	} catch (e) {}

	// Helper: resolve a start-deck entry (blueprint, blueprintId or already-instantiated)
	const resolveToInstance = (spec) => {
		try {
			if (!spec) return null;
			// Already an instantiated card
			if (spec.id && spec.blueprintId) return spec;
			// Full blueprint object
			if (spec.matrix || spec.shapeName) return instantiateBlueprint(spec);
			// String assumed to be a blueprintId; find in ownedBlueprints
			if (typeof spec === 'string') {
				const bp = ownedDeckBlueprints.find(b => (b && (b.blueprintId === spec || b.shapeName === spec)));
				if (bp) return instantiateBlueprint(bp);
			}
		} catch (e) { console.error('resolveToInstance failed', e); }
		return null;
	};

	// Start-deck: prefer explicit meta.startDeck (array of specs). If absent,
	// create a fresh deck composed from owned blueprints but filter by allowed colors.
	if (Array.isArray(meta && meta.startDeck) && meta.startDeck.length) {
		drawPile = shuffleArray((meta.startDeck.map(resolveToInstance).filter(Boolean)));
		discardPile = [];
		currentHand = [];
		turnCount = 0;
	} else {
		// Build fresh draw pile but respect scenarioAllowedColors
		drawPile = shuffleArray(ownedDeckBlueprints.map(bp => instantiateBlueprint(bp)));
		if (Array.isArray(window.scenarioAllowedColors)) {
			const allowed = window.scenarioAllowedColors;
			drawPile = drawPile.filter(c => c && (allowed.includes((c.color && c.color.name) || '') || (c.color && c.color.name) === 'multikleur'));
		}
		discardPile = [];
		currentHand = [];
		turnCount = 0;
	}

	// If meta provides explicit startHand, populate it (instances or specs).
	if (Array.isArray(meta && meta.startHand) && meta.startHand.length) {
		currentHand = meta.startHand.map(resolveToInstance).filter(Boolean);
	}

	// Deal extra starting cards for scenarios (requested for 4.1/4.2 testing).
	try {
		const extra = Math.max(0, Math.floor(Number(meta?.extraStartCards || 0) || 0));
		if (extra > 0) {
			for (let i = 0; i < extra; i += 1) {
				if (!Array.isArray(drawPile) || drawPile.length === 0) break;
				const card = drawPile.shift();
				if (card) currentHand.push(card);
			}
		}
	} catch (e) {}

	// Hard restrict: in scenarios, ensure the starting hand contains only allowed colors (plus multikleur).
	try {
		if (Array.isArray(window.scenarioAllowedColors) && Array.isArray(currentHand)) {
			const allowed = window.scenarioAllowedColors;
			currentHand = currentHand.filter(c => c && (allowed.includes((c.color && c.color.name) || '') || (c.color && c.color.name) === 'multikleur'));
		}
	} catch (e) {}

	// If meta provides startCoins (number), apply to the coin UI
	if (typeof meta?.startCoins === 'number') {
		try {
			const desired = Math.max(0, Math.floor(meta.startCoins));
			const container = document.getElementById('collected-coins');
			if (container) {
				// Ensure there are enough coin elements
				const existing = container.children.length;
				for (let i = existing; i < desired; i++) container.appendChild(createCoinElement(i));
				// Reset all
				container.querySelectorAll('.coin').forEach(el => el.classList.remove('active','used'));
				// Activate the first `desired` coins
				Array.from(container.querySelectorAll('.coin')).slice(0, desired).forEach(el => el.classList.add('active'));
				updateCoinCounter();
			}
		} catch (e) { console.error('Failed to apply startCoins', e); }
	}

	// Offer the pre-level multikleur choice and, if picked, insert it into the current hand
	showPreLevelChoice((pickedCard) => {
		if (pickedCard) {
			// mark and insert the chosen instantiated card into the hand immediately
			pickedCard.isPrelevelChoice = true;
			pickedCard.isUsed = false;
			// ensure identical blueprint isn't in the draw pile (remove exact matches)
			try { drawPile = (drawPile || []).filter(c => c && c.blueprintId !== pickedCard.blueprintId); } catch(e) {}
			currentHand.unshift(pickedCard);
			renderCurrentHand();
		} else {
			renderCurrentHand();
		}
		// keep deck UI aware: render preview and hand
		try { if (typeof updateDeckPreview === 'function') updateDeckPreview(); } catch(e){}
	});
}

// --- Subgoal checks for scenarios ---
function checkGreenHas4x4Square() {
	try {
		const g = document.getElementById('green-grid');
		if (!g) return false;
		const rows = Number(g.dataset.rows) || Math.ceil(Math.sqrt(g.querySelectorAll('.cell').length));
		const cols = Number(g.dataset.cols) || Math.ceil(Math.sqrt(g.querySelectorAll('.cell').length));
		for (let ry = 0; ry <= rows - 4; ry++) {
			for (let cx = 0; cx <= cols - 4; cx++) {
				let ok = true;
				for (let y = 0; y < 4 && ok; y++) {
					for (let x = 0; x < 4; x++) {
						const sel = g.querySelector(`.cell[data-x="${cx + x}"][data-y="${ry + y}"]`);
						if (!sel || sel.classList.contains('void-cell') || !sel.classList.contains('active')) { ok = false; break; }
					}
				}
				if (ok) return true;
			}
		}
	} catch (e) { console.error(e); }
	return false;
}

function checkBluePortalActive() {
	try {
		const b = document.getElementById('blue-grid');
		if (!b) return false;
		const keyCell = b.querySelector('.key-cell');
		if (!keyCell) return false;
		// A "used" key is the actual gate in the mechanics: either consumed flag or unlocked color.
		const consumed = String(keyCell.dataset.keyConsumed || '').toLowerCase() === 'true';
		if (consumed) return true;
		const unlocks = String(keyCell.dataset.keyColor || '').trim().toLowerCase();
		if (unlocks) {
			try { return isWorld4ColorUnlocked(unlocks); } catch (e) { return false; }
		}
		return false;
	} catch (e) { return false; }
}

// If loading scenario 4.2, register its subgoals (first shown only)
(function attachScenarioHooks(){
	const origLoad = window.loadScenario || null;
	window.loadScenario = function(id, meta) {
		if (typeof origLoad === 'function') origLoad(id, meta);
		try {
			// Back-compat: ensure scenario subgoals always register
			registerScenarioSubgoals(id, meta);
		} catch (e) { console.error(e); }
	};
})();

// Helper checks for scenarios
function checkGridHasFilledSquare(gridId, n) {
	try {
		const g = document.getElementById(gridId);
		if (!g) return false;
		const rows = Number(g.dataset.rows) || Math.ceil(Math.sqrt(g.querySelectorAll('.cell').length));
		const cols = Number(g.dataset.cols) || Math.ceil(Math.sqrt(g.querySelectorAll('.cell').length));
		for (let ry = 0; ry <= rows - n; ry++) {
			for (let cx = 0; cx <= cols - n; cx++) {
				let ok = true;
				for (let y = 0; y < n && ok; y++) {
					for (let x = 0; x < n; x++) {
						const sel = g.querySelector(`.cell[data-x="${cx + x}"][data-y="${ry + y}"]`);
						if (!sel || sel.classList.contains('void-cell') || !sel.classList.contains('active')) { ok = false; break; }
					}
				}
				if (ok) return true;
			}
		}
	} catch (e) { console.error(e); }
	return false;
}

function checkGridHasFullColumn(gridId, minHeight) {
	try {
		const g = document.getElementById(gridId);
		if (!g) return false;
		const rows = Number(g.dataset.rows) || Math.ceil(Math.sqrt(g.querySelectorAll('.cell').length));
		const cols = Number(g.dataset.cols) || Math.ceil(Math.sqrt(g.querySelectorAll('.cell').length));
		for (let cx = 0; cx < cols; cx++) {
			let activeCount = 0;
			for (let y = 0; y < rows; y++) {
				const sel = g.querySelector(`.cell[data-x="${cx}"][data-y="${y}"]`);
				if (!sel || sel.classList.contains('void-cell')) { activeCount = 0; break; }
				if (sel.classList.contains('active')) activeCount++; else { activeCount = 0; break; }
			}
			if (activeCount >= minHeight) return true;
		}
	} catch (e) { console.error(e); }
	return false;
}

// Scenario subgoal management
window.scenarioSubgoals = null;
window.currentScenarioSubgoalIndex = -1;
function setScenarioSubgoals(subgoals) {
	window.scenarioSubgoals = Array.isArray(subgoals) ? subgoals : null;
	window.currentScenarioSubgoalIndex = subgoals && subgoals.length ? 0 : -1;
	showCurrentScenarioSubgoal();
}

function showCurrentScenarioSubgoal() {
	try {
		const idx = Number(window.currentScenarioSubgoalIndex || 0);
		if (!window.scenarioSubgoals || idx < 0 || idx >= window.scenarioSubgoals.length) return;
		const sub = window.scenarioSubgoals[idx];
		// Display in objective zone briefly
		const titleEl = document.querySelector('#objective-zone h2');
		const currentEl = document.getElementById('objective-current');
		if (titleEl) titleEl.textContent = sub.title || titleEl.textContent;
		if (currentEl) currentEl.innerHTML = `<strong>Subdoel ${idx+1}:</strong> ${sub.text}`;
	} catch (e) {}
}

function monitorScenarioProgress() {
	try {
		if (!window.scenarioSubgoals || window.currentScenarioSubgoalIndex == null) return;
		const idx = Number(window.currentScenarioSubgoalIndex || 0);
		if (idx < 0 || idx >= window.scenarioSubgoals.length) return;
		const sub = window.scenarioSubgoals[idx];
		if (!sub || typeof sub.check !== 'function') return;
		const ok = !!sub.check();
		if (ok) {
			// show exclamation toast & visual
			showObjectiveToast(`â— ${sub.text} voltooid!`);
			// darken and remove prelevel card from draw if present
			try {
				const pre = currentHand.find(c => c && c.isPrelevelChoice && !c.isUsed);
				if (pre) {
					pre.isUsed = true;
					// remove any exact blueprint matches from drawPile
					drawPile = (drawPile || []).filter(c => c && c.blueprintId !== pre.blueprintId);
				}
				renderCurrentHand();
			} catch (e) {}
			// advance
			window.currentScenarioSubgoalIndex += 1;
			if (window.currentScenarioSubgoalIndex >= window.scenarioSubgoals.length) {
				// all done
				setLoadedLevelMeta(window.loadedCustomLevelMeta?.name || 'Scenario voltooid', 'Alle subdoelen voltooid!');
				window.scenarioSubgoals = null; window.currentScenarioSubgoalIndex = -1;
			} else {
				showCurrentScenarioSubgoal();
			}
		}
	} catch (e) { console.error(e); }
}

	function openEditorWindow() {
		const boardHtml = getEditorBoardHtml();
		try { localStorage.setItem(LOCUS_EDITOR_STORAGE_KEY, boardHtml); } catch (e) {}
		// Open as a separate page (clean separation).
		const w = window.open('editor.html', '_blank');
		if (!w) {
			alert('Popup geblokkeerd. Sta popups toe om de editor te openen.');
			return;
		}
		// Best effort: send immediately (editor also requests on load).
		try {
			w.postMessage({ type: 'LOCUS_EDITOR_BOARD', boardHtml }, '*');
		} catch (e) {}
	}

	// ---------- Scenario sharing (URL + editor bridge) ----------
	function scenarioBase64UrlEncode(text) {
		try {
			if (typeof TextEncoder !== 'undefined') {
				const bytes = new TextEncoder().encode(String(text || ''));
				let bin = '';
				for (let i = 0; i < bytes.length; i++) bin += String.fromCharCode(bytes[i]);
				return btoa(bin).replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/g, '');
			}
			return btoa(unescape(encodeURIComponent(String(text || '')))).replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/g, '');
		} catch (e) {
			return '';
		}
	}
	function scenarioBase64UrlDecode(token) {
		try {
			let t = String(token || '').trim();
			if (!t) return '';
			t = t.replace(/-/g, '+').replace(/_/g, '/');
			while (t.length % 4) t += '=';
			const bin = atob(t);
			if (typeof TextDecoder !== 'undefined') {
				const bytes = new Uint8Array(bin.length);
				for (let i = 0; i < bin.length; i++) bytes[i] = bin.charCodeAt(i);
				return new TextDecoder().decode(bytes);
			}
			return decodeURIComponent(escape(bin));
		} catch (e) {
			return '';
		}
	}
	function encodeScenarioPayload(payloadObj) {
		try { return scenarioBase64UrlEncode(JSON.stringify(payloadObj || {})); } catch (e) { return ''; }
	}

	// Compact URL-safe compressor for scenario payloads. Keeps links much shorter.
	// Uses a small dictionary-based decoder (LZ-style) compatible with the editor.
	// LSB-first bit reading (matches compressor in editor.js)
	const LZ_URL_KEY = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+-$";
	function lzDecompressFromUrlSafe(input) {
		try {
			const str = String(input || '');
			if (!str) return '';
			let val = 0;
			let pos = 6; // Start at 6 to force read on first bit
			let index = 0;
			const readBit = () => {
				if (pos === 6) {
					if (index >= str.length) return 0;
					val = LZ_URL_KEY.indexOf(str.charAt(index++));
					if (val < 0) val = 0;
					pos = 0;
				}
				const bit = (val >> pos) & 1;
				pos++;
				return bit;
			};
			const readBits = (num) => {
				let res = 0;
				for (let i = 0; i < num; i++) {
					res |= readBit() << i;
				}
				return res;
			};

			const dict = [0, 1, 2];
			let enlargeIn = 4;
			let dictSize = 4;
			let numBits = 3;
			let entry = '';
			let result = [];
			let w;

			let next = readBits(2);
			if (next === 0) {
				w = String.fromCharCode(readBits(8));
			} else if (next === 1) {
				w = String.fromCharCode(readBits(16));
			} else {
				return '';
			}
			result.push(w);
			dict[3] = w;

			while (true) {
				if (index > str.length) break;
				next = readBits(numBits);
				let c;
				if (next === 0) {
					c = String.fromCharCode(readBits(8));
					dict[dictSize++] = c;
					next = dictSize - 1;
					enlargeIn--;
				} else if (next === 1) {
					c = String.fromCharCode(readBits(16));
					dict[dictSize++] = c;
					next = dictSize - 1;
					enlargeIn--;
				} else if (next === 2) {
					return result.join('');
				}

				if (enlargeIn === 0) {
					enlargeIn = 1 << numBits;
					numBits++;
				}

				if (dict[next] !== undefined) {
					entry = dict[next];
				} else if (next === dictSize) {
					entry = w + w.charAt(0);
				} else {
					return '';
				}
				result.push(entry);

				// Add new sequence
				dict[dictSize++] = w + entry.charAt(0);
				enlargeIn--;
				w = entry;

				if (enlargeIn === 0) {
					enlargeIn = 1 << numBits;
					numBits++;
				}
			}
			return result.join('');
		} catch (e) {
			return '';
		}
	}
	function decodeScenarioPayload(token) {
		try {
			let t = String(token || '').trim();
			let txt = '';
			if (t.startsWith('lz:')) {
				txt = lzDecompressFromUrlSafe(t.slice(3));
			} else {
				txt = scenarioBase64UrlDecode(t);
			}
			if (!txt) return null;
			return JSON.parse(txt);
		} catch (e) { return null; }
	}

	function escapeHtml(s) {
		return String(s == null ? '' : s)
			.replace(/&/g, '&amp;')
			.replace(/</g, '&lt;')
			.replace(/>/g, '&gt;')
			.replace(/"/g, '&quot;')
			.replace(/'/g, '&#39;');
	}

	function buildBoardHtmlFromData(boardData) {
		try {
			if (!boardData || typeof boardData !== 'object') return '';
			const v = Number(boardData.v || 0);
			if (v !== 1) return '';
			const zones = boardData.zones && typeof boardData.zones === 'object' ? boardData.zones : {};
			const makeCell = (x, y, flags, symbolClass, trapType) => {
				const cls = ['cell'];
				if (flags?.v) cls.push('void-cell');
				if (flags?.b) cls.push('bold-cell');
				if (flags?.e) cls.push('end-cell');
				if (flags?.g) cls.push('gold-cell');
				if (flags?.p) cls.push('portal-cell');
				if (trapType) cls.push('trap-cell');
				const sym = symbolClass ? `<div class="symbol ${escapeHtml(symbolClass)}"></div>` : '';
				const trap = trapType === 'blackHole'
					? `<div class="trap-symbol trap-symbol--black-hole"></div>`
					: (trapType ? `<div class="trap-symbol"></div>` : '');
				const trapAttr = trapType ? ` data-trap-type="${escapeHtml(trapType)}"` : '';
				return `<div class="${cls.join(' ')}" data-x="${x}" data-y="${y}"${trapAttr}>${sym}${trap}</div>`;
			};
			const buildZone = (colorName, z) => {
				if (!z || typeof z !== 'object') return '';
				const rows = Math.max(0, Math.floor(Number(z.rows) || 0));
				const cols = Math.max(0, Math.floor(Number(z.cols) || 0));
				if (!rows || !cols) return '';
				const byKey = new Map();
				(Array.isArray(z.cells) ? z.cells : []).forEach(c => {
					if (!c || typeof c !== 'object') return;
					const x = Math.floor(Number(c.x));
					const y = Math.floor(Number(c.y));
					if (!Number.isFinite(x) || !Number.isFinite(y)) return;
					byKey.set(`${x},${y}`, c);
				});
				let cellsHtml = '';
				for (let y = 0; y < rows; y++) {
					for (let x = 0; x < cols; x++) {
						const c = byKey.get(`${x},${y}`);
						cellsHtml += makeCell(x, y, c, c?.s || '', c?.t || '');
					}
				}
				return `<div class="zone" data-color="${escapeHtml(colorName)}"><div class="grid" data-rows="${rows}" data-cols="${cols}">${cellsHtml}</div></div>`;
			};

			let html = '<div class="board">';
			['groen','geel','paars','blauw'].forEach(color => {
				if (zones[color]) html += buildZone(color, zones[color]);
			});
			const red = boardData.red && typeof boardData.red === 'object' ? boardData.red : null;
			if (red && Array.isArray(red.subs)) {
				let redHtml = '<div class="zone red-group">';
				red.subs.forEach(sub => {
					if (!sub || typeof sub !== 'object') return;
					const rows = Math.max(0, Math.floor(Number(sub.rows) || 0));
					const cols = Math.max(0, Math.floor(Number(sub.cols) || 0));
					if (!rows || !cols) return;
					const byKey = new Map();
					(Array.isArray(sub.cells) ? sub.cells : []).forEach(c => {
						if (!c || typeof c !== 'object') return;
						const x = Math.floor(Number(c.x));
						const y = Math.floor(Number(c.y));
						if (!Number.isFinite(x) || !Number.isFinite(y)) return;
						byKey.set(`${x},${y}`, c);
					});
					let cellsHtml = '';
					for (let y = 0; y < rows; y++) {
						for (let x = 0; x < cols; x++) {
							const c = byKey.get(`${x},${y}`);
							cellsHtml += makeCell(x, y, c, c?.s || '', c?.t || '');
						}
					}
					const idAttr = sub.id ? ` id="${escapeHtml(sub.id)}"` : '';
					redHtml += `<div class="zone"${idAttr} data-rows="${rows}" data-cols="${cols}">${cellsHtml}</div>`;
				});
				redHtml += '</div>';
				html += redHtml;
			}
			html += '</div>';
			return html;
		} catch (e) {
			console.warn('buildBoardHtmlFromData failed', e);
			return '';
		}
	}

	function buildScenarioCardCatalog() {
		try {
			const colors = Array.isArray(NON_WILDCARD_COLORS) ? NON_WILDCARD_COLORS : [];
			const result = [];
			const toTemplateId = (category, shapeName, colorName, isGolden) => {
				const base = `shape:${String(category || '')}:${encodeURIComponent(String(shapeName || ''))}:${encodeURIComponent(String(colorName || ''))}`;
				return isGolden ? `${base}:golden` : base;
			};
			const pushShapeTemplates = (shapeList, category, extras = {}) => {
				if (!Array.isArray(shapeList) || !shapeList.length) return;
				shapeList.forEach(shape => {
					if (!shape || !shape.name || !shape.matrix) return;
					colors.forEach(col => {
						if (!col || !col.name) return;
						const templateId = toTemplateId(category, shape.name, col.name, !!extras.isGolden);
						result.push({
							templateId,
							shapeName: String(shape.name),
							category,
							matrix: cloneShape(shape.matrix),
							colorName: String(col.name),
							colorCode: String(col.code || ''),
							isGolden: !!extras.isGolden,
							isBonusBoost: false
						});
					});
				});
			};

			pushShapeTemplates(CARD_BLUEPRINTS && CARD_BLUEPRINTS.mini, 'mini');
			pushShapeTemplates(CARD_BLUEPRINTS && CARD_BLUEPRINTS.standard, 'standard');
			pushShapeTemplates(CARD_BLUEPRINTS && CARD_BLUEPRINTS.large, 'large');
			pushShapeTemplates(Array.isArray(XL_6_SHAPES) ? XL_6_SHAPES : [], 'xl');
			pushShapeTemplates(Array.isArray(EXTRA_LARGE_7_SHAPES) ? EXTRA_LARGE_7_SHAPES : [], 'extraLarge');
			pushShapeTemplates(CARD_BLUEPRINTS && CARD_BLUEPRINTS.golden, 'golden', { isGolden: true });

			// Bonus Boost: one per bonus color key
			try {
				if (Array.isArray(BONUS_ORDER)) {
					BONUS_ORDER.forEach(key => {
						const meta = BONUS_COLOR_CONFIG && BONUS_COLOR_CONFIG[key] ? BONUS_COLOR_CONFIG[key] : null;
						if (!meta || !meta.colorName) return;
						const templateId = `bonusBoost:${encodeURIComponent(String(key))}`;
						result.push({
							templateId,
							shapeName: 'Bonus Boost',
							category: 'mini',
							matrix: [[1],[1]],
							colorName: String(meta.colorName),
							colorCode: '',
							isGolden: false,
							isBonusBoost: true,
							bonusKey: String(key)
						});
					});
				}
			} catch (e) {}

			return result;
		} catch (e) {
			return [];
		}
	}

	function scenarioTemplateIdFromBlueprint(blueprint) {
		try {
			if (!blueprint) return '';
			if (blueprint.isBonusBoost && blueprint.bonusKey) return `bonusBoost:${encodeURIComponent(String(blueprint.bonusKey))}`;
			const category = String(blueprint.category || 'standard');
			const shapeName = String(blueprint.shapeName || '');
			const colorName = String((blueprint.color && blueprint.color.name) ? blueprint.color.name : '');
			const isGolden = !!(blueprint.isGolden || blueprint.color?.isGolden);
			const base = `shape:${category}:${encodeURIComponent(shapeName)}:${encodeURIComponent(colorName)}`;
			return isGolden ? `${base}:golden` : base;
		} catch (e) {
			return '';
		}
	}

	function buildScenarioUpgradeCatalog() {
		try {
			return Object.keys(UPGRADES || {}).map(id => {
				const u = UPGRADES[id] || {};
				return {
					id,
					name: String(u.name || id),
					description: String(u.description || ''),
					cost: Number(u.cost || 0),
					purchased: !!u.purchased
				};
			});
		} catch (e) { return []; }
	}

	function setScenarioCoinCount(count) {
		try {
			const n = Math.max(0, Math.min(99, Math.floor(Number(count) || 0)));
			const container = document.getElementById('collected-coins');
			if (!container) return;
			// Ensure we have enough coin elements
			const coins = Array.from(container.querySelectorAll('.coin'));
			for (let i = coins.length; i < n; i += 1) {
				try { container.appendChild(createCoinElement(i)); } catch (e) {}
			}
			// Activate first N, deactivate the rest
			Array.from(container.querySelectorAll('.coin')).forEach((coinEl, idx) => {
				if (!coinEl || !coinEl.classList) return;
				coinEl.classList.toggle('active', idx < n);
				coinEl.classList.remove('used');
			});
			try { updateCoinCounter(); } catch (e) {}
		} catch (e) {}
	}

	function applyScenarioSettings(settings) {
		if (!settings || typeof settings !== 'object') return;
		try { window._locusScenarioMode = true; } catch (e) {}

		// World (optional)
		try {
			if (settings.world != null) {
				const w = Math.floor(Number(settings.world));
				if (w === 1 || w === 2 || w === 3 || w === 4) {
					currentWorld = w;
					document.body.classList.remove('world-1', 'world-2', 'world-3', 'world-4');
					document.body.classList.add(`world-${w}`);
				}
			}
		} catch (e) {}

		// Coins
		if (settings.coins != null) {
			setScenarioCoinCount(settings.coins);
		}

		// Upgrades (temporary)
		if (Array.isArray(settings.upgradeIds)) {
			const desired = new Set(settings.upgradeIds.map(x => String(x)));
			Object.keys(UPGRADES || {}).forEach(id => {
				if (!UPGRADES[id]) return;
				UPGRADES[id].purchased = desired.has(id);
			});
			// IMPORTANT: Do NOT run upgrade.onPurchase() here.
			// onPurchase contains runtime side effects (modals, saveGameState, and even rebuildGameBoards)
			// which would overwrite the imported scenario board.
			// If a scenario wants specific content (bonus cards, portals, etc.), it should be encoded in the boardHtml/deckTemplateIds.
			try {
				// Keep portalsActive in sync, but do not randomly place portals.
				portalsActive = desired.has('portals');
				if (!portalsActive) {
					try { clearPortals(); } catch (e) {}
				}
			} catch (e) {}
			try { shapePool = buildShapePool(); } catch (e) {}
		}

		// Deck
		if (Array.isArray(settings.deckTemplateIds) && settings.deckTemplateIds.length) {
			const catalog = buildScenarioCardCatalog();
			const byId = new Map(catalog.map(t => [String(t.templateId), t]));
			const deck = [];
			settings.deckTemplateIds.forEach(tidRaw => {
				const tid = String(tidRaw || '');
				if (!tid) return;
				if (tid.startsWith('bonusBoost:')) {
					const key = decodeURIComponent(tid.slice('bonusBoost:'.length));
					try { deck.push(createBonusBoostCardBlueprint(key)); } catch (e) {}
					return;
				}
				const tpl = byId.get(tid);
				if (!tpl) return;
				const color = { name: tpl.colorName, code: tpl.colorCode || '#ffffff' };
				const shapeEntry = { name: tpl.shapeName, matrix: cloneShape(tpl.matrix), category: tpl.category };
				try {
					deck.push(createCardBlueprint(shapeEntry, color, tpl.isGolden ? { isGolden: true, category: 'golden' } : {}));
				} catch (e) {}
			});
			if (deck.length) {
				ownedDeckBlueprints = deck;
			}
		}
	}

	// Unified loader for anything that represents a custom/scenario board.
	// This avoids the historical bug where some load paths applied only the board
	// while others applied only coins/upgrades/deck.
	function loadScenarioLikeToGame(raw, options = {}) {
		try {
			const src = String(options.source || 'scenario');
			const scenario = (raw && typeof raw === 'object') ? raw : {};

			// Snapshot the current normal run before switching to a scenario/custom board.
			// This enables "Terug naar vorig spel" to restore the exact level + deck/upgrades/coins + board.
			try { capturePreviousNormalRunSnapshot(src); } catch (e) {}

			// Build a normalized settings object.
			const settings = {
				world: scenario.world,
				coins: scenario.coins,
				upgradeIds: Array.isArray(scenario.upgradeIds) ? scenario.upgradeIds : [],
				deckTemplateIds: Array.isArray(scenario.deckTemplateIds) ? scenario.deckTemplateIds : []
			};
			// Allow callers to pass settings as scenarioSettings (editor bridge / saved boards)
			if (scenario.scenarioSettings && typeof scenario.scenarioSettings === 'object') {
				const ss = scenario.scenarioSettings;
				if (ss.world != null) settings.world = ss.world;
				if (ss.coins != null) settings.coins = ss.coins;
				if (Array.isArray(ss.upgradeIds)) settings.upgradeIds = ss.upgradeIds;
				if (Array.isArray(ss.deckTemplateIds)) settings.deckTemplateIds = ss.deckTemplateIds;
			}

			// Apply board
			let boardHtml = '';
			if (typeof scenario.boardHtml === 'string' && scenario.boardHtml.trim()) {
				boardHtml = scenario.boardHtml;
			} else if (scenario.boardData) {
				try { boardHtml = buildBoardHtmlFromData(scenario.boardData) || ''; } catch (e) { boardHtml = ''; }
			}
			if (boardHtml && typeof applyBoardHtmlToGame === 'function') {
				applyBoardHtmlToGame(boardHtml);
				try { window._locusEditorApplied = true; } catch (e) {}
			}

			// Meta
			try {
				const name = (scenario.name != null) ? String(scenario.name) : '';
				const objective = (scenario.objective != null) ? String(scenario.objective) : '';
				if ((name && name.trim()) || (objective && objective.trim())) {
					setLoadedLevelMeta(name || '', objective || '');
				}
			} catch (e) {}

			// Settings + start fresh run
			applyScenarioSettings(settings);
			startScenarioRun();
			try { window._locusScenarioLoaded = true; } catch (e) {}
			try { window._locusScenarioMode = true; } catch (e) {}

			try {
				if (typeof setStatus === 'function' && options.status !== false) {
					const name = (scenario.name != null) ? String(scenario.name) : '';
					setStatus(`${src}: ${name ? '"' + name + '"' : 'scenario'} geladen.`);
				}
			} catch (e) {}
			return true;
		} catch (e) {
			console.error('loadScenarioLikeToGame failed', e);
			return false;
		}
	}

	const LOCUS_PREV_RUN_SNAPSHOT_KEY = 'locusPrevRunSnapshotV1';

	function hasPreviousNormalRunSnapshot() {
		try {
			const raw = localStorage.getItem(LOCUS_PREV_RUN_SNAPSHOT_KEY);
			if (!raw) return false;
			const obj = JSON.parse(raw);
			return !!(obj && obj.gameSave && obj.boardHtmlExact);
		} catch (e) {
			return false;
		}
	}

	function capturePreviousNormalRunSnapshot(reason = '') {
		try {
			if (window && window._locusScenarioMode) return false;
		} catch (e) {}
		try {
			// Ensure the latest run state (including currentLevel/deck/coins/upgrades) is saved.
			if (typeof saveGameState === 'function') {
				try { saveGameState(); } catch (e) {}
			}
			const gameSave = localStorage.getItem('locusGameSave') || null;
			const boardEl = document.getElementById('board');
			const boardHtmlExact = boardEl ? boardEl.outerHTML : null;
			if (!gameSave || !boardHtmlExact) return false;
			const snap = {
				ts: Date.now(),
				reason: String(reason || ''),
				level: (typeof currentLevel !== 'undefined') ? currentLevel : null,
				gameSave,
				boardHtmlExact
			};
			localStorage.setItem(LOCUS_PREV_RUN_SNAPSHOT_KEY, JSON.stringify(snap));
			return true;
		} catch (e) {
			return false;
		}
	}

	function rehydrateTrapsFromDOM() {
		// Rebuild activeTraps list based on DOM (needed after restoring a board snapshot)
		try {
			activeTraps = [];
			trapIdCounter = 0;
			lastTrapHighlightId = null;
			blackHoleTrapPlaced = !!document.querySelector('.cell[data-black-hole="true"], .cell.trap-cell[data-trap-type="blackHole"]');
			trapPenaltyByKey = new Map();
		} catch (e) {}
		
		// First: clean up any trap-triggered state on cells that are no longer active
		document.querySelectorAll('.cell[data-trap-triggered="true"], .cell.trap-triggered').forEach(cell => {
			if (!cell) return;
			// If cell is no longer active but still has triggered state, clear it
			if (!cell.classList.contains('active')) {
				cell.classList.remove('trap-triggered');
				delete cell.dataset.trapTriggered;
				delete cell.dataset.trapInstanceId;
				delete cell.dataset.trapPenaltyApplied;
				delete cell.dataset.trapColorKey;
				delete cell.dataset.trapPenaltyKey;
			}
		});
		
		// Now rebuild from only cells that are both triggered AND active
		const triggered = Array.from(document.querySelectorAll('.cell.active[data-trap-triggered="true"], .cell.active.trap-triggered'));
		// Deduplicate by coordinate to avoid counting placeholder clones
		const seen = new Set();
		triggered.forEach(cell => {
			if (!cell) return;
			// Skip cells inside placeholder zones (clones of real zones)
			if (cell.closest('.zone-placeholder')) return;
			// Deduplicate by zone + coordinates
			const zoneId = normalizeZoneId(cell.dataset.zoneId || cell.closest('.grid')?.id || cell.closest('.zone')?.id || '');
			const x = cell.dataset.x;
			const y = cell.dataset.y;
			const key = (x !== undefined && y !== undefined) ? `${zoneId}|${x}|${y}` : null;
			if (key && seen.has(key)) return;
			if (key) seen.add(key);
			const trapType = cell.dataset.trapType || 'pit';
			const isBlackHole = trapType === 'blackHole' || isBlackHoleCell(cell);
			if (isBlackHole) return;
			const penaltyValue = TRAP_PENALTY;
			if (penaltyValue > 0) {
				applyTrapPenaltyOnce(cell, zoneId, penaltyValue);
			}
			const trapId = nextTrapId();
			cell.dataset.trapTriggered = 'true';
			cell.dataset.trapInstanceId = trapId;
			cell.classList.add('trap-triggered');
			activeTraps.push({
				id: trapId,
				cell,
				zoneId,
				penalty: penaltyValue,
				triggeredAt: Date.now(),
				type: trapType
			});
		});
		renderTrapSummary();
	}

	function restorePreviousNormalRunSnapshot() {
		let snap = null;
		try { snap = JSON.parse(localStorage.getItem(LOCUS_PREV_RUN_SNAPSHOT_KEY) || 'null'); } catch (e) { snap = null; }
		if (!snap || !snap.gameSave || !snap.boardHtmlExact) return false;

		try {
			if (window) {
				window._locusScenarioMode = false;
				window._locusScenarioLoaded = false;
				window._locusRunMode = 'normal';
				window._locusEditorApplied = false;
				window.scenarioAllowedColors = null;
				window.loadedCustomLevelMeta = null;
				window.loadedCustomObjectiveCompiled = null;
				window.loadedCustomLevelMetaCompleted = false;
			}
		} catch (e) {}
		try { portalsActive = false; clearPortals(); } catch (e) {}

		try { localStorage.setItem('locusGameSave', snap.gameSave); } catch (e) {}
		let loaded = false;
		try { if (typeof loadGameState === 'function') loaded = !!loadGameState(); } catch (e) { loaded = false; }
		if (!loaded) return false;

		const applyExactBoard = () => {
			try { if (typeof applyBoardHtmlToGame === 'function') applyBoardHtmlToGame(snap.boardHtmlExact); } catch (e) {}
			try { rehydrateTrapsFromDOM(); } catch (e) {}
			try { if (typeof updateScore === 'function') updateScore(); } catch (e) {}
			try { if (typeof renderTrapSummary === 'function') renderTrapSummary(); } catch (e) {}
			try { requestAnimationFrame(() => requestAnimationFrame(autoCenterScrollableZones)); } catch (e) {}
		};
		try { requestAnimationFrame(() => requestAnimationFrame(applyExactBoard)); } catch (e) { setTimeout(applyExactBoard, 80); }
		return true;
	}

	function startScenarioRun() {
		try {
			lastRoundFailureReason = null;
			resetScoreState();
			freePlacementsRemaining = 0;
			latestScoreSnapshot = { yellow: 0, red: 0, green: 0, purple: 0, blue: 0, bonus: 0, total: 0 };
			resetObjectives();
			currentObjectiveId = null;
			turnCount = 0;
			selectedCardId = null;
			selectedCardElement = null;
			selectedShape = null;
			selectedColor = null;
			try { if (rotateButton) rotateButton.disabled = true; } catch (e) {}
			// Fresh deck from the (scenario) ownedDeckBlueprints
			drawPile = shuffleArray((ownedDeckBlueprints || []).map(bp => instantiateBlueprint(bp)));
			discardPile = [];
			currentHand = [];
			turnCount = 0;
			updateDeckPreview();
			updateTurnCounterDisplay();
			renderCurrentHand();
			drawNextHand();
			updateDeckPreview();
			try { updateScore(); } catch (e) {}
			// Ensure upgrades UI is updated to show purchased state
			try { if (typeof renderUpgradesUI === 'function') renderUpgradesUI(); } catch (e) {}
			try { if (typeof updateShopUI === 'function') updateShopUI(); } catch (e) {}
		} catch (e) { console.error(e); }
	}

	function tryLoadScenarioFromUrl() {
		try {
			try {
				if (window._locusScenarioLoaded) return true;
			} catch (e) {}
			const href = String(window.location && window.location.href || '');
			const url = new URL(href);
			let token = url.searchParams.get('scenario') || '';
			if (!token) {
				// Support hash: #scenario=...
				const h = String(url.hash || '').replace(/^#/, '');
				if (h.startsWith('scenario=')) token = h.slice('scenario='.length);
				else {
					const m = h.match(/(?:^|&)scenario=([^&]+)/);
					if (m && m[1]) token = m[1];
				}
			}
			token = String(token || '').trim();
			if (!token) return false;
			const payload = decodeScenarioPayload(token);
			if (!payload || typeof payload !== 'object') return false;

			// Back-compat: some payloads used 'w'
			if (payload.world == null && payload.w != null) payload.world = payload.w;
			return loadScenarioLikeToGame(payload, { source: 'URL-scenario' });
		} catch (e) {
			console.error('Scenario URL load failed', e);
			return false;
		}
	}

	// === SCENARIO FILE IMPORT ===
	function importScenarioFile() {
		const input = document.createElement('input');
		input.type = 'file';
		input.accept = '.json,.locus.json';
		input.style.display = 'none';
		input.addEventListener('change', async (e) => {
			try {
				const file = input.files && input.files[0];
				if (!file) return;
				const text = await file.text();
				const scenario = JSON.parse(text);
				
				// Validate scenario format
				if (!scenario || scenario._type !== 'locus-scenario') {
					alert('Dit is geen geldig Locus scenario bestand.');
					return;
				}
				
				loadScenarioLikeToGame(scenario, { source: 'Bestand' });
				
				// Close menu if open
				try {
					const menuOverlay = document.getElementById('menu-overlay');
					const menuBtn = document.getElementById('menu-toggle');
					if (menuOverlay) menuOverlay.classList.remove('open');
					if (menuBtn) menuBtn.classList.remove('open');
				} catch (e) {}
				
			} catch (err) {
				console.error('Scenario import failed:', err);
				alert('Kon scenario niet laden: ' + (err.message || 'onbekende fout'));
			}
		});
		document.body.appendChild(input);
		input.click();
		document.body.removeChild(input);
	}
	// Make globally available
	window.importScenarioFile = importScenarioFile;

	window.addEventListener('message', (event) => {
		// Only respond to the opener/child channel we use.
		const data = event && event.data ? event.data : {};
		if (!data) return;
		// Editor requests catalogs so it can show selectable deck/upgrades.
		if (data.type === 'LOCUS_EDITOR_REQUEST_CATALOG') {
			try {
				const cards = buildScenarioCardCatalog();
				const upgrades = buildScenarioUpgradeCatalog();
				const meta = { currentWorld: (typeof currentWorld !== 'undefined') ? currentWorld : null, currentLevel: (typeof currentLevel !== 'undefined') ? currentLevel : null };
				event.source && event.source.postMessage({ type: 'LOCUS_EDITOR_CATALOG', cards, upgrades, meta }, '*');
			} catch (e) {}
			return;
		}
		if (data.type === 'LOCUS_EDITOR_REQUEST_STARTER_DECK') {
			try {
				const blueprints = buildStandardDeckBlueprint();
				const deckTemplateIds = Array.isArray(blueprints)
					? blueprints.map(scenarioTemplateIdFromBlueprint).filter(Boolean)
					: [];
				event.source && event.source.postMessage({ type: 'LOCUS_EDITOR_STARTER_DECK', deckTemplateIds }, '*');
			} catch (e) {}
			return;
		}
		if (data.type === 'LOCUS_EDITOR_REQUEST_BOARD') {
			const boardHtml = getEditorBoardHtml();
			try { localStorage.setItem(LOCUS_EDITOR_STORAGE_KEY, boardHtml); } catch (e) {}
			try { event.source && event.source.postMessage({ type: 'LOCUS_EDITOR_BOARD', boardHtml }, '*'); } catch (e) {}
			return;
		}
		// Accept boards sent from the external editor window
		if (data.type === 'LOCUS_EDITOR_BOARD' && typeof data.boardHtml === 'string') {
			try {
				// Use unified loader so board + settings + meta always stay in sync.
				const merged = {
					boardHtml: data.boardHtml,
					name: data.name || '',
					objective: data.objective || '',
					scenarioSettings: (data.scenarioSettings && typeof data.scenarioSettings === 'object') ? data.scenarioSettings : null
				};
				// If no settings were sent, just apply the board (old behavior).
				if (merged.scenarioSettings || merged.name || merged.objective) {
					loadScenarioLikeToGame(merged, { source: 'Editor' });
				} else {
					applyBoardHtmlToGame(data.boardHtml);
					try { window._locusEditorApplied = true; } catch (e) {}
					if (typeof setStatus === 'function') setStatus('Speelveld geladen vanuit editor.');
				}
			} catch (e) { console.error(e); }
			return;
		}
	});

	// If the page was opened via a scenario share link, we'll load it during initializeGame
	// to avoid merging with a partially-started run.

	function mulberry32(seed) {
		let a = seed >>> 0;
		return function() {
			a |= 0;
			a = (a + 0x6D2B79F5) | 0;
			let t = Math.imul(a ^ (a >>> 15), 1 | a);
			t = (t + Math.imul(t ^ (t >>> 7), 61 | t)) ^ t;
			return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
		};
	}

	function buildGeneratedPrintBoard(world, noBonuses) {
		const includeBonuses = !noBonuses;
		const prefix = `print-${world}-${Date.now().toString(36)}-${Math.random().toString(16).slice(2)}`;
		const staging = document.createElement('div');
		staging.style.position = 'fixed';
		staging.style.left = '-99999px';
		staging.style.top = '-99999px';
		staging.style.width = '1px';
		staging.style.height = '1px';
		staging.style.overflow = 'hidden';
		document.body.appendChild(staging);

		const makeZone = (id, color, child) => {
			const z = document.createElement('div');
			z.className = 'zone';
			z.id = id;
			z.dataset.color = color;
			if (child) z.appendChild(child);
			return z;
		};
		const makeGrid = (id) => {
			const g = document.createElement('div');
			g.className = 'grid';
			g.id = id;
			return g;
		};

		const boardEl = document.createElement('div');
		boardEl.className = 'board';
		const col1 = document.createElement('div');
		col1.className = 'column';
		const col2 = document.createElement('div');
		col2.className = 'column';
		const col3 = document.createElement('div');
		col3.className = 'column';

		const purpleGridId = `${prefix}-purple-grid`;
		const yellowGridId = `${prefix}-yellow-grid`;
		const greenGridId = `${prefix}-green-grid`;
		const blueGridId = `${prefix}-blue-grid`;
		const redZoneId = `${prefix}-red-zone`;
		const red1Id = `${prefix}-red-grid1`;
		const red2Id = `${prefix}-red-grid2`;
		const red3Id = `${prefix}-red-grid3`;
		const red4Id = `${prefix}-red-grid4`;

		const purpleZone = makeZone(`${prefix}-purple-zone`, 'paars', makeGrid(purpleGridId));
		const yellowZone = makeZone(`${prefix}-yellow-zone`, 'geel', makeGrid(yellowGridId));
		const greenZone = makeZone(`${prefix}-green-zone`, 'groen', makeGrid(greenGridId));
		const blueZone = makeZone(`${prefix}-blue-zone`, 'blauw', makeGrid(blueGridId));
		const redZone = document.createElement('div');
		redZone.className = 'zone red-group';
		redZone.id = redZoneId;
		redZone.dataset.color = 'rood';
		const red1 = document.createElement('div'); red1.className = 'zone'; red1.id = red1Id; red1.dataset.color = 'rood';
		const red2 = document.createElement('div'); red2.className = 'zone'; red2.id = red2Id; red2.dataset.color = 'rood';
		const red3 = document.createElement('div'); red3.className = 'zone'; red3.id = red3Id; red3.dataset.color = 'rood';
		const red4 = document.createElement('div'); red4.className = 'zone'; red4.id = red4Id; red4.dataset.color = 'rood';
		redZone.append(red1, red2, red3, red4);

		col1.append(purpleZone, yellowZone);
		col2.append(greenZone, redZone);
		col3.append(blueZone);
		boardEl.append(col1, col2, col3);
		staging.appendChild(boardEl);

		// Seed randomness so print generation is stable-ish.
		const origRandom = Math.random;
		try {
			Math.random = mulberry32(0xC0FFEE + (world === 'world2' ? 2 : 1));
		} catch (_) {}

		try {
			if (world === 'world1') {
				// Yellow (World 1): irregular columns -> rowLengths/offsets
				const yellowColumnHeights = [6, 6, 8, 8, 10, 10, 12, 12, 14, 14];
				const yellowCols = yellowColumnHeights.length;
				const yellowRows = Math.max(...yellowColumnHeights);
				const yellowRowPattern = [];
				const yellowRowOffsets = [];
				for (let r = 0; r < yellowRows; r++) {
					let activeCount = 0;
					for (let c = 0; c < yellowCols; c++) {
						const topRow = yellowRows - yellowColumnHeights[c];
						if (r >= topRow) activeCount++;
					}
					yellowRowPattern.push(activeCount);
					yellowRowOffsets.push(Math.max(0, yellowCols - activeCount));
				}
				createGrid(yellowGridId, yellowRows, yellowCols, {
					symbols: includeBonuses,
					goldCells: includeBonuses,
					minSymbols: includeBonuses ? 8 : 0,
					maxSymbols: includeBonuses ? 12 : 0,
					coinChance: includeBonuses ? 0.2 : 0,
					maxCoins: includeBonuses ? 15 : 0,
					rowLengths: yellowRowPattern,
					rowOffsets: yellowRowOffsets,
					boldColumns: [0],
					trapChance: 0,
					maxTraps: 0,
					blackHoleChance: 0
				});
				createGrid(purpleGridId, 9, 9, {
					symbols: includeBonuses,
					goldCells: includeBonuses,
					minSymbols: includeBonuses ? 6 : 0,
					maxSymbols: includeBonuses ? 8 : 0,
					coinChance: includeBonuses ? 0.03 : 0,
					maxCoins: includeBonuses ? 4 : 0,
					randomBoldCount: 8,
					avoidAdjacentBold: true,
					trapChance: 0,
					maxTraps: 0,
					blackHoleChance: 0
				});
				const blueRowPattern = [2, 2, 3, 3, 3, 2, 2, 3, 3, 2, 2, 3, 3, 3, 2, 2, 3, 3, 2, 2, 3, 3, 2, 3, 3];
				const blueRowOffsets = [1, 1, 1, 0, 0, 1, 2, 2, 2, 3, 2, 2, 1, 1, 1, 0, 0, 0, 1, 2, 2, 2, 3, 2, 1];
				const blueRows = blueRowPattern.length;
				const blueCols = Math.max(...blueRowOffsets.map((o, idx) => o + (blueRowPattern[idx] || 0)), 3);
				createGrid(blueGridId, blueRows, blueCols, {
					boldBottom: true,
					symbols: includeBonuses,
					goldCells: includeBonuses,
					minSymbols: includeBonuses ? 10 : 0,
					maxSymbols: includeBonuses ? 12 : 0,
					coinChance: includeBonuses ? 0.05 : 0,
					maxCoins: includeBonuses ? 6 : 0,
					rowLengths: blueRowPattern,
					rowOffsets: blueRowOffsets,
					trapChance: 0,
					maxTraps: 0,
					blackHoleChance: 0
				});
				generateRoots(greenGridId, 15, 15, 40, 0.25, includeBonuses ? 0.06 : 0, includeBonuses ? 12 : 0, includeBonuses ? 16 : 0, includeBonuses ? 4 : 0, false, 0, 0, 0);
				generateRoots(red1Id, 4, 4, 10, 0.3, includeBonuses ? 0.04 : 0, includeBonuses ? 2 : 0, includeBonuses ? 4 : 0, includeBonuses ? 2 : 0, true, 0, 0, 0, { targetCells: 8, targetPoints: 16, showPointsLabel: true });
				generateRoots(red2Id, 4, 5, 10, 0.3, includeBonuses ? 0.04 : 0, includeBonuses ? 2 : 0, includeBonuses ? 4 : 0, includeBonuses ? 2 : 0, true, 0, 0, 0, { targetCells: 12, targetPoints: 30, showPointsLabel: true });
				generateRoots(red3Id, 5, 5, 12, 0.3, includeBonuses ? 0.06 : 0, includeBonuses ? 3 : 0, includeBonuses ? 5 : 0, includeBonuses ? 2 : 0, true, 0, 0, 0, { targetCells: 16, targetPoints: 40, showPointsLabel: true });
				generateRoots(red4Id, 5, 5, 12, 0.3, includeBonuses ? 0.06 : 0, includeBonuses ? 3 : 0, includeBonuses ? 5 : 0, includeBonuses ? 2 : 0, true, 0, 0, 0, { targetCells: 20, targetPoints: 50, showPointsLabel: true });
			} else {
				// World 2 (print): deterministic shapes that keep proportions.
				createGrid(yellowGridId, 11, 11, {
					symbols: includeBonuses,
					goldCells: includeBonuses,
					minSymbols: includeBonuses ? 5 : 0,
					maxSymbols: includeBonuses ? 7 : 0,
					coinChance: includeBonuses ? 0.07 : 0,
					maxCoins: includeBonuses ? 8 : 0,
					trapChance: 0,
					maxTraps: 0,
					blackHoleChance: 0
				});
				createGrid(purpleGridId, 13, 13, {
					symbols: includeBonuses,
					goldCells: includeBonuses,
					minSymbols: includeBonuses ? 8 : 0,
					maxSymbols: includeBonuses ? 11 : 0,
					coinChance: includeBonuses ? 0.04 : 0,
					maxCoins: includeBonuses ? 6 : 0,
					fixedBoldCells: [[0,0],[0,12],[12,0],[12,12]],
					randomBoldCount: 10,
					avoidAdjacentBold: true,
					randomBoldMinEdgeDistance: 2,
					outerRingShade: includeBonuses,
					trapChance: 0,
					maxTraps: 0,
					blackHoleChance: 0
				});
				const blueRows = 60;
				const blueCols = 18;
				const blueRowPattern = [];
				const blueRowOffsets = [];
				for (let i = 0; i < blueRows; i++) {
					const baseW = (i % 12 === 7) ? 5 : ((i % 5 === 0) ? 4 : 3);
					const w = Math.max(2, Math.min(5, baseW));
					const raw = 4 + Math.round(2 * Math.sin(i / 6));
					const maxOffset = Math.max(0, blueCols - w);
					const off = Math.max(0, Math.min(maxOffset, raw));
					blueRowPattern.push(w);
					blueRowOffsets.push(off);
				}
				createGrid(blueGridId, blueRows, blueCols, {
					boldBottom: true,
					symbols: includeBonuses,
					goldCells: includeBonuses,
					minSymbols: includeBonuses ? 15 : 0,
					maxSymbols: includeBonuses ? 22 : 0,
					coinChance: includeBonuses ? 0.09 : 0,
					maxCoins: includeBonuses ? 16 : 0,
					rowLengths: blueRowPattern,
					rowOffsets: blueRowOffsets,
					trimLeft: true,
					trimRight: true,
					trapChance: 0,
					maxTraps: 0,
					blackHoleChance: 0
				});
				generateRoots(greenGridId, 34, 28, 220, 0.35, includeBonuses ? 0.02 : 0, includeBonuses ? 4 : 0, includeBonuses ? 6 : 0, includeBonuses ? 2 : 0, false, 0, 0, 0);
				generateRoots(red1Id, 4, 5, 14, 0.35, includeBonuses ? 0.03 : 0, includeBonuses ? 2 : 0, includeBonuses ? 3 : 0, includeBonuses ? 2 : 0, true, 0, 0, 0, { targetCells: 8, targetPoints: 16, showPointsLabel: true });
				generateRoots(red2Id, 4, 6, 16, 0.35, includeBonuses ? 0.03 : 0, includeBonuses ? 2 : 0, includeBonuses ? 3 : 0, includeBonuses ? 2 : 0, true, 0, 0, 0, { targetCells: 12, targetPoints: 30, showPointsLabel: true });
				generateRoots(red3Id, 5, 6, 18, 0.35, includeBonuses ? 0.03 : 0, includeBonuses ? 2 : 0, includeBonuses ? 3 : 0, includeBonuses ? 2 : 0, true, 0, 0, 0, { targetCells: 16, targetPoints: 40, showPointsLabel: true });
				generateRoots(red4Id, 5, 6, 20, 0.35, includeBonuses ? 0.03 : 0, includeBonuses ? 2 : 0, includeBonuses ? 3 : 0, includeBonuses ? 2 : 0, true, 0, 0, 0, { targetCells: 20, targetPoints: 50, showPointsLabel: true });
			}
		} finally {
			try { Math.random = origRandom; } catch (_) {}
		}

		// For World 2 prints, mark the green-zone start cell so the print preview can center on it.
		if (world === 'world2') {
			try {
				const greenRoot = staging.querySelector('#' + greenGridId + ' .root-cell');
				if (greenRoot) greenRoot.classList.add('print-focus');
			} catch (e) {}
		}

		if (noBonuses) stripBoardForLowInk(boardEl);
		const html = boardEl.outerHTML;
		try { staging.remove(); } catch { try { staging.parentNode && staging.parentNode.removeChild(staging); } catch {} }
		return html;
	}

	function openPrintWindow(boardHtml, opts) {
		const w = window.open('', '_blank');
		if (!w) {
			alert('Popup geblokkeerd. Sta popups toe om te printen.');
			return;
		}
		const lightMode = false;
		const noBonuses = !!opts.noBonuses;
		const css = `
.@page { size: A4 landscape; margin: 8mm; }
html, body { height: 100%; }
body { margin: 0; padding: 0; background: ${lightMode ? 'white' : '#111'}; color: ${lightMode ? '#111' : '#eee'}; font-family: Arial, sans-serif; }
#print-hide-icons .zone-info-btn, #print-hide-icons .zone-delete, #print-hide-icons .trash-btn,
.zone-info-btn, .zone-delete, .trash-btn { display: none; }
#print-root { width: fit-content; }
.board { display: flex; gap: 14px; align-items: center; transform-origin: top left; }
.column { display: flex; flex-direction: column; gap: 14px; align-items: center; }
.zone { background: transparent; padding: 10px; border-radius: 10px; box-shadow: none; border: 1px solid ${lightMode ? '#b9b9b9' : '#666'}; overflow: visible; max-height: none; }
.zone.red-group { padding 0px; border-radius: 10px; align-self: flex-start; }
.zone[data-color="geel"] { background: ${lightMode ? (noBonuses ? '#fffdf4' : '#fff6cf') : 'transparent'}; }
.zone[data-color="paars"] { background: ${lightMode ? (noBonuses ? '#fdf9ff' : '#f1e7ff') : 'transparent'}; }
.zone[data-color="groen"] { background: ${lightMode ? (noBonuses ? '#f6fff6' : '#e1f7e1') : 'transparent'}; }
.zone[data-color="blauw"] { background: ${lightMode ? (noBonuses ? '#f6fbff' : '#dff1ff') : 'transparent'}; }
.zone[data-color="rood"] { background: ${lightMode ? (noBonuses ? '#fff7f7' : '#ffe3e3') : 'transparent'}; }
.zone.red-group { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; padding: 0px; }
.zone.red-group > .zone { padding: 6px; }
	.grid { display: grid; gap: var(--board-grid-gap,2px); overflow: visible; max-height: none; grid-auto-columns: var(--cell-size); grid-auto-rows: var(--cell-size); }
	.cell { display: block; width: var(--cell-size); height: var(--cell-size); min-width: var(--cell-size); min-height: var(--cell-size); padding: 0; margin: 0; box-sizing: border-box; border: 1px solid ${lightMode ? '#b7b7b7' : '#777'}; background: ${lightMode ? 'rgba(255,255,255,0.92)' : '#1a1a1a'}; border-radius: 4px; }
	.cell.bold-cell { border-style: solid; border-width: 2px; border-color: ${lightMode ? '#2d2d2d' : '#ddd'}; }
	.cell.bold-cell.active { box-shadow: none; }
.cell.void-cell { border-color: transparent; background: transparent; }
.cell.active { background: ${lightMode ? '#f0f0f0' : '#2a2a2a'}; }
	.root-cell { border-radius: 4px; }
/* Zone-specific cell tinting (keeps the board recognizable, subtle tints). */
.zone[data-color="geel"] .cell { background: ${lightMode ? (noBonuses ? '#fffef8' : '#fffbe3') : 'transparent'}; }

.zone[data-color="geel"] .cell.active { background: ${lightMode ? (noBonuses ? '#f6f2d8' : '#efe29c') : 'transparent'}; }

		.zone[data-color="groen"] .cell { background: ${lightMode ? (noBonuses ? '#fbfffb' : '#eef9ee') : 'transparent'}; }
		.zone[data-color="groen"] .cell.active { background: ${lightMode ? (noBonuses ? '#e7f1e7' : '#bfe3bf') : 'transparent'}; }

		.zone[data-color="blauw"] .cell { background: ${lightMode ? (noBonuses ? '#fbfdff' : '#ecf6ff') : 'transparent'}; }
		.zone[data-color="blauw"] .cell.active { background: ${lightMode ? (noBonuses ? '#e5eef7' : '#b7d6f2') : 'transparent'}; }

		.zone[data-color="rood"] .cell { background: ${lightMode ? (noBonuses ? '#fffafb' : '#fff0f0') : 'transparent'}; }
		.zone[data-color="rood"] .cell.active { background: ${lightMode ? (noBonuses ? '#f6e4e4' : '#eeb3b3') : 'transparent'}; }

		/* Normalise all zone cells to the same base appearance so green/red match other grids. */
		.zone .cell { border-radius: 4px; border: 1px solid ${lightMode ? '#b7b7b7' : '#777'}; background: ${lightMode ? 'rgba(255,255,255,0.92)' : '#1a1a1a'}; }
		.zone .cell.active { background: ${lightMode ? '#f0f0f0' : '#2a2a2a'}; }

		/* Keep start/end/bold cells readable without heavy ink. */
		.cell.bold-cell.active { filter: ${lightMode ? 'none' : 'none'}; }
		${noBonuses ? '' : '.cell.gold-cell{outline:1px solid ' + (lightMode ? '#a98c2a' : '#c9a94a') + ';}'}
		${noBonuses ? '.symbol,.trap-symbol,.coin{display:none;}' : ''}
		`;

		// Collect existing page styles (all <style> and linked stylesheets) so print window matches game styling exactly.
		const existingStyles = Array.from(document.querySelectorAll('style, link[rel="stylesheet"]')).map(el => el.outerHTML).join('\n');

		// Determine actual cell size from the current board so printed board keeps on-screen proportions.
		const actualCellSize = (typeof getActualCellSize === 'function') ? getActualCellSize() : (parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--cell-size')) || 26);

		// Build head: include original stylesheets and a minimal set of print-only overrides.
		let htmlClass = (document.documentElement && document.documentElement.className) ? document.documentElement.className : '';
		const printOverrides = `
/* Minimal print overrides: hide UI elements, keep original colors and sizing */
@page { size: A4 landscape; margin: 8mm; }
body { background: transparent; }
.blur-overlay,
#drag-overlay,
#floating-preview,
#placement-zoom-lens,
#mobile-objective-banner,
#bottom-bar,
#card-choice-zone,
#bonus-zone,
#scoreboard,
#objective-zone,
#original-coins-zone,
#gold-zone,
#collected-coins,
#buy-placement-container,
#controls,
#round-modal-layer,
#shop-modal-layer,
#upgrade-modal-layer,
#deck-modal-layer,
#golden-unlock-layer,
#blackhole-modal-layer,
.objective-toast,
.zone-nav-arrow,
.zone-info-btn,
.zone-info-popover { display: none; }

/* Clip content to the zone bounds so grids do not overflow outside their zone */
.zone { overflow: hidden; max-height: none; }

/* Grids should scroll inside their zones if needed; default to auto so clipped content is accessible in preview (but not visually overflowing). */
.grid { display: grid; gap: var(--board-grid-gap,2px); overflow: auto; max-height: none; box-sizing: border-box; }

/* Green zone: center the inner grid so the start cell (print-focus) appears centered. */
.zone[data-color="groen"] .grid,
#green-zone .grid { align-content: center; justify-content: center; height: 100%; }

/* Blue zone: anchor content to the bottom so the grid appears to grow upwards. */
.zone[data-color="blauw"] .grid,
#blue-zone .grid { align-content: end; justify-content: center; height: 100%; }

/* Red zone: keep standard clipping behavior but allow its internal grids to center. */
.zone[data-color="rood"] .grid,
#red-zone .grid { align-content: center; justify-content: center; }

/* Hide native scrollbars in print preview */
* { scrollbar-width: none; -ms-overflow-style: none; }
*::-webkit-scrollbar { display: none; }
`;

		const headContent = existingStyles + '\n' + '<style>' + printOverrides + '</style>';

		const doc = `<!doctype html><html lang="nl" class="${htmlClass}"><head><meta charset="utf-8"><title>Print</title>${headContent}</head>\n<body>\n<div id="print-root">${boardHtml}</div>\n
<script>
(function(){
	function fit(){
		var b = document.querySelector('.board');
		if(!b) return;
		b.style.transform = '';
		b.style.transformOrigin = 'top left';
		var rect = b.getBoundingClientRect();
		var margin = 16;
		var scale = Math.min((window.innerWidth - margin) / rect.width, (window.innerHeight - margin) / rect.height, 1);

		// Try to center the start/root cell in the viewport when present.
		var root = b.querySelector('.print-focus') || b.querySelector('.root-cell') || b.querySelector('.cell.root') || b.querySelector('.cell.start');
		if (root) {
			var rootRect = root.getBoundingClientRect();
			var relX = (rootRect.left - rect.left) + (rootRect.width/2);
			var relY = (rootRect.top - rect.top) + (rootRect.height/2);
			var centerX = window.innerWidth / 2;
			var centerY = window.innerHeight / 2;
			// After scaling, the root center will be at rel*scale. Compute translation so it's at viewport center.
			var tx = centerX - (relX * scale);
			var ty = centerY - (relY * scale);
			// Apply scale first, then translate (translate values are in device pixels after scaling).
			b.style.transform = 'scale(' + scale.toFixed(4) + ') translate(' + tx.toFixed(2) + 'px,' + ty.toFixed(2) + 'px)';
		} else {
			b.style.transform = 'scale(' + scale.toFixed(4) + ')';
		}
	}
	var __autoPrint = ${opts && typeof opts.autoPrint !== 'undefined' ? (opts.autoPrint ? 'true' : 'false') : 'true'};
	window.addEventListener('load', function(){ fit(); if(__autoPrint) setTimeout(function(){ window.print(); }, 200); });
	window.addEventListener('resize', fit);
})();
</scr` + `ipt>
</body></html>`;
		w.document.open();
		w.document.write(doc);
		w.document.close();
	}

	function performPrintFromSettings() {
		const opts = getPrintSettings();
		let boardHtml = '';
		if (opts.source === 'world1') {
			boardHtml = buildGeneratedPrintBoard('world1', opts.noBonuses);
		} else if (opts.source === 'world2') {
			boardHtml = buildGeneratedPrintBoard('world2', opts.noBonuses);
		} else {
			boardHtml = buildPrintBoardFromCurrent(opts.noBonuses);
		}
		openPrintWindow(boardHtml, opts);
	}

	function performPreviewFromSettings() {
		const opts = getPrintSettings();
		let boardHtml = '';
		if (opts.source === 'world1') {
			boardHtml = buildGeneratedPrintBoard('world1', opts.noBonuses);
		} else if (opts.source === 'world2') {
			boardHtml = buildGeneratedPrintBoard('world2', opts.noBonuses);
		} else {
			boardHtml = buildPrintBoardFromCurrent(opts.noBonuses);
		}
		// Open print window but do not auto-invoke window.print()
		openPrintWindow(boardHtml, Object.assign({}, opts, { autoPrint: false }));
	}

	if (printBtn) {
		printBtn.addEventListener('click', (e) => {
			e.preventDefault();
			showPrintSettings();
		});
	}
	if (printSettingsClose) {
		printSettingsClose.addEventListener('click', (e) => {
			e.preventDefault();
			hidePrintSettings();
		});
	}
	if (printSettingsCancel) {
		printSettingsCancel.addEventListener('click', (e) => {
			e.preventDefault();
			hidePrintSettings();
		});
	}
	if (printSettingsPrint) {
		printSettingsPrint.addEventListener('click', (e) => {
			e.preventDefault();
			hidePrintSettings();
			performPrintFromSettings();
		});
	}
	if (printSettingsPreview) {
		printSettingsPreview.addEventListener('click', (e) => {
			e.preventDefault();
			hidePrintSettings();
			performPreviewFromSettings();
		});
	}
	if (editorBtn) {
		editorBtn.addEventListener('click', (e) => {
			e.preventDefault();
			// Close the hamburger menu if open.
			try {
				const menuToggle = document.getElementById('menu-toggle');
				const controls = document.getElementById('controls');
				if (menuToggle) menuToggle.classList.remove('active');
				if (controls) controls.classList.remove('open');
			} catch (err) {}
			openEditorWindow();
		});
	}
	if (printSettingsLayer) {
		printSettingsLayer.addEventListener('click', (e) => {
			if (e.target === printSettingsLayer) hidePrintSettings();
		});
	}
	
	if (confirmCompleteYes) {
	  confirmCompleteYes.addEventListener('click', () => {
		const callback = pendingRoundCompletion;
		hideCompleteRoundConfirm();
		if (typeof callback === 'function') {
			callback();
		} else if (newCardsButton) {
			newCardsButton.focus();
		}
	  });
	}
	if (confirmCompleteNo) {
	  confirmCompleteNo.addEventListener('click', () => {
		hideCompleteRoundConfirm();
		if (newCardsButton) newCardsButton.focus();
	  });
	}
	if (confirmCompleteLayer) {
		confirmCompleteLayer.addEventListener('click', event => {
		  if (event.target === confirmCompleteLayer) {
			hideCompleteRoundConfirm();
			if (newCardsButton) newCardsButton.focus();
		  }
		});
	}
	document.addEventListener('keydown', event => {
		if (event.key !== 'Escape') return;
		if (confirmNewGameLayer && confirmNewGameLayer.classList.contains('show')) {
			hideNewGameConfirm();
			return;
		}
		if (confirmCompleteLayer && confirmCompleteLayer.classList.contains('show')) {
			hideCompleteRoundConfirm();
			if (newCardsButton) newCardsButton.focus();
			return;
		}
		if (blackHoleModalLayer && blackHoleModalLayer.classList.contains('show')) {
			forfeitBlackHoleChallenge();
			return;
		}
		if (deckModalLayer && deckModalLayer.classList.contains('show')) {
			closeDeckModal();
		}
	});
	if (roundModalNext) {
	  const handleRoundNext = () => {
		hideAllModals();
		if (lastRoundWasSuccess) {
		  const upcomingLevel = currentLevel + 1;
		  try {
			const prevWorldInfo = (typeof getWorldAndSubLevel === 'function') ? getWorldAndSubLevel(currentLevel) : { world: 1 };
			const nextWorldInfo = (typeof getWorldAndSubLevel === 'function') ? getWorldAndSubLevel(upcomingLevel) : { world: 1 };
			const prevWorld = Number(prevWorldInfo?.world || 1);
			const nextWorld = Number(nextWorldInfo?.world || 1);
			if (Number.isFinite(prevWorld) && Number.isFinite(nextWorld) && nextWorld > prevWorld) {
				logWorldProgress({
					event: 'world_reached',
					world: nextWorld,
					level: upcomingLevel,
					prevWorld,
					prevLevel: currentLevel
				});
			}
		  } catch (e) {}
		  
		  // BELANGRIJK: Reset ALLE scores EN objectives VOORDAT we currentLevel updaten
		  // Dit voorkomt dat de nieuwe level objective wordt gecontroleerd met oude scores
		  resetScoreState();
		  resetObjectives();
		  document.querySelectorAll('#scoreboard .score').forEach(el => {
			el.textContent = '0';
		  });
		  const totalScoreEl = document.getElementById('total-score');
		  if (totalScoreEl) totalScoreEl.textContent = '0';
		  latestScoreSnapshot = { yellow: 0, red: 0, green: 0, purple: 0, blue: 0, bonus: 0, total: 0 };
		  
		  // NU pas currentLevel updaten
		  currentLevel = upcomingLevel;
		  // Werk de objective header meteen bij (leveltitel verversen)
		  try { setCurrentObjectiveForLevel(currentLevel); } catch (e) {}
		  
		  // Save direct na level completion
		  saveGameState();
		  
		  // Check voor nieuwe unlocks
		  const levelUnlocks = UNLOCK_PROGRESSION.getLevelUnlocks(upcomingLevel, currentWorld);
		  // One-time announcement: traps become relevant after completing level 4.
		  let announceTraps = false;
		  try {
			const trapsIntroKey = 'locus_traps_intro_shown_v1';
			announceTraps = (Number(upcomingLevel) === 5 && !localStorage.getItem(trapsIntroKey));
			if (announceTraps) localStorage.setItem(trapsIntroKey, 'true');
		  } catch {
			announceTraps = (Number(upcomingLevel) === 5);
		  }
		  if (announceTraps) {
			levelUnlocks.features = Array.isArray(levelUnlocks.features) ? levelUnlocks.features : [];
			levelUnlocks.features.push({
				id: 'trapsIntro',
				icon: 'âš ï¸',
				name: 'Traps actief',
				description: 'Pas op voor valkuilen!'
			});
		  }
		  const hasUnlocks = levelUnlocks.cardCategories.length > 0 || levelUnlocks.upgrades.length > 0 || (levelUnlocks.features && levelUnlocks.features.length > 0);
		  
		  if (hasUnlocks) {
			// Toon unlock modal met callback naar shop
			showUnlockModal(levelUnlocks, () => {
				openShopModal(() => startLevel(currentLevel));
			});
		  } else {
			// Geen unlocks, ga direct naar shop
			openShopModal(() => startLevel(currentLevel));
		  }
		} else {
		  startNewRun();
		}
	  };
	  roundModalNext.addEventListener('click', handleRoundNext);
	  roundModalNext.addEventListener('touchend', (e) => {
		e.preventDefault();
		handleRoundNext();
	  });
	}
	if (roundModalRestart) {
	  const handleRestart = () => {
		if (lastRoundWasSuccess) {
			showNewGameConfirm();
			return;
		}
		hideAllModals();
		startNewRun();
	  };
	  roundModalRestart.addEventListener('click', handleRestart);
	  roundModalRestart.addEventListener('touchend', (e) => {
		e.preventDefault();
		handleRestart();
	  });
	}
	if (roundModalCurrentRun) {
	  const handleReturnToCurrentRun = () => {
		hideAllModals();
		// Restore the exact previous run snapshot (level + cards/upgrades/coins + board).
		let restored = false;
		try {
			if (typeof restorePreviousNormalRunSnapshot === 'function') {
				restored = !!restorePreviousNormalRunSnapshot();
			}
		} catch (e) { restored = false; }
		if (!restored) {
			// Fallback to the legacy behavior (best effort)
			try {
				if (window) {
					window._locusScenarioMode = false;
					window._locusScenarioLoaded = false;
					window._locusRunMode = 'normal';
					window._locusEditorApplied = false;
					window.scenarioAllowedColors = null;
					window.loadedCustomLevelMeta = null;
					window.loadedCustomObjectiveCompiled = null;
					window.loadedCustomLevelMetaCompleted = false;
				}
			} catch (e) {}
			try { portalsActive = false; clearPortals(); } catch (e) {}
			let loaded = false;
			try {
				const hasSave = !!localStorage.getItem('locusGameSave');
				if (hasSave && typeof loadGameState === 'function') loaded = !!loadGameState();
			} catch (e) { loaded = false; }
			if (!loaded) startNewRun();
			try { requestAnimationFrame(() => requestAnimationFrame(autoCenterScrollableZones)); } catch (e) {}
		}
	  };
	  roundModalCurrentRun.addEventListener('click', handleReturnToCurrentRun);
	  roundModalCurrentRun.addEventListener('touchend', (e) => {
		e.preventDefault();
		handleReturnToCurrentRun();
	  });
	}
	if (shopModalSkip) {
	  const handleSkipShop = () => skipShop();
	  shopModalSkip.addEventListener('click', handleSkipShop);
	  shopModalSkip.addEventListener('touchend', (e) => {
		e.preventDefault();
		handleSkipShop();
	  });
	}
	
	// Shop modal kruisje handler
	const shopModalClose = document.getElementById('shop-modal-close');
	if (shopModalClose) {
	  const handleCloseShop = () => skipShop();
	  shopModalClose.addEventListener('click', handleCloseShop);
	  shopModalClose.addEventListener('touchend', (e) => {
		e.preventDefault();
		handleCloseShop();
	  });
	}
	
	// Unlock Modal handler - met touch support voor mobiel
	const unlockModalContinue = document.getElementById('unlock-modal-continue');
	if (unlockModalContinue) {
		const handleUnlockContinue = () => {
			hideUnlockModal();
		};
		unlockModalContinue.addEventListener('click', handleUnlockContinue);
		unlockModalContinue.addEventListener('touchend', (e) => {
			e.preventDefault(); // Voorkom dubbele trigger
			handleUnlockContinue();
		});
	}
	
	if (upgradeModalClose) {
	  upgradeModalClose.addEventListener('click', () => {
		upgradeModalLayer?.classList.remove('show');
	  });
	}

	// Rules Modal handlers
	const rulesModalLayer = document.getElementById('rules-modal-layer');
	const rulesModalClose = document.getElementById('rules-modal-close');
	
	window.showRulesModal = function() {
		if (rulesModalLayer) {
			rulesModalLayer.classList.add('show');
		}
	};

	if (rulesModalClose) {
		rulesModalClose.addEventListener('click', () => {
			rulesModalLayer?.classList.remove('show');
		});
	}
	
	if (rulesModalLayer) {
		rulesModalLayer.addEventListener('click', (e) => {
			if (e.target === rulesModalLayer) {
				rulesModalLayer.classList.remove('show');
			}
		});
	}

	const bonusZoneEl = document.getElementById('bonus-zone');
	if (bonusZoneEl) {
	  bonusZoneEl.addEventListener('pointerdown', onBonusPointerDown);
	  bonusZoneEl.addEventListener('click', event => {
		const badge = event.target.closest('.bonus-badge');
		if (badge) event.preventDefault();
	  });
	}
	updateBonusInventoryUI();
	// startNewRun() is verplaatst naar de game initialization functie
	initialiseCoins();
	addCoin();
	
	// Initialiseer de +1 blokplaatsing knop en preview
	const buyPlacementBtn = document.getElementById('buy-placement-btn');
	const purchasedBlockPreview = document.getElementById('purchased-block-preview');
	if (buyPlacementBtn) {
	  buyPlacementBtn.addEventListener('click', (e) => {
		e.stopPropagation();
		onBuyPlacementClick();
	  });
	  buyPlacementBtn.addEventListener('pointerdown', (e) => {
		e.stopPropagation();
	  });
	  buyPlacementBtn.addEventListener('pointerup', (e) => {
		e.stopPropagation();
	  });
	  updateBuyPlacementButton();
	}
	if (purchasedBlockPreview) {
	  // Gebruik pointerdown voor zowel mouse als touch
	  purchasedBlockPreview.addEventListener('pointerdown', (e) => {
		e.stopPropagation();
		e.preventDefault(); // Voorkom touch scroll
		// Capture pointer voor touch devices
		if (e.pointerId !== undefined) {
			try {
				purchasedBlockPreview.setPointerCapture(e.pointerId);
			} catch (err) { /* ignore */ }
		}
		onPurchasedBlockPreviewClick(e);
	  });
	  purchasedBlockPreview.addEventListener('click', (e) => {
		e.stopPropagation();
	  });
	  // Touch events als fallback
	  purchasedBlockPreview.addEventListener('touchstart', (e) => {
		// Niet blokkeren als pointerdown al afgehandeld is
		if (e.defaultPrevented) return;
		e.stopPropagation();
		const touch = e.touches[0];
		if (touch) {
			onPurchasedBlockPreviewClick({
				clientX: touch.clientX,
				clientY: touch.clientY,
				pointerType: 'touch',
				pointerId: touch.identifier
			});
		}
	  }, { passive: false });
	}

  // expose some helpers for debugging
	window.createGrid = createGrid;
	window.generateRoots = generateRoots;
	// Wrap updateScore so scenario monitor runs after each score recalculation
	try {
		window._origUpdateScore = updateScore;
		window.updateScore = function(cell) {
			try { window._origUpdateScore(cell); } catch(e) { try { window._origUpdateScore(cell); } catch(e){} }
			try { if (typeof monitorScenarioProgress === 'function') monitorScenarioProgress(); } catch(e){}
		};
	} catch (e) {
		window.updateScore = updateScore;
	}
  
  
	function hideEmptyZones() {
	const zones = document.querySelectorAll('#original-coins-zone, #original-score-zone, #original-objective-zone, #original-card-zone, #original-controls-zone, #original-bonus-zone');
	  zones.forEach(zone => {
		if (zone.children.length === 0) {
		  zone.style.display = 'none';
		} else {
		  zone.style.display = '';
		}
	  });
	}
 
	function getCardSizing() {
		const isMobile = window.innerWidth <= MOBILE_BREAKPOINT;
		// If we're in a zoomed-in mobile view, prefer measuring the actual
		// rendered cell size from the active zoom zone so card previews use
		// the same cell size as the board.
		try {
			if (document.body.classList.contains('zoomed-in') && typeof activeZoomZone !== 'undefined' && activeZoomZone) {
				const measured = Math.round(getActualCellSize(activeZoomZone));
				return {
					cardSize: isMobile ? 140 : 110,
					cellSize: Number.isFinite(measured) && measured > 6 ? measured : (isMobile ? 14 : 20)
				};
			}
		} catch (e) {}
		return {
			cardSize: isMobile ? 140 : 110,
			cellSize: isMobile ? 14 : 20
		};
	}

	function applyCardSizing() {
	const { cellSize: fallbackCellSize } = getCardSizing();
	const isMobile = window.innerWidth <= (typeof MOBILE_BREAKPOINT !== 'undefined' ? MOBILE_BREAKPOINT : 650);
	const allCards = document.querySelectorAll('#card-choice-zone .card-option, .shop-card .card-option, #deck-modal-content .card-option, #golden-unlock-content .card-option');
	allCards.forEach(card => {
		const cols = parseInt(card.dataset.shapeCols || '0', 10);
		const rows = parseInt(card.dataset.shapeRows || '0', 10);
		const pattern = card.querySelector('.card-pattern');
		const cells = pattern ? pattern.querySelectorAll('.card-cell') : card.querySelectorAll('.card-cell');

		// On mobile, cards inside #bottom-bar use their CSS --preview-cell value;
		// we must actively re-apply it because updateCardPattern may have set
		// board-sized inline styles before the card was in the DOM.
		if (isMobile && card.closest('#bottom-bar')) {
			const cssCellSizeRaw = (getComputedStyle(card).getPropertyValue('--preview-cell') || '').trim();
			const cssCellSize = parseFloat(cssCellSizeRaw);
			const cellSize = Number.isFinite(cssCellSize) && cssCellSize > 0 ? cssCellSize : 8;
			if (pattern && cols) pattern.style.gridTemplateColumns = `repeat(${cols}, ${cellSize}px)`;
			if (pattern && rows) pattern.style.gridTemplateRows = `repeat(${rows}, ${cellSize}px)`;
			cells.forEach(cell => {
			  cell.style.width = `${cellSize}px`;
			  cell.style.height = `${cellSize}px`;
			});
			return;
		}

		const cssCellSizeRaw = (getComputedStyle(card).getPropertyValue('--preview-cell') || '').trim();
		const cssCellSize = parseFloat(cssCellSizeRaw);
		const cellSize = Number.isFinite(cssCellSize) && cssCellSize > 0 ? cssCellSize : fallbackCellSize;
		if (pattern && cols) pattern.style.gridTemplateColumns = `repeat(${cols}, ${cellSize}px)`;
		if (pattern && rows) pattern.style.gridTemplateRows = `repeat(${rows}, ${cellSize}px)`;
		cells.forEach(cell => {
		  cell.style.width = `${cellSize}px`;
		  cell.style.height = `${cellSize}px`;
		});
	});

	const sizingGroups = [
		{ selector: '#card-choice-zone .card-option', extra: 92 },
		{ selector: '#deck-modal-content .card-option', extra: 82 },
		{ selector: '#golden-unlock-content .card-option', extra: 82 },
		{ selector: '.shop-card .card-option', extra: 82 }
	];
	sizingGroups.forEach(group => {
		const cards = Array.from(document.querySelectorAll(group.selector));
		if (!cards.length) return;
		const maxRows = cards.reduce((max, card) => {
			const rows = parseInt(card.dataset.shapeRows || '0', 10);
			return Math.max(max, Number.isFinite(rows) ? rows : 0);
		}, 0);
		const sample = cards[0];
		const cssCellSizeRaw = (getComputedStyle(sample).getPropertyValue('--preview-cell') || '').trim();
		const cssCellSize = parseFloat(cssCellSizeRaw);
		const cellSize = Number.isFinite(cssCellSize) && cssCellSize > 0 ? cssCellSize : fallbackCellSize;
		// Laat de hoogte meeschalen met de inhoud; mobile mag lager en regelbaar via JS.
		let requestedHeight = Math.max(0, (maxRows * cellSize) + group.extra);
		const isMobile = window.innerWidth <= (typeof MOBILE_BREAKPOINT !== 'undefined' ? MOBILE_BREAKPOINT : 650);
		const mobileCap = typeof window.mobileHandHeightCap === 'number' ? window.mobileHandHeightCap : 120;
		const mobileFloor = typeof window.mobileHandHeightFloor === 'number' ? window.mobileHandHeightFloor : 60;
		// Maak hand-kaarten op mobiel ~20% lager (deck-overview formaat) tenzij overschreven.
		if (isMobile && group.selector === '#card-choice-zone .card-option') {
			const handHeightScale = typeof window.mobileHandHeightScale === 'number' ? window.mobileHandHeightScale : 0.8;
			requestedHeight = requestedHeight * handHeightScale;
		}
		const minHeight = isMobile
			? Math.min(Math.max(mobileFloor, requestedHeight), mobileCap)
			: requestedHeight;
		cards.forEach(card => {
			card.style.minHeight = `${minHeight}px`;
			card.style.height = 'auto';
		});

		// Op mobiel: stem de CSS variabele voor hand-kaarten af op de berekende hoogte,
		// zodat de bottom-bar (card-choice-zone) dezelfde hoogte ziet als de inline kaart.
		const isHandGroup = group.selector === '#card-choice-zone .card-option';
		if (isHandGroup && isMobile) {
			document.documentElement.style.setProperty('--hand-card-height', `${minHeight}px`);
		} else if (isHandGroup && !isMobile) {
			// Laat desktop terugvallen op stylesheetwaarden.
			document.documentElement.style.removeProperty('--hand-card-height');
		}
	});
	}

	function applyMobileHandFitForFiveCards() {
		const bottomBar = document.getElementById('bottom-bar');
		if (!bottomBar) return;
		const isMobile = window.innerWidth <= MOBILE_BREAKPOINT;
		if (!isMobile) {
			bottomBar.style.removeProperty('--hand-card-width');
			return;
		}
		const cardControls = document.getElementById('card-controls');
		const cardOptions = document.getElementById('card-options');
		const actionButtons = document.getElementById('card-action-buttons');
		if (!cardControls || !cardOptions || !actionButtons) return;

		const cards = cardOptions.querySelectorAll('.card-option');
		const cardCount = cards.length;
		if (cardCount < 1) {
			bottomBar.style.removeProperty('--hand-card-width');
			return;
		}
		// Only auto-fit when the hand is too wide (e.g. 5+ cards).
		// For 3â€“4 cards we keep the CSS value (so width stays at the requested 32px).
		if (cardCount <= 4) {
			bottomBar.style.removeProperty('--hand-card-width');
			return;
		}

		const rootStyles = getComputedStyle(document.documentElement);
		const cardGap = parseFloat(rootStyles.getPropertyValue('--hand-card-gap')) || 6;
		const controlsGapRaw = getComputedStyle(cardControls).gap || '0px';
		const controlsGap = parseFloat(String(controlsGapRaw).split(' ')[0]) || 0;
		const optionsStyles = getComputedStyle(cardOptions);
		const paddingLeft = parseFloat(optionsStyles.paddingLeft) || 0;
		const paddingRight = parseFloat(optionsStyles.paddingRight) || 0;
		const available = cardControls.clientWidth
			- actionButtons.offsetWidth
			- controlsGap
			- paddingLeft
			- paddingRight;
		if (!(available > 0)) return;

		const targetWidth = Math.floor((available - (cardGap * Math.max(0, cardCount - 1))) / cardCount);
		// Boost de gewenste breedte lichtjes voor meer leesbaarheid (20% default).
		const desired = parseFloat(rootStyles.getPropertyValue('--hand-card-width')) || 40;
		const widthBoost = typeof window.mobileHandWidthBoost === 'number' ? window.mobileHandWidthBoost : 1.2;
		const boostedDesired = desired * widthBoost;
		const fitted = Math.max(32, Math.min(targetWidth, boostedDesired));
		bottomBar.style.setProperty('--hand-card-width', `${fitted}px`);
	}

	function scaleBoardForDesktop() {
		const board = document.getElementById('board');
		if (!board) return;
		const boardContainer = board.parentElement;
		const desktopBottom = document.getElementById('desktop-bottom');
		const desktopWrapper = document.getElementById('desktop-wrapper');
		const isDesktop = window.innerWidth > MOBILE_BREAKPOINT;
		const isMobileSidebar = document.body.classList.contains('mobile-sidebar-layout');
		if (!isDesktop || isMobileSidebar) {
			logLayout('scale:desktop:skip', { isDesktop, isMobileSidebar });
			if (desktopWrapper) {
				desktopWrapper.style.removeProperty('transform');
				desktopWrapper.style.removeProperty('transform-origin');
			}
			board.style.removeProperty('transform');
			board.style.removeProperty('transform-origin');
			if (boardContainer && boardContainer.id === 'desktop-grids') {
				boardContainer.style.removeProperty('justify-content');
			}
			if (desktopBottom) {
				desktopBottom.style.removeProperty('margin-top');
			}
			document.body.classList.remove('board-scaled');
			return;
		}

		if (!desktopWrapper) {
			board.style.removeProperty('transform');
			board.style.removeProperty('transform-origin');
			document.body.classList.remove('board-scaled');
			logLayout('scale:desktop:no-wrapper');
			return;
		}

		// reset inline transforms before measuring
		desktopWrapper.style.removeProperty('transform');
		desktopWrapper.style.removeProperty('transform-origin');

		// Always clear board-only scaling first; we may apply wrapper-level scaling.
		board.style.removeProperty('transform');
		board.style.removeProperty('transform-origin');

		const isPortrait = document.body.classList.contains('desktop-portrait');
		const isLandscape = document.body.classList.contains('desktop-landscape');

		// Desktop-landscape: scale the entire desktop wrapper so board + side UI fit together.
		if (isLandscape) {
			if (boardContainer && boardContainer.id === 'desktop-grids') {
				boardContainer.style.removeProperty('justify-content');
			}
			if (desktopBottom) {
				desktopBottom.style.removeProperty('margin-top');
			}
			document.body.classList.remove('board-scaled');

			// The body has padding: 10px on each side.
			// Be conservative: transformed content + shadows can otherwise get clipped at the viewport edges.
			const viewportW = document.documentElement ? document.documentElement.clientWidth : window.innerWidth;
			const viewportH = document.documentElement ? document.documentElement.clientHeight : window.innerHeight;
			// Margin to avoid edge clipping from shadows/rounding.
			// Keep this modest so the left/right panels don't get unnecessarily cramped.
			const safeMargin = 12;
			const availableWidth = Math.max(viewportW - safeMargin, 280);
			const availableHeight = Math.max(viewportH - safeMargin, 240);
			const contentWidth = desktopWrapper.scrollWidth;
			const contentHeight = desktopWrapper.scrollHeight;
			if (!(contentWidth > 0 && contentHeight > 0)) return;

			let scale = Math.min(availableWidth / contentWidth, availableHeight / contentHeight, 1);
			const needsTabletLandscapeFit = viewportW >= 800 && viewportW <= 1450 && viewportH >= 550 && viewportH <= 850;
			if (needsTabletLandscapeFit) {
				scale = Math.min(scale * 0.95, 1);
			}
			if (scale < 0.999) {
				// Anchor to the left so narrow screens don't waste space on the left,
				// but center it when there is spare horizontal room after scaling.
				desktopWrapper.style.transformOrigin = 'top center';
				const scaledWidth = contentWidth * scale;
				// const offsetX = Math.max(0, (viewportW - scaledWidth) / 2);
				desktopWrapper.style.transform = `scale(${scale.toFixed(4)})`;
			} else {
				desktopWrapper.style.removeProperty('transform');
				desktopWrapper.style.removeProperty('transform-origin');
			}
			return;
		}
		
		// Calculate sidebar widths for landscape mode
		let rightSidebarWidth = 0;
		if (isLandscape) {
			const wrapper = document.getElementById('desktop-wrapper');
			const rightSidebar = wrapper ? wrapper.querySelector('.desktop-right-column, #right-sidebar, [class*="right"]') : null;
			if (rightSidebar) {
				rightSidebarWidth = rightSidebar.offsetWidth || 200;
			} else {
				// Estimate sidebar width based on viewport
				rightSidebarWidth = Math.min(220, window.innerWidth * 0.18);
			}
		}
		
		// Portrait mode: leave more room for bottom bar
		// Landscape mode: account for right sidebar
		// Short height (<=925px): need extra room for compact bottom bar
		const isShortHeight = window.innerHeight <= 925;
		const bottomReserve = isPortrait ? (isShortHeight ? 150 : 160) : 70;
		const horizontalPadding = isPortrait ? 40 : 40;
		const sidebarReserve = isLandscape ? (rightSidebarWidth + 40) : 0; // sidebar + gap
		
		const availableWidth = Math.max(window.innerWidth - horizontalPadding - sidebarReserve, 280);
		const availableHeight = Math.max(window.innerHeight - horizontalPadding - bottomReserve, 200);
		const boardWidth = board.scrollWidth;
		const boardHeight = board.scrollHeight;
		if (!boardWidth || !boardHeight) return;
		logLayout('scale:desktop:measure', { boardWidth, boardHeight, availableWidth, availableHeight, isPortrait, isLandscape });

		// For constrained viewports (925-1650px), be more aggressive with scaling
		const isConstrainedLandscape = isLandscape && window.innerWidth < 1650;
		const maxScale = 1;
		
		const scale = Math.min(availableWidth / boardWidth, availableHeight / boardHeight, maxScale);
		const containerWidth = (boardContainer && boardContainer.clientWidth) ? boardContainer.clientWidth : (window.innerWidth - sidebarReserve);
		const scaledBoardWidth = boardWidth * scale;
		const scaledBoardHeight = boardHeight * scale;
		const offsetX = Math.max((containerWidth - scaledBoardWidth) / 2, 0);

		if (scale < 0.999) {
			// When we scale with CSS transforms, layout width stays unscaled.
			// If the parent is centered flex, this can push the board off to the left.
			// Fix by left-aligning layout and translating the scaled board back to center.
			if (boardContainer && boardContainer.id === 'desktop-grids') {
				boardContainer.style.justifyContent = 'flex-start';
			}
			// Desktop-portrait: compensate for transform-scale whitespace by pulling the bottom UI up.
			// This avoids clipping the board (transform doesn't affect layout height).
			if (isPortrait && desktopBottom) {
				const gap = Math.max(0, Math.round(boardHeight - scaledBoardHeight));
				desktopBottom.style.marginTop = gap ? `-${gap}px` : '';
			} else if (desktopBottom) {
				desktopBottom.style.removeProperty('margin-top');
			}
			board.style.transform = `translateX(${offsetX.toFixed(1)}px) scale(${scale})`;
			board.style.transformOrigin = 'top left';
			document.body.classList.add('board-scaled');
			logLayout('scale:desktop:set', { scale, offsetX, boardWidth, boardHeight, availableWidth, availableHeight });
		} else {
			board.style.removeProperty('transform');
			board.style.removeProperty('transform-origin');
			if (boardContainer && boardContainer.id === 'desktop-grids') {
				boardContainer.style.removeProperty('justify-content');
			}
			if (desktopBottom) {
				desktopBottom.style.removeProperty('margin-top');
			}
			document.body.classList.remove('board-scaled');
			logLayout('scale:desktop:clear');
		}
	}

	function scaleBoardForMobile() {
		const board = document.getElementById('board');
		if (!board) return;
		const isMobile = window.innerWidth <= MOBILE_BREAKPOINT;
		if (!isMobile) {
			document.documentElement.style.removeProperty('--board-scale');
			document.body.classList.remove('board-mobile-scaled');
			logLayout('scale:mobile:skip');
			return;
		}
		const isClassicMode = document.body.classList.contains('classic-mode');
		if (isClassicMode) {
			document.documentElement.style.setProperty('--board-scale', '1');
			document.body.classList.remove('board-mobile-scaled');
			return;
		}

		// Reset any inline desktop transform if we just crossed breakpoints.
		board.style.removeProperty('transform');
		board.style.removeProperty('transform-origin');
		document.body.classList.remove('board-scaled');

		const rootStyles = getComputedStyle(document.documentElement);
		const bottomBar = document.getElementById('bottom-bar');
		const bottomBarMeasured = (!isClassicMode && bottomBar) ? bottomBar.getBoundingClientRect().height : 0;
		const bottomBarCss = isClassicMode ? 0 : (parseFloat(rootStyles.getPropertyValue('--bottom-bar-height')) || 0);
		const bottomBarHeight = Math.max(bottomBarMeasured || 0, bottomBarCss || 0);
		const mobileObjective = document.getElementById('mobile-objective-banner');
		const objectiveHeight = mobileObjective ? mobileObjective.getBoundingClientRect().height : 0;

		// Provide some breathing room so we never render past the edges.
		const horizontalPadding = 16;
		const verticalPadding = 24;
		const availableWidth = Math.max(window.innerWidth - horizontalPadding, 280);
		const availableHeight = Math.max(window.innerHeight - bottomBarHeight - objectiveHeight - verticalPadding, 280);

		const boardWidth = board.scrollWidth;
		const boardHeight = board.scrollHeight;
		if (!boardWidth || !boardHeight) return;
		logLayout('scale:mobile:measure', { boardWidth, boardHeight, availableWidth, availableHeight, bottomBarHeight, objectiveHeight });

		const scaleW = availableWidth / boardWidth;
		const scaleH = availableHeight / boardHeight;
		// If the board is much taller than the viewport (e.g., long scrollable zones),
		// don't let height drive the scale too small; fit to width instead.
		const heightIsTall = boardHeight > (availableHeight * 1.15);
		let scale = Math.min(scaleW, heightIsTall ? 1 : scaleH, 1);
		scale = Math.max(0.25, Math.min(scale, 1));
		document.documentElement.style.setProperty('--board-scale', scale.toFixed(3));
		document.body.classList.add('board-mobile-scaled');
		logLayout('scale:mobile:set', { scale, scaleW, scaleH, heightIsTall });
	}

	// Remove desktop-wrapper when switching layouts to force rebuild
	// Defined before moveGameElements so it can be called from there
	function cleanupDesktopWrapper() {
		const desktopWrapper = document.getElementById('desktop-wrapper');
		if (!desktopWrapper) return;
		
		// Get references to elements that need to be restored
		const board = document.getElementById('board');
		const score = document.getElementById('scoreboard');
		const coins = document.getElementById('gold-zone');
		const objective = document.getElementById('objective-zone');
		const bonus = document.getElementById('bonus-zone');
		const cards = document.getElementById('card-choice-zone');
		const controls = document.getElementById('controls');
		
		// Find original containers
		const origCoins = document.getElementById('original-coins-zone');
		const origScore = document.getElementById('original-score-zone');
		const origCards = document.getElementById('original-card-zone');
		const origBonus = document.getElementById('original-bonus-zone');
		const origObjective = document.getElementById('original-objective-zone');
		
		// Restore elements to original containers
		if (score && origScore && !origScore.contains(score)) {
			origScore.appendChild(score);
		}
		if (coins && origCoins && !origCoins.contains(coins)) {
			origCoins.appendChild(coins);
		}
		if (cards && origCards && !origCards.contains(cards)) {
			origCards.appendChild(cards);
		}
		if (bonus && origBonus && !origBonus.contains(bonus)) {
			origBonus.appendChild(bonus);
		}
		if (objective && origObjective && !origObjective.contains(objective)) {
			origObjective.appendChild(objective);
		}
		
		// Move board back to body (before mobile-landscape-wrapper if it exists)
		const mlWrapper = document.getElementById('mobile-landscape-wrapper');
		if (board && board.parentNode !== document.body) {
			if (mlWrapper) {
				document.body.insertBefore(board, mlWrapper.nextSibling);
			} else {
				// Find a suitable position - after any wrapper containers
				const bottomBar = document.getElementById('bottom-bar');
				if (bottomBar) {
					document.body.insertBefore(board, bottomBar);
				} else {
					document.body.appendChild(board);
				}
			}
		}
		
		// Move controls back to body
		if (controls && controls.parentNode !== document.body) {
			document.body.appendChild(controls);
		}
		
		// Now remove the empty desktop wrapper
		desktopWrapper.remove();
	}

	function runZoneSizingOnce() {
		if (!zoneSizingNeedsRun) return;
		zoneSizingNeedsRun = false;
		try {
			const worldInfo = typeof getWorldAndSubLevel === 'function' ? getWorldAndSubLevel(currentLevel) : null;
			if (worldInfo && (worldInfo.world === 2 || worldInfo.world === 3)) {
				adjustZoneSizesForWorld2();
			}
		} catch (_) {}
		let didSync = false;
		try { didSync = !!syncZoneHeights(); } catch (_) { didSync = false; }
		if (!didSync) {
			zoneSizingNeedsRun = true;
			try { requestAnimationFrame(() => requestAnimationFrame(runZoneSizingOnce)); } catch (_) {}
			return;
		}
		// One-time deferred sync to catch sizing set in rAF inside adjustZoneSizesForWorld2.
		try { requestAnimationFrame(() => { try { syncZoneHeights(); } catch (_) {} }); } catch (_) {}
		try { scheduleGreenCenter({ force: false, allowZoom: false, fallback: true, fallbackDelay: 140 }); } catch (_) {}
	}

	function moveGameElements() {
	  const width = window.innerWidth;
	  const height = window.innerHeight;
	  const isMobile = width <= MOBILE_BREAKPOINT;
	  
	  // Bepaal portrait/landscape primair op basis van afmetingen (iPad/Safari matchMedia kan misrapporteren).
	  const ORIENTATION_EPS = 24; // px tolerance to avoid flapping near-square viewports
	  const effectiveLandscape = (width - height) > ORIENTATION_EPS;
	  const effectivePortrait = (height - width) > ORIENTATION_EPS;
	  // Fallback if near-square
	  const isPortrait = effectivePortrait || (!effectiveLandscape && height >= width);
	  
	  // Touch device check - belangrijk voor onderscheid desktop vs tablet/telefoon
	  // isCoarsePointer() checkt voor touch-primaire devices
	  const isTouchDevice = isCoarsePointer();
	  const isLargeTouchScreen = isTouchDevice && Math.min(width, height) >= 700;
	  
	  // Desktop breakpoints - voor wanneer bottom layout beter is
	  const DESKTOP_NARROW_BREAKPOINT = 800; // Was 925, nu smaller voor meer sidebar gebruik
	  const DESKTOP_SHORT_HEIGHT_BREAKPOINT = 500; // Was 925, nu korter - sidebars werken ook bij korte hoogte
	  
	  // BELANGRIJK: Verschil maken tussen:
	  // 1. Desktop/laptop (muis) â†’ gebruikt normale desktop layout (sidebars of bottom)
	  // 2. Tablet/telefoon (touch) in landscape â†’ gebruikt compacte mobile sidebar layout
	  
	  // Mobile sidebar layout is ALLEEN voor kleine touch screens (phones/small tablets) in landscape.
	  // Grote tablets (iPad) gebruiken de normale desktop layout.
	  const useMobileSidebarLayout = isTouchDevice && !isLargeTouchScreen && effectiveLandscape && 
	                                  width <= MOBILE_BREAKPOINT && height >= 350;
	  
	  const useDesktopLayout = !isMobile && !useMobileSidebarLayout;
	  // Desktop sidebar layout: landscape met voldoende breedte
	  const useDesktopLandscape = useDesktopLayout && effectiveLandscape && width > DESKTOP_NARROW_BREAKPOINT;
	  // Bottom layout: portrait of te smal
	  const isNarrowDesktop = useDesktopLayout && width <= DESKTOP_NARROW_BREAKPOINT;
	  const isShortDesktop = useDesktopLayout && height <= DESKTOP_SHORT_HEIGHT_BREAKPOINT;
	  
	  // Touch device in portrait mode
	  const isTouchPortrait = isTouchDevice && !useMobileSidebarLayout && !effectiveLandscape;
	  
	  // Desktop bottom layout: alleen in portrait of als echt te smal
	  // NIET meer gebaseerd op short height - sidebars werken goed met scroll
	  const useDesktopPortrait = useDesktopLayout && (isPortrait || isNarrowDesktop);
	  
	  // Add body classes for CSS targeting
	  document.body.classList.toggle('mobile-sidebar-layout', useMobileSidebarLayout);
	  document.body.classList.toggle('touch-portrait', isTouchPortrait);
	  document.body.classList.remove('mobile-landscape'); // deprecated class
	  
	  // Desktop classes - ook voor grote tablets (iPad) zodat portrait/landscape correct werkt
	  if (useDesktopLayout) {
		  document.body.classList.toggle('desktop-portrait', useDesktopPortrait);
		  document.body.classList.toggle('desktop-landscape', useDesktopLandscape && !useDesktopPortrait);
	  } else {
		  document.body.classList.remove('desktop-portrait', 'desktop-landscape');
	  }
	logLayout('moveGameElements:mode', {
		width,
		height,
		isMobile,
		isTouchDevice,
		useMobileSidebarLayout,
		useDesktopLayout,
		useDesktopLandscape,
		useDesktopPortrait
	});

		  const coins = document.getElementById('gold-zone');
		  const score = document.getElementById('scoreboard');
		  const objective = document.getElementById('objective-zone');
		  const bonus = document.getElementById('bonus-zone');
		  const cards = document.getElementById('card-choice-zone');
		  const controls = document.getElementById('controls');
		  const board = document.getElementById('board');

			  const bottomBarScore = document.getElementById('bottom-bar-score');
			  const bottomBarRight = document.getElementById('bottom-bar-cards');
			  const bottomBarBonus = document.getElementById('bottom-bar-bonus');
			  const bottomBarCoins = document.getElementById('bottom-bar-coins');
			  const bottomBarScoreCoins = document.getElementById('bottom-bar-score-coins');
		  const mobileObjective = document.getElementById('mobile-objective-banner');
		  
		  // Mobile Sidebar containers
		  const mlWrapper = document.getElementById('mobile-landscape-wrapper');
		  const mlLeft = document.getElementById('ml-sidebar-left');
		  const mlCenter = document.getElementById('ml-board-center');
		  const mlRight = document.getElementById('ml-sidebar-right');
		  const mlObjectiveTop = document.getElementById('ml-objective-top');

	const origCoins = document.getElementById('original-coins-zone');
	const origScore = document.getElementById('original-score-zone');
	const origObjective = document.getElementById('original-objective-zone');
	const origBonus = document.getElementById('original-bonus-zone');
	  const origCards = document.getElementById('original-card-zone');
	  const origControls = document.getElementById('original-controls-zone');

			// === MOBILE LANDSCAPE SIDEBAR LAYOUT ===
			// Dit geldt ALLEEN voor touch devices (tablets/telefoons) in landscape mode
			// Desktop/laptop behoudt normale layout
			if (useMobileSidebarLayout) {
				// Zorg dat de sidebar wrapper elementen bestaan
				if (!mlWrapper || !mlLeft || !mlCenter || !mlRight) {
					console.warn('Mobile landscape wrapper elements not found, cannot use sidebar layout');
				} else {
					logLayout('moveGameElements:mobile-sidebar');
				// Remove desktop wrapper if exists - use centralized cleanup
				if (document.getElementById('desktop-wrapper')) {
					cleanupDesktopWrapper();
				}
				
				// Show wrapper
				mlWrapper.style.display = 'flex';
				
				// Move elements to sidebars
				if (score && !mlLeft.contains(score)) mlLeft.appendChild(score);
				if (coins && !mlLeft.contains(coins)) mlLeft.appendChild(coins);
				
				// Move objective to top of center column
				if (objective && mlObjectiveTop && !mlObjectiveTop.contains(objective)) {
					mlObjectiveTop.appendChild(objective);
					mlObjectiveTop.style.display = 'flex';
				}
				
				if (board && !mlCenter.contains(board)) mlCenter.appendChild(board);
				if (cards && !mlRight.contains(cards)) mlRight.appendChild(cards);
				if (bonus && !mlRight.contains(bonus)) mlRight.appendChild(bonus);
				return;
				}
			}
			
			// Hide mobile sidebar wrapper when not in that mode
			if (mlWrapper) mlWrapper.style.display = 'none';
			if (mlObjectiveTop) mlObjectiveTop.style.display = 'none';

				if (isMobile) {
				logLayout('moveGameElements:mobile-bottom', { classic: document.body.classList.contains('classic-mode') });
				const isClassicMode = document.body.classList.contains('classic-mode');
				// Remove desktop wrapper if exists - use centralized cleanup
				if (document.getElementById('desktop-wrapper')) {
					cleanupDesktopWrapper();
				}
				
					// Move elements to bottom bar sections
					if (score && bottomBarScore && !bottomBarScore.contains(score)) bottomBarScore.appendChild(score);
					if (objective && mobileObjective && !mobileObjective.contains(objective)) mobileObjective.appendChild(objective);
					if (cards && bottomBarRight && !bottomBarRight.contains(cards)) bottomBarRight.appendChild(cards);

					// Mobile footer: row above scoreboard = bonus inventory + coin total + buy button.
					// In classic mode, the bottom bar is hidden: keep coins outside the bottom bar.
					if (bonus && bottomBarBonus && !bottomBarBonus.contains(bonus) && !isClassicMode) bottomBarBonus.appendChild(bonus);
					if (coins && bottomBarBonus && !bottomBarBonus.contains(coins) && !isClassicMode) bottomBarBonus.appendChild(coins);
					if (coins && board && !board.contains(coins) && isClassicMode) board.appendChild(coins);
					const buyPlacementContainer = document.getElementById('buy-placement-container');
					if (buyPlacementContainer && coins && !coins.contains(buyPlacementContainer)) {
						coins.appendChild(buyPlacementContainer);
					}

				if (controls && controls.parentNode !== document.body) document.body.appendChild(controls);
				
			} else {
			closeZoom();
			logLayout('moveGameElements:desktop', { landscape: useDesktopLandscape, portrait: useDesktopPortrait });

				// Ensure the buy button lives inside the coin zone again on desktop.
				const buyPlacementContainer = document.getElementById('buy-placement-container');
				if (buyPlacementContainer && coins && !coins.contains(buyPlacementContainer)) {
					coins.appendChild(buyPlacementContainer);
				}
		
		// Toggle body class for portrait bottom layout (keep both flags consistent)
		document.body.classList.toggle('desktop-portrait', useDesktopPortrait);
		document.body.classList.toggle('desktop-landscape', useDesktopLandscape && !useDesktopPortrait);
		
		// Create desktop wrapper if not exists
		let desktopWrapper = document.getElementById('desktop-wrapper');
		if (!desktopWrapper) {
			desktopWrapper = document.createElement('div');
			desktopWrapper.id = 'desktop-wrapper';
			
			// Create containers
			const desktopMenu = document.createElement('div');
			desktopMenu.id = 'desktop-menu';
			
			const desktopObjective = document.createElement('div');
			desktopObjective.id = 'desktop-objective';
			
			const desktopLeft = document.createElement('div');
			desktopLeft.id = 'desktop-left';
			
			const desktopGrids = document.createElement('div');
			desktopGrids.id = 'desktop-grids';
			
			const desktopRight = document.createElement('div');
			desktopRight.id = 'desktop-right';
			
			const desktopBottom = document.createElement('div');
			desktopBottom.id = 'desktop-bottom';
			
			// Create bottom section columns for portrait mode
			const bottomLeft = document.createElement('div');
			bottomLeft.id = 'desktop-bottom-left';
			const bottomCenter = document.createElement('div');
			bottomCenter.id = 'desktop-bottom-center';
			const bottomButtons = document.createElement('div');
			bottomButtons.id = 'desktop-bottom-buttons';
			const bottomRight = document.createElement('div');
			bottomRight.id = 'desktop-bottom-right';
			
			desktopBottom.appendChild(bottomLeft);
			desktopBottom.appendChild(bottomCenter);
			desktopBottom.appendChild(bottomButtons);
			desktopBottom.appendChild(bottomRight);
			
			desktopWrapper.appendChild(desktopMenu);
			desktopWrapper.appendChild(desktopObjective);
			desktopWrapper.appendChild(desktopLeft);
			desktopWrapper.appendChild(desktopGrids);
			desktopWrapper.appendChild(desktopRight);
			desktopWrapper.appendChild(desktopBottom);					// Insert wrapper before board
					if (board) {
						board.parentNode.insertBefore(desktopWrapper, board);
					}
					
					// Desktop menu toggle is handled by the single #menu-toggle overlay.
				}
				
				// Move elements to desktop positions
				const desktopMenu = document.getElementById('desktop-menu');
				const desktopObjective = document.getElementById('desktop-objective');
				const desktopLeft = document.getElementById('desktop-left');
				const desktopGrids = document.getElementById('desktop-grids');
				const desktopRight = document.getElementById('desktop-right');
				const desktopBottom = document.getElementById('desktop-bottom');
				const bottomLeft = document.getElementById('desktop-bottom-left');
				const bottomCenter = document.getElementById('desktop-bottom-center');
				const bottomButtons = document.getElementById('desktop-bottom-buttons');
				const bottomRight = document.getElementById('desktop-bottom-right');
				
				if (controls && desktopMenu && !desktopMenu.contains(controls)) {
					desktopMenu.appendChild(controls);
				}
				// Remove legacy duplicated desktop toggle if it exists from older versions.
				const legacyDesktopToggle = document.getElementById('desktop-menu-toggle');
				if (legacyDesktopToggle) legacyDesktopToggle.remove();
				if (objective && desktopObjective && !desktopObjective.contains(objective)) {
					desktopObjective.appendChild(objective);
				}
				if (board && desktopGrids && !desktopGrids.contains(board)) {
					desktopGrids.appendChild(board);
				}
				
				if (useDesktopPortrait) {
					// Portrait mode: gebruik bottom layout
					if (score && bottomLeft && !bottomLeft.contains(score)) {
						bottomLeft.appendChild(score);
					}
					if (cards && bottomCenter && !bottomCenter.contains(cards)) {
						bottomCenter.appendChild(cards);
					}
					
					// Move action buttons below cards in portrait mode
					// On touch devices (iPad portrait), buttons should be BELOW cards, not in separate column
					const actionButtons = document.getElementById('card-action-buttons');
					if (actionButtons) {
						// Remove from current parent first
						if (actionButtons.parentNode) {
							actionButtons.parentNode.removeChild(actionButtons);
						}
						// On touch device: add buttons BELOW cards (inside bottomCenter)
						// On non-touch: use separate button zone (bottomButtons)
						if (isTouchDevice && bottomCenter) {
							bottomCenter.appendChild(actionButtons);
						} else if (bottomButtons) {
							bottomButtons.appendChild(actionButtons);
						}
					}
					
					if (bonus && bottomRight && !bottomRight.contains(bonus)) {
						bottomRight.appendChild(bonus);
					}
					// Coins (counter + buy button) under the bonuses in portrait bottom layout.
					if (coins && bottomRight && !bottomRight.contains(coins)) {
						bottomRight.appendChild(coins);
					}
				} else {
					// Landscape mode: gebruik sidebar layout
					if (score && desktopLeft && !desktopLeft.contains(score)) {
						desktopLeft.appendChild(score);
					}
					if (coins && desktopLeft && !desktopLeft.contains(coins)) {
						desktopLeft.appendChild(coins);
					}
					if (cards && desktopRight && !desktopRight.contains(cards)) {
						desktopRight.appendChild(cards);
					}
					
					// In landscape mode, buttons go to separate zone below cards
					const actionButtons = document.getElementById('card-action-buttons');
					if (actionButtons) {
						// Remove from current parent first
						if (actionButtons.parentNode) {
							actionButtons.parentNode.removeChild(actionButtons);
						}
						// Add directly to desktopRight
						if (desktopRight) {
							desktopRight.appendChild(actionButtons);
						}
					}
					
					if (bonus && desktopRight && !desktopRight.contains(bonus)) {
						desktopRight.appendChild(bonus);
					}
				}
						
			}
	  
	  
	}

	function scrollChildIntoView(container, child, opts = {}) {
	  if (!container || !child) return;
	  const alignX = opts.alignX || 'center';
	  const alignY = opts.alignY || 'center';
	  const paddingY = Number.isFinite(opts.paddingY) ? opts.paddingY : 16;
	  const containerRect = container.getBoundingClientRect();
	  const childRect = child.getBoundingClientRect();
	  const currentLeft = container.scrollLeft;
	  const currentTop = container.scrollTop;
	  const deltaLeft = childRect.left - containerRect.left;
	  const deltaTop = childRect.top - containerRect.top;
	  let targetLeft = currentLeft;
	  let targetTop = currentTop;
	  if (alignX === 'center') {
		targetLeft = currentLeft + deltaLeft - (containerRect.width / 2 - childRect.width / 2);
	  }
	  if (alignY === 'center') {
		targetTop = currentTop + deltaTop - (containerRect.height / 2 - childRect.height / 2);
	  } else if (alignY === 'bottom') {
		targetTop = currentTop + deltaTop - (containerRect.height - childRect.height - paddingY);
	  }
	  container.scrollLeft = Math.max(0, targetLeft);
	  container.scrollTop = Math.max(0, targetTop);
	}

	function autoCenterScrollableZones() {
		// Do not auto-center while zoomed-in; it causes jumps on mobile.
		if (document.body.classList.contains('zoomed-in')) return;
	  // Only auto-center when the user hasn't scrolled yet (prevents fighting the player).
	  const greenZone = document.getElementById('green-zone');
	  const greenMem = (() => {
		try { return getZoneScrollMemory('green-zone'); } catch (_) { return null; }
	  })();
	  // World 1: green zone is intentionally non-scrollable (overflow hidden).
	  // Avoid programmatically scrolling it, because that looks like a late layout shift.
	  const greenScrollDisabled = (() => {
		if (!greenZone) return true;
		if (greenZone.classList.contains('no-scroll')) return true;
		try {
			const st = getComputedStyle(greenZone);
			const ox = st.overflowX;
			const oy = st.overflowY;
			return (ox === 'hidden' || ox === 'clip') && (oy === 'hidden' || oy === 'clip');
		} catch (_) {
			return false;
		}
	  })();
	  const greenShouldAutoCenter = !(greenMem && greenMem.normal && greenMem.normal.initialized);
	  if (greenZone && !greenScrollDisabled && greenShouldAutoCenter) {
		try { scheduleGreenCenter({ force: false, allowZoom: false, fallback: true, fallbackDelay: 140 }); } catch (_) {}
	  }

	  const blueZone = document.getElementById('blue-zone');
	  const blueShouldAutoCenter = (() => {
		try {
			const mem = getZoneScrollMemory('blue-zone');
			return !(mem && mem.normal && mem.normal.initialized);
		} catch (_) {
			return true;
		}
	  })();
	  if (blueZone && blueShouldAutoCenter && blueZone.scrollTop <= 2) {
		const boldCells = Array.from(document.querySelectorAll('#blue-grid .cell.bold-cell'));
		if (boldCells.length) {
			const maxY = Math.max(...boldCells.map(cell => Number(cell.dataset.y) || 0));
			const bottomCells = boldCells.filter(cell => (Number(cell.dataset.y) || 0) === maxY);
			bottomCells.sort((a, b) => (Number(a.dataset.x) || 0) - (Number(b.dataset.x) || 0));
			const target = bottomCells[Math.floor(bottomCells.length / 2)] || boldCells[0];
			scrollChildIntoView(blueZone, target, { alignX: 'center', alignY: 'bottom', paddingY: 18 });
		} else {
			blueZone.scrollTop = blueZone.scrollHeight;
			blueZone.scrollLeft = Math.max(0, (blueZone.scrollWidth - blueZone.clientWidth) / 2);
		}
	  }
	}

	// Centralized layout reflow (used on resize/orientation changes)
	let layoutReflowTimer = null;
	let layoutReflowInProgress = false;
	let lastLayoutViewportKey = '';
	let lastLayoutMode = ''; // track layout mode to detect switches
	const LOG_LAYOUT = false; // Set to true for layout debugging
	let pendingReflowKey = null;
	let pendingReflowDelay = 0;

	function logLayout(step, data) {
		if (!LOG_LAYOUT) return;
		const t = (performance && typeof performance.now === 'function') ? performance.now().toFixed(1) : Date.now();
		try {
			console.log(`[layout] ${t} ${step}`, data || '');
		} catch (_) {}
	}

	// Ensure font-dependent sizing settles before scaling/layout steps that measure text.
	function waitForFontsReadyThen(cb) {
		try {
			const ready = document.fonts && document.fonts.ready;
			if (ready && typeof ready.then === 'function') {
				ready.then(() => { try { cb(); } catch (_) {} }).catch(() => { try { cb(); } catch (_) {} });
				return;
			}
		} catch (_) {}
		// Fallback: run on next frame so layout has a chance to settle.
		try { requestAnimationFrame(() => { try { cb(); } catch (_) {} }); } catch (_) { try { cb(); } catch (_) {} }
	}
	function resetLayoutTransforms() {
		try {
			const board = document.getElementById('board');
			if (board) {
				board.style.removeProperty('transform');
				board.style.removeProperty('transform-origin');
				board.style.removeProperty('width');
				board.style.removeProperty('height');
			}
			const desktopWrapper = document.getElementById('desktop-wrapper');
			if (desktopWrapper) {
				desktopWrapper.style.removeProperty('transform');
				desktopWrapper.style.removeProperty('transform-origin');
				desktopWrapper.style.removeProperty('width');
				desktopWrapper.style.removeProperty('height');
			}
			// Reset all desktop layout containers
			['desktop-grids', 'desktop-left', 'desktop-right', 'desktop-bottom', 
			 'desktop-bottom-left', 'desktop-bottom-center', 'desktop-bottom-buttons', 'desktop-bottom-right',
			 'desktop-objective', 'desktop-menu'].forEach(id => {
				const el = document.getElementById(id);
				if (el) {
					el.style.removeProperty('transform');
					el.style.removeProperty('transform-origin');
					el.style.removeProperty('width');
					el.style.removeProperty('height');
					el.style.removeProperty('display');
				}
			});
			// Reset mobile sidebar containers
			['mobile-landscape-wrapper', 'ml-sidebar-left', 'ml-board-center', 'ml-sidebar-right', 'ml-objective-top'].forEach(id => {
				const el = document.getElementById(id);
				if (el) {
					el.style.removeProperty('transform');
					el.style.removeProperty('width');
					el.style.removeProperty('height');
				}
			});
			document.documentElement.style.removeProperty('--board-scale');
		} catch (_) {}
	}
	
	// Determine current layout mode for comparison
	function getCurrentLayoutMode() {
		const width = window.innerWidth;
		const height = window.innerHeight;
		const isMobile = width <= MOBILE_BREAKPOINT;
		const isTouchDevice = isCoarsePointer();
		const isLargeTouchScreen = isTouchDevice && Math.min(width, height) >= 700;
		const ORIENTATION_EPS = 24;
		const effectiveLandscape = (width - height) > ORIENTATION_EPS;
		const useMobileSidebarLayout = isTouchDevice && !isLargeTouchScreen && effectiveLandscape && width <= MOBILE_BREAKPOINT && height >= 350;
		if (useMobileSidebarLayout) return 'mobile-sidebar';
		if (isMobile) return 'mobile';
		const effectivePortrait = (height - width) > ORIENTATION_EPS;
		const isPortrait = effectivePortrait || (!effectiveLandscape && height >= width);
		if (isPortrait || width <= 800) return 'desktop-portrait';
		return 'desktop-landscape';
	}
	
	function reflowLayout() {
		if (layoutReflowInProgress) return;
		layoutReflowInProgress = true;
		logLayout('reflowLayout:start');
		try { document.body.classList.add('layout-reflow'); } catch (_) {}
		
		// Detect layout mode changes and clean up wrapper if needed
		try {
			const currentMode = getCurrentLayoutMode();
			if (lastLayoutMode && lastLayoutMode !== currentMode) {
				logLayout('layoutMode:change', { from: lastLayoutMode, to: currentMode });
				// Layout mode changed - clean up old wrapper to force rebuild
				cleanupDesktopWrapper();
				// Also reset all body layout classes
				document.body.classList.remove('mobile-sidebar-layout', 'touch-portrait', 
					'desktop-portrait', 'desktop-landscape', 'mobile-landscape');
				// Ensure zone sizing runs once for the new layout
				markZoneSizingNeeded();
			}
			lastLayoutMode = currentMode;
		} catch (_) {}
		
		// Step 1: clear stale inline sizing/transforms
		try { resetWorldLayoutStyles(); } catch (_) {}
		try { resetLayoutTransforms(); } catch (_) {}
		logLayout('layout:reset-done');
		// Step 2: re-place DOM blocks for current breakpoint/orientation
		try {
			moveGameElements();
			logLayout('layout:moved');
		} catch (e) {
			logLayout('layout:moved:error', e?.message || e);
		}
		// Step 3: run sizing/spacing on next frames so layout has settled
		try {
			requestAnimationFrame(() => {
				logLayout('layout:rAF-phase1');
				try { hideEmptyZones(); } catch (_) {}
				try { runZoneSizingOnce(); } catch (_) {}
				try { renderTrapSummary(); } catch (_) {}
				try { autoCenterScrollableZones(); } catch (_) {}
				try { placeActionButtons(); } catch (_) {}
				try { applyCardSizing(); } catch (_) {}
				try { applyMobileHandFitForFiveCards(); } catch (_) {}
				try { if (typeof updateHandScrollControls === 'function') updateHandScrollControls(); } catch (_) {}
				try { if (activeZoomZone) applyMobileZoomSizing(activeZoomZone); } catch (_) {}
				try { if (activeZoomZone) schedulePlaceholderSync(activeZoomZone); } catch (_) {}
				requestAnimationFrame(() => {
					// Now scale the board AFTER layout has settled and fonts are ready
					logLayout('layout:rAF-phase2');
					waitForFontsReadyThen(() => {
						try {
							scaleBoardForDesktop();
							logLayout('scale:desktop');
						} catch (e) {
							logLayout('scale:desktop:error', e?.message || e);
						}
						try {
							scaleBoardForMobile();
							logLayout('scale:mobile');
						} catch (e) {
							logLayout('scale:mobile:error', e?.message || e);
						}
						try { document.body.classList.remove('layout-reflow'); } catch (_) {}
						try { document.body.classList.remove('board-loading'); } catch (_) {}
						layoutReflowInProgress = false;
						logLayout('reflowLayout:done');
						if (pendingReflowKey) {
							const nextKey = pendingReflowKey;
							const nextDelay = pendingReflowDelay;
							pendingReflowKey = null;
							pendingReflowDelay = 0;
							if (nextKey === lastLayoutViewportKey) {
								logLayout('reflowLayout:pending-skip-same', { key: nextKey });
							} else {
								// reset last key so the queued run executes
								lastLayoutViewportKey = '';
								scheduleLayoutReflow(nextDelay || 0);
								logLayout('reflowLayout:run-pending', { key: nextKey, delay: nextDelay });
							}
						}
					});
				});
			});
		} catch (_) {
			// Fallback if rAF is blocked
			try {
				scaleBoardForDesktop();
				logLayout('scale:desktop:fallback');
			} catch (e) {
				logLayout('scale:desktop:error:fallback', e?.message || e);
			}
			try {
				scaleBoardForMobile();
				logLayout('scale:mobile:fallback');
			} catch (e) {
				logLayout('scale:mobile:error:fallback', e?.message || e);
			}
			try { document.body.classList.remove('layout-reflow'); } catch (_) {}
			try { document.body.classList.remove('board-loading'); } catch (_) {}
			layoutReflowInProgress = false;
			logLayout('reflowLayout:done:fallback');
			if (pendingReflowKey) {
				const nextKey = pendingReflowKey;
				const nextDelay = pendingReflowDelay;
				pendingReflowKey = null;
				pendingReflowDelay = 0;
				if (nextKey === lastLayoutViewportKey) {
					logLayout('reflowLayout:pending-skip-same', { key: nextKey, fallback: true });
				} else {
					lastLayoutViewportKey = '';
					scheduleLayoutReflow(nextDelay || 0);
					logLayout('reflowLayout:run-pending', { key: nextKey, delay: nextDelay, fallback: true });
				}
			}
		}
	}

	// Initial run
	function scheduleLayoutReflow(delay = 60) {
		const w = Math.round((window.innerWidth || 0) / 10) * 10;
		const h = Math.round((window.innerHeight || 0) / 20) * 20;
		// Include layout mode in key so orientation changes trigger reflow even at same dimensions
		const currentMode = getCurrentLayoutMode();
		const key = `${w}x${h}:${currentMode}`;

		if (layoutReflowInProgress) {
			// Avoid stacking identical requests while a reflow is active.
			if (key === lastLayoutViewportKey || key === pendingReflowKey) {
				logLayout('schedule:pending-skip-same', { key, pending: pendingReflowKey, last: lastLayoutViewportKey });
				return;
			}
			pendingReflowKey = key;
			pendingReflowDelay = delay;
			logLayout('schedule:pending-in-progress', { key, delay });
			return;
		}
		if (key === lastLayoutViewportKey && !layoutReflowInProgress) {
			logLayout('schedule:skip-same-key', { key });
			return;
		}
		lastLayoutViewportKey = key;
		if (layoutReflowTimer) clearTimeout(layoutReflowTimer);
		layoutReflowTimer = setTimeout(() => {
			logLayout('schedule:run', { key, delay });
			try { requestAnimationFrame(reflowLayout); } catch (_) { reflowLayout(); }
		}, delay);
	}
	
	// Laad opgeslagen spel of start nieuw spel (na alle initialisaties)
	// Check EERST of er een save is voordat we iets doen
	(function initializeGame() {
		// Scenario links must take full control and stay isolated from saves/current run.
		try {
			if (typeof tryLoadScenarioFromUrl === 'function' && tryLoadScenarioFromUrl()) {
				if (typeof scheduleLayoutReflow === 'function') scheduleLayoutReflow(0);
				return;
			}
		} catch (e) {}
		const hasSave = localStorage.getItem('locusGameSave');
		// By default do NOT auto-restore save on page reload to avoid surprising persistent decks.
		// Set AUTO_LOAD_SAVED_GAME = true to restore previous behavior.
		const AUTO_LOAD_SAVED_GAME = true;
		if (hasSave && AUTO_LOAD_SAVED_GAME) {
			if (loadGameState()) {
				if (typeof scheduleLayoutReflow === 'function') scheduleLayoutReflow(0);
				return;
			} else {
				console.warn('âš ï¸ Failed to load save, starting new game');
			}
		} else {
		}
		
		// Als we hier komen: geen save of laden mislukt
		startNewRun();
		if (typeof scheduleLayoutReflow === 'function') scheduleLayoutReflow(0);
	})();

	// Run again on resize/orientation with a stable reflow
	const handleViewportChange = () => scheduleLayoutReflow(120);
	window.addEventListener('resize', handleViewportChange, { passive: true });
	window.addEventListener('orientationchange', () => {
		// Force reflow on orientation change - reset the viewport key to ensure it triggers
		lastLayoutViewportKey = '';
		lastLayoutMode = '';
		scheduleLayoutReflow(180);
	}, { passive: true });
	if (window.visualViewport) {
		// visualViewport resize triggers frequent mid-frame reflows on mobile; rely on window resize only.
	}

	// Menu toggle handled earlier (removed duplicate handler)
	
	// ========================================
	// HIGH SCORE SYSTEM (ADDED)
	// ========================================
	
	function getHighScore() {
		return Number(localStorage.getItem('locusHighScore') || '0');
	}

	function updateHighScore(currentScore) {
		const oldHigh = getHighScore();
		if (currentScore > oldHigh) {
			localStorage.setItem('locusHighScore', String(currentScore));
			showHighScorePopup(currentScore);
		}
	}

	function showHighScorePopup(score) {
		// Remove existing
		document.querySelectorAll('.highscore-toast').forEach(el => el.remove());
		
		const popup = document.createElement('div');
		popup.className = 'highscore-toast';
		popup.innerHTML = `
			<span class="highscore-toast__icon">ðŸ†</span>
			<div>
				<div>Nieuw record!</div>
				<div class="highscore-toast__score">${score}</div>
			</div>
		`;
		document.body.appendChild(popup);
		
		// Auto remove
		setTimeout(() => {
			popup.style.transition = 'opacity 0.5s ease, transform 0.5s ease';
			popup.style.opacity = '0';
			popup.style.transform = 'translate(-50%, -20px) scale(0.9)';
			setTimeout(() => popup.remove(), 500);
		}, 3000);
	}

	function showHighScoreModal() {
		// Create modal if not exists
		let overlay = document.getElementById('highscore-modal-layer');
		if (!overlay) {
			overlay = document.createElement('div');
			overlay.id = 'highscore-modal-layer';
			overlay.className = 'highscore-modal-overlay';
			overlay.innerHTML = `
				<div class="highscore-modal">
					<h2>ðŸ† High Score</h2>
					<div class="highscore-value" id="modal-highscore-value">0</div>
					<button class="highscore-close-btn" onclick="closeHighScoreModal()">Sluiten</button>
				</div>
			`;
			document.body.appendChild(overlay);
			
			// Close on click outside
			overlay.addEventListener('click', (e) => {
				if (e.target === overlay) closeHighScoreModal();
			});
		}
		
		// Update value
		document.getElementById('modal-highscore-value').textContent = getHighScore();
		
		// Show
		overlay.classList.add('show');
		
		// Close menu if open
		const controls = document.getElementById('controls');
		const menuToggle = document.getElementById('menu-toggle');
		if (controls) controls.classList.remove('open');
		if (menuToggle) menuToggle.classList.remove('active');
	}

	function closeHighScoreModal() {
		const overlay = document.getElementById('highscore-modal-layer');
		if (overlay) overlay.classList.remove('show');
	}

	function showSavedLevelsModal() {
		let overlay = document.getElementById('saved-levels-modal');
		if (!overlay) {
			overlay = document.createElement('div');
			overlay.id = 'saved-levels-modal';
			overlay.className = 'highscore-modal-overlay';
			overlay.innerHTML = `
				<div class="highscore-modal">
					<h2>Opgeslagen levels</h2>
					<div id="saved-levels-list" style="max-height:420px; overflow:auto; padding-right:8px;"></div>
					<div style="margin-top:12px;"><button class="modal-btn" onclick="closeSavedLevelsModal()">Sluit</button></div>
				</div>
			`;
			document.body.appendChild(overlay);
			overlay.addEventListener('click', (e) => { if (e.target === overlay) closeSavedLevelsModal(); });
		}
		// populate list
		const list = document.getElementById('saved-levels-list');
		list.innerHTML = '';

		// Append example scenarios for quick testing (World 4 prototypes)
		const examplesHeader = document.createElement('div');
		examplesHeader.style.marginBottom = '8px';
		examplesHeader.innerHTML = '<div class="saved-title">Voorbeeld-scenario\'s (World 4)</div>';
		list.appendChild(examplesHeader);

		const examples = [
		  { id: 'world4-4.1', name: 'Wereld 4.1 - Groen + Blauw', desc: 'Rechthoekige groen + brede blauwe zone. Test: sleutel + deur met afgesloten gebied.', objective: 'Voltooi de subdoelen en open de deur met de sleutel.', allowedColors: ['groen','blauw'], extraStartCards: 3, scenarioId: '4.1' },
		  { id: 'world4-4.2', name: 'Wereld 4.2 - Vormen & Deur', desc: 'Creatieve vormen + sleutel in blauw; deur in groen met groter afgesloten gebied.', objective: 'Voltooi subdoelen: 4Ã—4 in groen, gebruik sleutel, open deur.', allowedColors: ['groen','blauw'], extraStartCards: 3, scenarioId: '4.2' }
		];
		examples.forEach(ex => {
		  const item = document.createElement('div');
		  item.style.display = 'flex'; item.style.gap = '8px'; item.style.alignItems = 'center'; item.style.marginBottom = '8px';
		  const label = document.createElement('div'); label.style.flex = '1';
		  const titleText = document.createElement('div'); titleText.textContent = ex.name; titleText.style.fontWeight = '600'; titleText.className = 'saved-title';
		  const objText = document.createElement('div'); objText.className = 'saved-obj-text'; objText.textContent = ex.objective || ex.desc;
		  label.appendChild(titleText); label.appendChild(objText);
		  const loadBtn = document.createElement('button'); loadBtn.textContent = 'Laad in spel'; loadBtn.className = 'modal-btn primary';
		  loadBtn.addEventListener('click', ()=>{ loadScenario(ex.scenarioId, ex); closeSavedLevelsModal(); });
		  item.appendChild(label); item.appendChild(loadBtn);
		  list.appendChild(item);
		});
		let saved = {};
		try {
			const raw = localStorage.getItem('locusSavedBoards');
			if (raw) {
				try {
					saved = JSON.parse(raw || '{}');
				} catch (err) {
					console.error('Failed to parse locusSavedBoards JSON:', err, 'raw length:', raw.length);
					console.error('Raw locusSavedBoards starts with:', String(raw).slice(0, 200));
					saved = {};
				}
			} else saved = {};
		} catch (e) { console.error('Error reading locusSavedBoards from localStorage', e); saved = {}; }
		// Also check for an existing backup of the current game session
		let backup = null;
		try { backup = JSON.parse(localStorage.getItem('locusGameSaveBackup') || 'null'); } catch (e) { backup = null; }
		const names = Object.keys(saved).sort((a,b)=>(saved[b].ts||0)-(saved[a].ts||0));
		if (!names.length && !backup) {
			list.textContent = 'Geen opgeslagen levels.';
		} else {
			names.forEach(n => {
				const item = document.createElement('div');
				item.style.display = 'flex'; item.style.gap = '8px'; item.style.alignItems = 'center'; item.style.marginBottom = '8px';
				const label = document.createElement('div'); label.style.flex = '1';
				const titleText = document.createElement('div'); titleText.textContent = n; titleText.style.fontWeight = '600'; titleText.className = 'saved-title';
				const objText = document.createElement('div'); objText.className = 'saved-obj-text';
				objText.textContent = saved[n].objective ? saved[n].objective : 'Geen doel (standaard: Haal 100 punten)';
				label.appendChild(titleText); label.appendChild(objText);
				const openEditorBtn = document.createElement('button'); openEditorBtn.textContent = 'Open in Editor'; openEditorBtn.className = 'modal-btn';
				openEditorBtn.addEventListener('click', ()=>{
					try { localStorage.setItem('locusEditorBoardHtml', saved[n].html); } catch (e) {}
					const w = window.open('editor.html', '_blank');
					if (w) try {
						w.postMessage({
							type:'LOCUS_EDITOR_BOARD',
							boardHtml: saved[n].html,
							name: saved[n].name || n,
							objective: saved[n].objective || null,
							scenarioSettings: (saved[n].scenarioSettings && typeof saved[n].scenarioSettings === 'object') ? saved[n].scenarioSettings : null
						}, '*');
					} catch (e) {}
				});
				const loadBtn = document.createElement('button'); loadBtn.textContent = 'Laad in spel'; loadBtn.className = 'modal-btn primary';
				const delBtn = document.createElement('button');
				delBtn.className = 'trash-btn modal-btn';
				delBtn.title = 'Verwijder opgeslagen level';
				delBtn.setAttribute('aria-label', `Verwijder ${n}`);
				delBtn.innerHTML = '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" aria-hidden="true"><path d="M3 6h18" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/><path d="M8 6v14a2 2 0 0 0 2 2h4a2 2 0 0 0 2-2V6" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/><path d="M10 11v6" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/><path d="M14 11v6" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/><path d="M9 6V4a1 1 0 0 1 1-1h4a1 1 0 0 1 1 1v2" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>';
				delBtn.style.padding = '6px';
				delBtn.style.border = '0';
				delBtn.style.background = 'transparent';
				delBtn.style.cursor = 'pointer';
				delBtn.style.color = 'inherit';
				delBtn.addEventListener('click', ()=>{
					if (!confirm(`Verwijder "${n}"?`)) return;
					try {
						try {
							const sb = JSON.parse(localStorage.getItem('locusSavedBoards')||'{}');
							delete sb[n];
							try {
								localStorage.setItem('locusSavedBoards', JSON.stringify(sb));
							} catch (le) {
								console.error('Failed to write locusSavedBoards during delete:', le, 'size:', JSON.stringify(sb).length);
								alert('Kon opgeslagen levels niet bijwerken (localStorage fout). Zie console voor details.');
							}
						} catch (pe) { console.error('Failed to parse locusSavedBoards when deleting:', pe); }
						// remove item from DOM
						if (item && item.parentNode) item.parentNode.removeChild(item);
					} catch (e) { console.error(e); }
				});
				loadBtn.addEventListener('click', ()=>{
					// Backup current game state + board before loading â€” ensure latest game state (coins/deck) is saved
					try {
						if (typeof saveGameState === 'function') {
							try { saveGameState(); } catch (e) { /* ignore save errors */ }
						}
						const currentGameSave = localStorage.getItem('locusGameSave') || null;
						const currentBoardHtmlExact = (document.getElementById('board') ? document.getElementById('board').outerHTML : null);
						// Keep a sanitized version for saved-boards autosave (so it doesn't store runtime placements),
						// but keep an exact snapshot for "restore previous session".
						const currentBoardHtmlSanitized = (typeof sanitizeBoardHtml === 'function' && currentBoardHtmlExact) ? sanitizeBoardHtml(currentBoardHtmlExact) : currentBoardHtmlExact;
						const backupObj = { ts: Date.now(), level: currentLevel || null, gameSave: currentGameSave, boardHtmlExact: currentBoardHtmlExact, boardHtml: currentBoardHtmlSanitized };
						localStorage.setItem('locusGameSaveBackup', JSON.stringify(backupObj));
						// Also add/overwrite a single autosave entry to saved boards for easy access (include gameSave)
						try {
							try {
								const sb = JSON.parse(localStorage.getItem('locusSavedBoards')||'{}');
								const autosaveKey = 'Autosave: laatste bewerking';
								sb[autosaveKey] = { html: backupObj.boardHtml, gameSave: backupObj.gameSave, name: autosaveKey, ts: backupObj.ts };
								try {
									localStorage.setItem('locusSavedBoards', JSON.stringify(sb));
								} catch (le) {
									console.error('Failed to write locusSavedBoards for autosave:', le, 'size:', JSON.stringify(sb).length);
								}
							} catch (pe) { console.error('Failed to parse locusSavedBoards for autosave:', pe); }
						} catch (e) {}
					} catch (e) {}
					// Load using unified loader (prevents board/settings mismatches)
					loadScenarioLikeToGame({
						boardHtml: saved[n].html,
						name: saved[n].name || n,
						objective: saved[n].objective || null,
						scenarioSettings: (saved[n].scenarioSettings && typeof saved[n].scenarioSettings === 'object') ? saved[n].scenarioSettings : null
					}, { source: 'Opgeslagen level' });
					setTimeout(()=>{ if (typeof setStatus === 'function') setStatus('Speelveld geladen. Gebruik "Herstel vorige" om terug te keren.'); }, 50);
				});
				item.appendChild(label); item.appendChild(openEditorBtn); item.appendChild(loadBtn); item.appendChild(delBtn);
				list.appendChild(item);
			});
			// If a backup exists, show a restore option at the end
				if (backup) {
				const restoreItem = document.createElement('div');
				restoreItem.style.display = 'flex'; restoreItem.style.gap = '8px'; restoreItem.style.alignItems = 'center'; restoreItem.style.marginTop = '12px';
				const lbl = document.createElement('div'); lbl.style.flex = '1'; lbl.textContent = `Herstel vorige sessie (level ${backup.level || '?'})`; lbl.className = 'saved-title';
				const restoreBtn = document.createElement('button'); restoreBtn.textContent = 'Herstel vorige'; restoreBtn.className = 'modal-btn';
				restoreBtn.addEventListener('click', ()=>{
					try {
						// restore saved game into localStorage
						if (backup.gameSave) localStorage.setItem('locusGameSave', backup.gameSave);
						// First restore gameplay state
						if (typeof loadGameState === 'function') {
							loadGameState();
						}
						// Then restore the exact board DOM snapshot
						const exactHtml = backup.boardHtmlExact || backup.boardHtml || null;
						if (exactHtml) {
							setTimeout(()=>{
								applyBoardHtmlToGame(exactHtml);
								try { if (typeof rehydrateTrapsFromDOM === 'function') rehydrateTrapsFromDOM(); } catch(e){}
								if (typeof updateScore === 'function') setTimeout(()=> updateScore(), 120);
							}, 80);
						}
						setTimeout(()=>{ if (typeof setStatus === 'function') setStatus('Vorige sessie hersteld.'); }, 200);
					} catch (e) { console.error(e); }
				});
				restoreItem.appendChild(lbl); restoreItem.appendChild(restoreBtn);
				list.appendChild(restoreItem);
			}
		}
		overlay.classList.add('show');
		// close menu
		const controls = document.getElementById('controls');
		const menuToggle = document.getElementById('menu-toggle');
		if (controls) controls.classList.remove('open');
		if (menuToggle) menuToggle.classList.remove('active');
	}

	function closeSavedLevelsModal() {
		const overlay = document.getElementById('saved-levels-modal');
		if (overlay) overlay.classList.remove('show');
	}
	
  </script>
</html>
