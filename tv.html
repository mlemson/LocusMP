<!DOCTYPE html>
<html lang="nl">
<head>
	<meta charset="utf-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>LOCUS ‚Äî TV Display</title>
	<link rel="stylesheet" href="multiplayer.css">
	<style>
		/* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
		   LOCUS TV DISPLAY ‚Äî Big Screen Spectator View
		   ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */
		:root {
			--tv-bg: #0c0e14;
			--tv-panel: rgba(20,22,34,0.92);
			--tv-text: #e8e6e0;
			--tv-dim: rgba(255,255,255,0.45);
			--tv-accent: #6366f1;
			--tv-gold: #f0c040;
			--tv-radius: 12px;
			--tv-cell-size: 32px;
			--tv-cell-gap: 3px;
			--tv-cell-radius: 6px;
			--mp-cell-size: 32px;
			--mp-cell-radius: 6px;
			--mp-radius: 12px;
		}
		* { margin: 0; padding: 0; box-sizing: border-box; }
		body {
			background: var(--tv-bg);
			color: var(--tv-text);
			font-family: 'Segoe UI', -apple-system, sans-serif;
			overflow: hidden;
			width: 100vw;
			height: 100vh;
		}

		/* ‚îÄ‚îÄ Waiting / Connection State ‚îÄ‚îÄ */
		.tv-waiting {
			display: flex;
			flex-direction: column;
			align-items: center;
			justify-content: center;
			height: 100vh;
			gap: 24px;
		}
		.tv-waiting h1 {
			font-size: 3rem;
			font-weight: 800;
			letter-spacing: 8px;
			background: linear-gradient(135deg, #6366f1, #818cf8, #c084fc);
			-webkit-background-clip: text;
			-webkit-text-fill-color: transparent;
		}
		.tv-waiting p {
			font-size: 1.3rem;
			color: var(--tv-dim);
		}
		.tv-waiting .tv-room-code {
			font-size: 3.5rem;
			font-weight: 800;
			letter-spacing: 12px;
			color: var(--tv-gold);
			padding: 16px 40px;
			background: rgba(240,192,64,0.08);
			border: 2px solid rgba(240,192,64,0.2);
			border-radius: 16px;
		}
		.tv-pulse {
			animation: tvPulse 2s ease-in-out infinite;
		}
		@keyframes tvPulse {
			0%, 100% { opacity: 0.5; }
			50% { opacity: 1; }
		}
		.tv-player-list {
			display: flex;
			gap: 16px;
			flex-wrap: wrap;
			justify-content: center;
			margin-top: 16px;
		}
		.tv-waiting-share {
			display: flex;
			align-items: center;
			justify-content: center;
			gap: 20px;
			flex-wrap: wrap;
		}
		.tv-waiting-qr-wrap {
			display: none;
			flex-direction: column;
			align-items: center;
			gap: 8px;
		}
		.tv-waiting-qr {
			width: 150px;
			height: 150px;
			padding: 8px;
			background: #fff;
			border-radius: 12px;
			border: 1px solid rgba(255,255,255,0.18);
			object-fit: contain;
		}
		.tv-waiting-qr-link {
			font-size: 0.9rem;
			color: var(--tv-dim);
			text-decoration: none;
		}
		.tv-waiting-qr-link:hover { color: #fff; }
		.tv-player-chip {
			background: var(--tv-panel);
			border: 1px solid rgba(255,255,255,0.1);
			border-radius: 24px;
			padding: 8px 20px;
			font-size: 1.1rem;
			display: flex;
			align-items: center;
			gap: 8px;
		}
		.tv-player-chip .tv-connected {
			width: 8px; height: 8px;
			border-radius: 50%;
			background: #22c55e;
		}
		.tv-player-chip .tv-disconnected {
			width: 8px; height: 8px;
			border-radius: 50%;
			background: #ef4444;
		}

		/* ‚îÄ‚îÄ Game Layout ‚îÄ‚îÄ */
		.tv-game {
			display: none;
			width: 100vw;
			height: 100vh;
			grid-template-columns: 260px 1fr;
			grid-template-rows: auto 1fr auto;
			grid-template-areas:
				"top     top"
				"sidebar board"
				"bottom bottom";
		}
		.tv-game.active { display: grid; }

		/* ‚îÄ‚îÄ Top Bar ‚îÄ‚îÄ */
		.tv-top-bar {
			grid-area: top;
			display: flex;
			align-items: center;
			justify-content: space-between;
			flex-wrap: wrap;
			gap: 8px;
			padding: 12px 24px;
			background: var(--tv-panel);
			border-bottom: 1px solid rgba(255,255,255,0.06);
			backdrop-filter: blur(12px);
		}
		.tv-turn-info {
			display: flex;
			align-items: center;
			flex-direction: row;
			gap: 16px;
		}
		.tv-turn-label {
			font-size: 0.9rem;
			color: var(--tv-dim);
			text-transform: uppercase;
			letter-spacing: 1px;
		}
		.tv-turn-player {
			font-size: 1.2rem;
			font-weight: 700;
		}
		.tv-turn-player.my-turn {
			color: var(--tv-gold);
		}
		.tv-round-badge {
			font-size: 0.85rem;
			color: var(--tv-dim);
			background: rgba(255,255,255,0.06);
			padding: 4px 12px;
			border-radius: 8px;
		}
		.tv-logo-small {
			font-size: 1.2rem;
			font-weight: 800;
			letter-spacing: 4px;
			color: var(--tv-dim);
		}

		/* ‚îÄ‚îÄ Timer ‚îÄ‚îÄ */
		.tv-timer {
			display: flex;
			align-items: center;
			gap: 8px;
			font-size: 1.1rem;
			font-weight: 600;
		}
		.tv-timer-bar {
			width: 120px;
			height: 6px;
			background: rgba(255,255,255,0.1);
			border-radius: 3px;
			overflow: hidden;
		}
		.tv-timer-fill {
			height: 100%;
			border-radius: 3px;
			background: var(--tv-accent);
			transition: width 1s linear, background 0.3s ease;
			width: 100%;
		}
		.tv-timer-fill.warning { background: #f59e0b; }
		.tv-timer-fill.danger { background: #ef4444; }

		/* ‚îÄ‚îÄ Board ‚îÄ‚îÄ */
		.tv-board-area {
			grid-area: board;
			display: flex;
			align-items: center;
			justify-content: center;
			padding: 16px;
			overflow: hidden;
		}
		.tv-board {
			display: flex;
			gap: 12px;
			padding: 8px;
			max-width: 100%;
			max-height: 100%;
			align-items: flex-start;
		}
		.tv-board-col {
			display: flex;
			flex-direction: column;
			gap: 12px;
			align-items: flex-start;
		}
		.tv-zone {
			border-radius: var(--mp-radius);
			padding: 10px;
			padding-top: 28px;
			position: relative;
			border: 2px solid;
			box-shadow: 0 4px 10px rgba(0,0,0,0.3);
		}
		.tv-zone-label {
			position: absolute;
			top: -8px;
			left: 12px;
			font-size: 0.65rem;
			font-weight: 700;
			text-transform: uppercase;
			letter-spacing: 1.5px;
			padding: 2px 8px;
			border-radius: 4px;
			z-index: 2;
		}
		.tv-zone-label { display: none; }
		.tv-grid {
			display: grid;
			gap: 2px;
			justify-content: center;
		}
		.tv-cell {
			width: var(--mp-cell-size);
			height: var(--mp-cell-size);
			border-radius: var(--mp-cell-radius);
			background: rgba(255,255,255,0.06);
			border: 1px solid rgba(255,255,255,0.1);
			transition: background 0.25s ease, transform 0.15s ease, box-shadow 0.25s ease;
			display: flex;
			align-items: center;
			justify-content: center;
		}
		.tv-cell.void { visibility: hidden; }
		.tv-cell.active {
			box-shadow: inset 0 1px 3px rgba(0,0,0,0.3), 0 0 6px rgba(58,111,247,0.2);
			transform: scale(1.02);
		}
		/* Bonus dots on unclaimed cells */
		.tv-bonus-dot {
			display: flex;
			align-items: center;
			justify-content: center;
			width: 16px;
			height: 16px;
			border-radius: 4px;
			background: rgba(255,255,255,0.35);
			margin: auto;
			box-shadow: 0 0 3px rgba(0,0,0,0.2);
		}
		/* Zone colors */
		.tv-zone-yellow { background: var(--zone-yellow-bg); }
		.tv-zone-yellow .tv-zone-label { background: rgba(207,186,81,0.85); color: #1a1700; }
		.tv-zone-yellow .tv-cell { background: var(--cell-yellow-bg); border-color: var(--cell-yellow-border); }
		.tv-zone-yellow .tv-cell.active { background: var(--cell-yellow-active) !important; border-color: var(--cell-yellow-active-border) !important; }

		.tv-zone-green { background: var(--zone-green-bg); }
		.tv-zone-green .tv-zone-label { background: rgba(90,171,110,0.85); color: #0a1f0e; }
		.tv-zone-green .tv-cell { background: var(--cell-green-bg); border-color: var(--cell-green-border); }
		.tv-zone-green .tv-cell.active { background: var(--cell-green-active) !important; border-color: var(--cell-green-active-border) !important; }

		.tv-zone-blue { background: var(--zone-blue-bg); }
		.tv-zone-blue .tv-zone-label { background: rgba(86,137,176,0.85); color: #0a1520; }
		.tv-zone-blue .tv-cell { background: var(--cell-blue-bg); border-color: var(--cell-blue-border); }
		.tv-zone-blue .tv-cell.active { background: var(--cell-blue-active) !important; border-color: var(--cell-blue-active-border) !important; }

		.tv-zone-red { background: var(--zone-red-bg); }
		.tv-zone-red .tv-zone-label { background: rgba(181,96,105,0.85); color: #200a0c; }
		.tv-zone-red .tv-cell { background: var(--cell-red-bg); border-color: var(--cell-red-border); }
		.tv-zone-red .tv-cell.active { background: var(--cell-red-active) !important; border-color: var(--cell-red-active-border) !important; }

		.tv-zone-purple { background: var(--zone-purple-bg); }
		.tv-zone-purple .tv-zone-label { background: rgba(143,118,184,0.85); color: #120a20; }
		.tv-zone-purple .tv-cell { background: var(--cell-purple-bg); border-color: var(--cell-purple-border); }
		.tv-zone-purple .tv-cell.active { background: var(--cell-purple-active) !important; border-color: var(--cell-purple-active-border) !important; }

		/* Red subgrids */
		.tv-red-group {
			display: flex;
			flex-wrap: wrap;
			gap: 8px;
			justify-content: center;
		}

		/* ‚îÄ‚îÄ Sidebar ‚îÄ‚îÄ */
		.tv-sidebar {
			grid-area: sidebar;
			width: 260px;
			display: flex;
			flex-direction: column;
			gap: 8px;
			padding: 12px;
			background: var(--tv-panel);
			border-right: 1px solid rgba(255,255,255,0.06);
			overflow-y: auto;
		}
		.tv-score-row {
			display: flex;
			align-items: center;
			gap: 10px;
			padding: 10px 12px;
			border-radius: 10px;
			transition: all 0.3s ease;
		}
		.tv-score-row.current-turn {
			box-shadow: 0 0 12px rgba(99,102,241,0.15);
		}
		.tv-score-rank {
			font-size: 0.75rem;
			color: var(--tv-dim);
			width: 16px;
			text-align: center;
		}
		.tv-score-name {
			flex: 1;
			font-weight: 600;
			font-size: 0.95rem;
			white-space: nowrap;
			overflow: hidden;
			text-overflow: ellipsis;
		}
		.tv-score-pts {
			font-weight: 700;
			font-size: 1.1rem;
			color: var(--tv-gold);
			min-width: 36px;
			text-align: right;
		}
		.tv-score-cards {
			font-size: 0.7rem;
			color: var(--tv-dim);
		}

		/* ‚îÄ‚îÄ Bottom Bar (Current Player Hand) ‚îÄ‚îÄ */
		.tv-bottom-bar {
			grid-area: bottom;
			display: flex;
			align-items: center;
			justify-content: center;
			gap: 16px;
			padding: 12px 24px;
			background: var(--tv-panel);
			border-top: 1px solid rgba(255,255,255,0.06);
			min-height: 80px;
		}
		.tv-hand-label {
			font-size: 0.85rem;
			color: var(--tv-dim);
			text-transform: uppercase;
			letter-spacing: 1px;
		}
		.tv-hand-cards {
			display: flex;
			gap: 12px;
			align-items: center;
			overflow-x: auto;
			overflow-y: hidden;
			justify-content: center;
		}
		.tv-card {
			background: var(--tv-panel);
			border: 1px solid rgba(255,255,255,0.10);
			border-radius: 10px;
			padding: 8px;
			display: flex;
			flex-direction: column;
			align-items: center;
			gap: 4px;
			min-width: 80px;
			cursor: default;
		}
		.tv-card-name {
			font-size: 0.7rem;
			color: var(--tv-dim);
			text-align: center;
			white-space: nowrap;
		}
		.tv-card-grid {
			display: inline-grid;
			gap: 2px;
		}
		.tv-card-cell {
			width: 14px;
			height: 14px;
			border-radius: 3px;
		}
		.tv-card-cell.filled {
			box-shadow: inset 0 0 2px rgba(0,0,0,0.2);
		}
		.tv-card-cell:not(.filled) {
			background: rgba(255,255,255,0.04);
		}
		.tv-hidden-hand {
			font-size: 1rem;
			color: var(--tv-dim);
			font-style: italic;
		}

		/* ‚îÄ‚îÄ Taunt overlay ‚îÄ‚îÄ */
		.tv-taunt {
			position: fixed;
			top: 50%;
			left: 50%;
			transform: translate(-50%, -50%) scale(0);
			background: rgba(20,22,34,0.95);
			border: 2px solid rgba(99,102,241,0.3);
			border-radius: 20px;
			padding: 24px 48px;
			z-index: 100;
			text-align: center;
			transition: transform 0.3s cubic-bezier(0.34, 1.56, 0.64, 1), opacity 0.3s ease;
			opacity: 0;
			pointer-events: none;
		}
		.tv-taunt.show {
			transform: translate(-50%, -50%) scale(1);
			opacity: 1;
		}
		.tv-taunt-name {
			font-size: 0.9rem;
			color: var(--tv-accent);
			margin-bottom: 4px;
		.tv-top-right {
			display: flex;
			align-items: center;
			gap: 14px;
			margin-left: auto;
		}
		.tv-score-main {
			display: flex;
			align-items: center;
			gap: 10px;
			flex: 1;
			min-width: 0;
		}
		.tv-score-meta {
			flex: 1;
			min-width: 0;
		}
		}
		.tv-taunt-text {
			font-size: 2rem;
			font-weight: 700;
		}

		/* ‚îÄ‚îÄ Level Complete overlay ‚îÄ‚îÄ */
		.tv-level-overlay {
			position: fixed;
			inset: 0;
			background: rgba(0,0,0,0.85);
			display: none;
			align-items: center;
			justify-content: center;
			z-index: 50;
		}
		.tv-level-overlay.show { display: flex; }
		.tv-level-card {
			background: var(--tv-panel);
			border: 1px solid rgba(255,255,255,0.1);
			border-radius: 20px;
			padding: 40px 60px;
			text-align: center;
		}
		.tv-level-card h2 {
			font-size: 2rem;
			margin-bottom: 16px;
		}
		.tv-level-scores {
			display: flex;
			flex-direction: column;
			gap: 8px;
		}
		.tv-level-score-row {
			display: flex;
			align-items: center;
			justify-content: space-between;
			gap: 24px;
			padding: 8px 16px;
			border-radius: 8px;
			background: rgba(255,255,255,0.03);
		}
		.tv-level-score-row.winner {
			background: rgba(240,192,64,0.12);
			border: 1px solid rgba(240,192,64,0.3);
		}

		/* ‚îÄ‚îÄ Phase overlays (shop + final) ‚îÄ‚îÄ */
		.tv-phase-overlay {
			position: fixed;
			left: 50%;
			top: 56%;
			transform: translate(-50%, -50%);
			width: min(760px, calc(100vw - 48px));
			background: rgba(20,22,34,0.95);
			border: 1px solid rgba(255,255,255,0.14);
			border-radius: 16px;
			box-shadow: 0 14px 38px rgba(0,0,0,0.45);
			padding: 18px;
			z-index: 45;
			display: none;
		}
		.tv-phase-overlay.show {
			display: block;
		}
		.tv-phase-title {
			font-size: 1.3rem;
			font-weight: 800;
			letter-spacing: 0.5px;
			margin-bottom: 8px;
		}
		.tv-phase-sub {
			font-size: 0.88rem;
			color: var(--tv-dim);
			margin-bottom: 12px;
		}
		.tv-phase-list {
			display: flex;
			flex-direction: column;
			gap: 7px;
		}
		.tv-phase-row {
			display: flex;
			align-items: center;
			justify-content: space-between;
			gap: 12px;
			padding: 8px 10px;
			border-radius: 9px;
			background: rgba(255,255,255,0.04);
			border: 1px solid rgba(255,255,255,0.08);
		}
		.tv-phase-row .name {
			font-weight: 700;
		}
		.tv-phase-row .meta {
			font-size: 0.83rem;
			color: var(--tv-dim);
		}
		.tv-phase-row .ready {
			font-size: 0.82rem;
			font-weight: 700;
		}
		.tv-phase-row .ready.ok {
			color: #7adf8d;
		}
		.tv-phase-row.winner {
			border-color: rgba(240,192,64,0.45);
			background: rgba(240,192,64,0.13);
		}

		/* ‚îÄ‚îÄ Floating action feed ‚îÄ‚îÄ */
		.tv-action-feed {
			position: fixed;
			right: 14px;
			top: 82px;
			display: flex;
			flex-direction: column;
			gap: 8px;
			z-index: 65;
			pointer-events: none;
		}
		.tv-action-item {
			min-width: 250px;
			max-width: 360px;
			padding: 9px 12px;
			border-radius: 10px;
			border: 1px solid rgba(255,255,255,0.15);
			background: rgba(12,14,28,0.94);
			box-shadow: 0 10px 24px rgba(0,0,0,0.35);
			font-size: 0.9rem;
			animation: tvActionIn 360ms cubic-bezier(0.2, 0.8, 0.2, 1), tvActionOut 320ms ease-in forwards;
			animation-delay: 0ms, 2500ms;
		}
		.tv-action-item.score {
			border-color: rgba(245,215,110,0.45);
		}
		.tv-action-item.bomb {
			border-color: rgba(239,68,68,0.5);
			background: rgba(45,18,18,0.92);
		}
		.tv-action-item.info {
			border-color: rgba(99,102,241,0.45);
		}
		@keyframes tvActionIn {
			0% { opacity: 0; transform: translateX(30px) scale(0.96); }
			100% { opacity: 1; transform: translateX(0) scale(1); }
		}
		@keyframes tvActionOut {
			to { opacity: 0; transform: translateX(26px) scale(0.98); }
		}

		/* ‚îÄ‚îÄ Responsive: smaller TVs ‚îÄ‚îÄ */
		@media (max-width: 1200px) {
			:root {
				--tv-cell-size: 26px;
				--tv-cell-gap: 2px;
			}
			.tv-sidebar { width: 220px; }
		}
		@media (max-width: 900px) {
			:root {
				--tv-cell-size: 20px;
				--tv-cell-gap: 2px;
				--tv-cell-radius: 4px;
			}
			.tv-sidebar { width: 180px; }
			.tv-turn-player { font-size: 1.2rem; }
		}

		/* ‚ïê‚ïê‚ïê AURORA THEME ‚ïê‚ïê‚ïê */
		html.theme-aurora body {
			background: #0a0c18;
		}
		html.theme-aurora .tv-panel,
		html.theme-aurora .tv-top-bar,
		html.theme-aurora .tv-sidebar,
		html.theme-aurora .tv-bottom-bar {
			background: rgba(12,14,28,0.90);
			border-color: rgba(99,102,241,0.10);
		}
		html.theme-aurora .tv-waiting h1 {
			background: linear-gradient(135deg, #6366f1, #818cf8, #c084fc);
		}
		html.theme-aurora .tv-cell.active {
			box-shadow: 0 0 6px rgba(99,102,241,0.2);
		}

		/* ‚ïê‚ïê‚ïê BLOOM THEME ‚ïê‚ïê‚ïê */
		html.theme-bloom body {
			background: #faf5eb;
			color: #3d3429;
		}
		html.theme-bloom .tv-waiting h1 {
			background: linear-gradient(135deg, #c07050, #e0a070, #907050);
			-webkit-background-clip: text;
			-webkit-text-fill-color: transparent;
		}
		html.theme-bloom .tv-waiting p,
		html.theme-bloom .tv-dim,
		html.theme-bloom .tv-turn-label,
		html.theme-bloom .tv-round-badge,
		html.theme-bloom .tv-hand-label,
		html.theme-bloom .tv-hidden-hand,
		html.theme-bloom .tv-card-name,
		html.theme-bloom .tv-score-rank {
			color: rgba(61,52,41,0.55);
		}
		html.theme-bloom .tv-top-bar,
		html.theme-bloom .tv-sidebar,
		html.theme-bloom .tv-bottom-bar {
			background: rgba(248,244,236,0.95);
			border-color: rgba(180,160,130,0.12);
		}
		html.theme-bloom .tv-score-row {
			background: rgba(180,160,130,0.06);
			border-color: rgba(180,160,130,0.10);
		}
		html.theme-bloom .tv-score-row.current-turn {
			background: rgba(224,122,95,0.08);
			border-color: rgba(224,122,95,0.25);
			box-shadow: 0 0 10px rgba(224,122,95,0.08);
		}
		html.theme-bloom .tv-score-pts {
			color: #c07050;
		}
		html.theme-bloom .tv-room-code {
			color: #c07050;
			background: rgba(224,122,95,0.06);
			border-color: rgba(224,122,95,0.18);
		}
		html.theme-bloom .tv-zone {
			border-color: rgba(180,160,130,0.12);
		}
		html.theme-bloom .tv-cell {
			border-color: rgba(180,160,130,0.15);
			background: rgba(180,160,130,0.06);
		}
		html.theme-bloom .tv-cell.active {
			border-radius: 7px;
		}
		html.theme-bloom .tv-card {
			background: rgba(248,244,236,0.85);
			border-color: rgba(180,160,130,0.15);
		}
		html.theme-bloom .tv-logo-small {
			color: rgba(61,52,41,0.35);
		}
		html.theme-bloom .tv-taunt {
			background: rgba(248,244,236,0.96);
			border-color: rgba(224,122,95,0.25);
			color: #3d3429;
		}
		html.theme-bloom .tv-taunt-name {
			color: #c07050;
		}

		/* ‚ïê‚ïê‚ïê REEF THEME ‚ïê‚ïê‚ïê */
		html.theme-reef body {
			background: linear-gradient(160deg, #0a1628 0%, #0d2137 50%, #0a1628 100%);
			color: #e8f4f0;
		}
		html.theme-reef .tv-panel,
		html.theme-reef .tv-top-bar,
		html.theme-reef .tv-sidebar,
		html.theme-reef .tv-bottom-bar {
			background: rgba(10,28,50,0.90);
			border-color: rgba(0,210,190,0.10);
		}
		html.theme-reef .tv-waiting h1 {
			background: linear-gradient(135deg, #00d2be, #38c9e8, #ff7f50, #ffd700);
			-webkit-background-clip: text;
			-webkit-text-fill-color: transparent;
		}
		html.theme-reef .tv-cell.active {
			box-shadow: 0 0 6px rgba(0,210,190,0.25);
		}
		html.theme-reef .tv-score-row {
			background: rgba(0,210,190,0.04);
			border-color: rgba(0,210,190,0.08);
		}
		html.theme-reef .tv-score-row.current-turn {
			background: rgba(0,210,190,0.08);
			border-color: rgba(0,210,190,0.25);
			box-shadow: 0 0 10px rgba(0,210,190,0.08);
		}
		html.theme-reef .tv-score-pts {
			color: #00d2be;
		}
		html.theme-reef .tv-room-code {
			color: #00d2be;
			background: rgba(0,210,190,0.06);
			border-color: rgba(0,210,190,0.18);
		}
		html.theme-reef .tv-zone {
			border-color: rgba(0,210,190,0.12);
		}
		html.theme-reef .tv-cell {
			border-color: rgba(0,210,190,0.15);
			background: rgba(0,210,190,0.04);
		}
		html.theme-reef .tv-card {
			background: rgba(10,28,50,0.85);
			border-color: rgba(0,210,190,0.12);
		}
		html.theme-reef .tv-logo-small {
			color: rgba(0,210,190,0.35);
		}
		html.theme-reef .tv-taunt {
			background: rgba(10,28,50,0.96);
			border-color: rgba(0,210,190,0.25);
			color: #e8f4f0;
		}
		html.theme-reef .tv-taunt-name {
			color: #00d2be;
		}

		/* ‚ïê‚ïê‚ïê Cell detail styles ‚ïê‚ïê‚ïê */
		.tv-cell.bold {
			border-width: 2px;
			border-color: rgba(255,255,255,0.30);
		}
		.tv-cell.end {
			border-style: dashed;
			border-color: rgba(255,255,255,0.25);
		}
		.tv-cell.gold {
			box-shadow: inset 0 0 5px rgba(240,192,64,0.5);
		}
		.tv-cell.outer-ring-0 {
			border-color: rgba(143,118,184,0.45);
			border-width: 2px;
		}
		.tv-cell.outer-ring-1 {
			border-color: rgba(143,118,184,0.30);
			border-width: 2px;
		}
		.tv-cell.green-end.active {
			position: relative;
		}
		.tv-cell.green-end {
			border-color: rgba(110, 231, 183, 0.55);
			box-shadow: inset 0 0 0 1px rgba(110, 231, 183, 0.35);
		}
		.tv-cell.green-end::before {
			content: '';
			position: absolute;
			left: 50%;
			top: 50%;
			width: 6px;
			height: 6px;
			border-radius: 999px;
			transform: translate(-50%, -50%);
			background: rgba(110, 231, 183, 0.75);
		}
		.tv-cell.green-end.active::after {
			content: '‚úì';
			position: absolute;
			inset: 0;
			display: flex;
			align-items: center;
			justify-content: center;
			font-size: 0.7em;
			font-weight: 700;
			color: rgba(255,255,255,0.85);
		}
		.tv-cell .tv-bonus-dot {
			display: flex;
			align-items: center;
			justify-content: center;
			width: 18px;
			height: 18px;
			border-radius: 4px;
			margin: auto;
			position: absolute;
			top: 50%;
			left: 50%;
			transform: translate(-50%, -50%);
			box-shadow: 0 0 4px rgba(0,0,0,0.3), inset 0 1px 2px rgba(255,255,255,0.3);
		}
		.tv-cell .tv-gold-dot {
			display: block;
			width: 14px;
			height: 14px;
			border-radius: 50%;
			background: radial-gradient(circle at 35% 35%, #ffe87c, #f0c040, #c8960a);
			box-shadow: 0 0 8px rgba(240,192,64,0.8), 0 0 3px rgba(240,192,64,0.5);
			margin: auto;
			position: absolute;
			top: 50%;
			left: 50%;
			transform: translate(-50%, -50%);
		}
		.tv-cell .tv-gold-dot::after {
			content: '‚ú¶';
			position: absolute;
			inset: 0;
			display: flex;
			align-items: center;
			justify-content: center;
			font-size: 8px;
			color: rgba(100,70,0,0.6);
		}
		.tv-cell .tv-pearl-dot {
			display: block;
			width: 14px;
			height: 14px;
			border-radius: 50%;
			background: radial-gradient(circle at 30% 30%, #fff, #e8e4f0, #c4c0d8);
			box-shadow: 0 0 6px rgba(255,255,255,0.6), 0 0 3px rgba(200,195,220,0.5);
			margin: auto;
			position: absolute;
			top: 50%;
			left: 50%;
			transform: translate(-50%, -50%);
		}
		.tv-cell .tv-pearl-dot::after {
			content: 'üíé';
			position: absolute;
			inset: 0;
			display: flex;
			align-items: center;
			justify-content: center;
			font-size: 8px;
		}
		.tv-cell { position: relative; }

		/* ‚îÄ‚îÄ Ghost/Preview overlay ‚îÄ‚îÄ */
		.tv-cell.preview-ghost {
			background: rgba(255,255,255,0.18) !important;
			border-color: rgba(255,255,255,0.35) !important;
			animation: tvGhostPulse 1.2s ease-in-out infinite;
		}
		.tv-cell.preview-ghost.preview-denied {
			background: rgba(239,68,68,0.20) !important;
			border-color: rgba(239,68,68,0.40) !important;
		}
		@keyframes tvGhostPulse {
			0%, 100% { opacity: 0.6; }
			50% { opacity: 1; }
		}
		.tv-cell.just-placed {
			animation: tvCellPlacePop 420ms cubic-bezier(0.2, 0.8, 0.2, 1);
		}
		@keyframes tvCellPlacePop {
			0% { transform: scale(0.55); filter: brightness(1.4); }
			55% { transform: scale(1.12); filter: brightness(1.15); }
			100% { transform: scale(1.02); filter: brightness(1); }
		}

		/* ‚îÄ‚îÄ Player card mini-grids in sidebar ‚îÄ‚îÄ */
		.tv-player-cards {
			display: flex;
			gap: 6px;
			flex-wrap: wrap;
			margin-top: 4px;
		}
		.tv-player-mini-card {
			display: inline-grid;
			gap: 1px;
			opacity: 0.95;
			padding: 2px;
			border-radius: 5px;
			background: rgba(255,255,255,0.05);
		}
		.tv-mini-cell {
			width: 10px;
			height: 10px;
			border-radius: 2px;
		}
		.tv-mini-cell.filled {
			box-shadow: inset 0 0 1px rgba(0,0,0,0.2);
		}
		.tv-mini-cell:not(.filled) {
			background: rgba(255,255,255,0.04);
		}
		.tv-score-cards-count {
			font-size: 0.65rem;
			color: var(--tv-dim);
			margin-top: 2px;
		}
		.tv-score-row.score-up {
			animation: tvScorePop 420ms ease-out;
		}
		@keyframes tvScorePop {
			0% { transform: scale(1); }
			45% { transform: scale(1.035); box-shadow: 0 0 14px rgba(240,192,64,0.25); }
			100% { transform: scale(1); }
		}
		.tv-red-target {
			position: absolute;
			top: -6px;
			right: 8px;
			font-size: 0.55rem;
			font-weight: 700;
			padding: 1px 5px;
			border-radius: 6px;
			background: rgba(181,96,105,0.8);
			color: #fff;
		}

		/* ‚îÄ‚îÄ Red subgrid progress ‚îÄ‚îÄ */
		.tv-red-progress {
			height: 3px;
			background: rgba(255,255,255,0.08);
			border-radius: 2px;
			margin-top: 4px;
			overflow: hidden;
		}
		.tv-red-progress-fill {
			height: 100%;
			background: #b56069;
			border-radius: 2px;
			transition: width 0.3s ease;
		}
	</style>
</head>
<body>
	<!-- Waiting Screen -->
	<div id="tv-waiting" class="tv-waiting">
		<h1>LOCUS</h1>
		<p id="tv-status" class="tv-pulse">Wachten op verbinding met host...</p>
		<div class="tv-waiting-share">
			<div id="tv-room-code" class="tv-room-code" style="display:none;">------</div>
			<div id="tv-waiting-qr-wrap" class="tv-waiting-qr-wrap">
				<img id="tv-waiting-qr" class="tv-waiting-qr" alt="QR code om direct te joinen" />
				<a id="tv-waiting-qr-link" class="tv-waiting-qr-link" href="#" target="_blank" rel="noopener">Open op mobiel</a>
			</div>
		</div>
		<div id="tv-player-list" class="tv-player-list"></div>
	</div>

	<!-- Game Screen -->
	<div id="tv-game" class="tv-game mp-game-layout">
		<div class="tv-top-bar mp-top-bar">
			<div class="tv-turn-info mp-turn-indicator">
				<span class="tv-turn-label">Beurt:</span>
				<span id="tv-turn-player" class="tv-turn-player">‚Äî</span>
				<span id="tv-round-badge" class="tv-round-badge">Ronde 1</span>
			</div>
			<div class="tv-top-right mp-top-right">
				<div id="tv-timer" class="tv-timer" style="display:none;">
					<div class="tv-timer-bar"><div id="tv-timer-fill" class="tv-timer-fill"></div></div>
					<span id="tv-timer-text">40s</span>
				</div>
				<span class="tv-logo-small">LOCUS</span>
			</div>
		</div>

		<div class="tv-board-area">
			<div id="tv-board" class="tv-board mp-board"></div>
		</div>

		<div class="tv-sidebar mp-sidebar">
			<div id="tv-scoreboard" class="mp-scoreboard"></div>
		</div>

		<div class="tv-bottom-bar mp-bottom-bar">
			<span id="tv-hand-label" class="tv-hand-label mp-turn-label"></span>
			<div id="tv-hand-cards" class="tv-hand-cards mp-hand-container"></div>
		</div>
	</div>

	<!-- Taunt popup -->
	<div id="tv-taunt" class="tv-taunt">
		<div id="tv-taunt-name" class="tv-taunt-name"></div>
		<div id="tv-taunt-text" class="tv-taunt-text"></div>
	</div>

	<div id="tv-action-feed" class="tv-action-feed"></div>

	<!-- Level Complete overlay -->
	<div id="tv-level-overlay" class="tv-level-overlay">
		<div class="tv-level-card">
			<h2 id="tv-level-title">Level Compleet!</h2>
			<div id="tv-level-scores" class="tv-level-scores"></div>
		</div>
	</div>

	<div id="tv-shop-overlay" class="tv-phase-overlay">
		<div class="tv-phase-title">üõí Shop Fase</div>
		<div class="tv-phase-sub">Alle spelers kopen upgrades en markeren zich klaar.</div>
		<div id="tv-shop-list" class="tv-phase-list"></div>
	</div>

	<div id="tv-final-overlay" class="tv-phase-overlay">
		<div class="tv-phase-title">üèÜ Eindscore</div>
		<div id="tv-final-sub" class="tv-phase-sub"></div>
		<div id="tv-final-list" class="tv-phase-list"></div>
	</div>

	<script>
	/**
	 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
	 * LOCUS TV Display Controller
	 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
	 * Receives game state from host via:
	 *  1. Presentation Receiver API (Chromecast / wireless display)
	 *  2. BroadcastChannel fallback (same-device popup window)
	 */
	(function() {
		'use strict';

		let currentState = null;
		let timerInterval = null;
		let presentationConn = null;
		let ghostCells = []; // current preview ghost cells
		let lastMoveHistoryLength = 0;

		// ‚ïê‚ïê‚ïê SOUND EFFECTS (Web Audio API) ‚ïê‚ïê‚ïê
		let audioCtx = null;
		function getAudioCtx() {
			if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
			return audioCtx;
		}
		function playTone(freq, duration = 0.15, type = 'sine', volume = 0.12) {
			try {
				const ctx = getAudioCtx();
				const osc = ctx.createOscillator();
				const gain = ctx.createGain();
				osc.type = type;
				osc.frequency.value = freq;
				gain.gain.setValueAtTime(volume, ctx.currentTime);
				gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + duration);
				osc.connect(gain); gain.connect(ctx.destination);
				osc.start(); osc.stop(ctx.currentTime + duration);
			} catch (_) {}
		}
		function playPlaceSound() {
			playTone(440, 0.1, 'sine', 0.10);
			setTimeout(() => playTone(660, 0.08, 'sine', 0.07), 60);
		}
		function playScoreSound() {
			playTone(523, 0.12, 'sine', 0.12);
			setTimeout(() => playTone(659, 0.12, 'sine', 0.10), 80);
			setTimeout(() => playTone(784, 0.15, 'sine', 0.10), 160);
		}
		function playTurnStartSound() {
			playTone(587, 0.12, 'sine', 0.08);
			setTimeout(() => playTone(784, 0.15, 'sine', 0.10), 100);
		}
		function playTimerWarningSound() { playTone(880, 0.2, 'sine', 0.08); }
		function playTauntSound() {
			playTone(520, 0.07, 'triangle', 0.09);
			setTimeout(() => playTone(660, 0.08, 'triangle', 0.08), 70);
		}
		function playGoldSound() {
			playTone(1047, 0.1, 'sine', 0.12);
			setTimeout(() => playTone(1319, 0.12, 'sine', 0.10), 80);
			setTimeout(() => playTone(1568, 0.15, 'sine', 0.08), 160);
		}
		function playLevelCompleteSound() {
			playTone(392, 0.2, 'sine', 0.12);
			setTimeout(() => playTone(494, 0.2, 'sine', 0.10), 150);
			setTimeout(() => playTone(587, 0.2, 'sine', 0.10), 300);
			setTimeout(() => playTone(784, 0.3, 'sine', 0.12), 450);
		}

		// Track previous state for detecting changes
		let prevTurnIndex = null;
		let prevScores = {};

		// ‚îÄ‚îÄ Unified message handler ‚îÄ‚îÄ
		function handleMessage(msg) {
			if (!msg || !msg.type) return;
			switch (msg.type) {
				case 'gameState':
					onGameState(msg.state);
					break;
				case 'taunt':
					showTaunt(msg.data);
					playTauntSound();
					break;
					case 'timeBomb':
						showActionFeed(`üí£ ${msg?.data?.bomberPlayerName || 'Speler'} bombardeert ${msg?.data?.bombedPlayerName || 'speler'}`, 'bomb');
						playTauntSound();
						break;
				case 'levelComplete':
					showLevelComplete(msg.data);
					playLevelCompleteSound();
					break;
				case 'theme':
					applyTheme(msg.theme);
					break;
				case 'ping':
					sendToHost({ type: 'pong' });
					break;
				case 'opponentInteraction':
					onOpponentInteraction(msg.data);
					break;
			}
		}

		// ‚îÄ‚îÄ Send message back to host (via active channel) ‚îÄ‚îÄ
		function sendToHost(msg) {
			if (presentationConn) {
				try { presentationConn.send(JSON.stringify(msg)); return; } catch (_) {}
			}
			if (bcChannel) {
				try { bcChannel.postMessage(msg); } catch (_) {}
			}
		}

		// ‚îÄ‚îÄ 1. Try Presentation Receiver API (Chromecast / wireless display) ‚îÄ‚îÄ
		let bcChannel = null;
		let receiverReady = false;

		if (navigator.presentation && navigator.presentation.receiver) {
			console.log('[TV] Presentation Receiver API detected, wachten op verbinding...');
			navigator.presentation.receiver.connectionList.then(list => {
				console.log('[TV] Presentation Receiver: connectionList ontvangen, connections:', list.connections.length);
				for (const conn of list.connections) {
					setupPresentationConnection(conn);
				}
				list.onconnectionavailable = (e) => {
					console.log('[TV] Nieuwe Presentation connection beschikbaar');
					setupPresentationConnection(e.connection);
				};
			}).catch(err => {
				console.warn('[TV] Presentation Receiver niet beschikbaar:', err);
				initBroadcastChannel();
			});

			// Safety: also try BroadcastChannel after 2s if no Presentation connection arrived
			setTimeout(() => {
				if (!receiverReady && !presentationConn) {
					console.log('[TV] Geen Presentation connection na 2s, probeer BroadcastChannel als backup');
					initBroadcastChannel();
				}
			}, 2000);
		} else {
			// ‚îÄ‚îÄ 2. Fallback: BroadcastChannel (same-device popup) ‚îÄ‚îÄ
			initBroadcastChannel();
		}

		function setupPresentationConnection(conn) {
			receiverReady = true;
			presentationConn = conn;
			console.log('[TV] Presentation connection opgezet, state:', conn.state);
			conn.onmessage = (e) => {
				try {
					const msg = typeof e.data === 'string' ? JSON.parse(e.data) : e.data;
					handleMessage(msg);
				} catch (err) {
					console.warn('[TV] Parse error:', err);
				}
			};
			conn.onclose = () => {
				console.log('[TV] Presentation connection gesloten');
				presentationConn = null;
			};
			sendToHost({ type: 'tvReady' });
			setTimeout(() => sendToHost({ type: 'tvReady' }), 500);
			setTimeout(() => sendToHost({ type: 'tvReady' }), 1500);
		}

		function initBroadcastChannel() {
			if (bcChannel) return;
			try {
				bcChannel = new BroadcastChannel('locus-tv');
				bcChannel.onmessage = (e) => handleMessage(e.data);
				bcChannel.postMessage({ type: 'tvReady' });
				setTimeout(() => { try { bcChannel.postMessage({ type: 'tvReady' }); } catch(_) {} }, 500);
				setTimeout(() => { try { bcChannel.postMessage({ type: 'tvReady' }); } catch(_) {} }, 1500);
			} catch (err) {
				console.warn('[TV] BroadcastChannel niet beschikbaar:', err);
			}
		}

		// ‚îÄ‚îÄ Apply theme from host ‚îÄ‚îÄ
		function applyTheme(theme) {
			document.documentElement.classList.remove('theme-aurora', 'theme-bloom', 'theme-reef');
			if (theme === 'aurora') document.documentElement.classList.add('theme-aurora');
			else if (theme === 'bloom') document.documentElement.classList.add('theme-bloom');
			else if (theme === 'reef') document.documentElement.classList.add('theme-reef');
		}

		// ‚îÄ‚îÄ State Update ‚îÄ‚îÄ
		function onGameState(state) {
			if (!state) return;
			const prevState = currentState;
			currentState = state;

			const waitingEl = document.getElementById('tv-waiting');
			const gameEl = document.getElementById('tv-game');

			if (state.phase === 'waiting' || state.phase === 'choosingStartDeck' || state.phase === 'choosingGoals') {
				waitingEl.style.display = 'flex';
				gameEl.classList.remove('active');
				renderWaiting(state);
			} else if (state.phase === 'playing' || state.phase === 'shopping') {
				waitingEl.style.display = 'none';
				gameEl.classList.add('active');
				renderGame(state, prevState);
				renderPhaseOverlays(state);
				processActionEvents(state, prevState);
				document.getElementById('tv-level-overlay').classList.remove('show');

				// Sound effects based on state changes
				if (prevState) {
					// Turn changed
					if (state.currentTurnIndex !== prevTurnIndex && prevTurnIndex !== null) {
						playTurnStartSound();
					}
					// Score changed (someone scored)
					const order = state.playerOrder || [];
					for (const pid of order) {
						const newScore = state.players?.[pid]?.score || 0;
						const oldScore = prevScores[pid] || 0;
						if (newScore > oldScore) {
							playPlaceSound();
							break;
						}
					}
				}
				prevTurnIndex = state.currentTurnIndex;
				// Capture scores
				const players = state.players || {};
				prevScores = {};
				for (const pid of Object.keys(players)) {
					prevScores[pid] = players[pid]?.score || 0;
				}
			} else if (state.phase === 'levelComplete') {
				if (!gameEl.classList.contains('active')) {
					gameEl.classList.add('active');
					waitingEl.style.display = 'none';
				}
				renderGame(state, prevState);
				renderPhaseOverlays(state);
				processActionEvents(state, prevState);
			} else if (state.phase === 'ended') {
				renderGame(state, prevState);
				renderPhaseOverlays(state);
				processActionEvents(state, prevState);
			}
		}

		function showActionFeed(text, type = 'info') {
			const feed = document.getElementById('tv-action-feed');
			if (!feed || !text) return;
			const item = document.createElement('div');
			item.className = `tv-action-item ${type}`;
			item.textContent = text;
			feed.prepend(item);
			while (feed.children.length > 5) {
				feed.removeChild(feed.lastElementChild);
			}
			setTimeout(() => item.remove(), 2900);
		}

		function processActionEvents(state, prevState) {
			if (!state || !prevState || !prevState.players) {
				lastMoveHistoryLength = Array.isArray(state?.moveHistory) ? state.moveHistory.length : 0;
				return;
			}

			const zoneLabels = {
				yellow: 'geel',
				green: 'groen',
				blue: 'blauw',
				red: 'rood',
				purple: 'paars',
				bonus: 'balance'
			};

			for (const pid of state.playerOrder || []) {
				const player = state.players?.[pid];
				const prevPlayer = prevState.players?.[pid];
				if (!player || !prevPlayer) continue;

				const bd = player.scoreBreakdown || {};
				const prevBd = prevPlayer.scoreBreakdown || {};
				let emittedBreakdown = false;

				for (const zoneKey of ['yellow', 'green', 'blue', 'red', 'purple', 'bonus']) {
					const now = Number(bd[zoneKey] || 0);
					const before = Number(prevBd[zoneKey] || 0);
					const delta = now - before;
					if (delta > 0) {
						emittedBreakdown = true;
						showActionFeed(`+${delta} ${zoneLabels[zoneKey]} ‚Ä¢ ${player.name || 'Speler'}`, 'score');
					}
				}

				if (!emittedBreakdown) {
					const scoreDelta = Number(player.score || 0) - Number(prevPlayer.score || 0);
					if (scoreDelta > 0) {
						showActionFeed(`+${scoreDelta} totaal ‚Ä¢ ${player.name || 'Speler'}`, 'score');
					}
				}
			}

			const currentHistory = Array.isArray(state.moveHistory) ? state.moveHistory : [];
			const previousLen = Array.isArray(prevState.moveHistory)
				? prevState.moveHistory.length
				: Math.max(0, lastMoveHistoryLength);
			if (currentHistory.length > previousLen) {
				const newEntries = currentHistory.slice(previousLen);
				for (const entry of newEntries) {
					if (entry?.timeBombed) {
						const bombedName = state.players?.[entry.playerId]?.name || 'speler';
						const bomberName = state.players?.[entry.bombedBy]?.name || 'speler';
						showActionFeed(`üí£ ${bomberName} bombardeert ${bombedName}`, 'bomb');
					}
					if (entry?.type === 'bonus-spawn' && Number(entry.spawned || 0) > 0) {
						showActionFeed(`‚ú® +${entry.spawned} bonus spawns`, 'info');
					}
				}
			}
			lastMoveHistoryLength = currentHistory.length;
		}

		function renderPhaseOverlays(state) {
			const shopOverlay = document.getElementById('tv-shop-overlay');
			const finalOverlay = document.getElementById('tv-final-overlay');
			if (!shopOverlay || !finalOverlay) return;

			shopOverlay.classList.remove('show');
			finalOverlay.classList.remove('show');

			if (state.phase === 'shopping') {
				renderShopOverlay(state);
				shopOverlay.classList.add('show');
			} else if (state.phase === 'ended') {
				renderFinalOverlay(state);
				finalOverlay.classList.add('show');
			}
		}

		function renderShopOverlay(state) {
			const listEl = document.getElementById('tv-shop-list');
			if (!listEl) return;
			const players = state.players || {};
			const order = state.playerOrder || Object.keys(players);
			listEl.innerHTML = order.map(pid => {
				const p = players[pid] || {};
				const ready = !!p.shopReady;
				return `
					<div class="tv-phase-row">
						<div>
							<div class="name">${esc(p.name || 'Speler')}</div>
							<div class="meta">üí∞ ${Number(p.goldCoins || 0)} ‚Ä¢ Wins: ${Number(p.matchWins || 0)}</div>
						</div>
						<div class="ready ${ready ? 'ok' : ''}">${ready ? '‚úÖ Klaar' : '‚è≥ Winkelt'}</div>
					</div>
				`;
			}).join('');
		}

		function renderFinalOverlay(state) {
			const subEl = document.getElementById('tv-final-sub');
			const listEl = document.getElementById('tv-final-list');
			if (!subEl || !listEl) return;

			const finalScores = state.finalScores || {};
			const players = state.players || {};
			const rows = (state.playerOrder || Object.keys(players))
				.map(pid => {
					const fs = finalScores[pid] || {};
					return {
						pid,
						name: players[pid]?.name || pid,
						total: Number(fs.finalTotal ?? players[pid]?.score ?? 0),
						wins: Number(fs.matchWins ?? players[pid]?.matchWins ?? 0),
						coins: Number(fs.goldCoins ?? players[pid]?.goldCoins ?? 0)
					};
				})
				.sort((a, b) => (b.wins - a.wins) || (b.total - a.total));

			const winnerPid = state.winner || rows[0]?.pid || null;
			const winnerName = winnerPid ? (players[winnerPid]?.name || winnerPid) : '‚Äî';
			subEl.textContent = `Winnaar: ${winnerName}`;

			listEl.innerHTML = rows.map((r, i) => `
				<div class="tv-phase-row ${r.pid === winnerPid ? 'winner' : ''}">
					<div>
						<div class="name">${i === 0 ? 'üëë ' : ''}${esc(r.name)}</div>
						<div class="meta">Wins ${r.wins} ‚Ä¢ Goud ${r.coins}</div>
					</div>
					<div class="ready ok">${r.total} pt</div>
				</div>
			`).join('');
		}

		// ‚îÄ‚îÄ Opponent Interaction (ghost preview on board) ‚îÄ‚îÄ
		function onOpponentInteraction(data) {
			if (!data) return;
			clearGhostPreview();
			if (data.type === 'end' || data.type === 'start') return;
			if (data.type !== 'move') return;
			if (!data.zoneName || !Array.isArray(data.matrix)) return;
			if (!Number.isFinite(data.baseX) || !Number.isFinite(data.baseY)) return;

			const isValid = data.isValid !== false;
			for (let r = 0; r < data.matrix.length; r++) {
				for (let c = 0; c < (data.matrix[r]?.length || 0); c++) {
					if (!data.matrix[r][c]) continue;
					const x = data.baseX + c;
					const y = data.baseY + r;
					const sel = data.subgridId
						? `.tv-cell[data-zone="${data.zoneName}"][data-subgrid="${data.subgridId}"][data-x="${x}"][data-y="${y}"]`
						: `.tv-cell[data-zone="${data.zoneName}"][data-x="${x}"][data-y="${y}"]`;
					const el = document.querySelector(sel);
					if (el) {
						el.classList.add('preview-ghost');
						if (!isValid) el.classList.add('preview-denied');
						ghostCells.push(el);
					}
				}
			}
		}

		function clearGhostPreview() {
			for (const el of ghostCells) {
				if (el && el.classList) {
					el.classList.remove('preview-ghost', 'preview-denied');
				}
			}
			ghostCells = [];
		}

		// ‚îÄ‚îÄ Waiting Screen ‚îÄ‚îÄ
		function renderWaiting(state) {
			const statusEl = document.getElementById('tv-status');
			const codeEl = document.getElementById('tv-room-code');
			const listEl = document.getElementById('tv-player-list');
			const qrWrap = document.getElementById('tv-waiting-qr-wrap');
			const qrImg = document.getElementById('tv-waiting-qr');
			const qrLink = document.getElementById('tv-waiting-qr-link');

			if (state.inviteCode) {
				const code = String(state.inviteCode).toUpperCase().replace(/[^A-Z0-9]/g, '').slice(0, 6);
				codeEl.textContent = code;
				codeEl.style.display = 'block';
				statusEl.textContent = 'Wachten op spelers...';
				if (qrWrap && qrImg && qrLink) {
					const joinUrl = new URL('multiplayer.html', window.location.href);
					joinUrl.searchParams.set('join', code);
					const href = joinUrl.href;
					qrImg.src = `https://api.qrserver.com/v1/create-qr-code/?size=260x260&margin=0&data=${encodeURIComponent(href)}`;
					qrLink.href = href;
					qrWrap.style.display = 'flex';
				}
			} else if (qrWrap) {
				qrWrap.style.display = 'none';
			}

			if (state.phase === 'choosingGoals' || state.phase === 'choosingStartDeck') {
				statusEl.textContent = state.phase === 'choosingStartDeck'
					? 'Spelers kiezen hun startdeck...'
					: 'Spelers kiezen hun doelstelling...';
			}

			const players = state.players || {};
			const order = state.playerOrder || Object.keys(players);
			listEl.innerHTML = order.map(pid => {
				const p = players[pid];
				if (!p) return '';
				const dot = p.connected !== false
					? '<span class="tv-connected"></span>'
					: '<span class="tv-disconnected"></span>';
				return `<div class="tv-player-chip">${dot} ${esc(p.name || 'Speler')}</div>`;
			}).join('');
		}

		// ‚îÄ‚îÄ Game Rendering ‚îÄ‚îÄ
		function renderGame(state, prevState) {
			renderBoard(state.boardState, prevState?.boardState || null);
			renderScoreboard(state, prevState || null);
			renderTurnInfo(state);
			renderCurrentHand(state);
			updateTimer(state);
		}

		// ‚îÄ‚îÄ Board ‚îÄ‚îÄ
		function renderBoard(boardState, prevBoardState) {
			const container = document.getElementById('tv-board');
			if (!container || !boardState) return;
			const justPlaced = collectNewlyActivatedCells(prevBoardState, boardState);

			const zones = boardState.zones;
			container.innerHTML = `
				<div class="tv-board-col mp-board-col mp-board-col-left">
					${renderZone('yellow', zones.yellow, justPlaced)}
					${renderZone('green', zones.green, justPlaced)}
				</div>
				<div class="tv-board-col mp-board-col mp-board-col-middle">
					${renderZone('blue', zones.blue, justPlaced)}
				</div>
				<div class="tv-board-col mp-board-col mp-board-col-right">
					${renderRedZone(zones.red, justPlaced)}
					${renderZone('purple', zones.purple, justPlaced)}
				</div>
			`;

			// Auto-scale board to fit the available area
			requestAnimationFrame(() => {
				const area = container.parentElement;
				if (!area) return;
				const areaW = area.clientWidth - 32;
				const areaH = area.clientHeight - 32;
				const boardW = container.scrollWidth;
				const boardH = container.scrollHeight;
				if (boardW > 0 && boardH > 0) {
					const scale = Math.min(1, areaW / boardW, areaH / boardH);
					container.style.transform = `scale(${scale})`;
					container.style.transformOrigin = 'center center';
				}
			});
		}

		// ‚îÄ‚îÄ Bonus dot colors ‚îÄ‚îÄ
		const bonusColors = {
			yellow: '#cfba51', green: '#92c28c', blue: '#5689b0',
			red: '#b56069', purple: '#8f76b8',
			any: 'linear-gradient(135deg, #cfba51 0%, #92c28c 24%, #5689b0 48%, #b56069 72%, #8f76b8 100%)'
		};
		const zoneActiveColors = {
			yellow: '#cfba51', green: '#92c28c', blue: '#5689b0',
			red: '#b56069', purple: '#8f76b8'
		};

		function buildCellKey(zoneName, subgridId, x, y) {
			return `${zoneName}|${subgridId || ''}|${x},${y}`;
		}

		function getCellFromBoard(boardState, zoneName, subgridId, x, y) {
			if (!boardState?.zones) return null;
			if (zoneName === 'red') {
				const sgs = boardState.zones.red?.subgrids || [];
				const sg = sgs.find(s => s.id === subgridId);
				return sg?.cells?.[`${x},${y}`] || null;
			}
			return boardState.zones?.[zoneName]?.cells?.[`${x},${y}`] || null;
		}

		function collectNewlyActivatedCells(prevBoardState, boardState) {
			const out = new Set();
			if (!boardState?.zones) return out;

			for (const zoneName of ['yellow', 'green', 'blue', 'purple']) {
				const zone = boardState.zones[zoneName];
				for (const cell of Object.values(zone?.cells || {})) {
					if (!cell) continue;
					const now = !!(cell.active || cell.playerId);
					if (!now) continue;
					const prev = getCellFromBoard(prevBoardState, zoneName, null, cell.x, cell.y);
					const before = !!(prev?.active || prev?.playerId);
					if (!before) out.add(buildCellKey(zoneName, null, cell.x, cell.y));
				}
			}

			for (const sg of (boardState.zones.red?.subgrids || [])) {
				for (const cell of Object.values(sg?.cells || {})) {
					if (!cell) continue;
					const now = !!(cell.active || cell.playerId);
					if (!now) continue;
					const prev = getCellFromBoard(prevBoardState, 'red', sg.id, cell.x, cell.y);
					const before = !!(prev?.active || prev?.playerId);
					if (!before) out.add(buildCellKey('red', sg.id, cell.x, cell.y));
				}
			}

			return out;
		}

		function renderCell(cell, zoneName, subgridId, justPlacedSet) {
			if (!cell) return '<div class="tv-cell mp-cell void"></div>';

			const flags = cell.flags || [];
			const classes = ['tv-cell', 'mp-cell'];
			const isActive = cell.active || !!cell.playerId;
			if (isActive) classes.push('active');
			if (flags.includes('bold')) classes.push('bold');
			if (flags.includes('end')) classes.push('end');
			if (flags.includes('gold')) classes.push('gold');
			if (flags.includes('outer-ring-0')) classes.push('outer-ring-0');
			if (flags.includes('outer-ring-1')) classes.push('outer-ring-1');
			if (zoneName === 'green' && flags.includes('end')) classes.push('green-end');
			if (justPlacedSet?.has(buildCellKey(zoneName, subgridId, cell.x, cell.y))) classes.push('just-placed');

			// Background color
			let style = '';
			if (isActive && cell.color) {
				const code = typeof cell.color === 'string' ? cell.color : (cell.color?.code || '');
				if (code === 'rainbow') {
					style = `background:${zoneActiveColors[zoneName] || '#888'};`;
				} else if (code) {
					style = `background:${code};`;
				}
			}

			// Inner content
			let inner = '';
			if (cell.bonusSymbol && !isActive) {
				const bg = bonusColors[cell.bonusSymbol] || '#888';
				inner += `<span class="tv-bonus-dot" style="background:${bg}"></span>`;
			}
			if (flags.includes('gold') && !isActive) {
				inner += '<span class="tv-gold-dot"></span>';
			}
			if (cell.treasureCoins && !isActive) {
				inner += `<span class="tv-pearl-dot" title="+${cell.treasureCoins}"></span>`;
			}

			const dataAttrs = `data-x="${cell.x}" data-y="${cell.y}" data-zone="${zoneName}"${subgridId ? ` data-subgrid="${subgridId}"` : ''}`;

			return `<div class="${classes.join(' ')}" ${dataAttrs} style="${style}">${inner}</div>`;
		}

		function renderZone(name, zoneData, justPlacedSet) {
			if (!zoneData) return '';
			const zoneRows = zoneData.rows || 0;
			const zoneCols = zoneData.cols || 0;
			const cells = zoneData.cells;
			if (!cells || !zoneRows || !zoneCols) return '';

			let cellsHtml = '';
			for (let y = 0; y < zoneRows; y++) {
				for (let x = 0; x < zoneCols; x++) {
					const key = `${x},${y}`;
					const cell = cells[key];
					cellsHtml += renderCell(cell, name, null, justPlacedSet);
				}
			}

			return `
				<div class="tv-zone mp-zone tv-zone-${name} mp-zone-${name}">
					<div class="tv-grid mp-grid" style="grid-template-columns: repeat(${zoneCols}, var(--mp-cell-size));">
						${cellsHtml}
					</div>
				</div>
			`;
		}

		function renderRedZone(redData, justPlacedSet) {
			if (!redData) return '';
			const subgrids = redData.subgrids || [];
			if (subgrids.length === 0) return '';

			let subgridsHtml = '';
			for (const sg of subgrids) {
				const sgRows = sg.rows || 0;
				const sgCols = sg.cols || 0;
				const sgCells = sg.cells;
				if (!sgCells || !sgRows || !sgCols) continue;

				let cellsHtml = '';
				for (let y = 0; y < sgRows; y++) {
					for (let x = 0; x < sgCols; x++) {
						const key = `${x},${y}`;
						cellsHtml += renderCell(sgCells[key], 'red', sg.id, justPlacedSet);
					}
				}

				// Progress bar
				const allCells = Object.values(sgCells);
				const filledCount = allCells.filter(c => c.active || c.playerId).length;
				const totalCount = allCells.length;
				const fillPct = totalCount > 0 ? Math.round((filledCount / totalCount) * 100) : 0;
				const ptsLabel = sg.targetPoints
					? `<span class="tv-red-target">${sg.targetPoints}pt</span>`
					: '';

				subgridsHtml += `
					<div style="position:relative;">
						${ptsLabel}
						<div class="tv-grid mp-grid mp-red-subgrid" style="grid-template-columns: repeat(${sgCols}, var(--mp-cell-size));">
							${cellsHtml}
						</div>
						<div class="tv-red-progress"><div class="tv-red-progress-fill" style="width:${fillPct}%"></div></div>
					</div>
				`;
			}

			return `
				<div class="tv-zone mp-zone tv-zone-red mp-zone-red">
					<div class="tv-red-group mp-red-group">${subgridsHtml}</div>
				</div>
			`;
		}

		// ‚îÄ‚îÄ Scoreboard (with player cards) ‚îÄ‚îÄ
		function renderScoreboard(state, prevState) {
			const container = document.getElementById('tv-scoreboard');
			if (!container) return;

			const players = state.players || {};
			const order = state.playerOrder || [];
			const currentPid = order[state.currentTurnIndex] || null;

			// Sort by score descending
			const sorted = order.map((pid, i) => ({
				pid, rank: i + 1,
				name: players[pid]?.name || 'Speler',
				score: players[pid]?.score || 0,
				connected: players[pid]?.connected !== false,
				hand: players[pid]?.hand,
				isCurrent: pid === currentPid
			})).sort((a, b) => b.score - a.score);

			container.innerHTML = sorted.map((p, i) => {
				const prevScore = prevState?.players?.[p.pid]?.score || 0;
				const scoreUpClass = p.score > prevScore ? 'score-up' : '';
				// Render mini cards for this player
				let cardsHtml = '';
				const hand = p.hand;
				if (Array.isArray(hand) && hand.length > 0) {
					if (typeof hand[0] === 'object' && hand[0]?.matrix) {
						// Full card data available ‚Äî render mini grids
						cardsHtml = '<div class="tv-player-cards">' + hand.map(card => {
							const matrix = card.matrix || [];
							const colorCode = card.color?.code || '#666';
							const isRainbow = colorCode === 'rainbow';
							const cols = matrix[0]?.length || 0;
							const fill = isRainbow
								? 'background: linear-gradient(135deg, #b56069, #cfba51, #92c28c, #5689b0, #8f76b8)'
								: `background: ${colorCode}`;
							let miniCells = '';
							for (const row of matrix) {
								for (const c of row) {
									miniCells += c
										? `<div class="tv-mini-cell mp-mini-cell filled" style="${fill}"></div>`
										: '<div class="tv-mini-cell mp-mini-cell"></div>';
								}
							}
							return `<div class="tv-player-mini-card mp-mini-grid" style="grid-template-columns: repeat(${cols}, 10px);">${miniCells}</div>`;
						}).join('') + '</div>';
					} else {
						// Only count
						const count = typeof hand === 'number' ? hand : hand.length;
						cardsHtml = `<div class="tv-score-cards-count">${count} kaart${count !== 1 ? 'en' : ''}</div>`;
					}
				} else if (typeof hand === 'number' && hand > 0) {
					cardsHtml = `<div class="tv-score-cards-count">${hand} kaart${hand !== 1 ? 'en' : ''}</div>`;
				}

				return `
					<div class="tv-score-row mp-score-row ${p.isCurrent ? 'current-turn is-active' : ''} ${!p.connected ? 'disconnected' : ''} ${scoreUpClass}">
						<div class="tv-score-main">
							<span class="tv-score-rank mp-score-rank">${i + 1}</span>
							<div class="tv-score-meta">
								<div class="tv-score-name mp-score-name">${esc(p.name)} ${!p.connected ? 'üîå' : ''}</div>
								${cardsHtml}
							</div>
						</div>
						<span class="tv-score-pts mp-score-value-big">${p.score}</span>
					</div>
				`;
			}).join('');
		}

		// ‚îÄ‚îÄ Turn Info ‚îÄ‚îÄ
		function renderTurnInfo(state) {
			const players = state.players || {};
			const order = state.playerOrder || [];
			const currentPid = order[state.currentTurnIndex] || null;
			const player = currentPid ? players[currentPid] : null;

			const turnEl = document.getElementById('tv-turn-player');
			const roundEl = document.getElementById('tv-round-badge');

			if (turnEl) {
				turnEl.textContent = player ? player.name : '‚Äî';
				turnEl.className = 'tv-turn-player';
			}
			if (roundEl) {
				roundEl.textContent = `Ronde ${state.turnCount || 1} ‚Ä¢ Level ${state.level || 1}`;
			}
		}

		// ‚îÄ‚îÄ Current Player Hand ‚îÄ‚îÄ
		function renderCurrentHand(state) {
			const labelEl = document.getElementById('tv-hand-label');
			const cardsEl = document.getElementById('tv-hand-cards');
			if (!labelEl || !cardsEl) return;

			const players = state.players || {};
			const order = state.playerOrder || [];
			const currentPid = order[state.currentTurnIndex] || null;
			const player = currentPid ? players[currentPid] : null;

			if (!player) {
				labelEl.textContent = '';
				cardsEl.innerHTML = '';
				return;
			}

			const hand = Array.isArray(player.hand) ? player.hand : [];
			labelEl.textContent = `${player.name}'s kaarten:`;

			if (hand.length === 0) {
				cardsEl.innerHTML = '<span class="tv-hidden-hand">Geen kaarten</span>';
				return;
			}

			// Check if hand has actual card data (not just count)
			const hasCardData = hand[0] && typeof hand[0] === 'object' && hand[0].matrix;
			if (!hasCardData) {
				cardsEl.innerHTML = `<span class="tv-hidden-hand">${hand.length} kaart${hand.length !== 1 ? 'en' : ''}</span>`;
				return;
			}

			cardsEl.innerHTML = hand.map(card => {
				const matrix = card.matrix || [];
				const colorCode = card.color?.code || '#666';
				const isRainbow = colorCode === 'rainbow';
				const cols = matrix[0]?.length || 0;
				const fill = isRainbow
					? 'background: linear-gradient(135deg, #b56069, #cfba51, #92c28c, #5689b0, #8f76b8)'
					: `background: ${colorCode}`;

				let cells = '';
				for (const row of matrix) {
					for (const c of row) {
						cells += c
							? `<div class="tv-card-cell mp-mini-cell filled" style="${fill}"></div>`
							: '<div class="tv-card-cell mp-mini-cell"></div>';
					}
				}

				return `
					<div class="tv-card mp-card">
						<div class="tv-card-grid mp-mini-grid" style="grid-template-columns: repeat(${cols}, 14px);">
							${cells}
						</div>
						<span class="tv-card-name mp-card-name">${esc(card.shapeName || card.id || '')}</span>
					</div>
				`;
			}).join('');
		}

		// ‚îÄ‚îÄ Timer (with sound) ‚îÄ‚îÄ
		let lastTimerBeep = null;
		function updateTimer(state) {
			const timerEl = document.getElementById('tv-timer');
			const fillEl = document.getElementById('tv-timer-fill');
			const textEl = document.getElementById('tv-timer-text');
			if (!timerEl || !fillEl || !textEl) return;

			if (state.paused) {
				timerEl.style.display = 'flex';
				textEl.textContent = '‚è∏';
				fillEl.style.width = '100%';
				fillEl.className = 'tv-timer-fill';
				clearInterval(timerInterval);
				return;
			}

			const start = state._turnTimerStart;
			const duration = state._turnTimerDurationMs;
			if (!start || !duration) {
				timerEl.style.display = 'none';
				clearInterval(timerInterval);
				return;
			}

			timerEl.style.display = 'flex';
			clearInterval(timerInterval);

			function tick() {
				const elapsed = Date.now() - start;
				const remaining = Math.max(0, duration - elapsed);
				const pct = (remaining / duration) * 100;
				const secs = Math.ceil(remaining / 1000);

				fillEl.style.width = pct + '%';
				textEl.textContent = secs + 's';

				fillEl.className = 'tv-timer-fill';
				if (pct < 25) fillEl.classList.add('danger');
				else if (pct < 50) fillEl.classList.add('warning');

				// Beep in last 5 seconds
				if (secs <= 5 && secs > 0 && lastTimerBeep !== secs) {
					lastTimerBeep = secs;
					playTimerWarningSound();
				}
			}

			lastTimerBeep = null;
			tick();
			timerInterval = setInterval(tick, 500);
		}

		// ‚îÄ‚îÄ Taunt ‚îÄ‚îÄ
		function showTaunt(data) {
			const el = document.getElementById('tv-taunt');
			const nameEl = document.getElementById('tv-taunt-name');
			const textEl = document.getElementById('tv-taunt-text');
			if (!el || !nameEl || !textEl) return;

			nameEl.textContent = data.playerName || 'Speler';
			textEl.textContent = data.text || '';
			el.classList.add('show');

			setTimeout(() => el.classList.remove('show'), 2500);
		}

		// ‚îÄ‚îÄ Level Complete ‚îÄ‚îÄ
		function showLevelComplete(data) {
			const overlay = document.getElementById('tv-level-overlay');
			const titleEl = document.getElementById('tv-level-title');
			const scoresEl = document.getElementById('tv-level-scores');
			if (!overlay || !titleEl || !scoresEl) return;

			titleEl.textContent = `Level ${data.level || '?'} Compleet!`;

			const scores = data.levelScores || {};
			const winner = data.levelWinner;

			scoresEl.innerHTML = Object.entries(scores)
				.sort((a, b) => (b[1]?.total || 0) - (a[1]?.total || 0))
				.map(([pid, s]) => `
					<div class="tv-level-score-row ${pid === winner ? 'winner' : ''}">
						<span>${esc(s.name || pid)} ${pid === winner ? 'üëë' : ''}</span>
						<span style="font-weight:700; color: var(--tv-gold);">${s.total || 0} pt</span>
					</div>
				`).join('');

			overlay.classList.add('show');
		}

		// ‚îÄ‚îÄ Util ‚îÄ‚îÄ
		function esc(s) {
			const d = document.createElement('div');
			d.textContent = s;
			return d.innerHTML;
		}
	})();
	</script>
</body>
</html>
