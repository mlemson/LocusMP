<!DOCTYPE html>
<html lang="nl">
<head>
	<meta charset="utf-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>LOCUS ‚Äî TV Display</title>
	<style>
		/* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
		   LOCUS TV DISPLAY ‚Äî Big Screen Spectator View
		   ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */
		:root {
			--tv-bg: #0c0e14;
			--tv-panel: rgba(20,22,34,0.92);
			--tv-text: #e8e6e0;
			--tv-dim: rgba(255,255,255,0.45);
			--tv-accent: #6366f1;
			--tv-gold: #f0c040;
			--tv-radius: 12px;
			--tv-cell-size: 32px;
			--tv-cell-gap: 3px;
			--tv-cell-radius: 6px;
		}
		* { margin: 0; padding: 0; box-sizing: border-box; }
		body {
			background: var(--tv-bg);
			color: var(--tv-text);
			font-family: 'Segoe UI', -apple-system, sans-serif;
			overflow: hidden;
			width: 100vw;
			height: 100vh;
		}

		/* ‚îÄ‚îÄ Waiting / Connection State ‚îÄ‚îÄ */
		.tv-waiting {
			display: flex;
			flex-direction: column;
			align-items: center;
			justify-content: center;
			height: 100vh;
			gap: 24px;
		}
		.tv-waiting h1 {
			font-size: 3rem;
			font-weight: 800;
			letter-spacing: 8px;
			background: linear-gradient(135deg, #6366f1, #818cf8, #c084fc);
			-webkit-background-clip: text;
			-webkit-text-fill-color: transparent;
		}
		.tv-waiting p {
			font-size: 1.3rem;
			color: var(--tv-dim);
		}
		.tv-waiting .tv-room-code {
			font-size: 3.5rem;
			font-weight: 800;
			letter-spacing: 12px;
			color: var(--tv-gold);
			padding: 16px 40px;
			background: rgba(240,192,64,0.08);
			border: 2px solid rgba(240,192,64,0.2);
			border-radius: 16px;
		}
		.tv-pulse {
			animation: tvPulse 2s ease-in-out infinite;
		}
		@keyframes tvPulse {
			0%, 100% { opacity: 0.5; }
			50% { opacity: 1; }
		}
		.tv-player-list {
			display: flex;
			gap: 16px;
			flex-wrap: wrap;
			justify-content: center;
			margin-top: 16px;
		}
		.tv-player-chip {
			background: var(--tv-panel);
			border: 1px solid rgba(255,255,255,0.1);
			border-radius: 24px;
			padding: 8px 20px;
			font-size: 1.1rem;
			display: flex;
			align-items: center;
			gap: 8px;
		}
		.tv-player-chip .tv-connected {
			width: 8px; height: 8px;
			border-radius: 50%;
			background: #22c55e;
		}
		.tv-player-chip .tv-disconnected {
			width: 8px; height: 8px;
			border-radius: 50%;
			background: #ef4444;
		}

		/* ‚îÄ‚îÄ Game Layout ‚îÄ‚îÄ */
		.tv-game {
			display: none;
			width: 100vw;
			height: 100vh;
			grid-template-columns: 1fr auto;
			grid-template-rows: auto 1fr auto;
			grid-template-areas:
				"top    top"
				"board  sidebar"
				"bottom bottom";
		}
		.tv-game.active { display: grid; }

		/* ‚îÄ‚îÄ Top Bar ‚îÄ‚îÄ */
		.tv-top-bar {
			grid-area: top;
			display: flex;
			align-items: center;
			justify-content: space-between;
			padding: 12px 24px;
			background: var(--tv-panel);
			border-bottom: 1px solid rgba(255,255,255,0.06);
			backdrop-filter: blur(12px);
		}
		.tv-turn-info {
			display: flex;
			align-items: center;
			gap: 16px;
		}
		.tv-turn-label {
			font-size: 0.9rem;
			color: var(--tv-dim);
			text-transform: uppercase;
			letter-spacing: 1px;
		}
		.tv-turn-player {
			font-size: 1.5rem;
			font-weight: 700;
		}
		.tv-turn-player.my-turn {
			color: var(--tv-gold);
		}
		.tv-round-badge {
			font-size: 0.85rem;
			color: var(--tv-dim);
			background: rgba(255,255,255,0.06);
			padding: 4px 12px;
			border-radius: 8px;
		}
		.tv-logo-small {
			font-size: 1.2rem;
			font-weight: 800;
			letter-spacing: 4px;
			color: var(--tv-dim);
		}

		/* ‚îÄ‚îÄ Timer ‚îÄ‚îÄ */
		.tv-timer {
			display: flex;
			align-items: center;
			gap: 8px;
			font-size: 1.1rem;
			font-weight: 600;
		}
		.tv-timer-bar {
			width: 120px;
			height: 6px;
			background: rgba(255,255,255,0.1);
			border-radius: 3px;
			overflow: hidden;
		}
		.tv-timer-fill {
			height: 100%;
			border-radius: 3px;
			background: var(--tv-accent);
			transition: width 1s linear, background 0.3s ease;
			width: 100%;
		}
		.tv-timer-fill.warning { background: #f59e0b; }
		.tv-timer-fill.danger { background: #ef4444; }

		/* ‚îÄ‚îÄ Board ‚îÄ‚îÄ */
		.tv-board-area {
			grid-area: board;
			display: flex;
			align-items: center;
			justify-content: center;
			padding: 16px;
			overflow: hidden;
		}
		.tv-board {
			display: flex;
			gap: 12px;
			max-width: 100%;
			max-height: 100%;
		}
		.tv-board-col {
			display: flex;
			flex-direction: column;
			gap: 12px;
		}
		.tv-zone {
			border-radius: var(--tv-radius);
			padding: 10px;
			position: relative;
		}
		.tv-zone-label {
			position: absolute;
			top: -8px;
			left: 12px;
			font-size: 0.65rem;
			font-weight: 700;
			text-transform: uppercase;
			letter-spacing: 1.5px;
			padding: 2px 8px;
			border-radius: 4px;
			z-index: 2;
		}
		.tv-grid {
			display: grid;
			gap: var(--tv-cell-gap);
		}
		.tv-cell {
			width: var(--tv-cell-size);
			height: var(--tv-cell-size);
			border-radius: var(--tv-cell-radius);
			border: 1px solid rgba(255,255,255,0.08);
			background: rgba(255,255,255,0.04);
			transition: background 0.3s ease;
		}
		.tv-cell.void { visibility: hidden; }
		.tv-cell.active {
			transform: scale(1.02);
		}
		/* Bonus dots on unclaimed cells */
		.tv-bonus-dot {
			display: flex;
			align-items: center;
			justify-content: center;
			width: 16px;
			height: 16px;
			border-radius: 4px;
			background: rgba(255,255,255,0.35);
			margin: auto;
			box-shadow: 0 0 3px rgba(0,0,0,0.2);
		}
		/* Zone colors */
		.tv-zone-yellow { background: rgba(207,186,81,0.08); border: 1px solid rgba(207,186,81,0.18); }
		.tv-zone-yellow .tv-zone-label { background: rgba(207,186,81,0.85); color: #1a1700; }
		.tv-zone-yellow .tv-cell { background: rgba(207,186,81,0.10); border-color: rgba(207,186,81,0.20); }
		.tv-zone-yellow .tv-cell.active { background: rgba(207,186,81,0.65); border-color: rgba(207,186,81,0.80); box-shadow: 0 0 6px rgba(207,186,81,0.3); }

		.tv-zone-green { background: rgba(90,171,110,0.08); border: 1px solid rgba(90,171,110,0.18); }
		.tv-zone-green .tv-zone-label { background: rgba(90,171,110,0.85); color: #0a1f0e; }
		.tv-zone-green .tv-cell { background: rgba(90,171,110,0.10); border-color: rgba(90,171,110,0.20); }
		.tv-zone-green .tv-cell.active { background: rgba(90,171,110,0.65); border-color: rgba(90,171,110,0.80); box-shadow: 0 0 6px rgba(90,171,110,0.3); }

		.tv-zone-blue { background: rgba(86,137,176,0.08); border: 1px solid rgba(86,137,176,0.18); }
		.tv-zone-blue .tv-zone-label { background: rgba(86,137,176,0.85); color: #0a1520; }
		.tv-zone-blue .tv-cell { background: rgba(86,137,176,0.10); border-color: rgba(86,137,176,0.20); }
		.tv-zone-blue .tv-cell.active { background: rgba(86,137,176,0.65); border-color: rgba(86,137,176,0.80); box-shadow: 0 0 6px rgba(86,137,176,0.3); }

		.tv-zone-red { background: rgba(181,96,105,0.08); border: 1px solid rgba(181,96,105,0.18); }
		.tv-zone-red .tv-zone-label { background: rgba(181,96,105,0.85); color: #200a0c; }
		.tv-zone-red .tv-cell { background: rgba(181,96,105,0.10); border-color: rgba(181,96,105,0.20); }
		.tv-zone-red .tv-cell.active { background: rgba(181,96,105,0.65); border-color: rgba(181,96,105,0.80); box-shadow: 0 0 6px rgba(181,96,105,0.3); }

		.tv-zone-purple { background: rgba(143,118,184,0.08); border: 1px solid rgba(143,118,184,0.18); }
		.tv-zone-purple .tv-zone-label { background: rgba(143,118,184,0.85); color: #120a20; }
		.tv-zone-purple .tv-cell { background: rgba(143,118,184,0.10); border-color: rgba(143,118,184,0.20); }
		.tv-zone-purple .tv-cell.active { background: rgba(143,118,184,0.65); border-color: rgba(143,118,184,0.80); box-shadow: 0 0 6px rgba(143,118,184,0.3); }

		/* Red subgrids */
		.tv-red-group {
			display: flex;
			flex-wrap: wrap;
			gap: 8px;
			justify-content: center;
		}

		/* ‚îÄ‚îÄ Sidebar ‚îÄ‚îÄ */
		.tv-sidebar {
			grid-area: sidebar;
			width: 260px;
			display: flex;
			flex-direction: column;
			gap: 8px;
			padding: 12px;
			background: var(--tv-panel);
			border-left: 1px solid rgba(255,255,255,0.06);
			overflow-y: auto;
		}
		.tv-score-row {
			display: flex;
			align-items: center;
			gap: 10px;
			padding: 10px 12px;
			border-radius: 10px;
			background: rgba(255,255,255,0.03);
			border: 1px solid rgba(255,255,255,0.06);
			transition: all 0.3s ease;
		}
		.tv-score-row.current-turn {
			background: rgba(99,102,241,0.12);
			border-color: rgba(99,102,241,0.3);
			box-shadow: 0 0 12px rgba(99,102,241,0.15);
		}
		.tv-score-rank {
			font-size: 0.75rem;
			color: var(--tv-dim);
			width: 16px;
			text-align: center;
		}
		.tv-score-name {
			flex: 1;
			font-weight: 600;
			font-size: 0.95rem;
			white-space: nowrap;
			overflow: hidden;
			text-overflow: ellipsis;
		}
		.tv-score-pts {
			font-weight: 700;
			font-size: 1.1rem;
			color: var(--tv-gold);
			min-width: 36px;
			text-align: right;
		}
		.tv-score-cards {
			font-size: 0.7rem;
			color: var(--tv-dim);
		}

		/* ‚îÄ‚îÄ Bottom Bar (Current Player Hand) ‚îÄ‚îÄ */
		.tv-bottom-bar {
			grid-area: bottom;
			display: flex;
			align-items: center;
			justify-content: center;
			gap: 16px;
			padding: 12px 24px;
			background: var(--tv-panel);
			border-top: 1px solid rgba(255,255,255,0.06);
			min-height: 80px;
		}
		.tv-hand-label {
			font-size: 0.85rem;
			color: var(--tv-dim);
			text-transform: uppercase;
			letter-spacing: 1px;
		}
		.tv-hand-cards {
			display: flex;
			gap: 12px;
			align-items: center;
		}
		.tv-card {
			background: var(--tv-panel);
			border: 1px solid rgba(255,255,255,0.10);
			border-radius: 10px;
			padding: 8px;
			display: flex;
			flex-direction: column;
			align-items: center;
			gap: 4px;
			min-width: 80px;
		}
		.tv-card-name {
			font-size: 0.7rem;
			color: var(--tv-dim);
			text-align: center;
			white-space: nowrap;
		}
		.tv-card-grid {
			display: inline-grid;
			gap: 2px;
		}
		.tv-card-cell {
			width: 14px;
			height: 14px;
			border-radius: 3px;
		}
		.tv-card-cell.filled {
			box-shadow: inset 0 0 2px rgba(0,0,0,0.2);
		}
		.tv-card-cell:not(.filled) {
			background: rgba(255,255,255,0.04);
		}
		.tv-hidden-hand {
			font-size: 1rem;
			color: var(--tv-dim);
			font-style: italic;
		}

		/* ‚îÄ‚îÄ Taunt overlay ‚îÄ‚îÄ */
		.tv-taunt {
			position: fixed;
			top: 50%;
			left: 50%;
			transform: translate(-50%, -50%) scale(0);
			background: rgba(20,22,34,0.95);
			border: 2px solid rgba(99,102,241,0.3);
			border-radius: 20px;
			padding: 24px 48px;
			z-index: 100;
			text-align: center;
			transition: transform 0.3s cubic-bezier(0.34, 1.56, 0.64, 1), opacity 0.3s ease;
			opacity: 0;
			pointer-events: none;
		}
		.tv-taunt.show {
			transform: translate(-50%, -50%) scale(1);
			opacity: 1;
		}
		.tv-taunt-name {
			font-size: 0.9rem;
			color: var(--tv-accent);
			margin-bottom: 4px;
		}
		.tv-taunt-text {
			font-size: 2rem;
			font-weight: 700;
		}

		/* ‚îÄ‚îÄ Level Complete overlay ‚îÄ‚îÄ */
		.tv-level-overlay {
			position: fixed;
			inset: 0;
			background: rgba(0,0,0,0.85);
			display: none;
			align-items: center;
			justify-content: center;
			z-index: 50;
		}
		.tv-level-overlay.show { display: flex; }
		.tv-level-card {
			background: var(--tv-panel);
			border: 1px solid rgba(255,255,255,0.1);
			border-radius: 20px;
			padding: 40px 60px;
			text-align: center;
		}
		.tv-level-card h2 {
			font-size: 2rem;
			margin-bottom: 16px;
		}
		.tv-level-scores {
			display: flex;
			flex-direction: column;
			gap: 8px;
		}
		.tv-level-score-row {
			display: flex;
			align-items: center;
			justify-content: space-between;
			gap: 24px;
			padding: 8px 16px;
			border-radius: 8px;
			background: rgba(255,255,255,0.03);
		}
		.tv-level-score-row.winner {
			background: rgba(240,192,64,0.12);
			border: 1px solid rgba(240,192,64,0.3);
		}

		/* ‚îÄ‚îÄ Responsive: smaller TVs ‚îÄ‚îÄ */
		@media (max-width: 1200px) {
			:root {
				--tv-cell-size: 26px;
				--tv-cell-gap: 2px;
			}
			.tv-sidebar { width: 220px; }
		}
		@media (max-width: 900px) {
			:root {
				--tv-cell-size: 20px;
				--tv-cell-gap: 2px;
				--tv-cell-radius: 4px;
			}
			.tv-sidebar { width: 180px; }
			.tv-turn-player { font-size: 1.2rem; }
		}

		/* ‚ïê‚ïê‚ïê AURORA THEME ‚ïê‚ïê‚ïê */
		html.theme-aurora body {
			background: #0a0c18;
		}
		html.theme-aurora .tv-panel,
		html.theme-aurora .tv-top-bar,
		html.theme-aurora .tv-sidebar,
		html.theme-aurora .tv-bottom-bar {
			background: rgba(12,14,28,0.90);
			border-color: rgba(99,102,241,0.10);
		}
		html.theme-aurora .tv-waiting h1 {
			background: linear-gradient(135deg, #6366f1, #818cf8, #c084fc);
		}
		html.theme-aurora .tv-cell.active {
			box-shadow: 0 0 6px rgba(99,102,241,0.2);
		}

		/* ‚ïê‚ïê‚ïê BLOOM THEME ‚ïê‚ïê‚ïê */
		html.theme-bloom body {
			background: #faf5eb;
			color: #3d3429;
		}
		html.theme-bloom .tv-waiting h1 {
			background: linear-gradient(135deg, #c07050, #e0a070, #907050);
			-webkit-background-clip: text;
			-webkit-text-fill-color: transparent;
		}
		html.theme-bloom .tv-waiting p,
		html.theme-bloom .tv-dim,
		html.theme-bloom .tv-turn-label,
		html.theme-bloom .tv-round-badge,
		html.theme-bloom .tv-hand-label,
		html.theme-bloom .tv-hidden-hand,
		html.theme-bloom .tv-card-name,
		html.theme-bloom .tv-score-rank {
			color: rgba(61,52,41,0.55);
		}
		html.theme-bloom .tv-top-bar,
		html.theme-bloom .tv-sidebar,
		html.theme-bloom .tv-bottom-bar {
			background: rgba(248,244,236,0.95);
			border-color: rgba(180,160,130,0.12);
		}
		html.theme-bloom .tv-score-row {
			background: rgba(180,160,130,0.06);
			border-color: rgba(180,160,130,0.10);
		}
		html.theme-bloom .tv-score-row.current-turn {
			background: rgba(224,122,95,0.08);
			border-color: rgba(224,122,95,0.25);
			box-shadow: 0 0 10px rgba(224,122,95,0.08);
		}
		html.theme-bloom .tv-score-pts {
			color: #c07050;
		}
		html.theme-bloom .tv-room-code {
			color: #c07050;
			background: rgba(224,122,95,0.06);
			border-color: rgba(224,122,95,0.18);
		}
		html.theme-bloom .tv-zone {
			border-color: rgba(180,160,130,0.12);
		}
		html.theme-bloom .tv-cell {
			border-color: rgba(180,160,130,0.15);
			background: rgba(180,160,130,0.06);
		}
		html.theme-bloom .tv-cell.active {
			border-radius: 7px;
		}
		html.theme-bloom .tv-card {
			background: rgba(248,244,236,0.85);
			border-color: rgba(180,160,130,0.15);
		}
		html.theme-bloom .tv-logo-small {
			color: rgba(61,52,41,0.35);
		}
		html.theme-bloom .tv-taunt {
			background: rgba(248,244,236,0.96);
			border-color: rgba(224,122,95,0.25);
			color: #3d3429;
		}
		html.theme-bloom .tv-taunt-name {
			color: #c07050;
		}

		/* ‚ïê‚ïê‚ïê Cell detail styles ‚ïê‚ïê‚ïê */
		.tv-cell.bold {
			border-width: 2px;
			border-color: rgba(255,255,255,0.30);
		}
		.tv-cell.end {
			border-style: dashed;
			border-color: rgba(255,255,255,0.25);
		}
		.tv-cell.gold {
			box-shadow: inset 0 0 5px rgba(240,192,64,0.5);
		}
		.tv-cell.outer-ring-0 {
			border-color: rgba(143,118,184,0.45);
			border-width: 2px;
		}
		.tv-cell.outer-ring-1 {
			border-color: rgba(143,118,184,0.30);
			border-width: 2px;
		}
		.tv-cell.green-end.active {
			position: relative;
		}
		.tv-cell.green-end.active::after {
			content: '‚úì';
			position: absolute;
			inset: 0;
			display: flex;
			align-items: center;
			justify-content: center;
			font-size: 0.7em;
			font-weight: 700;
			color: rgba(255,255,255,0.85);
		}
		.tv-cell .tv-bonus-dot {
			display: flex;
			align-items: center;
			justify-content: center;
			width: 18px;
			height: 18px;
			border-radius: 4px;
			margin: auto;
			position: absolute;
			top: 50%;
			left: 50%;
			transform: translate(-50%, -50%);
			box-shadow: 0 0 4px rgba(0,0,0,0.3), inset 0 1px 2px rgba(255,255,255,0.3);
		}
		.tv-cell .tv-gold-dot {
			display: block;
			width: 14px;
			height: 14px;
			border-radius: 50%;
			background: radial-gradient(circle at 35% 35%, #ffe87c, #f0c040, #c8960a);
			box-shadow: 0 0 8px rgba(240,192,64,0.8), 0 0 3px rgba(240,192,64,0.5);
			margin: auto;
			position: absolute;
			top: 50%;
			left: 50%;
			transform: translate(-50%, -50%);
		}
		.tv-cell .tv-gold-dot::after {
			content: '‚ú¶';
			position: absolute;
			inset: 0;
			display: flex;
			align-items: center;
			justify-content: center;
			font-size: 8px;
			color: rgba(100,70,0,0.6);
		}
		.tv-cell .tv-pearl-dot {
			display: block;
			width: 14px;
			height: 14px;
			border-radius: 50%;
			background: radial-gradient(circle at 30% 30%, #fff, #e8e4f0, #c4c0d8);
			box-shadow: 0 0 6px rgba(255,255,255,0.6), 0 0 3px rgba(200,195,220,0.5);
			margin: auto;
			position: absolute;
			top: 50%;
			left: 50%;
			transform: translate(-50%, -50%);
		}
		.tv-cell .tv-pearl-dot::after {
			content: 'üíé';
			position: absolute;
			inset: 0;
			display: flex;
			align-items: center;
			justify-content: center;
			font-size: 8px;
		}
		.tv-cell { position: relative; }

		/* ‚îÄ‚îÄ Ghost/Preview overlay ‚îÄ‚îÄ */
		.tv-cell.preview-ghost {
			background: rgba(255,255,255,0.18) !important;
			border-color: rgba(255,255,255,0.35) !important;
			animation: tvGhostPulse 1.2s ease-in-out infinite;
		}
		.tv-cell.preview-ghost.preview-denied {
			background: rgba(239,68,68,0.20) !important;
			border-color: rgba(239,68,68,0.40) !important;
		}
		@keyframes tvGhostPulse {
			0%, 100% { opacity: 0.6; }
			50% { opacity: 1; }
		}

		/* ‚îÄ‚îÄ Player card mini-grids in sidebar ‚îÄ‚îÄ */
		.tv-player-cards {
			display: flex;
			gap: 4px;
			flex-wrap: wrap;
			margin-top: 4px;
		}
		.tv-player-mini-card {
			display: inline-grid;
			gap: 1px;
			opacity: 0.7;
		}
		.tv-mini-cell {
			width: 7px;
			height: 7px;
			border-radius: 2px;
		}
		.tv-mini-cell.filled {
			box-shadow: inset 0 0 1px rgba(0,0,0,0.2);
		}
		.tv-mini-cell:not(.filled) {
			background: rgba(255,255,255,0.04);
		}
		.tv-score-cards-count {
			font-size: 0.65rem;
			color: var(--tv-dim);
			margin-top: 2px;
		}

		/* ‚îÄ‚îÄ Red subgrid progress ‚îÄ‚îÄ */
		.tv-red-progress {
			height: 3px;
			background: rgba(255,255,255,0.08);
			border-radius: 2px;
			margin-top: 4px;
			overflow: hidden;
		}
		.tv-red-progress-fill {
			height: 100%;
			background: #b56069;
			border-radius: 2px;
			transition: width 0.3s ease;
		}
	</style>
</head>
<body>
	<!-- Waiting Screen -->
	<div id="tv-waiting" class="tv-waiting">
		<h1>LOCUS</h1>
		<p id="tv-status" class="tv-pulse">Wachten op verbinding met host...</p>
		<div id="tv-room-code" class="tv-room-code" style="display:none;">------</div>
		<div id="tv-player-list" class="tv-player-list"></div>
	</div>

	<!-- Game Screen -->
	<div id="tv-game" class="tv-game">
		<div class="tv-top-bar">
			<div class="tv-turn-info">
				<span class="tv-turn-label">Beurt:</span>
				<span id="tv-turn-player" class="tv-turn-player">‚Äî</span>
				<span id="tv-round-badge" class="tv-round-badge">Ronde 1</span>
			</div>
			<div id="tv-timer" class="tv-timer" style="display:none;">
				<div class="tv-timer-bar"><div id="tv-timer-fill" class="tv-timer-fill"></div></div>
				<span id="tv-timer-text">40s</span>
			</div>
			<span class="tv-logo-small">LOCUS</span>
		</div>

		<div class="tv-board-area">
			<div id="tv-board" class="tv-board"></div>
		</div>

		<div class="tv-sidebar">
			<div id="tv-scoreboard" style="display: flex; flex-direction: column; gap: 6px;"></div>
		</div>

		<div class="tv-bottom-bar">
			<span id="tv-hand-label" class="tv-hand-label"></span>
			<div id="tv-hand-cards" class="tv-hand-cards"></div>
		</div>
	</div>

	<!-- Taunt popup -->
	<div id="tv-taunt" class="tv-taunt">
		<div id="tv-taunt-name" class="tv-taunt-name"></div>
		<div id="tv-taunt-text" class="tv-taunt-text"></div>
	</div>

	<!-- Level Complete overlay -->
	<div id="tv-level-overlay" class="tv-level-overlay">
		<div class="tv-level-card">
			<h2 id="tv-level-title">Level Compleet!</h2>
			<div id="tv-level-scores" class="tv-level-scores"></div>
		</div>
	</div>

	<script>
	/**
	 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
	 * LOCUS TV Display Controller
	 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
	 * Receives game state from host via:
	 *  1. Presentation Receiver API (Chromecast / wireless display)
	 *  2. BroadcastChannel fallback (same-device popup window)
	 */
	(function() {
		'use strict';

		let currentState = null;
		let timerInterval = null;
		let presentationConn = null;
		let ghostCells = []; // current preview ghost cells

		// ‚ïê‚ïê‚ïê SOUND EFFECTS (Web Audio API) ‚ïê‚ïê‚ïê
		let audioCtx = null;
		function getAudioCtx() {
			if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
			return audioCtx;
		}
		function playTone(freq, duration = 0.15, type = 'sine', volume = 0.12) {
			try {
				const ctx = getAudioCtx();
				const osc = ctx.createOscillator();
				const gain = ctx.createGain();
				osc.type = type;
				osc.frequency.value = freq;
				gain.gain.setValueAtTime(volume, ctx.currentTime);
				gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + duration);
				osc.connect(gain); gain.connect(ctx.destination);
				osc.start(); osc.stop(ctx.currentTime + duration);
			} catch (_) {}
		}
		function playPlaceSound() {
			playTone(440, 0.1, 'sine', 0.10);
			setTimeout(() => playTone(660, 0.08, 'sine', 0.07), 60);
		}
		function playScoreSound() {
			playTone(523, 0.12, 'sine', 0.12);
			setTimeout(() => playTone(659, 0.12, 'sine', 0.10), 80);
			setTimeout(() => playTone(784, 0.15, 'sine', 0.10), 160);
		}
		function playTurnStartSound() {
			playTone(587, 0.12, 'sine', 0.08);
			setTimeout(() => playTone(784, 0.15, 'sine', 0.10), 100);
		}
		function playTimerWarningSound() { playTone(880, 0.2, 'sine', 0.08); }
		function playTauntSound() {
			playTone(520, 0.07, 'triangle', 0.09);
			setTimeout(() => playTone(660, 0.08, 'triangle', 0.08), 70);
		}
		function playGoldSound() {
			playTone(1047, 0.1, 'sine', 0.12);
			setTimeout(() => playTone(1319, 0.12, 'sine', 0.10), 80);
			setTimeout(() => playTone(1568, 0.15, 'sine', 0.08), 160);
		}
		function playLevelCompleteSound() {
			playTone(392, 0.2, 'sine', 0.12);
			setTimeout(() => playTone(494, 0.2, 'sine', 0.10), 150);
			setTimeout(() => playTone(587, 0.2, 'sine', 0.10), 300);
			setTimeout(() => playTone(784, 0.3, 'sine', 0.12), 450);
		}

		// Track previous state for detecting changes
		let prevTurnIndex = null;
		let prevScores = {};

		// ‚îÄ‚îÄ Unified message handler ‚îÄ‚îÄ
		function handleMessage(msg) {
			if (!msg || !msg.type) return;
			switch (msg.type) {
				case 'gameState':
					onGameState(msg.state);
					break;
				case 'taunt':
					showTaunt(msg.data);
					playTauntSound();
					break;
				case 'levelComplete':
					showLevelComplete(msg.data);
					playLevelCompleteSound();
					break;
				case 'theme':
					applyTheme(msg.theme);
					break;
				case 'ping':
					sendToHost({ type: 'pong' });
					break;
				case 'opponentInteraction':
					onOpponentInteraction(msg.data);
					break;
			}
		}

		// ‚îÄ‚îÄ Send message back to host (via active channel) ‚îÄ‚îÄ
		function sendToHost(msg) {
			if (presentationConn) {
				try { presentationConn.send(JSON.stringify(msg)); return; } catch (_) {}
			}
			if (bcChannel) {
				try { bcChannel.postMessage(msg); } catch (_) {}
			}
		}

		// ‚îÄ‚îÄ 1. Try Presentation Receiver API (Chromecast / wireless display) ‚îÄ‚îÄ
		let bcChannel = null;
		let receiverReady = false;

		if (navigator.presentation && navigator.presentation.receiver) {
			console.log('[TV] Presentation Receiver API detected, wachten op verbinding...');
			navigator.presentation.receiver.connectionList.then(list => {
				console.log('[TV] Presentation Receiver: connectionList ontvangen, connections:', list.connections.length);
				for (const conn of list.connections) {
					setupPresentationConnection(conn);
				}
				list.onconnectionavailable = (e) => {
					console.log('[TV] Nieuwe Presentation connection beschikbaar');
					setupPresentationConnection(e.connection);
				};
			}).catch(err => {
				console.warn('[TV] Presentation Receiver niet beschikbaar:', err);
				initBroadcastChannel();
			});

			// Safety: also try BroadcastChannel after 2s if no Presentation connection arrived
			setTimeout(() => {
				if (!receiverReady && !presentationConn) {
					console.log('[TV] Geen Presentation connection na 2s, probeer BroadcastChannel als backup');
					initBroadcastChannel();
				}
			}, 2000);
		} else {
			// ‚îÄ‚îÄ 2. Fallback: BroadcastChannel (same-device popup) ‚îÄ‚îÄ
			initBroadcastChannel();
		}

		function setupPresentationConnection(conn) {
			receiverReady = true;
			presentationConn = conn;
			console.log('[TV] Presentation connection opgezet, state:', conn.state);
			conn.onmessage = (e) => {
				try {
					const msg = typeof e.data === 'string' ? JSON.parse(e.data) : e.data;
					handleMessage(msg);
				} catch (err) {
					console.warn('[TV] Parse error:', err);
				}
			};
			conn.onclose = () => {
				console.log('[TV] Presentation connection gesloten');
				presentationConn = null;
			};
			sendToHost({ type: 'tvReady' });
			setTimeout(() => sendToHost({ type: 'tvReady' }), 500);
			setTimeout(() => sendToHost({ type: 'tvReady' }), 1500);
		}

		function initBroadcastChannel() {
			if (bcChannel) return;
			try {
				bcChannel = new BroadcastChannel('locus-tv');
				bcChannel.onmessage = (e) => handleMessage(e.data);
				bcChannel.postMessage({ type: 'tvReady' });
				setTimeout(() => { try { bcChannel.postMessage({ type: 'tvReady' }); } catch(_) {} }, 500);
				setTimeout(() => { try { bcChannel.postMessage({ type: 'tvReady' }); } catch(_) {} }, 1500);
			} catch (err) {
				console.warn('[TV] BroadcastChannel niet beschikbaar:', err);
			}
		}

		// ‚îÄ‚îÄ Apply theme from host ‚îÄ‚îÄ
		function applyTheme(theme) {
			document.documentElement.classList.remove('theme-aurora', 'theme-bloom');
			if (theme === 'aurora') document.documentElement.classList.add('theme-aurora');
			else if (theme === 'bloom') document.documentElement.classList.add('theme-bloom');
		}

		// ‚îÄ‚îÄ State Update ‚îÄ‚îÄ
		function onGameState(state) {
			if (!state) return;
			const prevState = currentState;
			currentState = state;

			const waitingEl = document.getElementById('tv-waiting');
			const gameEl = document.getElementById('tv-game');

			if (state.phase === 'waiting' || state.phase === 'choosingStartDeck' || state.phase === 'choosingGoals') {
				waitingEl.style.display = 'flex';
				gameEl.classList.remove('active');
				renderWaiting(state);
			} else if (state.phase === 'playing' || state.phase === 'shopping') {
				waitingEl.style.display = 'none';
				gameEl.classList.add('active');
				renderGame(state);
				document.getElementById('tv-level-overlay').classList.remove('show');

				// Sound effects based on state changes
				if (prevState) {
					// Turn changed
					if (state.currentTurnIndex !== prevTurnIndex && prevTurnIndex !== null) {
						playTurnStartSound();
					}
					// Score changed (someone scored)
					const order = state.playerOrder || [];
					for (const pid of order) {
						const newScore = state.players?.[pid]?.score || 0;
						const oldScore = prevScores[pid] || 0;
						if (newScore > oldScore) {
							playPlaceSound();
							break;
						}
					}
				}
				prevTurnIndex = state.currentTurnIndex;
				// Capture scores
				const players = state.players || {};
				prevScores = {};
				for (const pid of Object.keys(players)) {
					prevScores[pid] = players[pid]?.score || 0;
				}
			} else if (state.phase === 'levelComplete') {
				if (!gameEl.classList.contains('active')) {
					gameEl.classList.add('active');
					waitingEl.style.display = 'none';
				}
				renderGame(state);
			} else if (state.phase === 'ended') {
				renderGame(state);
			}
		}

		// ‚îÄ‚îÄ Opponent Interaction (ghost preview on board) ‚îÄ‚îÄ
		function onOpponentInteraction(data) {
			if (!data) return;
			clearGhostPreview();
			if (data.type === 'end' || data.type === 'start') return;
			if (data.type !== 'move') return;
			if (!data.zoneName || !Array.isArray(data.matrix)) return;
			if (!Number.isFinite(data.baseX) || !Number.isFinite(data.baseY)) return;

			const isValid = data.isValid !== false;
			for (let r = 0; r < data.matrix.length; r++) {
				for (let c = 0; c < (data.matrix[r]?.length || 0); c++) {
					if (!data.matrix[r][c]) continue;
					const x = data.baseX + c;
					const y = data.baseY + r;
					const sel = data.subgridId
						? `.tv-cell[data-zone="${data.zoneName}"][data-subgrid="${data.subgridId}"][data-x="${x}"][data-y="${y}"]`
						: `.tv-cell[data-zone="${data.zoneName}"][data-x="${x}"][data-y="${y}"]`;
					const el = document.querySelector(sel);
					if (el) {
						el.classList.add('preview-ghost');
						if (!isValid) el.classList.add('preview-denied');
						ghostCells.push(el);
					}
				}
			}
		}

		function clearGhostPreview() {
			for (const el of ghostCells) {
				if (el && el.classList) {
					el.classList.remove('preview-ghost', 'preview-denied');
				}
			}
			ghostCells = [];
		}

		// ‚îÄ‚îÄ Waiting Screen ‚îÄ‚îÄ
		function renderWaiting(state) {
			const statusEl = document.getElementById('tv-status');
			const codeEl = document.getElementById('tv-room-code');
			const listEl = document.getElementById('tv-player-list');

			if (state.inviteCode) {
				codeEl.textContent = state.inviteCode;
				codeEl.style.display = 'block';
				statusEl.textContent = 'Wachten op spelers...';
			}

			if (state.phase === 'choosingGoals' || state.phase === 'choosingStartDeck') {
				statusEl.textContent = state.phase === 'choosingStartDeck'
					? 'Spelers kiezen hun startdeck...'
					: 'Spelers kiezen hun doelstelling...';
			}

			const players = state.players || {};
			const order = state.playerOrder || Object.keys(players);
			listEl.innerHTML = order.map(pid => {
				const p = players[pid];
				if (!p) return '';
				const dot = p.connected !== false
					? '<span class="tv-connected"></span>'
					: '<span class="tv-disconnected"></span>';
				return `<div class="tv-player-chip">${dot} ${esc(p.name || 'Speler')}</div>`;
			}).join('');
		}

		// ‚îÄ‚îÄ Game Rendering ‚îÄ‚îÄ
		function renderGame(state) {
			renderBoard(state.boardState);
			renderScoreboard(state);
			renderTurnInfo(state);
			renderCurrentHand(state);
			updateTimer(state);
		}

		// ‚îÄ‚îÄ Board ‚îÄ‚îÄ
		function renderBoard(boardState) {
			const container = document.getElementById('tv-board');
			if (!container || !boardState) return;

			const zones = boardState.zones;
			container.innerHTML = `
				<div class="tv-board-col">
					${renderZone('yellow', zones.yellow, 'Geel')}
					${renderZone('green', zones.green, 'Groen')}
				</div>
				<div class="tv-board-col">
					${renderZone('blue', zones.blue, 'Blauw')}
				</div>
				<div class="tv-board-col">
					${renderRedZone(zones.red)}
					${renderZone('purple', zones.purple, 'Paars')}
				</div>
			`;

			// Auto-scale board to fit the available area
			requestAnimationFrame(() => {
				const area = container.parentElement;
				if (!area) return;
				const areaW = area.clientWidth - 32;
				const areaH = area.clientHeight - 32;
				const boardW = container.scrollWidth;
				const boardH = container.scrollHeight;
				if (boardW > 0 && boardH > 0) {
					const scale = Math.min(1, areaW / boardW, areaH / boardH);
					container.style.transform = `scale(${scale})`;
					container.style.transformOrigin = 'center center';
				}
			});
		}

		// ‚îÄ‚îÄ Bonus dot colors ‚îÄ‚îÄ
		const bonusColors = {
			yellow: '#cfba51', green: '#92c28c', blue: '#5689b0',
			red: '#b56069', purple: '#8f76b8',
			any: 'linear-gradient(135deg, #cfba51 0%, #92c28c 24%, #5689b0 48%, #b56069 72%, #8f76b8 100%)'
		};
		const zoneActiveColors = {
			yellow: '#cfba51', green: '#92c28c', blue: '#5689b0',
			red: '#b56069', purple: '#8f76b8'
		};

		function renderCell(cell, zoneName, subgridId) {
			if (!cell) return '<div class="tv-cell void"></div>';

			const flags = cell.flags || [];
			const classes = ['tv-cell'];
			const isActive = cell.active || !!cell.playerId;
			if (isActive) classes.push('active');
			if (flags.includes('bold')) classes.push('bold');
			if (flags.includes('end')) classes.push('end');
			if (flags.includes('gold')) classes.push('gold');
			if (flags.includes('outer-ring-0')) classes.push('outer-ring-0');
			if (flags.includes('outer-ring-1')) classes.push('outer-ring-1');
			if (zoneName === 'green' && flags.includes('end')) classes.push('green-end');

			// Background color
			let style = '';
			if (isActive && cell.color) {
				const code = typeof cell.color === 'string' ? cell.color : (cell.color?.code || '');
				if (code === 'rainbow') {
					style = `background:${zoneActiveColors[zoneName] || '#888'};`;
				} else if (code) {
					style = `background:${code};`;
				}
			}

			// Inner content
			let inner = '';
			if (cell.bonusSymbol && !isActive) {
				const bg = bonusColors[cell.bonusSymbol] || '#888';
				const bonusLabel = cell.bonusSymbol === 'any' ? '‚òÖ' : cell.bonusSymbol.charAt(0).toUpperCase();
				inner += `<span class="tv-bonus-dot" style="background:${bg}"><span style="font-size:9px;font-weight:700;color:rgba(0,0,0,0.5);line-height:1">${bonusLabel}</span></span>`;
			}
			if (flags.includes('gold') && !isActive) {
				inner += '<span class="tv-gold-dot"></span>';
			}
			if (cell.treasureCoins && !isActive) {
				inner += `<span class="tv-pearl-dot" title="+${cell.treasureCoins}"></span>`;
			}

			const dataAttrs = `data-x="${cell.x}" data-y="${cell.y}" data-zone="${zoneName}"${subgridId ? ` data-subgrid="${subgridId}"` : ''}`;

			return `<div class="${classes.join(' ')}" ${dataAttrs} style="${style}">${inner}</div>`;
		}

		function renderZone(name, zoneData, label) {
			if (!zoneData) return '';
			const zoneRows = zoneData.rows || 0;
			const zoneCols = zoneData.cols || 0;
			const cells = zoneData.cells;
			if (!cells || !zoneRows || !zoneCols) return '';

			let cellsHtml = '';
			for (let y = 0; y < zoneRows; y++) {
				for (let x = 0; x < zoneCols; x++) {
					const key = `${x},${y}`;
					const cell = cells[key];
					cellsHtml += renderCell(cell, name, null);
				}
			}

			return `
				<div class="tv-zone tv-zone-${name}">
					<span class="tv-zone-label">${label}</span>
					<div class="tv-grid" style="grid-template-columns: repeat(${zoneCols}, var(--tv-cell-size));">
						${cellsHtml}
					</div>
				</div>
			`;
		}

		function renderRedZone(redData) {
			if (!redData) return '';
			const subgrids = redData.subgrids || [];
			if (subgrids.length === 0) return '';

			let subgridsHtml = '';
			for (const sg of subgrids) {
				const sgRows = sg.rows || 0;
				const sgCols = sg.cols || 0;
				const sgCells = sg.cells;
				if (!sgCells || !sgRows || !sgCols) continue;

				let cellsHtml = '';
				for (let y = 0; y < sgRows; y++) {
					for (let x = 0; x < sgCols; x++) {
						const key = `${x},${y}`;
						cellsHtml += renderCell(sgCells[key], 'red', sg.id);
					}
				}

				// Progress bar
				const allCells = Object.values(sgCells);
				const filledCount = allCells.filter(c => c.active || c.playerId).length;
				const totalCount = allCells.length;
				const fillPct = totalCount > 0 ? Math.round((filledCount / totalCount) * 100) : 0;
				const ptsLabel = sg.targetPoints
					? `<span class="tv-zone-label" style="font-size:0.55rem;top:-6px;right:8px;left:auto;">${sg.targetPoints}pt</span>`
					: '';

				subgridsHtml += `
					<div style="position:relative;">
						${ptsLabel}
						<div class="tv-grid" style="grid-template-columns: repeat(${sgCols}, var(--tv-cell-size));">
							${cellsHtml}
						</div>
						<div class="tv-red-progress"><div class="tv-red-progress-fill" style="width:${fillPct}%"></div></div>
					</div>
				`;
			}

			return `
				<div class="tv-zone tv-zone-red">
					<span class="tv-zone-label">Rood</span>
					<div class="tv-red-group">${subgridsHtml}</div>
				</div>
			`;
		}

		// ‚îÄ‚îÄ Scoreboard (with player cards) ‚îÄ‚îÄ
		function renderScoreboard(state) {
			const container = document.getElementById('tv-scoreboard');
			if (!container) return;

			const players = state.players || {};
			const order = state.playerOrder || [];
			const currentPid = order[state.currentTurnIndex] || null;

			// Sort by score descending
			const sorted = order.map((pid, i) => ({
				pid, rank: i + 1,
				name: players[pid]?.name || 'Speler',
				score: players[pid]?.score || 0,
				connected: players[pid]?.connected !== false,
				hand: players[pid]?.hand,
				isCurrent: pid === currentPid
			})).sort((a, b) => b.score - a.score);

			container.innerHTML = sorted.map((p, i) => {
				// Render mini cards for this player
				let cardsHtml = '';
				const hand = p.hand;
				if (Array.isArray(hand) && hand.length > 0) {
					if (typeof hand[0] === 'object' && hand[0]?.matrix) {
						// Full card data available ‚Äî render mini grids
						cardsHtml = '<div class="tv-player-cards">' + hand.map(card => {
							const matrix = card.matrix || [];
							const colorCode = card.color?.code || '#666';
							const isRainbow = colorCode === 'rainbow';
							const cols = matrix[0]?.length || 0;
							const fill = isRainbow
								? 'background: linear-gradient(135deg, #b56069, #cfba51, #92c28c, #5689b0, #8f76b8)'
								: `background: ${colorCode}`;
							let miniCells = '';
							for (const row of matrix) {
								for (const c of row) {
									miniCells += c
										? `<div class="tv-mini-cell filled" style="${fill}"></div>`
										: '<div class="tv-mini-cell"></div>';
								}
							}
							return `<div class="tv-player-mini-card" style="grid-template-columns: repeat(${cols}, 7px);">${miniCells}</div>`;
						}).join('') + '</div>';
					} else {
						// Only count
						const count = typeof hand === 'number' ? hand : hand.length;
						cardsHtml = `<div class="tv-score-cards-count">${count} kaart${count !== 1 ? 'en' : ''}</div>`;
					}
				} else if (typeof hand === 'number' && hand > 0) {
					cardsHtml = `<div class="tv-score-cards-count">${hand} kaart${hand !== 1 ? 'en' : ''}</div>`;
				}

				return `
					<div class="tv-score-row ${p.isCurrent ? 'current-turn' : ''}">
						<div style="display:flex;align-items:center;gap:10px;flex:1;min-width:0;">
							<span class="tv-score-rank">${i + 1}</span>
							<div style="flex:1;min-width:0;">
								<div class="tv-score-name">${esc(p.name)} ${!p.connected ? 'üîå' : ''}</div>
								${cardsHtml}
							</div>
						</div>
						<span class="tv-score-pts">${p.score}</span>
					</div>
				`;
			}).join('');
		}

		// ‚îÄ‚îÄ Turn Info ‚îÄ‚îÄ
		function renderTurnInfo(state) {
			const players = state.players || {};
			const order = state.playerOrder || [];
			const currentPid = order[state.currentTurnIndex] || null;
			const player = currentPid ? players[currentPid] : null;

			const turnEl = document.getElementById('tv-turn-player');
			const roundEl = document.getElementById('tv-round-badge');

			if (turnEl) {
				turnEl.textContent = player ? player.name : '‚Äî';
				turnEl.className = 'tv-turn-player';
			}
			if (roundEl) {
				roundEl.textContent = `Ronde ${state.turnCount || 1} ‚Ä¢ Level ${state.level || 1}`;
			}
		}

		// ‚îÄ‚îÄ Current Player Hand ‚îÄ‚îÄ
		function renderCurrentHand(state) {
			const labelEl = document.getElementById('tv-hand-label');
			const cardsEl = document.getElementById('tv-hand-cards');
			if (!labelEl || !cardsEl) return;

			const players = state.players || {};
			const order = state.playerOrder || [];
			const currentPid = order[state.currentTurnIndex] || null;
			const player = currentPid ? players[currentPid] : null;

			if (!player) {
				labelEl.textContent = '';
				cardsEl.innerHTML = '';
				return;
			}

			const hand = Array.isArray(player.hand) ? player.hand : [];
			labelEl.textContent = `${player.name}'s kaarten:`;

			if (hand.length === 0) {
				cardsEl.innerHTML = '<span class="tv-hidden-hand">Geen kaarten</span>';
				return;
			}

			// Check if hand has actual card data (not just count)
			const hasCardData = hand[0] && typeof hand[0] === 'object' && hand[0].matrix;
			if (!hasCardData) {
				cardsEl.innerHTML = `<span class="tv-hidden-hand">${hand.length} kaart${hand.length !== 1 ? 'en' : ''}</span>`;
				return;
			}

			cardsEl.innerHTML = hand.map(card => {
				const matrix = card.matrix || [];
				const colorCode = card.color?.code || '#666';
				const isRainbow = colorCode === 'rainbow';
				const cols = matrix[0]?.length || 0;
				const fill = isRainbow
					? 'background: linear-gradient(135deg, #b56069, #cfba51, #92c28c, #5689b0, #8f76b8)'
					: `background: ${colorCode}`;

				let cells = '';
				for (const row of matrix) {
					for (const c of row) {
						cells += c
							? `<div class="tv-card-cell filled" style="${fill}"></div>`
							: '<div class="tv-card-cell"></div>';
					}
				}

				return `
					<div class="tv-card">
						<div class="tv-card-grid" style="grid-template-columns: repeat(${cols}, 14px);">
							${cells}
						</div>
						<span class="tv-card-name">${esc(card.shapeName || card.id || '')}</span>
					</div>
				`;
			}).join('');
		}

		// ‚îÄ‚îÄ Timer (with sound) ‚îÄ‚îÄ
		let lastTimerBeep = null;
		function updateTimer(state) {
			const timerEl = document.getElementById('tv-timer');
			const fillEl = document.getElementById('tv-timer-fill');
			const textEl = document.getElementById('tv-timer-text');
			if (!timerEl || !fillEl || !textEl) return;

			if (state.paused) {
				timerEl.style.display = 'flex';
				textEl.textContent = '‚è∏';
				fillEl.style.width = '100%';
				fillEl.className = 'tv-timer-fill';
				clearInterval(timerInterval);
				return;
			}

			const start = state._turnTimerStart;
			const duration = state._turnTimerDurationMs;
			if (!start || !duration) {
				timerEl.style.display = 'none';
				clearInterval(timerInterval);
				return;
			}

			timerEl.style.display = 'flex';
			clearInterval(timerInterval);

			function tick() {
				const elapsed = Date.now() - start;
				const remaining = Math.max(0, duration - elapsed);
				const pct = (remaining / duration) * 100;
				const secs = Math.ceil(remaining / 1000);

				fillEl.style.width = pct + '%';
				textEl.textContent = secs + 's';

				fillEl.className = 'tv-timer-fill';
				if (pct < 25) fillEl.classList.add('danger');
				else if (pct < 50) fillEl.classList.add('warning');

				// Beep in last 5 seconds
				if (secs <= 5 && secs > 0 && lastTimerBeep !== secs) {
					lastTimerBeep = secs;
					playTimerWarningSound();
				}
			}

			lastTimerBeep = null;
			tick();
			timerInterval = setInterval(tick, 500);
		}

		// ‚îÄ‚îÄ Taunt ‚îÄ‚îÄ
		function showTaunt(data) {
			const el = document.getElementById('tv-taunt');
			const nameEl = document.getElementById('tv-taunt-name');
			const textEl = document.getElementById('tv-taunt-text');
			if (!el || !nameEl || !textEl) return;

			nameEl.textContent = data.playerName || 'Speler';
			textEl.textContent = data.text || '';
			el.classList.add('show');

			setTimeout(() => el.classList.remove('show'), 2500);
		}

		// ‚îÄ‚îÄ Level Complete ‚îÄ‚îÄ
		function showLevelComplete(data) {
			const overlay = document.getElementById('tv-level-overlay');
			const titleEl = document.getElementById('tv-level-title');
			const scoresEl = document.getElementById('tv-level-scores');
			if (!overlay || !titleEl || !scoresEl) return;

			titleEl.textContent = `Level ${data.level || '?'} Compleet!`;

			const scores = data.levelScores || {};
			const winner = data.levelWinner;

			scoresEl.innerHTML = Object.entries(scores)
				.sort((a, b) => (b[1]?.total || 0) - (a[1]?.total || 0))
				.map(([pid, s]) => `
					<div class="tv-level-score-row ${pid === winner ? 'winner' : ''}">
						<span>${esc(s.name || pid)} ${pid === winner ? 'üëë' : ''}</span>
						<span style="font-weight:700; color: var(--tv-gold);">${s.total || 0} pt</span>
					</div>
				`).join('');

			overlay.classList.add('show');
		}

		// ‚îÄ‚îÄ Util ‚îÄ‚îÄ
		function esc(s) {
			const d = document.createElement('div');
			d.textContent = s;
			return d.innerHTML;
		}
	})();
	</script>
</body>
</html>
