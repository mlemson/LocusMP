<!DOCTYPE html>
<html lang="nl">
<head>
	<meta charset="utf-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
	<title>LOCUS ‚Äî Multiplayer</title>
	<link rel="stylesheet" href="multiplayer.css">
</head>
<body>
	<!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
	     THEME SWITCHER (linksboven)
	     ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
	<div id="mp-theme-switcher" class="mp-theme-switcher">
		<div class="mp-theme-pill" title="Kies een thema">
			<button class="mp-theme-btn" data-theme="aurora">Aurora</button>
			<button class="mp-theme-btn" data-theme="bloom">Bloom</button>
			<button class="mp-theme-btn" data-theme="classic">Classic</button>
			<span class="mp-theme-indicator"></span>
		</div>
	</div>

	<!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
	     SCREEN 1: LOBBY
	     ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
	<div id="lobby-screen" class="mp-screen">
		<div class="mp-version-badge" id="mp-version-badge">v--</div>
		<div class="mp-logo-container">
			<h1 class="mp-logo">LOCUS</h1>
			<div class="mp-logo-sub">MULTIPLAYER</div>
		</div>

		<div class="mp-lobby-card">
			<div class="mp-input-group mp-name-required">
				<label for="player-name-input">üë§ Jouw naam</label>
				<input type="text" id="player-name-input" placeholder="Vul hier je naam in..." maxlength="20" autocomplete="off" required />
			</div>

			<div class="mp-lobby-spacer"></div>

			<button id="create-game-btn" class="mp-btn mp-btn-primary">
				üéÆ Nieuw Spel
			</button>

			<div class="mp-divider"><span>of doe mee</span></div>

			<div class="mp-input-group">
				<label for="invite-code-input">Spelcode</label>
				<input type="text" id="invite-code-input" placeholder="bv. ABC123"
					   maxlength="6" autocomplete="off" style="text-transform: uppercase; letter-spacing: 4px; text-align: center;" />
			</div>

			<button id="join-game-btn" class="mp-btn mp-btn-secondary">
				üîó Deelnemen
			</button>

			<div id="host-settings-block">
				<div class="mp-divider"><span>Host instellingen</span></div>
				<div class="mp-settings-row">
					<div class="mp-input-group" style="flex:1;">
						<label for="map-size-select">Kaart</label>
						<select id="map-size-select">
							<option value="2">Klein</option>
							<option value="4" selected>Middel</option>
							<option value="6">Groot</option>
							<option value="8">Mega</option>
						</select>
					</div>
					<div class="mp-input-group" style="flex:1;">
						<label for="cards-per-player-select">Kaarten</label>
						<select id="cards-per-player-select">
							<option value="4">4</option>
							<option value="6">6</option>
							<option value="8" selected>8</option>
							<option value="10">10</option>
							<option value="12">12</option>
						</select>
					</div>
				</div>
			</div>
		</div>
	</div>

	<!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
	     SCREEN 2: WACHTKAMER
	     ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
	<div id="waiting-screen" class="mp-screen" style="display:none;">
		<div class="mp-waiting-card">
			<h2>Wachtkamer</h2>

			<div class="mp-invite-section">
				<p>Deel deze code met je medespelers:</p>
				<div class="mp-invite-share-row">
					<div>
						<div id="invite-code-display" class="mp-invite-code" title="Klik om te kopi√´ren">------</div>
						<small>Klik om te kopi√´ren</small>
					</div>
					<div class="mp-invite-qr-wrap">
						<img id="invite-qr-img" class="mp-invite-qr" alt="QR code om direct te joinen" />
						<a id="invite-qr-link" class="mp-invite-qr-link" href="#" target="_blank" rel="noopener">Open join-link</a>
					</div>
				</div>
			</div>

			<div id="waiting-status" class="mp-player-count">0/4 spelers</div>

			<div id="player-list" class="mp-player-list">
				<!-- Dynamisch gevuld -->
			</div>

			<button id="tv-cast-btn" class="mp-btn mp-btn-cast" style="display:none;" title="Deel het scherm op de TV">
				<svg class="mp-cast-icon" viewBox="0 0 24 24" width="18" height="18" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
					<path d="M2 16.1A5 5 0 0 1 5.9 20M2 12.05A9 9 0 0 1 9.95 20M2 8V6a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2h-6"/>
					<circle cx="2" cy="20" r="1" fill="currentColor"/>
				</svg>
				<span>Cast naar TV</span>
			</button>

			<button id="start-game-btn" class="mp-btn mp-btn-primary" disabled style="display:none;">
				üöÄ Start Spel
			</button>

			<div class="mp-waiting-dots">
				<span>Wachten op spelers</span>
				<div class="mp-dots"><span></span><span></span><span></span></div>
			</div>
		</div>
	</div>

	<!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
	     SCREEN 3: DOELSTELLING KIEZEN
	     ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
	<div id="goal-screen" class="mp-screen" style="display:none;">
		<div id="goal-choices-container" class="mp-goal-container">
			<!-- Dynamisch gevuld -->
		</div>
	</div>

	<!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
	     SCREEN 4: HET SPEL
	     ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
	<div id="game-screen" class="mp-screen mp-game-layout" style="display:none;">
		<!-- Top bar: scoreboard + turn -->
		<div class="mp-top-bar">
			<details id="mp-taunt-menu" class="mp-taunt-menu" aria-label="Taunt menu">
				<summary id="mp-taunt-menu-toggle" class="mp-taunt-menu-toggle" title="Taunts">üí¨</summary>
				<div class="mp-taunt-menu-panel">
					<button class="mp-taunt-btn" data-taunt="Nooo!">Nooo!</button>
					<button class="mp-taunt-btn" data-taunt="HAHA">HAHA</button>
					<button class="mp-taunt-btn" data-taunt="Well played!">Well played!</button>
					<button class="mp-taunt-btn" data-taunt="Oeps...">Oeps...</button>
					<button class="mp-taunt-btn" data-taunt="Kom op!">Kom op!</button>
				</div>
			</details>
			<div id="mp-turn-indicator" class="mp-turn-indicator">
				<div class="mp-turn-label">Ronde 0</div>
				<div class="mp-turn-player">Wachten...</div>
			</div>
			<div id="mp-my-objective" class="mp-my-objective"></div>
			<div class="mp-top-right">
				<button id="tv-cast-game-btn" class="mp-cast-game-btn" style="display:none;" title="TV Cast aan/uit">
					<svg viewBox="0 0 24 24" width="16" height="16" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
						<path d="M2 16.1A5 5 0 0 1 5.9 20M2 12.05A9 9 0 0 1 9.95 20M2 8V6a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2h-6"/>
						<circle cx="2" cy="20" r="1" fill="currentColor"/>
					</svg>
				</button>
				<div id="mp-room-code-badge" class="mp-room-code-badge">Room: ------</div>
				<!-- scoreboard gets inserted here by JS on mobile -->
			</div>
		</div>

		<!-- Sidebar: scoreboard + opponent panels -->
		<div class="mp-sidebar">
			<div id="mp-scoreboard" class="mp-scoreboard">
				<!-- Dynamisch gevuld -->
			</div>
			<div id="mp-opponent-panels" class="mp-opponent-panels">
				<!-- Dynamisch gevuld -->
			</div>
		</div>

		<!-- Bord -->
		<div id="mp-board-container" class="mp-board-container">
			<!-- Dynamisch gevuld -->
		</div>

		<!-- Hand (kaarten) -->
		<div class="mp-bottom-bar">
			<div id="mp-bonus-bar" class="mp-bonus-bar" style="display:none;"></div>
			<div class="mp-hand-row">
				<button id="mp-deck-overview-btn" class="mp-btn mp-btn-secondary mp-deck-btn" title="Bekijk je deck">
					<span id="mp-deck-count">0</span>
				</button>
				<div id="mp-hand-container" class="mp-hand-container">
					<!-- Dynamisch gevuld -->
				</div>
				<button id="mp-pass-btn" class="mp-btn mp-btn-warning" style="display:none;">
					<span class="mp-pass-icon" aria-hidden="true">üóë</span>
					<span class="mp-pass-text">Pas</span>
				</button>
			</div>
			<div class="mp-bottom-actions">
				<div id="mp-turn-timer" class="mp-turn-timer" style="display:none;">
					<div class="mp-timer-bar"><div class="mp-timer-fill"></div></div>
					<span class="mp-timer-text">40s</span>
				</div>
				<button id="mp-undo-btn" class="mp-btn mp-btn-secondary" style="display:none;" title="Ongedaan maken (Ctrl+Z)">
					‚Ü© Undo
				</button>
				<button id="mp-end-turn-btn" class="mp-btn mp-btn-primary" style="display:none;">
					‚úÖ Beurt Be√´indigen
				</button>
			</div>
		</div>
	</div>

	<!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
	     SCREEN 5: RESULTATEN
	     ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
	<div id="results-screen" class="mp-screen" style="display:none;">
		<div id="results-container" class="mp-results-container">
			<!-- Dynamisch gevuld -->
		</div>
		<button id="play-again-btn" class="mp-btn mp-btn-primary" style="margin-top: 24px;">
			üîÑ Nog een Ronde
		</button>
	</div>

	<!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
	     SCREEN 6: SHOP
	     ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
	<div id="shop-screen" class="mp-screen" style="display:none;">
		<div id="shop-container" class="mp-shop-container">
			<!-- Dynamisch gevuld -->
		</div>
	</div>

	<!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
	     DECK OVERVIEW OVERLAY
	     ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
	<div id="mp-deck-overlay" class="mp-deck-overlay" style="display:none;">
		<div class="mp-deck-overlay-header">
			<h3>üÉè Jouw Deck</h3>
			<button id="mp-deck-close-btn" class="mp-deck-close-x" title="Sluiten">‚úï</button>
		</div>
		<div id="mp-deck-cards" class="mp-deck-cards">
			<!-- Dynamisch gevuld -->
		</div>
	</div>

	<!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
	     SCRIPTS
	     ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->

	<!-- PeerJS voor P2P hosting (CDN ‚Äî meerdere fallbacks) -->
	<script src="https://cdn.jsdelivr.net/npm/peerjs@1.5.4/dist/peerjs.min.js"></script>
	<script>
		if (typeof Peer === 'undefined') {
			// Fallback CDN als jsdelivr geblokkeerd is
			var s = document.createElement('script');
			s.src = 'https://cdnjs.cloudflare.com/ajax/libs/peerjs/1.5.4/peerjs.min.js';
			s.onerror = function() { console.warn('[Locus] PeerJS kon niet geladen worden ‚Äî P2P niet beschikbaar'); };
			document.head.appendChild(s);
		}
	</script>

	<!-- Socket.IO client (alleen laden als we via de Locus Node.js server draaien) -->
	<script>
		(function() {
			var host = window.location.hostname || '';
			var proto = window.location.protocol || '';
			// Skip Socket.IO op file://, GitHub Pages, Netlify, Vercel, en andere static hosts
			if (proto === 'file:') return;
			if (host.endsWith('.github.io')) return;
			if (host.endsWith('.netlify.app')) return;
			if (host.endsWith('.vercel.app')) return;
			if (host.endsWith('.pages.dev')) return;
			var s = document.createElement('script');
			s.src = '/socket.io/socket.io.js';
			s.onerror = function() { /* P2P modus beschikbaar als alternatief */ };
			document.head.appendChild(s);
		})();
	</script>

	<!-- Shared game rules -->
	<script src="shared/game-rules.js"></script>

	<!-- Multiplayer client (Socket.IO) -->
	<script src="client/multiplayer-client.js"></script>

	<!-- P2P Host/Guest module (WebRTC) -->
	<script src="client/p2p-host.js"></script>

	<!-- Lobby UI -->
	<script src="client/lobby-ui.js"></script>

	<!-- App bootstrap -->
	<script>
		async function _resolveLatestBuildDate() {
			if (window.__locusBuildMeta?.buildDate instanceof Date && !Number.isNaN(window.__locusBuildMeta.buildDate.getTime())) {
				return window.__locusBuildMeta.buildDate;
			}

			const candidates = [
				'multiplayer.html',
				'multiplayer.css',
				'shared/game-rules.js',
				'client/multiplayer-client.js',
				'client/p2p-host.js',
				'client/lobby-ui.js'
			];

			let latestTs = 0;
			for (const file of candidates) {
				try {
					const res = await fetch(file, { method: 'HEAD', cache: 'no-store' });
					const lm = res?.headers?.get('last-modified');
					if (!lm) continue;
					const ts = new Date(lm).getTime();
					if (Number.isFinite(ts) && ts > latestTs) latestTs = ts;
				} catch (_) {
					// ignore and fallback below
				}
			}

			if (!latestTs) {
				const docTs = new Date(document.lastModified || '').getTime();
				if (Number.isFinite(docTs)) latestTs = docTs;
			}

			if (!latestTs) latestTs = Date.now();
			return new Date(latestTs);
		}

		async function _setLobbyVersionBadge() {
			const badgeEl = document.getElementById('mp-version-badge');
			if (!badgeEl) return;
			const now = await _resolveLatestBuildDate();
			const pad = (n) => String(n).padStart(2, '0');
			const buildTag = `${now.getFullYear()}.${pad(now.getMonth() + 1)}.${pad(now.getDate())}-${pad(now.getHours())}${pad(now.getMinutes())}`;
			const dateText = now.toLocaleDateString('nl-BE', { day: '2-digit', month: '2-digit', year: 'numeric' });
			const timeText = now.toLocaleTimeString('nl-BE', { hour: '2-digit', minute: '2-digit' });
			const badgeText = `Build ${buildTag}`;
			window.__locusBuildMeta = { buildDate: now, badgeText };
			badgeEl.textContent = badgeText;
			badgeEl.title = badgeText;
		}

		// ‚îÄ‚îÄ Theme switcher logic ‚îÄ‚îÄ
		function _applyTheme(theme) {
			document.documentElement.classList.remove('theme-aurora', 'theme-bloom');
			if (theme === 'aurora') document.documentElement.classList.add('theme-aurora');
			else if (theme === 'bloom') document.documentElement.classList.add('theme-bloom');
		}

		function _initThemeSwitcher() {
			const pill = document.querySelector('.mp-theme-pill');
			if (!pill) return;
			const btns = pill.querySelectorAll('.mp-theme-btn');
			const indicator = pill.querySelector('.mp-theme-indicator');
			const saved = localStorage.getItem('locus-theme') || 'aurora';

			function setActive(theme) {
				btns.forEach((btn, i) => {
					const isActive = btn.dataset.theme === theme;
					btn.classList.toggle('active', isActive);
					if (isActive && indicator) {
						indicator.style.transform = `translateX(${i * 100}%)`;
					}
				});
				_applyTheme(theme);
				localStorage.setItem('locus-theme', theme);
				// Forward theme to TV cast
				if (window._ui && window._ui._tvCastActive) {
					try { window._ui._tvPostMessage({ type: 'theme', theme }); } catch (_) {}
				}
			}

			setActive(saved);

			btns.forEach(btn => {
				btn.addEventListener('click', () => setActive(btn.dataset.theme));
			});
		}

		// Apply theme immediately to avoid flash
		(function() {
			const saved = localStorage.getItem('locus-theme') || 'aurora';
			if (saved === 'aurora') document.documentElement.classList.add('theme-aurora');
			else if (saved === 'bloom') document.documentElement.classList.add('theme-bloom');
		})();

		const LOBBY_NAME_STORAGE_KEY = 'locus_last_user_name';

		function _getSavedLobbyName() {
			try {
				const raw = (localStorage.getItem(LOBBY_NAME_STORAGE_KEY)
					|| sessionStorage.getItem('locus_p2p_userName')
					|| '').trim();
				if (!raw) return '';
				return raw.slice(0, 20);
			} catch (_) {
				return '';
			}
		}

		function _saveLobbyName(name) {
			const cleaned = String(name || '').trim().slice(0, 20);
			if (!cleaned) return;
			try { localStorage.setItem(LOBBY_NAME_STORAGE_KEY, cleaned); } catch (_) {}
		}

		function _initLobbyNamePersistence() {
			const nameInput = document.getElementById('player-name-input');
			if (!nameInput) return;

			if (!nameInput.value) {
				const savedName = _getSavedLobbyName();
				if (savedName) nameInput.value = savedName;
			}

			nameInput.addEventListener('input', () => {
				_saveLobbyName(nameInput.value || '');
			});
		}

		// Wacht iets langer zodat dynamisch geladen scripts (socket.io, peerjs fallback) tijd hebben
		window.addEventListener('load', () => {
			setTimeout(_bootstrapApp, 150);
		});

		function _applyJoinCodeFromUrl() {
			try {
				const url = new URL(window.location.href);
				const raw = (url.searchParams.get('join') || url.searchParams.get('code') || url.searchParams.get('invite') || '').toUpperCase();
				const code = raw.replace(/[^A-Z0-9]/g, '').slice(0, 6);
				if (!code || code.length !== 6) return;

				const inviteInput = document.getElementById('invite-code-input');
				if (inviteInput) inviteInput.value = code;
				const p2pInput = document.getElementById('p2p-room-code-input');
				if (p2pInput) p2pInput.value = code;

				const nameInput = document.getElementById('player-name-input');
				if (nameInput && !nameInput.value) {
					nameInput.focus();
				}
			} catch (_) {}
		}

		async function _bootstrapApp() {
			_initThemeSwitcher();
			_initLobbyNamePersistence();
			_applyJoinCodeFromUrl();
			await _setLobbyVersionBadge();

			// Detecteer of Socket.IO server beschikbaar is
			const hasSocketIO = typeof io !== 'undefined';
			const hasPeerJS = typeof Peer !== 'undefined';
			let mp = null;

			console.log('[Locus] Socket.IO:', hasSocketIO ? 'beschikbaar' : 'niet beschikbaar');
			console.log('[Locus] PeerJS:', hasPeerJS ? 'beschikbaar' : 'niet beschikbaar');

			if (hasSocketIO) {
				// Normale server modus
				mp = new LocusMultiplayer();
			} else {
				// Geen server ‚Äî verberg server-only knoppen, toon P2P opties
				console.log('[Locus] Geen Socket.IO server ‚Äî alleen P2P modus');
				const createBtn = document.getElementById('create-game-btn');
				const joinBtn = document.getElementById('join-game-btn');
				if (createBtn) createBtn.style.display = 'none';
				if (joinBtn) joinBtn.style.display = 'none';
				// Verberg de "OF" divider boven join
				const dividers = document.querySelectorAll('.mp-lobby-card > .mp-divider');
				if (dividers.length > 0) dividers[0].style.display = 'none';
				// Verberg invite code input group
				const inviteInput = document.getElementById('invite-code-input');
				if (inviteInput && inviteInput.parentElement) inviteInput.parentElement.style.display = 'none';
			}

			if (mp) {
				const ui = new LocusLobbyUI(mp);
				ui.init();

				// Auto-reconnect
				const savedGame = sessionStorage.getItem('locus_gameId');
				if (savedGame) {
					try {
						const result = await mp.init();
						if (result.reconnected) {
							ui.handleReconnect();
						}
					} catch (err) {
						console.warn('[Locus] Auto-reconnect mislukt:', err.message);
					}
				}

				window._mp = mp;
				window._ui = ui;
			}

			// P2P knoppen beschikbaar als PeerJS geladen is
			if (hasPeerJS) {
				_setupP2PButtons(mp);
				_applyJoinCodeFromUrl();
				await _tryAutoReconnectP2P(hasSocketIO);
			} else {
				// Geen PeerJS en geen Socket.IO ‚Üí toon foutmelding
				if (!hasSocketIO) {
					const lobbyCard = document.querySelector('.mp-lobby-card');
					if (lobbyCard) {
						const msg = document.createElement('div');
						msg.style.cssText = 'padding:16px;text-align:center;color:#ff6b6b;font-weight:bold;';
						msg.textContent = '‚ö†Ô∏è Geen server en P2P bibliotheek kon niet laden. Controleer je internetverbinding of open via een server.';
						lobbyCard.appendChild(msg);
					}
				}
			}
		}

		async function _tryAutoReconnectP2P(hasSocketIO) {
			if (hasSocketIO) return;
			if (typeof Peer === 'undefined') return;

			let role = null;
			let roomCode = null;
			let playerId = null;
			let userName = null;
			try {
				role = sessionStorage.getItem('locus_p2p_role');
				roomCode = sessionStorage.getItem('locus_p2p_roomCode');
				playerId = sessionStorage.getItem('locus_p2p_playerId');
				userName = sessionStorage.getItem('locus_p2p_userName');
			} catch (_) {
				return;
			}

			if (!roomCode || !userName) return;

			if (role === 'guest') {
				try {
					const guest = new LocusP2PGuest();
					await guest.init();
					const result = await guest.joinGame(userName, roomCode, { reconnectPlayerId: playerId || null });

					guest.userName = userName;
					guest.gameId = result.gameId;
					guest.inviteCode = roomCode;

					const ui = new LocusLobbyUI(guest);
					ui.init();
					ui._showWaitingRoom(roomCode, false);
					if (guest.gameState) ui.handleReconnect();

					window._mp = guest;
					window._ui = ui;
					console.log('[Locus] P2P auto-reconnect geslaagd (guest)');
				} catch (err) {
					console.warn('[Locus] P2P auto-reconnect mislukt (guest):', err.message || err);
				}
				return;
			}

			if (role === 'host') {
				try {
					let savedState = null;
					try {
						const raw = sessionStorage.getItem('locus_p2p_state');
						savedState = raw ? JSON.parse(raw) : null;
					} catch (_) {
						savedState = null;
					}

					const host = new LocusP2PHost();
					await host.startHost(userName, {
						roomCode,
						hostPlayerId: playerId || null,
						resumeState: savedState
					});

					const p2pMp = _createP2PHostAdapter(host);
					p2pMp.gameState = host._sanitizeForPlayer(host.hostPlayerId);
					p2pMp.userId = host.hostPlayerId;
					p2pMp.userName = userName;
					p2pMp.gameId = host.gameState.id;
					p2pMp.inviteCode = host.roomCode;
					p2pMp.connected = true;

					const ui = new LocusLobbyUI(p2pMp);
					ui.init();
					if (host.gameState?.phase === 'waiting') ui._showWaitingRoom(host.roomCode, true);
					if (p2pMp.gameState) ui.handleReconnect();

					window._mp = p2pMp;
					window._ui = ui;
					window._p2pHost = host;

					try {
						sessionStorage.setItem('locus_p2p_role', 'host');
						sessionStorage.setItem('locus_p2p_roomCode', host.roomCode);
						sessionStorage.setItem('locus_p2p_playerId', host.hostPlayerId);
						sessionStorage.setItem('locus_p2p_userName', userName);
						sessionStorage.setItem('locus_p2p_state', JSON.stringify(host.gameState));
					} catch (_) {}

					host.onStateChanged = (state) => {
						const prev = p2pMp.gameState;
						p2pMp.gameState = state;
						if (p2pMp.onGameStateChanged) {
							try { p2pMp.onGameStateChanged(state, prev); } catch (err) { console.error('[P2P Adapter] onGameStateChanged ERROR:', err); }
						}
						try { sessionStorage.setItem('locus_p2p_state', JSON.stringify(host.gameState)); } catch (_) {}
					};

					host.onPlayerJoined = (data) => {
						if (p2pMp.onPlayerJoined) p2pMp.onPlayerJoined(data);
					};

					host.onPlayerLeft = (leftPlayerId) => {
						if (p2pMp.onPlayerLeft) p2pMp.onPlayerLeft(leftPlayerId);
					};

					host.onEvent = (eventType, data) => {
						switch (eventType) {
							case 'movePlayed': if (p2pMp.onMovePlayed) p2pMp.onMovePlayed(data); break;
							case 'levelComplete': if (p2pMp.onLevelComplete) p2pMp.onLevelComplete(data.levelScores, data.levelWinner, data.level); break;
							case 'nextLevelStarted': if (p2pMp.onNextLevel) p2pMp.onNextLevel(data.level); break;
							case 'gameEnded': if (p2pMp.onGameEnded) p2pMp.onGameEnded(data); break;
							case 'timeBombUsed': if (p2pMp.onTimeBombed) p2pMp.onTimeBombed(data); break;
							case 'opponentInteraction': if (p2pMp.onOpponentInteraction) p2pMp.onOpponentInteraction(data); break;
							case 'taunt': if (p2pMp.onTaunt) p2pMp.onTaunt(data); break;
							case 'pauseChanged': if (p2pMp.onPauseChanged) p2pMp.onPauseChanged(data); break;
						}
					};

					console.log('[Locus] P2P auto-reconnect geslaagd (host)');
				} catch (err) {
					console.warn('[Locus] P2P auto-reconnect mislukt (host):', err.message || err);
				}
			}
		}

		function _setupP2PButtons(existingMp) {
			const lobbyCard = document.querySelector('.mp-lobby-card');
			if (!lobbyCard) return;

			// Voeg P2P sectie toe onder de bestaande lobby
			const hasServer = typeof io !== 'undefined';
			const p2pSection = document.createElement('div');
			p2pSection.className = 'mp-p2p-section';
			p2pSection.innerHTML = `
				<div class="mp-divider"><span>${hasServer ? 'of direct spelen' : 'Direct Spelen'}</span></div>
				<div class="mp-input-group">
					<label for="p2p-room-code-input">Spelcode</label>
					<input type="text" id="p2p-room-code-input" placeholder="bv. A3BK7X"
						   maxlength="6" autocomplete="off" style="text-transform: uppercase; letter-spacing: 4px; text-align: center;" />
				</div>
				<button id="p2p-join-btn" class="mp-btn mp-btn-secondary" style="margin-top: 4px;">
					üîó Deelnemen
				</button>
				<div id="p2p-host-actions">
					<div class="mp-divider" style="margin-top: 12px;"><span>of host zelf</span></div>
					<button id="p2p-host-btn" class="mp-btn mp-btn-primary mp-btn-p2p-host">
						üåê Host Spel
					</button>
					<button id="p2p-debug-btn" style="display:none;margin-top:8px;padding:4px 10px;font-size:11px;opacity:0.5;background:none;border:1px solid #666;color:#999;border-radius:6px;cursor:pointer;">
						üêõ Debug Log
					</button>
				</div>
			`;
			lobbyCard.appendChild(p2pSection);
			if (!hasServer) {
				const hostSettings = document.getElementById('host-settings-block');
				if (hostSettings) p2pSection.appendChild(hostSettings);
				const hostActions = document.getElementById('p2p-host-actions');
				if (hostActions) p2pSection.appendChild(hostActions);
			}

			// P2P Host
			document.getElementById('p2p-host-btn').addEventListener('click', async () => {
				const nameInput = document.getElementById('player-name-input');
				const name = nameInput?.value?.trim();
				if (!name) {
					nameInput?.classList.add('mp-shake');
					setTimeout(() => nameInput?.classList.remove('mp-shake'), 500);
					return;
				}
				_saveLobbyName(name);

				if (typeof Peer === 'undefined') {
					alert('PeerJS is niet geladen. Controleer je internetverbinding en herlaad de pagina.');
					return;
				}

				const maxPlayers = 8;
				const cardsPerPlayer = Number(document.getElementById('cards-per-player-select')?.value || 8);
				const mapSize = Number(document.getElementById('map-size-select')?.value || 4);

				// Toon loading state
				const hostBtn = document.getElementById('p2p-host-btn');
				const origText = hostBtn.textContent;
				hostBtn.disabled = true;
				hostBtn.textContent = '‚è≥ Verbinden...';

				try {
					const host = new LocusP2PHost();
					LocusP2PHost._logMobile('Host starten... roomCode zal zijn: ' + (host.roomCode || 'wordt gegenereerd'));
					const result = await host.startHost(name, { maxPlayers, cardsPerPlayer, mapSize });
					LocusP2PHost._logMobile('Host gestart! Room: ' + result.roomCode);

					// Maak een P2P-wrapper die dezelfde interface heeft als LocusMultiplayer
					const p2pMp = _createP2PHostAdapter(host);

					// Stel state in V√ì√ìR ui.init() zodat de lobby direct de waiting room toont
					p2pMp.gameState = host._sanitizeForPlayer(host.hostPlayerId);
					p2pMp.userId = host.hostPlayerId;
					p2pMp.userName = name;
					p2pMp.gameId = host.gameState.id;
					p2pMp.inviteCode = result.roomCode;
					p2pMp.connected = true;

					const ui = new LocusLobbyUI(p2pMp);
					ui.init();

					// Forceer transitie naar wachtkamer
					ui._showWaitingRoom(result.roomCode, true);

					window._mp = p2pMp;
					window._ui = ui;
					window._p2pHost = host;
					try {
						sessionStorage.setItem('locus_p2p_role', 'host');
						sessionStorage.setItem('locus_p2p_roomCode', result.roomCode);
						sessionStorage.setItem('locus_p2p_playerId', host.hostPlayerId);
						sessionStorage.setItem('locus_p2p_userName', name);
						sessionStorage.setItem('locus_p2p_state', JSON.stringify(host.gameState));
					} catch (_) {}

					// State sync: wanneer host state verandert ‚Üí update UI
					host.onStateChanged = (state) => {
						console.log('[P2P Adapter] onStateChanged, phase:', state?.phase, 'userId:', p2pMp.userId);
						const prev = p2pMp.gameState;
						p2pMp.gameState = state;
						if (p2pMp.onGameStateChanged) {
							try {
								p2pMp.onGameStateChanged(state, prev);
							} catch (err) {
								console.error('[P2P Adapter] onGameStateChanged ERROR:', err);
							}
						} else {
							console.warn('[P2P Adapter] onGameStateChanged is niet gezet!');
						}
						try { sessionStorage.setItem('locus_p2p_state', JSON.stringify(host.gameState)); } catch (_) {}
					};

					host.onPlayerJoined = (data) => {
						if (p2pMp.onPlayerJoined) p2pMp.onPlayerJoined(data);
					};

					host.onPlayerLeft = (playerId) => {
						if (p2pMp.onPlayerLeft) p2pMp.onPlayerLeft(playerId);
					};

					// Event forwarding: host ontvangt ook events zoals levelComplete, movePlayed etc.
					host.onEvent = (eventType, data) => {
						switch (eventType) {
							case 'movePlayed': if (p2pMp.onMovePlayed) p2pMp.onMovePlayed(data); break;
							case 'levelComplete': if (p2pMp.onLevelComplete) p2pMp.onLevelComplete(data.levelScores, data.levelWinner, data.level); break;
							case 'nextLevelStarted': if (p2pMp.onNextLevel) p2pMp.onNextLevel(data.level); break;
							case 'gameEnded': if (p2pMp.onGameEnded) p2pMp.onGameEnded(data); break;
							case 'timeBombUsed': if (p2pMp.onTimeBombed) p2pMp.onTimeBombed(data); break;
							case 'opponentInteraction': if (p2pMp.onOpponentInteraction) p2pMp.onOpponentInteraction(data); break;
							case 'taunt': if (p2pMp.onTaunt) p2pMp.onTaunt(data); break;
							case 'pauseChanged': if (p2pMp.onPauseChanged) p2pMp.onPauseChanged(data); break;
						}
					};

				} catch (err) {
					hostBtn.disabled = false;
					hostBtn.textContent = origText;
					alert('P2P host starten mislukt: ' + (err.message || err));
				}
			});

			// P2P Join
			document.getElementById('p2p-join-btn').addEventListener('click', async () => {

			// Debug button: show on mobile/touch devices
			const debugBtn = document.getElementById('p2p-debug-btn');
			if (debugBtn && ('ontouchstart' in window || navigator.maxTouchPoints > 0)) {
				debugBtn.style.display = 'block';
				debugBtn.addEventListener('click', () => {
					if (typeof LocusP2PHost !== 'undefined') LocusP2PHost.showMobileDebug();
				});
			}
				const nameInput = document.getElementById('player-name-input');
				const name = nameInput?.value?.trim();
				if (!name) {
					nameInput?.classList.add('mp-shake');
					setTimeout(() => nameInput?.classList.remove('mp-shake'), 500);
					return;
				}
				_saveLobbyName(name);

				if (typeof Peer === 'undefined') {
					alert('PeerJS is niet geladen. Controleer je internetverbinding en herlaad de pagina.');
					return;
				}

				// Gebruik de P2P room code input (niet de server invite code input)
				const codeInput = document.getElementById('p2p-room-code-input');
				const code = codeInput?.value?.trim()?.toUpperCase();
				if (!code || code.length !== 6) {
					alert('Vul een geldige 6-letter room code in.');
					codeInput?.focus();
					return;
				}

				const joinBtn = document.getElementById('p2p-join-btn');
				const origText = joinBtn.textContent;
				joinBtn.disabled = true;
				joinBtn.textContent = '‚è≥ Verbinden...';

				try {
					const guest = new LocusP2PGuest();
					await guest.init();
					let reconnectPlayerId = null;
					try {
						const savedRole = sessionStorage.getItem('locus_p2p_role');
						const savedRoom = sessionStorage.getItem('locus_p2p_roomCode');
						const savedPid = sessionStorage.getItem('locus_p2p_playerId');
						if (savedRole === 'guest' && savedRoom === code && savedPid) {
							reconnectPlayerId = savedPid;
						}
					} catch (_) {
						reconnectPlayerId = null;
					}

					const result = await guest.joinGame(name, code, { reconnectPlayerId });

					// Guest heeft dezelfde interface als LocusMultiplayer
					guest.userName = name;
					guest.gameId = result.gameId;
					guest.inviteCode = code;

					const ui = new LocusLobbyUI(guest);
					ui.init();

					// Forceer transitie naar wachtkamer
					ui._showWaitingRoom(code, false);

					window._mp = guest;
					window._ui = ui;
					try {
						sessionStorage.setItem('locus_p2p_role', 'guest');
						sessionStorage.setItem('locus_p2p_roomCode', code);
						sessionStorage.setItem('locus_p2p_playerId', result.playerId);
						sessionStorage.setItem('locus_p2p_userName', name);
					} catch (_) {}

				} catch (err) {
					joinBtn.disabled = false;
					joinBtn.textContent = origText;
					alert('P2P joinen mislukt: ' + (err.message || err));
				}
			});
		}

		/**
		 * Maak een adapter object dat de LocusMultiplayer interface
		 * implementeert maar de P2PHost gebruikt als backend.
		 */
		function _createP2PHostAdapter(host) {
			return {
				serverUrl: 'p2p',
				socket: null,
				userId: host.hostPlayerId,
				userName: null,
				gameId: null,
				inviteCode: null,
				gameState: null,
				connected: true,

				// Callbacks
				onGameStateChanged: null,
				onPlayerJoined: null,
				onPlayerLeft: null,
				onTurnChanged: null,
				onGameStarted: null,
				onGameEnded: null,
				onGoalPhase: null,
				onError: null,
				onConnectionChanged: null,
				onMovePlayed: null,
				onLevelComplete: null,
				onShopPhase: null,
				onNextLevel: null,
				onObjectivesRevealed: null,
				onTimeBombed: null,
				onOpponentInteraction: null,
				onTaunt: null,
				onPauseChanged: null,

				async init() { return { userId: host.hostPlayerId }; },

				async createGame(name, opts) {
					return { gameId: host.gameState.id, inviteCode: host.roomCode, playerId: host.hostPlayerId };
				},

				async joinGame() { /* host is already in */ },

				async startGame() { return host.hostAction('startGame'); },
				async chooseStartingDeck(dt) { return host.hostAction('chooseStartingDeck', { deckType: dt }); },
				async chooseGoal(idx) { return host.hostAction('chooseGoal', { objectiveIndex: idx }); },

				async playCard(cardId, zoneName, baseX, baseY, rotation, mirrored, subgridId) {
					return host.hostAction('playMove', { cardId, zoneName, baseX, baseY, rotation, mirrored, subgridId });
				},

				async playBonus(bonusColor, zoneName, baseX, baseY, subgridId, rotation) {
					return host.hostAction('playBonus', { bonusColor, zoneName, baseX, baseY, subgridId, rotation });
				},

				async pass(cardId) { return host.hostAction('passMove', { cardId }); },
				async endTurn(cardId) { return host.hostAction('endTurn', { cardId }); },
				async undoMove() { return host.hostAction('undoMove'); },
				async startShopPhase() { return host.hostAction('startShopPhase'); },
				async buyShopItem(itemId, extra) { return host.hostAction('buyShopItem', { itemId, extra }); },
				async claimFreeCard(cardId) { return host.hostAction('claimFreeCard', { cardId }); },
				async setShopReady() { return host.hostAction('shopReady'); },
				async useTimeBomb() { return host.hostAction('useTimeBomb'); },
				async togglePause() { return host.hostAction('togglePause'); },
				async sendTaunt(text) {
					// Host broadcast taunt locally
					host._broadcastEvent('taunt', {
						playerId: host.hostPlayerId,
						playerName: host.gameState?.players[host.hostPlayerId]?.name || 'Host',
						text, timestamp: Date.now()
					});
					return { success: true };
				},
				sendInteraction(data) {
					host._broadcastEventExcept(null, 'opponentInteraction', {
						...data,
						playerId: host.hostPlayerId,
						playerName: host.gameState?.players[host.hostPlayerId]?.name || 'Host'
					});
				},

				isMyTurn() {
					if (!this.gameState || this.gameState.phase !== 'playing') return false;
					return this.gameState.playerOrder[this.gameState.currentTurnIndex] === this.userId;
				},

				getCurrentPlayer() {
					if (!this.gameState) return null;
					const pid = this.gameState.playerOrder[this.gameState.currentTurnIndex];
					return this.gameState.players[pid] || null;
				},

				getMyPlayer() {
					if (!this.gameState) return null;
					return this.gameState.players[this.userId] || null;
				},

				getMyHand() {
					const p = this.getMyPlayer();
					return p ? p.hand : [];
				},

				getScoreboard() {
					if (!this.gameState) return [];
					return this.gameState.playerOrder.map(pid => {
						const p = this.gameState.players[pid];
						return {
							id: pid, name: p.name, score: p.score || 0,
							scoreBreakdown: p.scoreBreakdown || null,
							isCurrentTurn: this.gameState.playerOrder[this.gameState.currentTurnIndex] === pid,
							isMe: pid === this.userId,
							cardsLeft: Array.isArray(p.drawPile) ? p.drawPile.length : (p.drawPile || 0),
							handSize: Array.isArray(p.hand) ? p.hand.length : 0,
							discardPileSize: Array.isArray(p.discardPile) ? p.discardPile.length : (typeof p.discardPile === 'number' ? p.discardPile : 0),
							bonusInventory: p.bonusInventory || {},
							connected: p.connected
						};
					});
				},

				getBoardState() {
					return this.gameState?.boardState || null;
				},

				previewPlacement(zoneName, baseX, baseY, matrix, subgridId) {
					if (!this.gameState?.boardState) return { valid: false };
					const Rules = window.LocusGameRules;
					if (!Rules) return { valid: false };
					let zoneData;
					if (zoneName === 'red') {
						const sgs = subgridId
							? (this.gameState.boardState.zones.red?.subgrids || []).filter(sg => sg.id === subgridId)
							: (this.gameState.boardState.zones.red?.subgrids || []);
						for (const sg of sgs) {
							const cells = Rules.collectPlacementCellsData(sg, baseX, baseY, matrix);
							if (cells) return { valid: Rules.validatePlacement(zoneName, sg, cells), cells };
						}
						return { valid: false };
					}
					zoneData = this.gameState.boardState.zones[zoneName];
					if (!zoneData) return { valid: false };
					const cells = Rules.collectPlacementCellsData(zoneData, baseX, baseY, matrix);
					if (!cells) return { valid: false };
					return { valid: Rules.validatePlacement(zoneName, zoneData, cells), cells };
				},

				disconnect() {
					host.destroy();
					this.gameState = null;
					this.connected = false;
				}
			};
		}
	</script>
</body>
</html>
